/*!
@defgroup flexcan FlexCAN
@ingroup drivers
@details The boot loader uses both HAL and Peripheral drivers for the FlexCAN Controller Area Network (FlexCAN) block of Kinetis devices.
@{
*/

/*!
@defgroup flexcan_hal FlexCAN HAL driver
@details This section describes the programming interface of the FlexCAN HAL driver.
@ingroup flexcan
*/

/*!
@defgroup flexcan_driver FlexCAN Driver
@details This section describes the programming interface of the FlexCAN Peripheral driver.
@ingroup flexcan

# FlexCAN Overview {#FlexOvw}

The FlexCAN (flexible controller area network) module is a communication controller implementing
the CAN protocol according to the CAN 2.0B protocol specification. The FlexCAN module supports
both standard and extended message frames. The message buffers are stored in an embedded RAM
dedicated to the FlexCAN module. The CAN Protocol Engine (PE) sub-module manages the serial
communication on the CAN bus by requesting RAM access for receiving and transmitting message frames,
validating received messages, and performing error handling.


# FlexCAN Initialization  {#FlexCANInit}

To initialize the FlexCAN driver, call the FLEXCAN_DRV_Init() function and pass the instance number
of the FlexCAN you want to use. For example, to use FlexCAN0, pass a value of 0 to the
flexcan_init function.  In addition, you should also pass a user configuration structure
#flexcan_user_config_t, as shown here:

~~~~~{.c}
// FlexCAN configuration structure for user
typedef struct FLEXCANUserConfig {
    uint32_t max_num_mb;                            //!< The maximum number of Message Buffers//
    flexcan_rx_fifo_id_filter_num_t num_id_filters; //!< The number of Rx FIFO ID filters needed//
    bool is_rx_fifo_needed;                         //!< 1 if needed; 0 if not//
} flexcan_user_config_t;
~~~~~

Typically, the user configures the #flexcan_user_config_t instantiation as 16 message buffers, 
8 RX FIFO ID filters and set to true when RX FIFO is needed. This is a code example to set up a
FlexCAN configuration instantiation:

~~~~~{.c}
    flexcan_config_t flexcan1_data;

    flexcan1_data.max_num_mb = 16;
    flexcan1_data.num_id_filters = kFlexCanRxFifoIDFilters_8;
    flexcan1_data.is_rx_fifo_needed = true;
~~~~~

# FlexCAN Module timing {#FlexMDt}

FlexCAN bit rate is derived from the serial clock, which is generated by dividing the
PE clock by the programmed PRESDIV value. Each serial clock period is also called a time quantum.
The FlexCAN bit-rate is defined as the Sclock divided by the number of time quanta, where time quanta are
further broken down segments within the bit time (time to transmit and sample a bit).
This list shows the CAN bit-rates that are supported in the FlexCAN driver.
    * 1 Mbytes/s
    * 500 Kbytes/s
    * 250 Kbytes/s
    * 125 Kbytes/s

The FlexCAN module supports several different ways to set up the bit timing parameters that are
required by the CAN protocol. The Control Register has various fields used to control bit
timing parameters: PRESDIV, PROPSEG, PSEG1, PSEG2, and RJW.

To calculate the CAN bit timing parameters, use the method outlined in the Application Note AN1798, section 4.1.
A maximum time for PROP_SEG is used, the remaining TQ is split equally between PSEG1
and PSEG2, provided PSEG2 >=2. RJW is set to the minimum of 4 or to the PSEG1.


# FlexCAN Transfers {#FlexTrsfr}

To transmit a FlexCAN frame, the CPU must prepare a message buffer for transmission by calling the
FLEXCAN_DRV_Send() function. To receive the FlexCAN frames into a message buffer, the CPU must also prepare it
for reception by first setting up the receive mask by calling  FLEXCAN_DRV_SetMaskType(),
FLEXCAN_DRV_SetRxFifoGlobalMask(), FLEXCAN_DRV_SetRxMbGlobalMask() and FLEXCAN_DRV_SetRxIndividualMask() functions.
Then configure the RX buffers by calling either FLEXCAN_DRV_ConfigRxMb() or FLEXCAN_DRV_ConfigRxFifo() functions
depending on the mode of reception. Finally, call FLEXCAN_DRV_RxMessageBuffer() or FLEXCAN_DRV_RxFifo functions
depending on the mode of reception.
The FlexCAN uses only the interrupt-driven process to transfer data.

*/
/*! @}*/

