/*
** ###################################################################
**     Compilers:           Keil ARM C/C++ Compiler
**                          Freescale C/C++ for Embedded ARM
**                          GNU C Compiler
**                          GNU C Compiler - CodeSourcery Sourcery G++
**                          IAR ANSI C/C++ Compiler for ARM
**
**     Reference manual:    KS22P100M120SF0RM, Rev. 0, June 15, 2015
**     Version:             rev. 1.0, 2015-06-23
**     Build:               b150820
**
**     Abstract:
**         Extension to the CMSIS register access layer header.
**
**     Copyright (c) 2015 Freescale Semiconductor, Inc.
**     All rights reserved.
**
**     Redistribution and use in source and binary forms, with or without modification,
**     are permitted provided that the following conditions are met:
**
**     o Redistributions of source code must retain the above copyright notice, this list
**       of conditions and the following disclaimer.
**
**     o Redistributions in binary form must reproduce the above copyright notice, this
**       list of conditions and the following disclaimer in the documentation and/or
**       other materials provided with the distribution.
**
**     o Neither the name of Freescale Semiconductor, Inc. nor the names of its
**       contributors may be used to endorse or promote products derived from this
**       software without specific prior written permission.
**
**     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
**     ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
**     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
**     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
**     ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
**     (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
**     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
**     ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
**     (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
**     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
**
**     http:                 www.freescale.com
**     mail:                 support@freescale.com
**
**     Revisions:
**     - rev. 1.0 (2015-06-23)
**         Initial version.
**
** ###################################################################
*/

/*
 * WARNING! DO NOT EDIT THIS FILE DIRECTLY!
 *
 * This file was generated automatically and any changes may be lost.
 */
#ifndef __MKS22F25612_EXTENSION_H__
#define __MKS22F25612_EXTENSION_H__

#include "SKEAZN642.h"
#include "fsl_bitaccess.h"

/*
 * MKS22F25612 ADC
 *
 * Analog-to-Digital Converter
 *
 * Registers defined in this header file:
 * - ADC_SC1 - ADC Status and Control Registers 1
 * - ADC_CFG1 - ADC Configuration Register 1
 * - ADC_CFG2 - ADC Configuration Register 2
 * - ADC_R - ADC Data Result Register
 * - ADC_CV1 - Compare Value Registers
 * - ADC_CV2 - Compare Value Registers
 * - ADC_SC2 - Status and Control Register 2
 * - ADC_SC3 - Status and Control Register 3
 * - ADC_OFS - ADC Offset Correction Register
 * - ADC_PG - ADC Plus-Side Gain Register
 * - ADC_MG - ADC Minus-Side Gain Register
 * - ADC_CLPD - ADC Plus-Side General Calibration Value Register
 * - ADC_CLPS - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 * - ADC_CLMD - ADC Minus-Side General Calibration Value Register
 * - ADC_CLMS - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 * - ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 */

#define ADC_INSTANCE_COUNT (1U) /*!< Number of instances of the ADC module. */
#define ADC0_IDX (0U) /*!< Instance number for ADC0. */

/*******************************************************************************
 * ADC_SC1 - ADC Status and Control Registers 1
 ******************************************************************************/

/*!
 * @brief ADC_SC1 - ADC Status and Control Registers 1 (RW)
 *
 * Reset value: 0x0000001FU
 *
 * SC1A is used for both software and hardware trigger modes of operation. To
 * allow sequential conversions of the ADC to be triggered by internal peripherals,
 * the ADC can have more than one status and control register: one for each
 * conversion. The SC1B-SC1n registers indicate potentially multiple SC1 registers
 * for use only in hardware trigger mode. See the chip configuration information
 * about the number of SC1n registers specific to this device. The SC1n registers
 * have identical fields, and are used in a "ping-pong" approach to control ADC
 * operation. At any one point in time, only one of the SC1n registers is actively
 * controlling ADC conversions. Updating SC1A while SC1n is actively controlling
 * a conversion is allowed, and vice-versa for any of the SC1n registers specific
 * to this MCU. Writing SC1A while SC1A is actively controlling a conversion
 * aborts the current conversion. In Software Trigger mode, when SC2[ADTRG]=0,
 * writes to SC1A subsequently initiate a new conversion, if SC1[ADCH] contains a
 * value other than all 1s (module disabled). Writing any of the SC1n registers while
 * that specific SC1n register is actively controlling a conversion aborts the
 * current conversion. None of the SC1B-SC1n registers are used for software
 * trigger operation and therefore writes to the SC1B-SC1n registers do not initiate a
 * new conversion.
 */
/*!
 * @name Constants and macros for entire ADC_SC1 register
 */
/*@{*/
#define ADC_RD_SC1(base, index)  (ADC_SC1_REG(base, index))
#define ADC_WR_SC1(base, index, value) (ADC_SC1_REG(base, index) = (value))
#define ADC_RMW_SC1(base, index, mask, value) (ADC_WR_SC1(base, index, (ADC_RD_SC1(base, index) & ~(mask)) | (value)))
#define ADC_SET_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) |  (value)))
#define ADC_CLR_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) & ~(value)))
#define ADC_TOG_SC1(base, index, value) (ADC_WR_SC1(base, index, ADC_RD_SC1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC1 bitfields
 */

/*!
 * @name Register ADC_SC1, field ADCH[4:0] (RW)
 *
 * Selects one of the input channels. The input channel decode depends on the
 * value of DIFF. DAD0-DAD3 are associated with the input pin pairs DADPx and
 * DADMx. Some of the input channel options in the bitfield-setting descriptions might
 * not be available for your device. For the actual ADC channel assignments for
 * your device, see the Chip Configuration details. The successive approximation
 * converter subsystem is turned off when the channel select bits are all set,
 * that is, ADCH = 11111. This feature allows explicit disabling of the ADC and
 * isolation of the input channel from all sources. Terminating continuous
 * conversions this way prevents an additional single conversion from being performed. It
 * is not necessary to set ADCH to all 1s to place the ADC in a low-power state
 * when continuous conversions are not enabled because the module automatically
 * enters a low-power state when a conversion completes.
 *
 * Values:
 * - 00000 - When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is
 *     selected as input.
 * - 00001 - When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is
 *     selected as input.
 * - 00010 - When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is
 *     selected as input.
 * - 00011 - When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is
 *     selected as input.
 * - 00100 - When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
 * - 00101 - When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
 * - 00110 - When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
 * - 00111 - When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
 * - 01000 - When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
 * - 01001 - When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
 * - 01010 - When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
 * - 01011 - When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
 * - 01100 - When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
 * - 01101 - When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
 * - 01110 - When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
 * - 01111 - When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
 * - 10000 - When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
 * - 10001 - When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
 * - 10010 - When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
 * - 10011 - When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
 * - 10100 - When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
 * - 10101 - When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
 * - 10110 - When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
 * - 10111 - When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
 * - 11000 - Reserved.
 * - 11001 - Reserved.
 * - 11010 - When DIFF=0, Temp Sensor (single-ended) is selected as input; when
 *     DIFF=1, Temp Sensor (differential) is selected as input.
 * - 11011 - When DIFF=0, Bandgap (single-ended) is selected as input; when
 *     DIFF=1, Bandgap (differential) is selected as input.
 * - 11100 - Reserved.
 * - 11101 - When DIFF=0,VREFSH is selected as input; when DIFF=1, -VREFSH
 *     (differential) is selected as input. Voltage reference selected is determined
 *     by SC2[REFSEL].
 * - 11110 - When DIFF=0,VREFSL is selected as input; when DIFF=1, it is
 *     reserved. Voltage reference selected is determined by SC2[REFSEL].
 * - 11111 - Module is disabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_ADCH field. */
#define ADC_RD_SC1_ADCH(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_ADCH_MASK) >> ADC_SC1_ADCH_SHIFT)
#define ADC_BRD_SC1_ADCH(base, index) (ADC_RD_SC1_ADCH(base, index))

/*! @brief Set the ADCH field to a new value. */
#define ADC_WR_SC1_ADCH(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_ADCH_MASK, ADC_SC1_ADCH(value)))
#define ADC_BWR_SC1_ADCH(base, index, value) (ADC_WR_SC1_ADCH(base, index, value))
/*@}*/

/*!
 * @name Register ADC_SC1, field DIFF[5] (RW)
 *
 * Configures the ADC to operate in differential mode. When enabled, this mode
 * automatically selects from the differential channels, and changes the
 * conversion algorithm and the number of cycles to complete a conversion.
 *
 * Values:
 * - 0 - Single-ended conversions and input channels are selected.
 * - 1 - Differential conversions and input channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_DIFF field. */
#define ADC_RD_SC1_DIFF(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_DIFF_MASK) >> ADC_SC1_DIFF_SHIFT)
#define ADC_BRD_SC1_DIFF(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT))

/*! @brief Set the DIFF field to a new value. */
#define ADC_WR_SC1_DIFF(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_DIFF_MASK, ADC_SC1_DIFF(value)))
#define ADC_BWR_SC1_DIFF(base, index, value) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_DIFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC1, field AIEN[6] (RW)
 *
 * Enables conversion complete interrupts. When COCO becomes set while the
 * respective AIEN is high, an interrupt is asserted.
 *
 * Values:
 * - 0 - Conversion complete interrupt is disabled.
 * - 1 - Conversion complete interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_AIEN field. */
#define ADC_RD_SC1_AIEN(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT)
#define ADC_BRD_SC1_AIEN(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT))

/*! @brief Set the AIEN field to a new value. */
#define ADC_WR_SC1_AIEN(base, index, value) (ADC_RMW_SC1(base, index, ADC_SC1_AIEN_MASK, ADC_SC1_AIEN(value)))
#define ADC_BWR_SC1_AIEN(base, index, value) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_AIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC1, field COCO[7] (RO)
 *
 * This is a read-only field that is set each time a conversion is completed
 * when the compare function is disabled, or SC2[ACFE]=0 and the hardware average
 * function is disabled, or SC3[AVGE]=0. When the compare function is enabled, or
 * SC2[ACFE]=1, COCO is set upon completion of a conversion only if the compare
 * result is true. When the hardware average function is enabled, or SC3[AVGE]=1,
 * COCO is set upon completion of the selected number of conversions (determined
 * by AVGS). COCO in SC1A is also set at the completion of a calibration sequence.
 * COCO is cleared when the respective SC1n register is written or when the
 * respective Rn register is read.
 *
 * Values:
 * - 0 - Conversion is not completed.
 * - 1 - Conversion is completed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC1_COCO field. */
#define ADC_RD_SC1_COCO(base, index) ((ADC_SC1_REG(base, index) & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT)
#define ADC_BRD_SC1_COCO(base, index) (BITBAND_ACCESS32(&ADC_SC1_REG(base, index), ADC_SC1_COCO_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_CFG1 - ADC Configuration Register 1
 ******************************************************************************/

/*!
 * @brief ADC_CFG1 - ADC Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The configuration Register 1 (CFG1) selects the mode of operation, clock
 * source, clock divide, and configuration for low power or long sample time.
 */
/*!
 * @name Constants and macros for entire ADC_CFG1 register
 */
/*@{*/
#define ADC_RD_CFG1(base)        (ADC_CFG1_REG(base))
#define ADC_WR_CFG1(base, value) (ADC_CFG1_REG(base) = (value))
#define ADC_RMW_CFG1(base, mask, value) (ADC_WR_CFG1(base, (ADC_RD_CFG1(base) & ~(mask)) | (value)))
#define ADC_SET_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) |  (value)))
#define ADC_CLR_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) & ~(value)))
#define ADC_TOG_CFG1(base, value) (ADC_WR_CFG1(base, ADC_RD_CFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG1 bitfields
 */

/*!
 * @name Register ADC_CFG1, field ADICLK[1:0] (RW)
 *
 * Selects the input clock source to generate the internal clock, ADCK. Note
 * that when the ADACK clock source is selected, it is not required to be active
 * prior to conversion start. When it is selected and it is not active prior to a
 * conversion start, when CFG2[ADACKEN]=0, the asynchronous clock is activated at
 * the start of a conversion and deactivated when conversions are terminated. In
 * this case, there is an associated clock startup delay each time the clock
 * source is re-activated.
 *
 * Values:
 * - 00 - Bus clock
 * - 01 - Alternate clock 2 (ALTCLK2)
 * - 10 - Alternate clock (ALTCLK)
 * - 11 - Asynchronous clock (ADACK)
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADICLK field. */
#define ADC_RD_CFG1_ADICLK(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
#define ADC_BRD_CFG1_ADICLK(base) (ADC_RD_CFG1_ADICLK(base))

/*! @brief Set the ADICLK field to a new value. */
#define ADC_WR_CFG1_ADICLK(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADICLK_MASK, ADC_CFG1_ADICLK(value)))
#define ADC_BWR_CFG1_ADICLK(base, value) (ADC_WR_CFG1_ADICLK(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field MODE[3:2] (RW)
 *
 * Selects the ADC resolution mode.
 *
 * Values:
 * - 00 - When DIFF=0:It is single-ended 8-bit conversion; when DIFF=1, it is
 *     differential 9-bit conversion with 2's complement output.
 * - 01 - When DIFF=0:It is single-ended 12-bit conversion ; when DIFF=1, it is
 *     differential 13-bit conversion with 2's complement output.
 * - 10 - When DIFF=0:It is single-ended 10-bit conversion. ; when DIFF=1, it is
 *     differential 11-bit conversion with 2's complement output
 * - 11 - When DIFF=0:It is single-ended 16-bit conversion..; when DIFF=1, it is
 *     differential 16-bit conversion with 2's complement output
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_MODE field. */
#define ADC_RD_CFG1_MODE(base) ((ADC_CFG1_REG(base) & ADC_CFG1_MODE_MASK) >> ADC_CFG1_MODE_SHIFT)
#define ADC_BRD_CFG1_MODE(base) (ADC_RD_CFG1_MODE(base))

/*! @brief Set the MODE field to a new value. */
#define ADC_WR_CFG1_MODE(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_MODE_MASK, ADC_CFG1_MODE(value)))
#define ADC_BWR_CFG1_MODE(base, value) (ADC_WR_CFG1_MODE(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLSMP[4] (RW)
 *
 * Selects between different sample times based on the conversion mode selected.
 * This field adjusts the sample period to allow higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption if
 * continuous conversions are enabled and high conversion rates are not required.
 * When ADLSMP=1, the long sample time select bits, (ADLSTS[1:0]), can select the
 * extent of the long sample time.
 *
 * Values:
 * - 0 - Short sample time.
 * - 1 - Long sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLSMP field. */
#define ADC_RD_CFG1_ADLSMP(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLSMP_MASK) >> ADC_CFG1_ADLSMP_SHIFT)
#define ADC_BRD_CFG1_ADLSMP(base) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT))

/*! @brief Set the ADLSMP field to a new value. */
#define ADC_WR_CFG1_ADLSMP(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLSMP_MASK, ADC_CFG1_ADLSMP(value)))
#define ADC_BWR_CFG1_ADLSMP(base, value) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLSMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADIV[6:5] (RW)
 *
 * Selects the divide ratio used by the ADC to generate the internal clock ADCK.
 *
 * Values:
 * - 00 - The divide ratio is 1 and the clock rate is input clock.
 * - 01 - The divide ratio is 2 and the clock rate is (input clock)/2.
 * - 10 - The divide ratio is 4 and the clock rate is (input clock)/4.
 * - 11 - The divide ratio is 8 and the clock rate is (input clock)/8.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADIV field. */
#define ADC_RD_CFG1_ADIV(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
#define ADC_BRD_CFG1_ADIV(base) (ADC_RD_CFG1_ADIV(base))

/*! @brief Set the ADIV field to a new value. */
#define ADC_WR_CFG1_ADIV(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADIV_MASK, ADC_CFG1_ADIV(value)))
#define ADC_BWR_CFG1_ADIV(base, value) (ADC_WR_CFG1_ADIV(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG1, field ADLPC[7] (RW)
 *
 * Controls the power configuration of the successive approximation converter.
 * This optimizes power consumption when higher sample rates are not required.
 *
 * Values:
 * - 0 - Normal power configuration.
 * - 1 - Low-power configuration. The power is reduced at the expense of maximum
 *     clock speed.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG1_ADLPC field. */
#define ADC_RD_CFG1_ADLPC(base) ((ADC_CFG1_REG(base) & ADC_CFG1_ADLPC_MASK) >> ADC_CFG1_ADLPC_SHIFT)
#define ADC_BRD_CFG1_ADLPC(base) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT))

/*! @brief Set the ADLPC field to a new value. */
#define ADC_WR_CFG1_ADLPC(base, value) (ADC_RMW_CFG1(base, ADC_CFG1_ADLPC_MASK, ADC_CFG1_ADLPC(value)))
#define ADC_BWR_CFG1_ADLPC(base, value) (BITBAND_ACCESS32(&ADC_CFG1_REG(base), ADC_CFG1_ADLPC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_CFG2 - ADC Configuration Register 2
 ******************************************************************************/

/*!
 * @brief ADC_CFG2 - ADC Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Configuration Register 2 (CFG2) selects the special high-speed configuration
 * for very high speed conversions and selects the long sample time duration
 * during long sample mode.
 */
/*!
 * @name Constants and macros for entire ADC_CFG2 register
 */
/*@{*/
#define ADC_RD_CFG2(base)        (ADC_CFG2_REG(base))
#define ADC_WR_CFG2(base, value) (ADC_CFG2_REG(base) = (value))
#define ADC_RMW_CFG2(base, mask, value) (ADC_WR_CFG2(base, (ADC_RD_CFG2(base) & ~(mask)) | (value)))
#define ADC_SET_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) |  (value)))
#define ADC_CLR_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) & ~(value)))
#define ADC_TOG_CFG2(base, value) (ADC_WR_CFG2(base, ADC_RD_CFG2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CFG2 bitfields
 */

/*!
 * @name Register ADC_CFG2, field ADLSTS[1:0] (RW)
 *
 * Selects between the extended sample times when long sample time is selected,
 * that is, when CFG1[ADLSMP]=1. This allows higher impedance inputs to be
 * accurately sampled or to maximize conversion speed for lower impedance inputs.
 * Longer sample times can also be used to lower overall power consumption when
 * continuous conversions are enabled if high conversion rates are not required.
 *
 * Values:
 * - 00 - Default longest sample time; 20 extra ADCK cycles; 24 ADCK cycles
 *     total.
 * - 01 - 12 extra ADCK cycles; 16 ADCK cycles total sample time.
 * - 10 - 6 extra ADCK cycles; 10 ADCK cycles total sample time.
 * - 11 - 2 extra ADCK cycles; 6 ADCK cycles total sample time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADLSTS field. */
#define ADC_RD_CFG2_ADLSTS(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADLSTS_MASK) >> ADC_CFG2_ADLSTS_SHIFT)
#define ADC_BRD_CFG2_ADLSTS(base) (ADC_RD_CFG2_ADLSTS(base))

/*! @brief Set the ADLSTS field to a new value. */
#define ADC_WR_CFG2_ADLSTS(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADLSTS_MASK, ADC_CFG2_ADLSTS(value)))
#define ADC_BWR_CFG2_ADLSTS(base, value) (ADC_WR_CFG2_ADLSTS(base, value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADHSC[2] (RW)
 *
 * Configures the ADC for very high-speed operation. The conversion sequence is
 * altered with 2 ADCK cycles added to the conversion time to allow higher speed
 * conversion clocks.
 *
 * Values:
 * - 0 - Normal conversion sequence selected.
 * - 1 - High-speed conversion sequence selected with 2 additional ADCK cycles
 *     to total conversion time.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADHSC field. */
#define ADC_RD_CFG2_ADHSC(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADHSC_MASK) >> ADC_CFG2_ADHSC_SHIFT)
#define ADC_BRD_CFG2_ADHSC(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT))

/*! @brief Set the ADHSC field to a new value. */
#define ADC_WR_CFG2_ADHSC(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADHSC_MASK, ADC_CFG2_ADHSC(value)))
#define ADC_BWR_CFG2_ADHSC(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADHSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field ADACKEN[3] (RW)
 *
 * Enables the asynchronous clock source and the clock source output regardless
 * of the conversion and status of CFG1[ADICLK]. Based on MCU configuration, the
 * asynchronous clock may be used by other modules. See chip configuration
 * information. Setting this field allows the clock to be used even while the ADC is
 * idle or operating from a different clock source. Also, latency of initiating a
 * single or first-continuous conversion with the asynchronous clock selected is
 * reduced because the ADACK clock is already operational.
 *
 * Values:
 * - 0 - Asynchronous clock output disabled; Asynchronous clock is enabled only
 *     if selected by ADICLK and a conversion is active.
 * - 1 - Asynchronous clock and clock output is enabled regardless of the state
 *     of the ADC.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_ADACKEN field. */
#define ADC_RD_CFG2_ADACKEN(base) ((ADC_CFG2_REG(base) & ADC_CFG2_ADACKEN_MASK) >> ADC_CFG2_ADACKEN_SHIFT)
#define ADC_BRD_CFG2_ADACKEN(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT))

/*! @brief Set the ADACKEN field to a new value. */
#define ADC_WR_CFG2_ADACKEN(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_ADACKEN_MASK, ADC_CFG2_ADACKEN(value)))
#define ADC_BWR_CFG2_ADACKEN(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_ADACKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_CFG2, field MUXSEL[4] (RW)
 *
 * Changes the ADC mux setting to select between alternate sets of ADC channels.
 *
 * Values:
 * - 0 - ADxxa channels are selected.
 * - 1 - ADxxb channels are selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_CFG2_MUXSEL field. */
#define ADC_RD_CFG2_MUXSEL(base) ((ADC_CFG2_REG(base) & ADC_CFG2_MUXSEL_MASK) >> ADC_CFG2_MUXSEL_SHIFT)
#define ADC_BRD_CFG2_MUXSEL(base) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT))

/*! @brief Set the MUXSEL field to a new value. */
#define ADC_WR_CFG2_MUXSEL(base, value) (ADC_RMW_CFG2(base, ADC_CFG2_MUXSEL_MASK, ADC_CFG2_MUXSEL(value)))
#define ADC_BWR_CFG2_MUXSEL(base, value) (BITBAND_ACCESS32(&ADC_CFG2_REG(base), ADC_CFG2_MUXSEL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_R - ADC Data Result Register
 ******************************************************************************/

/*!
 * @brief ADC_R - ADC Data Result Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The data result registers (Rn) contain the result of an ADC conversion of the
 * channel selected by the corresponding status and channel control register
 * (SC1A:SC1n). For every status and channel control register, there is a
 * corresponding data result register. Unused bits in R n are cleared in unsigned
 * right-aligned modes and carry the sign bit (MSB) in sign-extended 2's complement modes.
 * For example, when configured for 10-bit single-ended mode, D[15:10] are
 * cleared. When configured for 11-bit differential mode, D[15:10] carry the sign bit,
 * that is, bit 10 extended through bit 15. The following table describes the
 * behavior of the data result registers in the different modes of operation. Data
 * result register description Conversion mode D15 D14 D13 D12 D11 D10 D9 D8 D7
 * D6 D5 D4 D3 D2 D1 D0 Format 16-bit differential S D D D D D D D D D D D D D D D
 * Signed 2's complement 16-bit single-ended D D D D D D D D D D D D D D D D
 * Unsigned right justified 13-bit differential S S S S D D D D D D D D D D D D
 * Sign-extended 2's complement 12-bit single-ended 0 0 0 0 D D D D D D D D D D D D
 * Unsigned right-justified 11-bit differential S S S S S S D D D D D D D D D D
 * Sign-extended 2's complement 10-bit single-ended 0 0 0 0 0 0 D D D D D D D D D D
 * Unsigned right-justified 9-bit differential S S S S S S S S D D D D D D D D
 * Sign-extended 2's complement 8-bit single-ended 0 0 0 0 0 0 0 0 D D D D D D D D
 * Unsigned right-justified S: Sign bit or sign bit extension; D: Data, which is
 * 2's complement data if indicated
 */
/*!
 * @name Constants and macros for entire ADC_R register
 */
/*@{*/
#define ADC_RD_R(base, index)    (ADC_R_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual ADC_R bitfields
 */

/*!
 * @name Register ADC_R, field D[15:0] (RO)
 */
/*@{*/
/*! @brief Read current value of the ADC_R_D field. */
#define ADC_RD_R_D(base, index) ((ADC_R_REG(base, index) & ADC_R_D_MASK) >> ADC_R_D_SHIFT)
#define ADC_BRD_R_D(base, index) (ADC_RD_R_D(base, index))
/*@}*/

/*******************************************************************************
 * ADC_CV1 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV1 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV1 register
 */
/*@{*/
#define ADC_RD_CV1(base)         (ADC_CV1_REG(base))
#define ADC_WR_CV1(base, value)  (ADC_CV1_REG(base) = (value))
#define ADC_RMW_CV1(base, mask, value) (ADC_WR_CV1(base, (ADC_RD_CV1(base) & ~(mask)) | (value)))
#define ADC_SET_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) |  (value)))
#define ADC_CLR_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) & ~(value)))
#define ADC_TOG_CV1(base, value) (ADC_WR_CV1(base, ADC_RD_CV1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV1 bitfields
 */

/*!
 * @name Register ADC_CV1, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV1_CV field. */
#define ADC_RD_CV1_CV(base)  ((ADC_CV1_REG(base) & ADC_CV1_CV_MASK) >> ADC_CV1_CV_SHIFT)
#define ADC_BRD_CV1_CV(base) (ADC_RD_CV1_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV1_CV(base, value) (ADC_RMW_CV1(base, ADC_CV1_CV_MASK, ADC_CV1_CV(value)))
#define ADC_BWR_CV1_CV(base, value) (ADC_WR_CV1_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CV2 - Compare Value Registers
 ******************************************************************************/

/*!
 * @brief ADC_CV2 - Compare Value Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Compare Value Registers (CV1 and CV2) contain a compare value used to
 * compare the conversion result when the compare function is enabled, that is,
 * SC2[ACFE]=1. This register is formatted in the same way as the Rn registers in
 * different modes of operation for both bit position definition and value format
 * using unsigned or sign-extended 2's complement. Therefore, the compare function
 * uses only the CVn fields that are related to the ADC mode of operation. The
 * compare value 2 register (CV2) is used only when the compare range function is
 * enabled, that is, SC2[ACREN]=1.
 */
/*!
 * @name Constants and macros for entire ADC_CV2 register
 */
/*@{*/
#define ADC_RD_CV2(base)         (ADC_CV2_REG(base))
#define ADC_WR_CV2(base, value)  (ADC_CV2_REG(base) = (value))
#define ADC_RMW_CV2(base, mask, value) (ADC_WR_CV2(base, (ADC_RD_CV2(base) & ~(mask)) | (value)))
#define ADC_SET_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) |  (value)))
#define ADC_CLR_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) & ~(value)))
#define ADC_TOG_CV2(base, value) (ADC_WR_CV2(base, ADC_RD_CV2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CV2 bitfields
 */

/*!
 * @name Register ADC_CV2, field CV[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_CV2_CV field. */
#define ADC_RD_CV2_CV(base)  ((ADC_CV2_REG(base) & ADC_CV2_CV_MASK) >> ADC_CV2_CV_SHIFT)
#define ADC_BRD_CV2_CV(base) (ADC_RD_CV2_CV(base))

/*! @brief Set the CV field to a new value. */
#define ADC_WR_CV2_CV(base, value) (ADC_RMW_CV2(base, ADC_CV2_CV_MASK, ADC_CV2_CV(value)))
#define ADC_BWR_CV2_CV(base, value) (ADC_WR_CV2_CV(base, value))
/*@}*/

/*******************************************************************************
 * ADC_SC2 - Status and Control Register 2
 ******************************************************************************/

/*!
 * @brief ADC_SC2 - Status and Control Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The status and control register 2 (SC2) contains the conversion active,
 * hardware/software trigger select, compare function, and voltage reference select of
 * the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC2 register
 */
/*@{*/
#define ADC_RD_SC2(base)         (ADC_SC2_REG(base))
#define ADC_WR_SC2(base, value)  (ADC_SC2_REG(base) = (value))
#define ADC_RMW_SC2(base, mask, value) (ADC_WR_SC2(base, (ADC_RD_SC2(base) & ~(mask)) | (value)))
#define ADC_SET_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) |  (value)))
#define ADC_CLR_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) & ~(value)))
#define ADC_TOG_SC2(base, value) (ADC_WR_SC2(base, ADC_RD_SC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC2 bitfields
 */

/*!
 * @name Register ADC_SC2, field REFSEL[1:0] (RW)
 *
 * Selects the voltage reference source used for conversions.
 *
 * Values:
 * - 00 - Default voltage reference pin pair, that is, external pins VREFH and
 *     VREFL
 * - 01 - Alternate reference pair, that is, VALTH and VALTL . This pair may be
 *     additional external pins or internal sources depending on the MCU
 *     configuration. See the chip configuration information for details specific to this
 *     MCU
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_REFSEL field. */
#define ADC_RD_SC2_REFSEL(base) ((ADC_SC2_REG(base) & ADC_SC2_REFSEL_MASK) >> ADC_SC2_REFSEL_SHIFT)
#define ADC_BRD_SC2_REFSEL(base) (ADC_RD_SC2_REFSEL(base))

/*! @brief Set the REFSEL field to a new value. */
#define ADC_WR_SC2_REFSEL(base, value) (ADC_RMW_SC2(base, ADC_SC2_REFSEL_MASK, ADC_SC2_REFSEL(value)))
#define ADC_BWR_SC2_REFSEL(base, value) (ADC_WR_SC2_REFSEL(base, value))
/*@}*/

/*!
 * @name Register ADC_SC2, field DMAEN[2] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled and will assert the ADC DMA request during an ADC
 *     conversion complete event noted when any of the SC1n[COCO] flags is asserted.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_DMAEN field. */
#define ADC_RD_SC2_DMAEN(base) ((ADC_SC2_REG(base) & ADC_SC2_DMAEN_MASK) >> ADC_SC2_DMAEN_SHIFT)
#define ADC_BRD_SC2_DMAEN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define ADC_WR_SC2_DMAEN(base, value) (ADC_RMW_SC2(base, ADC_SC2_DMAEN_MASK, ADC_SC2_DMAEN(value)))
#define ADC_BWR_SC2_DMAEN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACREN[3] (RW)
 *
 * Configures the compare function to check if the conversion result of the
 * input being monitored is either between or outside the range formed by CV1 and CV2
 * determined by the value of ACFGT. ACFE must be set for ACFGT to have any
 * effect.
 *
 * Values:
 * - 0 - Range function disabled. Only CV1 is compared.
 * - 1 - Range function enabled. Both CV1 and CV2 are compared.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACREN field. */
#define ADC_RD_SC2_ACREN(base) ((ADC_SC2_REG(base) & ADC_SC2_ACREN_MASK) >> ADC_SC2_ACREN_SHIFT)
#define ADC_BRD_SC2_ACREN(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT))

/*! @brief Set the ACREN field to a new value. */
#define ADC_WR_SC2_ACREN(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACREN_MASK, ADC_SC2_ACREN(value)))
#define ADC_BWR_SC2_ACREN(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFGT[4] (RW)
 *
 * Configures the compare function to check the conversion result relative to
 * the CV1 and CV2 based upon the value of ACREN. ACFE must be set for ACFGT to
 * have any effect.
 *
 * Values:
 * - 0 - Configures less than threshold, outside range not inclusive and inside
 *     range not inclusive; functionality based on the values placed in CV1 and
 *     CV2.
 * - 1 - Configures greater than or equal to threshold, outside and inside
 *     ranges inclusive; functionality based on the values placed in CV1 and CV2.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFGT field. */
#define ADC_RD_SC2_ACFGT(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFGT_MASK) >> ADC_SC2_ACFGT_SHIFT)
#define ADC_BRD_SC2_ACFGT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT))

/*! @brief Set the ACFGT field to a new value. */
#define ADC_WR_SC2_ACFGT(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFGT_MASK, ADC_SC2_ACFGT(value)))
#define ADC_BWR_SC2_ACFGT(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFGT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ACFE[5] (RW)
 *
 * Enables the compare function.
 *
 * Values:
 * - 0 - Compare function disabled.
 * - 1 - Compare function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ACFE field. */
#define ADC_RD_SC2_ACFE(base) ((ADC_SC2_REG(base) & ADC_SC2_ACFE_MASK) >> ADC_SC2_ACFE_SHIFT)
#define ADC_BRD_SC2_ACFE(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT))

/*! @brief Set the ACFE field to a new value. */
#define ADC_WR_SC2_ACFE(base, value) (ADC_RMW_SC2(base, ADC_SC2_ACFE_MASK, ADC_SC2_ACFE(value)))
#define ADC_BWR_SC2_ACFE(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ACFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADTRG[6] (RW)
 *
 * Selects the type of trigger used for initiating a conversion. Two types of
 * trigger are selectable: Software trigger: When software trigger is selected, a
 * conversion is initiated following a write to SC1A. Hardware trigger: When
 * hardware trigger is selected, a conversion is initiated following the assertion of
 * the ADHWT input after a pulse of the ADHWTSn input.
 *
 * Values:
 * - 0 - Software trigger selected.
 * - 1 - Hardware trigger selected.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADTRG field. */
#define ADC_RD_SC2_ADTRG(base) ((ADC_SC2_REG(base) & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT)
#define ADC_BRD_SC2_ADTRG(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT))

/*! @brief Set the ADTRG field to a new value. */
#define ADC_WR_SC2_ADTRG(base, value) (ADC_RMW_SC2(base, ADC_SC2_ADTRG_MASK, ADC_SC2_ADTRG(value)))
#define ADC_BWR_SC2_ADTRG(base, value) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADTRG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC2, field ADACT[7] (RO)
 *
 * Indicates that a conversion or hardware averaging is in progress. ADACT is
 * set when a conversion is initiated and cleared when a conversion is completed or
 * aborted.
 *
 * Values:
 * - 0 - Conversion not in progress.
 * - 1 - Conversion in progress.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC2_ADACT field. */
#define ADC_RD_SC2_ADACT(base) ((ADC_SC2_REG(base) & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT)
#define ADC_BRD_SC2_ADACT(base) (BITBAND_ACCESS32(&ADC_SC2_REG(base), ADC_SC2_ADACT_SHIFT))
/*@}*/

/*******************************************************************************
 * ADC_SC3 - Status and Control Register 3
 ******************************************************************************/

/*!
 * @brief ADC_SC3 - Status and Control Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The Status and Control Register 3 (SC3) controls the calibration, continuous
 * convert, and hardware averaging functions of the ADC module.
 */
/*!
 * @name Constants and macros for entire ADC_SC3 register
 */
/*@{*/
#define ADC_RD_SC3(base)         (ADC_SC3_REG(base))
#define ADC_WR_SC3(base, value)  (ADC_SC3_REG(base) = (value))
#define ADC_RMW_SC3(base, mask, value) (ADC_WR_SC3(base, (ADC_RD_SC3(base) & ~(mask)) | (value)))
#define ADC_SET_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) |  (value)))
#define ADC_CLR_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) & ~(value)))
#define ADC_TOG_SC3(base, value) (ADC_WR_SC3(base, ADC_RD_SC3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_SC3 bitfields
 */

/*!
 * @name Register ADC_SC3, field AVGS[1:0] (RW)
 *
 * Determines how many ADC conversions will be averaged to create the ADC
 * average result.
 *
 * Values:
 * - 00 - 4 samples averaged.
 * - 01 - 8 samples averaged.
 * - 10 - 16 samples averaged.
 * - 11 - 32 samples averaged.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGS field. */
#define ADC_RD_SC3_AVGS(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
#define ADC_BRD_SC3_AVGS(base) (ADC_RD_SC3_AVGS(base))

/*! @brief Set the AVGS field to a new value. */
#define ADC_WR_SC3_AVGS(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGS_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGS(value)))
#define ADC_BWR_SC3_AVGS(base, value) (ADC_WR_SC3_AVGS(base, value))
/*@}*/

/*!
 * @name Register ADC_SC3, field AVGE[2] (RW)
 *
 * Enables the hardware average function of the ADC.
 *
 * Values:
 * - 0 - Hardware average function disabled.
 * - 1 - Hardware average function enabled.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_AVGE field. */
#define ADC_RD_SC3_AVGE(base) ((ADC_SC3_REG(base) & ADC_SC3_AVGE_MASK) >> ADC_SC3_AVGE_SHIFT)
#define ADC_BRD_SC3_AVGE(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT))

/*! @brief Set the AVGE field to a new value. */
#define ADC_WR_SC3_AVGE(base, value) (ADC_RMW_SC3(base, (ADC_SC3_AVGE_MASK | ADC_SC3_CALF_MASK), ADC_SC3_AVGE(value)))
#define ADC_BWR_SC3_AVGE(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_AVGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field ADCO[3] (RW)
 *
 * Enables continuous conversions.
 *
 * Values:
 * - 0 - One conversion or one set of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 * - 1 - Continuous conversions or sets of conversions if the hardware average
 *     function is enabled, that is, AVGE=1, after initiating a conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_ADCO field. */
#define ADC_RD_SC3_ADCO(base) ((ADC_SC3_REG(base) & ADC_SC3_ADCO_MASK) >> ADC_SC3_ADCO_SHIFT)
#define ADC_BRD_SC3_ADCO(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT))

/*! @brief Set the ADCO field to a new value. */
#define ADC_WR_SC3_ADCO(base, value) (ADC_RMW_SC3(base, (ADC_SC3_ADCO_MASK | ADC_SC3_CALF_MASK), ADC_SC3_ADCO(value)))
#define ADC_BWR_SC3_ADCO(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_ADCO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field CALF[6] (W1C)
 *
 * Displays the result of the calibration sequence. The calibration sequence
 * will fail if SC2[ADTRG] = 1, any ADC register is written, or any stop mode is
 * entered before the calibration sequence completes. Writing 1 to CALF clears it.
 *
 * Values:
 * - 0 - Calibration completed normally.
 * - 1 - Calibration failed. ADC accuracy specifications are not guaranteed.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CALF field. */
#define ADC_RD_SC3_CALF(base) ((ADC_SC3_REG(base) & ADC_SC3_CALF_MASK) >> ADC_SC3_CALF_SHIFT)
#define ADC_BRD_SC3_CALF(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT))

/*! @brief Set the CALF field to a new value. */
#define ADC_WR_SC3_CALF(base, value) (ADC_RMW_SC3(base, ADC_SC3_CALF_MASK, ADC_SC3_CALF(value)))
#define ADC_BWR_SC3_CALF(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register ADC_SC3, field CAL[7] (RW)
 *
 * Begins the calibration sequence when set. This field stays set while the
 * calibration is in progress and is cleared when the calibration sequence is
 * completed. CALF must be checked to determine the result of the calibration sequence.
 * Once started, the calibration routine cannot be interrupted by writes to the
 * ADC registers or the results will be invalid and CALF will set. Setting CAL
 * will abort any current conversion.
 */
/*@{*/
/*! @brief Read current value of the ADC_SC3_CAL field. */
#define ADC_RD_SC3_CAL(base) ((ADC_SC3_REG(base) & ADC_SC3_CAL_MASK) >> ADC_SC3_CAL_SHIFT)
#define ADC_BRD_SC3_CAL(base) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT))

/*! @brief Set the CAL field to a new value. */
#define ADC_WR_SC3_CAL(base, value) (ADC_RMW_SC3(base, (ADC_SC3_CAL_MASK | ADC_SC3_CALF_MASK), ADC_SC3_CAL(value)))
#define ADC_BWR_SC3_CAL(base, value) (BITBAND_ACCESS32(&ADC_SC3_REG(base), ADC_SC3_CAL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * ADC_OFS - ADC Offset Correction Register
 ******************************************************************************/

/*!
 * @brief ADC_OFS - ADC Offset Correction Register (RW)
 *
 * Reset value: 0x00000004U
 *
 * The ADC Offset Correction Register (OFS) contains the user-selected or
 * calibration-generated offset error correction value. This register is a 2's
 * complement, left-justified, 16-bit value . The value in OFS is subtracted from the
 * conversion and the result is transferred into the result registers, Rn. If the
 * result is greater than the maximum or less than the minimum result value, it is
 * forced to the appropriate limit for the current mode of operation. For more
 * information regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to
 * achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_OFS register
 */
/*@{*/
#define ADC_RD_OFS(base)         (ADC_OFS_REG(base))
#define ADC_WR_OFS(base, value)  (ADC_OFS_REG(base) = (value))
#define ADC_RMW_OFS(base, mask, value) (ADC_WR_OFS(base, (ADC_RD_OFS(base) & ~(mask)) | (value)))
#define ADC_SET_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) |  (value)))
#define ADC_CLR_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) & ~(value)))
#define ADC_TOG_OFS(base, value) (ADC_WR_OFS(base, ADC_RD_OFS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_OFS bitfields
 */

/*!
 * @name Register ADC_OFS, field OFS[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_OFS_OFS field. */
#define ADC_RD_OFS_OFS(base) ((ADC_OFS_REG(base) & ADC_OFS_OFS_MASK) >> ADC_OFS_OFS_SHIFT)
#define ADC_BRD_OFS_OFS(base) (ADC_RD_OFS_OFS(base))

/*! @brief Set the OFS field to a new value. */
#define ADC_WR_OFS_OFS(base, value) (ADC_RMW_OFS(base, ADC_OFS_OFS_MASK, ADC_OFS_OFS(value)))
#define ADC_BWR_OFS_OFS(base, value) (ADC_WR_OFS_OFS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_PG - ADC Plus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_PG - ADC Plus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Plus-Side Gain Register (PG) contains the gain error correction for the
 * plus-side input in differential mode or the overall conversion in single-ended
 * mode. PG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between PG[15] and PG[14]. This register must be
 * written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration functionThe
 * ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_PG register
 */
/*@{*/
#define ADC_RD_PG(base)          (ADC_PG_REG(base))
#define ADC_WR_PG(base, value)   (ADC_PG_REG(base) = (value))
#define ADC_RMW_PG(base, mask, value) (ADC_WR_PG(base, (ADC_RD_PG(base) & ~(mask)) | (value)))
#define ADC_SET_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) |  (value)))
#define ADC_CLR_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) & ~(value)))
#define ADC_TOG_PG(base, value)  (ADC_WR_PG(base, ADC_RD_PG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_PG bitfields
 */

/*!
 * @name Register ADC_PG, field PG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_PG_PG field. */
#define ADC_RD_PG_PG(base)   ((ADC_PG_REG(base) & ADC_PG_PG_MASK) >> ADC_PG_PG_SHIFT)
#define ADC_BRD_PG_PG(base)  (ADC_RD_PG_PG(base))

/*! @brief Set the PG field to a new value. */
#define ADC_WR_PG_PG(base, value) (ADC_RMW_PG(base, ADC_PG_PG_MASK, ADC_PG_PG(value)))
#define ADC_BWR_PG_PG(base, value) (ADC_WR_PG_PG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_MG - ADC Minus-Side Gain Register
 ******************************************************************************/

/*!
 * @brief ADC_MG - ADC Minus-Side Gain Register (RW)
 *
 * Reset value: 0x00008200U
 *
 * The Minus-Side Gain Register (MG) contains the gain error correction for the
 * minus-side input in differential mode. This register is ignored in
 * single-ended mode. MG, a 16-bit real number in binary format, is the gain adjustment
 * factor, with the radix point fixed between MG[15] and MG[14]. This register must
 * be written by the user with the value described in the calibration procedure.
 * Otherwise, the gain error specifications may not be met. For more information
 * regarding the calibration procedure, please refer to the Calibration
 * functionThe ADC contains a self-calibration function that is required to achieve the
 * specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_MG register
 */
/*@{*/
#define ADC_RD_MG(base)          (ADC_MG_REG(base))
#define ADC_WR_MG(base, value)   (ADC_MG_REG(base) = (value))
#define ADC_RMW_MG(base, mask, value) (ADC_WR_MG(base, (ADC_RD_MG(base) & ~(mask)) | (value)))
#define ADC_SET_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) |  (value)))
#define ADC_CLR_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) & ~(value)))
#define ADC_TOG_MG(base, value)  (ADC_WR_MG(base, ADC_RD_MG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_MG bitfields
 */

/*!
 * @name Register ADC_MG, field MG[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the ADC_MG_MG field. */
#define ADC_RD_MG_MG(base)   ((ADC_MG_REG(base) & ADC_MG_MG_MASK) >> ADC_MG_MG_SHIFT)
#define ADC_BRD_MG_MG(base)  (ADC_RD_MG_MG(base))

/*! @brief Set the MG field to a new value. */
#define ADC_WR_MG_MG(base, value) (ADC_RMW_MG(base, ADC_MG_MG_MASK, ADC_MG_MG(value)))
#define ADC_BWR_MG_MG(base, value) (ADC_WR_MG_MG(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPD - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPD - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Plus-Side General Calibration Value Registers (CLPx) contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLP0[5:0], CLP1[6:0],
 * CLP2[7:0], CLP3[8:0], CLP4[9:0], CLPS[5:0], and CLPD[5:0]. CLPx are automatically set
 * when the self-calibration sequence is done, that is, CAL is cleared. If these
 * registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLPD register
 */
/*@{*/
#define ADC_RD_CLPD(base)        (ADC_CLPD_REG(base))
#define ADC_WR_CLPD(base, value) (ADC_CLPD_REG(base) = (value))
#define ADC_RMW_CLPD(base, mask, value) (ADC_WR_CLPD(base, (ADC_RD_CLPD(base) & ~(mask)) | (value)))
#define ADC_SET_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) |  (value)))
#define ADC_CLR_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) & ~(value)))
#define ADC_TOG_CLPD(base, value) (ADC_WR_CLPD(base, ADC_RD_CLPD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPD bitfields
 */

/*!
 * @name Register ADC_CLPD, field CLPD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPD_CLPD field. */
#define ADC_RD_CLPD_CLPD(base) ((ADC_CLPD_REG(base) & ADC_CLPD_CLPD_MASK) >> ADC_CLPD_CLPD_SHIFT)
#define ADC_BRD_CLPD_CLPD(base) (ADC_RD_CLPD_CLPD(base))

/*! @brief Set the CLPD field to a new value. */
#define ADC_WR_CLPD_CLPD(base, value) (ADC_RMW_CLPD(base, ADC_CLPD_CLPD_MASK, ADC_CLPD_CLPD(value)))
#define ADC_BWR_CLPD_CLPD(base, value) (ADC_WR_CLPD_CLPD(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLPS - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLPS - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLPS register
 */
/*@{*/
#define ADC_RD_CLPS(base)        (ADC_CLPS_REG(base))
#define ADC_WR_CLPS(base, value) (ADC_CLPS_REG(base) = (value))
#define ADC_RMW_CLPS(base, mask, value) (ADC_WR_CLPS(base, (ADC_RD_CLPS(base) & ~(mask)) | (value)))
#define ADC_SET_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) |  (value)))
#define ADC_CLR_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) & ~(value)))
#define ADC_TOG_CLPS(base, value) (ADC_WR_CLPS(base, ADC_RD_CLPS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLPS bitfields
 */

/*!
 * @name Register ADC_CLPS, field CLPS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLPS_CLPS field. */
#define ADC_RD_CLPS_CLPS(base) ((ADC_CLPS_REG(base) & ADC_CLPS_CLPS_MASK) >> ADC_CLPS_CLPS_SHIFT)
#define ADC_BRD_CLPS_CLPS(base) (ADC_RD_CLPS_CLPS(base))

/*! @brief Set the CLPS field to a new value. */
#define ADC_WR_CLPS_CLPS(base, value) (ADC_RMW_CLPS(base, ADC_CLPS_CLPS_MASK, ADC_CLPS_CLPS(value)))
#define ADC_BWR_CLPS_CLPS(base, value) (ADC_WR_CLPS_CLPS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP4 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP4 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP4 register
 */
/*@{*/
#define ADC_RD_CLP4(base)        (ADC_CLP4_REG(base))
#define ADC_WR_CLP4(base, value) (ADC_CLP4_REG(base) = (value))
#define ADC_RMW_CLP4(base, mask, value) (ADC_WR_CLP4(base, (ADC_RD_CLP4(base) & ~(mask)) | (value)))
#define ADC_SET_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) |  (value)))
#define ADC_CLR_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) & ~(value)))
#define ADC_TOG_CLP4(base, value) (ADC_WR_CLP4(base, ADC_RD_CLP4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP4 bitfields
 */

/*!
 * @name Register ADC_CLP4, field CLP4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP4_CLP4 field. */
#define ADC_RD_CLP4_CLP4(base) ((ADC_CLP4_REG(base) & ADC_CLP4_CLP4_MASK) >> ADC_CLP4_CLP4_SHIFT)
#define ADC_BRD_CLP4_CLP4(base) (ADC_RD_CLP4_CLP4(base))

/*! @brief Set the CLP4 field to a new value. */
#define ADC_WR_CLP4_CLP4(base, value) (ADC_RMW_CLP4(base, ADC_CLP4_CLP4_MASK, ADC_CLP4_CLP4(value)))
#define ADC_BWR_CLP4_CLP4(base, value) (ADC_WR_CLP4_CLP4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP3 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP3 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP3 register
 */
/*@{*/
#define ADC_RD_CLP3(base)        (ADC_CLP3_REG(base))
#define ADC_WR_CLP3(base, value) (ADC_CLP3_REG(base) = (value))
#define ADC_RMW_CLP3(base, mask, value) (ADC_WR_CLP3(base, (ADC_RD_CLP3(base) & ~(mask)) | (value)))
#define ADC_SET_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) |  (value)))
#define ADC_CLR_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) & ~(value)))
#define ADC_TOG_CLP3(base, value) (ADC_WR_CLP3(base, ADC_RD_CLP3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP3 bitfields
 */

/*!
 * @name Register ADC_CLP3, field CLP3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP3_CLP3 field. */
#define ADC_RD_CLP3_CLP3(base) ((ADC_CLP3_REG(base) & ADC_CLP3_CLP3_MASK) >> ADC_CLP3_CLP3_SHIFT)
#define ADC_BRD_CLP3_CLP3(base) (ADC_RD_CLP3_CLP3(base))

/*! @brief Set the CLP3 field to a new value. */
#define ADC_WR_CLP3_CLP3(base, value) (ADC_RMW_CLP3(base, ADC_CLP3_CLP3_MASK, ADC_CLP3_CLP3(value)))
#define ADC_BWR_CLP3_CLP3(base, value) (ADC_WR_CLP3_CLP3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP2 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP2 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP2 register
 */
/*@{*/
#define ADC_RD_CLP2(base)        (ADC_CLP2_REG(base))
#define ADC_WR_CLP2(base, value) (ADC_CLP2_REG(base) = (value))
#define ADC_RMW_CLP2(base, mask, value) (ADC_WR_CLP2(base, (ADC_RD_CLP2(base) & ~(mask)) | (value)))
#define ADC_SET_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) |  (value)))
#define ADC_CLR_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) & ~(value)))
#define ADC_TOG_CLP2(base, value) (ADC_WR_CLP2(base, ADC_RD_CLP2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP2 bitfields
 */

/*!
 * @name Register ADC_CLP2, field CLP2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP2_CLP2 field. */
#define ADC_RD_CLP2_CLP2(base) ((ADC_CLP2_REG(base) & ADC_CLP2_CLP2_MASK) >> ADC_CLP2_CLP2_SHIFT)
#define ADC_BRD_CLP2_CLP2(base) (ADC_RD_CLP2_CLP2(base))

/*! @brief Set the CLP2 field to a new value. */
#define ADC_WR_CLP2_CLP2(base, value) (ADC_RMW_CLP2(base, ADC_CLP2_CLP2_MASK, ADC_CLP2_CLP2(value)))
#define ADC_BWR_CLP2_CLP2(base, value) (ADC_WR_CLP2_CLP2(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP1 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP1 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP1 register
 */
/*@{*/
#define ADC_RD_CLP1(base)        (ADC_CLP1_REG(base))
#define ADC_WR_CLP1(base, value) (ADC_CLP1_REG(base) = (value))
#define ADC_RMW_CLP1(base, mask, value) (ADC_WR_CLP1(base, (ADC_RD_CLP1(base) & ~(mask)) | (value)))
#define ADC_SET_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) |  (value)))
#define ADC_CLR_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) & ~(value)))
#define ADC_TOG_CLP1(base, value) (ADC_WR_CLP1(base, ADC_RD_CLP1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP1 bitfields
 */

/*!
 * @name Register ADC_CLP1, field CLP1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP1_CLP1 field. */
#define ADC_RD_CLP1_CLP1(base) ((ADC_CLP1_REG(base) & ADC_CLP1_CLP1_MASK) >> ADC_CLP1_CLP1_SHIFT)
#define ADC_BRD_CLP1_CLP1(base) (ADC_RD_CLP1_CLP1(base))

/*! @brief Set the CLP1 field to a new value. */
#define ADC_WR_CLP1_CLP1(base, value) (ADC_RMW_CLP1(base, ADC_CLP1_CLP1_MASK, ADC_CLP1_CLP1(value)))
#define ADC_BWR_CLP1_CLP1(base, value) (ADC_WR_CLP1_CLP1(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLP0 - ADC Plus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLP0 - ADC Plus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLPD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLP0 register
 */
/*@{*/
#define ADC_RD_CLP0(base)        (ADC_CLP0_REG(base))
#define ADC_WR_CLP0(base, value) (ADC_CLP0_REG(base) = (value))
#define ADC_RMW_CLP0(base, mask, value) (ADC_WR_CLP0(base, (ADC_RD_CLP0(base) & ~(mask)) | (value)))
#define ADC_SET_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) |  (value)))
#define ADC_CLR_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) & ~(value)))
#define ADC_TOG_CLP0(base, value) (ADC_WR_CLP0(base, ADC_RD_CLP0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLP0 bitfields
 */

/*!
 * @name Register ADC_CLP0, field CLP0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLP0_CLP0 field. */
#define ADC_RD_CLP0_CLP0(base) ((ADC_CLP0_REG(base) & ADC_CLP0_CLP0_MASK) >> ADC_CLP0_CLP0_SHIFT)
#define ADC_BRD_CLP0_CLP0(base) (ADC_RD_CLP0_CLP0(base))

/*! @brief Set the CLP0 field to a new value. */
#define ADC_WR_CLP0_CLP0(base, value) (ADC_RMW_CLP0(base, ADC_CLP0_CLP0_MASK, ADC_CLP0_CLP0(value)))
#define ADC_BWR_CLP0_CLP0(base, value) (ADC_WR_CLP0_CLP0(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLMD - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMD - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x0000000AU
 *
 * The Minus-Side General Calibration Value (CLMx) registers contain calibration
 * information that is generated by the calibration function. These registers
 * contain seven calibration values of varying widths: CLM0[5:0], CLM1[6:0],
 * CLM2[7:0], CLM3[8:0], CLM4[9:0], CLMS[5:0], and CLMD[5:0]. CLMx are automatically
 * set when the self-calibration sequence is done, that is, CAL is cleared. If
 * these registers are written by the user after calibration, the linearity error
 * specifications may not be met. For more information regarding the calibration
 * procedure, please refer to the Calibration functionThe ADC contains a
 * self-calibration function that is required to achieve the specified accuracy. section.
 */
/*!
 * @name Constants and macros for entire ADC_CLMD register
 */
/*@{*/
#define ADC_RD_CLMD(base)        (ADC_CLMD_REG(base))
#define ADC_WR_CLMD(base, value) (ADC_CLMD_REG(base) = (value))
#define ADC_RMW_CLMD(base, mask, value) (ADC_WR_CLMD(base, (ADC_RD_CLMD(base) & ~(mask)) | (value)))
#define ADC_SET_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) |  (value)))
#define ADC_CLR_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) & ~(value)))
#define ADC_TOG_CLMD(base, value) (ADC_WR_CLMD(base, ADC_RD_CLMD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMD bitfields
 */

/*!
 * @name Register ADC_CLMD, field CLMD[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMD_CLMD field. */
#define ADC_RD_CLMD_CLMD(base) ((ADC_CLMD_REG(base) & ADC_CLMD_CLMD_MASK) >> ADC_CLMD_CLMD_SHIFT)
#define ADC_BRD_CLMD_CLMD(base) (ADC_RD_CLMD_CLMD(base))

/*! @brief Set the CLMD field to a new value. */
#define ADC_WR_CLMD_CLMD(base, value) (ADC_RMW_CLMD(base, ADC_CLMD_CLMD_MASK, ADC_CLMD_CLMD(value)))
#define ADC_BWR_CLMD_CLMD(base, value) (ADC_WR_CLMD_CLMD(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLMS - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLMS - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLMS register
 */
/*@{*/
#define ADC_RD_CLMS(base)        (ADC_CLMS_REG(base))
#define ADC_WR_CLMS(base, value) (ADC_CLMS_REG(base) = (value))
#define ADC_RMW_CLMS(base, mask, value) (ADC_WR_CLMS(base, (ADC_RD_CLMS(base) & ~(mask)) | (value)))
#define ADC_SET_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) |  (value)))
#define ADC_CLR_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) & ~(value)))
#define ADC_TOG_CLMS(base, value) (ADC_WR_CLMS(base, ADC_RD_CLMS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLMS bitfields
 */

/*!
 * @name Register ADC_CLMS, field CLMS[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLMS_CLMS field. */
#define ADC_RD_CLMS_CLMS(base) ((ADC_CLMS_REG(base) & ADC_CLMS_CLMS_MASK) >> ADC_CLMS_CLMS_SHIFT)
#define ADC_BRD_CLMS_CLMS(base) (ADC_RD_CLMS_CLMS(base))

/*! @brief Set the CLMS field to a new value. */
#define ADC_WR_CLMS_CLMS(base, value) (ADC_RMW_CLMS(base, ADC_CLMS_CLMS_MASK, ADC_CLMS_CLMS(value)))
#define ADC_BWR_CLMS_CLMS(base, value) (ADC_WR_CLMS_CLMS(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM4 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM4 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000200U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM4 register
 */
/*@{*/
#define ADC_RD_CLM4(base)        (ADC_CLM4_REG(base))
#define ADC_WR_CLM4(base, value) (ADC_CLM4_REG(base) = (value))
#define ADC_RMW_CLM4(base, mask, value) (ADC_WR_CLM4(base, (ADC_RD_CLM4(base) & ~(mask)) | (value)))
#define ADC_SET_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) |  (value)))
#define ADC_CLR_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) & ~(value)))
#define ADC_TOG_CLM4(base, value) (ADC_WR_CLM4(base, ADC_RD_CLM4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM4 bitfields
 */

/*!
 * @name Register ADC_CLM4, field CLM4[9:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM4_CLM4 field. */
#define ADC_RD_CLM4_CLM4(base) ((ADC_CLM4_REG(base) & ADC_CLM4_CLM4_MASK) >> ADC_CLM4_CLM4_SHIFT)
#define ADC_BRD_CLM4_CLM4(base) (ADC_RD_CLM4_CLM4(base))

/*! @brief Set the CLM4 field to a new value. */
#define ADC_WR_CLM4_CLM4(base, value) (ADC_RMW_CLM4(base, ADC_CLM4_CLM4_MASK, ADC_CLM4_CLM4(value)))
#define ADC_BWR_CLM4_CLM4(base, value) (ADC_WR_CLM4_CLM4(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM3 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM3 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000100U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM3 register
 */
/*@{*/
#define ADC_RD_CLM3(base)        (ADC_CLM3_REG(base))
#define ADC_WR_CLM3(base, value) (ADC_CLM3_REG(base) = (value))
#define ADC_RMW_CLM3(base, mask, value) (ADC_WR_CLM3(base, (ADC_RD_CLM3(base) & ~(mask)) | (value)))
#define ADC_SET_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) |  (value)))
#define ADC_CLR_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) & ~(value)))
#define ADC_TOG_CLM3(base, value) (ADC_WR_CLM3(base, ADC_RD_CLM3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM3 bitfields
 */

/*!
 * @name Register ADC_CLM3, field CLM3[8:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM3_CLM3 field. */
#define ADC_RD_CLM3_CLM3(base) ((ADC_CLM3_REG(base) & ADC_CLM3_CLM3_MASK) >> ADC_CLM3_CLM3_SHIFT)
#define ADC_BRD_CLM3_CLM3(base) (ADC_RD_CLM3_CLM3(base))

/*! @brief Set the CLM3 field to a new value. */
#define ADC_WR_CLM3_CLM3(base, value) (ADC_RMW_CLM3(base, ADC_CLM3_CLM3_MASK, ADC_CLM3_CLM3(value)))
#define ADC_BWR_CLM3_CLM3(base, value) (ADC_WR_CLM3_CLM3(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM2 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM2 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000080U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM2 register
 */
/*@{*/
#define ADC_RD_CLM2(base)        (ADC_CLM2_REG(base))
#define ADC_WR_CLM2(base, value) (ADC_CLM2_REG(base) = (value))
#define ADC_RMW_CLM2(base, mask, value) (ADC_WR_CLM2(base, (ADC_RD_CLM2(base) & ~(mask)) | (value)))
#define ADC_SET_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) |  (value)))
#define ADC_CLR_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) & ~(value)))
#define ADC_TOG_CLM2(base, value) (ADC_WR_CLM2(base, ADC_RD_CLM2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM2 bitfields
 */

/*!
 * @name Register ADC_CLM2, field CLM2[7:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM2_CLM2 field. */
#define ADC_RD_CLM2_CLM2(base) ((ADC_CLM2_REG(base) & ADC_CLM2_CLM2_MASK) >> ADC_CLM2_CLM2_SHIFT)
#define ADC_BRD_CLM2_CLM2(base) (ADC_RD_CLM2_CLM2(base))

/*! @brief Set the CLM2 field to a new value. */
#define ADC_WR_CLM2_CLM2(base, value) (ADC_RMW_CLM2(base, ADC_CLM2_CLM2_MASK, ADC_CLM2_CLM2(value)))
#define ADC_BWR_CLM2_CLM2(base, value) (ADC_WR_CLM2_CLM2(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM1 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM1 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000040U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM1 register
 */
/*@{*/
#define ADC_RD_CLM1(base)        (ADC_CLM1_REG(base))
#define ADC_WR_CLM1(base, value) (ADC_CLM1_REG(base) = (value))
#define ADC_RMW_CLM1(base, mask, value) (ADC_WR_CLM1(base, (ADC_RD_CLM1(base) & ~(mask)) | (value)))
#define ADC_SET_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) |  (value)))
#define ADC_CLR_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) & ~(value)))
#define ADC_TOG_CLM1(base, value) (ADC_WR_CLM1(base, ADC_RD_CLM1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM1 bitfields
 */

/*!
 * @name Register ADC_CLM1, field CLM1[6:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM1_CLM1 field. */
#define ADC_RD_CLM1_CLM1(base) ((ADC_CLM1_REG(base) & ADC_CLM1_CLM1_MASK) >> ADC_CLM1_CLM1_SHIFT)
#define ADC_BRD_CLM1_CLM1(base) (ADC_RD_CLM1_CLM1(base))

/*! @brief Set the CLM1 field to a new value. */
#define ADC_WR_CLM1_CLM1(base, value) (ADC_RMW_CLM1(base, ADC_CLM1_CLM1_MASK, ADC_CLM1_CLM1(value)))
#define ADC_BWR_CLM1_CLM1(base, value) (ADC_WR_CLM1_CLM1(base, value))
/*@}*/

/*******************************************************************************
 * ADC_CLM0 - ADC Minus-Side General Calibration Value Register
 ******************************************************************************/

/*!
 * @brief ADC_CLM0 - ADC Minus-Side General Calibration Value Register (RW)
 *
 * Reset value: 0x00000020U
 *
 * For more information, see CLMD register description.
 */
/*!
 * @name Constants and macros for entire ADC_CLM0 register
 */
/*@{*/
#define ADC_RD_CLM0(base)        (ADC_CLM0_REG(base))
#define ADC_WR_CLM0(base, value) (ADC_CLM0_REG(base) = (value))
#define ADC_RMW_CLM0(base, mask, value) (ADC_WR_CLM0(base, (ADC_RD_CLM0(base) & ~(mask)) | (value)))
#define ADC_SET_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) |  (value)))
#define ADC_CLR_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) & ~(value)))
#define ADC_TOG_CLM0(base, value) (ADC_WR_CLM0(base, ADC_RD_CLM0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual ADC_CLM0 bitfields
 */

/*!
 * @name Register ADC_CLM0, field CLM0[5:0] (RW)
 *
 * Calibration Value
 */
/*@{*/
/*! @brief Read current value of the ADC_CLM0_CLM0 field. */
#define ADC_RD_CLM0_CLM0(base) ((ADC_CLM0_REG(base) & ADC_CLM0_CLM0_MASK) >> ADC_CLM0_CLM0_SHIFT)
#define ADC_BRD_CLM0_CLM0(base) (ADC_RD_CLM0_CLM0(base))

/*! @brief Set the CLM0 field to a new value. */
#define ADC_WR_CLM0_CLM0(base, value) (ADC_RMW_CLM0(base, ADC_CLM0_CLM0_MASK, ADC_CLM0_CLM0(value)))
#define ADC_BWR_CLM0_CLM0(base, value) (ADC_WR_CLM0_CLM0(base, value))
/*@}*/

/*
 * MKS22F25612 CAN
 *
 * Flex Controller Area Network module
 *
 * Registers defined in this header file:
 * - CAN_MCR - Module Configuration Register
 * - CAN_CTRL1 - Control 1 register
 * - CAN_TIMER - Free Running Timer
 * - CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 * - CAN_RX14MASK - Rx 14 Mask register
 * - CAN_RX15MASK - Rx 15 Mask register
 * - CAN_ECR - Error Counter
 * - CAN_ESR1 - Error and Status 1 register
 * - CAN_IMASK1 - Interrupt Masks 1 register
 * - CAN_IFLAG1 - Interrupt Flags 1 register
 * - CAN_CTRL2 - Control 2 register
 * - CAN_ESR2 - Error and Status 2 register
 * - CAN_CRCR - CRC Register
 * - CAN_RXFGMASK - Rx FIFO Global Mask register
 * - CAN_RXFIR - Rx FIFO Information Register
 * - CAN_CBT - CAN Bit Timing Register
 * - CAN_CS - Message Buffer 0 CS Register
 * - CAN_ID - Message Buffer 0 ID Register
 * - CAN_WORD0 - Message Buffer 0 WORD0 Register
 * - CAN_WORD1 - Message Buffer 0 WORD1 Register
 * - CAN_RXIMR - Rx Individual Mask Registers
 */

#define CAN_INSTANCE_COUNT (2U) /*!< Number of instances of the CAN module. */
#define CAN0_IDX (0U) /*!< Instance number for CAN0. */
#define CAN1_IDX (1U) /*!< Instance number for CAN1. */

/*******************************************************************************
 * CAN_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief CAN_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0xD890000FU
 *
 * This register defines global system configurations, such as the module
 * operation modes and the maximum message buffer configuration.
 */
/*!
 * @name Constants and macros for entire CAN_MCR register
 */
/*@{*/
#define CAN_RD_MCR(base)         (CAN_MCR_REG(base))
#define CAN_WR_MCR(base, value)  (CAN_MCR_REG(base) = (value))
#define CAN_RMW_MCR(base, mask, value) (CAN_WR_MCR(base, (CAN_RD_MCR(base) & ~(mask)) | (value)))
#define CAN_SET_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) |  (value)))
#define CAN_CLR_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) & ~(value)))
#define CAN_TOG_MCR(base, value) (CAN_WR_MCR(base, CAN_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_MCR bitfields
 */

/*!
 * @name Register CAN_MCR, field MAXMB[6:0] (RW)
 *
 * This 7-bit field defines the number of the last Message Buffers that will
 * take part in the matching and arbitration processes. The reset value (0x0F) is
 * equivalent to a 16 MB configuration. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Number of the last MB =
 * MAXMB MAXMB must be programmed with a value smaller than or equal to the number
 * of available Message Buffers. Additionally, the definition of MAXMB value
 * must take into account the region of MBs occupied by Rx FIFO and its ID filters
 * table space defined by RFFN bit in CAN_CTRL2 register. MAXMB also impacts the
 * definition of the minimum number of peripheral clocks per CAN bit as described
 * in Table "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate"
 * (see Arbitration and matching timing).
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MAXMB field. */
#define CAN_RD_MCR_MAXMB(base) ((CAN_MCR_REG(base) & CAN_MCR_MAXMB_MASK) >> CAN_MCR_MAXMB_SHIFT)
#define CAN_BRD_MCR_MAXMB(base) (CAN_RD_MCR_MAXMB(base))

/*! @brief Set the MAXMB field to a new value. */
#define CAN_WR_MCR_MAXMB(base, value) (CAN_RMW_MCR(base, CAN_MCR_MAXMB_MASK, CAN_MCR_MAXMB(value)))
#define CAN_BWR_MCR_MAXMB(base, value) (CAN_WR_MCR_MAXMB(base, value))
/*@}*/

/*!
 * @name Register CAN_MCR, field IDAM[9:8] (RW)
 *
 * This 2-bit field identifies the format of the Rx FIFO ID Filter Table
 * elements. Note that all elements of the table are configured at the same time by this
 * field (they are all the same format). See Section "Rx FIFO Structure". This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes.
 *
 * Values:
 * - 00 - Format A: One full ID (standard and extended) per ID Filter Table
 *     element.
 * - 01 - Format B: Two full standard IDs or two partial 14-bit (standard and
 *     extended) IDs per ID Filter Table element.
 * - 10 - Format C: Four partial 8-bit Standard IDs per ID Filter Table element.
 * - 11 - Format D: All frames rejected.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IDAM field. */
#define CAN_RD_MCR_IDAM(base) ((CAN_MCR_REG(base) & CAN_MCR_IDAM_MASK) >> CAN_MCR_IDAM_SHIFT)
#define CAN_BRD_MCR_IDAM(base) (CAN_RD_MCR_IDAM(base))

/*! @brief Set the IDAM field to a new value. */
#define CAN_WR_MCR_IDAM(base, value) (CAN_RMW_MCR(base, CAN_MCR_IDAM_MASK, CAN_MCR_IDAM(value)))
#define CAN_BWR_MCR_IDAM(base, value) (CAN_WR_MCR_IDAM(base, value))
/*@}*/

/*!
 * @name Register CAN_MCR, field AEN[12] (RW)
 *
 * When asserted, this bit enables the Tx abort mechanism. This mechanism
 * guarantees a safe procedure for aborting a pending transmission, so that no frame is
 * sent in the CAN bus without notification. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes. When CAN_MCR[AEN]
 * is asserted, only the abort mechanism (see Transmission abort mechanism) must
 * be used for updating Mailboxes configured for transmission. Writing the Abort
 * code into Rx Mailboxes can cause unpredictable results when the CAN_MCR[AEN] is
 * asserted.
 *
 * Values:
 * - 0 - Abort disabled.
 * - 1 - Abort enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_AEN field. */
#define CAN_RD_MCR_AEN(base) ((CAN_MCR_REG(base) & CAN_MCR_AEN_MASK) >> CAN_MCR_AEN_SHIFT)
#define CAN_BRD_MCR_AEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_AEN_SHIFT))

/*! @brief Set the AEN field to a new value. */
#define CAN_WR_MCR_AEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_AEN_MASK, CAN_MCR_AEN(value)))
#define CAN_BWR_MCR_AEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_AEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPRIOEN[13] (RW)
 *
 * This bit is provided for backwards compatibility with legacy applications. It
 * controls whether the local priority feature is enabled or not. It is used to
 * expand the ID used during the arbitration process. With this expanded ID
 * concept, the arbitration process is done based on the full 32-bit word, but the
 * actual transmitted ID still has 11-bit for standard frames and 29-bit for
 * extended frames. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes.
 *
 * Values:
 * - 0 - Local Priority disabled.
 * - 1 - Local Priority enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPRIOEN field. */
#define CAN_RD_MCR_LPRIOEN(base) ((CAN_MCR_REG(base) & CAN_MCR_LPRIOEN_MASK) >> CAN_MCR_LPRIOEN_SHIFT)
#define CAN_BRD_MCR_LPRIOEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPRIOEN_SHIFT))

/*! @brief Set the LPRIOEN field to a new value. */
#define CAN_WR_MCR_LPRIOEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_LPRIOEN_MASK, CAN_MCR_LPRIOEN(value)))
#define CAN_BWR_MCR_LPRIOEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPRIOEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field DMA[15] (RW)
 *
 * The DMA Enable bit controls whether the DMA feature is enabled or not. The
 * DMA feature can only be used in Rx FIFO, consequently the bit CAN_MCR[RFEN] must
 * be asserted. When DMA and RFEN are set, the CAN_IFLAG1[BUF5I] generates the
 * DMA request and no RX FIFO interrupt is generated. This bit can be written in
 * Freeze mode only as it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - DMA feature for RX FIFO disabled.
 * - 1 - DMA feature for RX FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_DMA field. */
#define CAN_RD_MCR_DMA(base) ((CAN_MCR_REG(base) & CAN_MCR_DMA_MASK) >> CAN_MCR_DMA_SHIFT)
#define CAN_BRD_MCR_DMA(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define CAN_WR_MCR_DMA(base, value) (CAN_RMW_MCR(base, CAN_MCR_DMA_MASK, CAN_MCR_DMA(value)))
#define CAN_BWR_MCR_DMA(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field IRMQ[16] (RW)
 *
 * This bit indicates whether Rx matching process will be based either on
 * individual masking and queue or on masking scheme with CAN_RXMGMASK, CAN_RX14MASK,
 * CAN_RX15MASK and CAN_RXFGMASK. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Individual Rx masking and queue feature are disabled. For backward
 *     compatibility with legacy applications, the reading of C/S word locks the MB
 *     even if it is EMPTY.
 * - 1 - Individual Rx masking and queue feature are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_IRMQ field. */
#define CAN_RD_MCR_IRMQ(base) ((CAN_MCR_REG(base) & CAN_MCR_IRMQ_MASK) >> CAN_MCR_IRMQ_SHIFT)
#define CAN_BRD_MCR_IRMQ(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_IRMQ_SHIFT))

/*! @brief Set the IRMQ field to a new value. */
#define CAN_WR_MCR_IRMQ(base, value) (CAN_RMW_MCR(base, CAN_MCR_IRMQ_MASK, CAN_MCR_IRMQ(value)))
#define CAN_BWR_MCR_IRMQ(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_IRMQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SRXDIS[17] (RW)
 *
 * This bit defines whether FlexCAN is allowed to receive frames transmitted by
 * itself. If this bit is asserted, frames transmitted by the module will not be
 * stored in any MB, regardless if the MB is programmed with an ID that matches
 * the transmitted frame, and no interrupt flag or interrupt signal will be
 * generated due to the frame reception. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Self reception enabled.
 * - 1 - Self reception disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SRXDIS field. */
#define CAN_RD_MCR_SRXDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_SRXDIS_MASK) >> CAN_MCR_SRXDIS_SHIFT)
#define CAN_BRD_MCR_SRXDIS(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SRXDIS_SHIFT))

/*! @brief Set the SRXDIS field to a new value. */
#define CAN_WR_MCR_SRXDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_SRXDIS_MASK, CAN_MCR_SRXDIS(value)))
#define CAN_BWR_MCR_SRXDIS(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SRXDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field DOZE[18] (RW)
 *
 * This bit defines whether FlexCAN is allowed to enter low-power mode when Doze
 * mode is requested at chip level . This bit is automatically reset when
 * FlexCAN wakes up from Doze mode upon detecting activity on the CAN bus (self wake-up
 * enabled).
 *
 * Values:
 * - 0 - FlexCAN is not enabled to enter low-power mode when Doze mode is
 *     requested.
 * - 1 - FlexCAN is enabled to enter low-power mode when Doze mode is requested.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_DOZE field. */
#define CAN_RD_MCR_DOZE(base) ((CAN_MCR_REG(base) & CAN_MCR_DOZE_MASK) >> CAN_MCR_DOZE_SHIFT)
#define CAN_BRD_MCR_DOZE(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DOZE_SHIFT))

/*! @brief Set the DOZE field to a new value. */
#define CAN_WR_MCR_DOZE(base, value) (CAN_RMW_MCR(base, CAN_MCR_DOZE_MASK, CAN_MCR_DOZE(value)))
#define CAN_BWR_MCR_DOZE(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_DOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKSRC[19] (RW)
 *
 * This bit defines whether the integrated low-pass filter is applied to protect
 * the Rx CAN input from spurious wake up. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - FlexCAN uses the unfiltered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 * - 1 - FlexCAN uses the filtered Rx input to detect recessive to dominant
 *     edges on the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKSRC field. */
#define CAN_RD_MCR_WAKSRC(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKSRC_MASK) >> CAN_MCR_WAKSRC_SHIFT)
#define CAN_BRD_MCR_WAKSRC(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKSRC_SHIFT))

/*! @brief Set the WAKSRC field to a new value. */
#define CAN_WR_MCR_WAKSRC(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKSRC_MASK, CAN_MCR_WAKSRC(value)))
#define CAN_BWR_MCR_WAKSRC(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field LPMACK[20] (RO)
 *
 * This read-only bit indicates that FlexCAN is in a low-power mode (Disable
 * mode, Doze mode , Stop mode). A low-power mode cannot be entered until all
 * current transmission or reception processes have finished, so the CPU can poll the
 * LPMACK bit to know when FlexCAN has actually entered low power mode. This bit
 * is not affected by soft reset. LPMACK will be asserted within 180 CAN bits from
 * the low-power mode request by the CPU, and negated within 2 CAN bits after
 * the low-power mode request removal (see Section "Protocol Timing").
 *
 * Values:
 * - 0 - FlexCAN is not in a low-power mode.
 * - 1 - FlexCAN is in a low-power mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_LPMACK field. */
#define CAN_RD_MCR_LPMACK(base) ((CAN_MCR_REG(base) & CAN_MCR_LPMACK_MASK) >> CAN_MCR_LPMACK_SHIFT)
#define CAN_BRD_MCR_LPMACK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_LPMACK_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field WRNEN[21] (RW)
 *
 * When asserted, this bit enables the generation of the TWRNINT and RWRNINT
 * flags in the Error and Status Register 1 (ESR1). If WRNEN is negated, the TWRNINT
 * and RWRNINT flags will always be zero, independent of the values of the error
 * counters, and no warning interrupt will ever be generated. This bit can be
 * written in Freeze mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - TWRNINT and RWRNINT bits are zero, independent of the values in the
 *     error counters.
 * - 1 - TWRNINT and RWRNINT bits are set when the respective error counter
 *     transitions from less than 96 to greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WRNEN field. */
#define CAN_RD_MCR_WRNEN(base) ((CAN_MCR_REG(base) & CAN_MCR_WRNEN_MASK) >> CAN_MCR_WRNEN_SHIFT)
#define CAN_BRD_MCR_WRNEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WRNEN_SHIFT))

/*! @brief Set the WRNEN field to a new value. */
#define CAN_WR_MCR_WRNEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_WRNEN_MASK, CAN_MCR_WRNEN(value)))
#define CAN_BWR_MCR_WRNEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WRNEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SLFWAK[22] (RW)
 *
 * This bit enables the Self Wake Up feature when FlexCAN is in a low-power mode
 * other than Disable mode. When this feature is enabled, the FlexCAN module
 * monitors the bus for wake up event, that is, a recessive-to-dominant transition.
 * If a wake up event is detected during Doze mode, FlexCAN requests to resume
 * its clocks and, if enabled to do so, generates a Wake Up interrupt to the CPU.
 * If a wake up event is detected during Stop mode, then FlexCAN generates, if
 * enabled to do so, a Wake Up interrupt to the CPU so that it can exit Stop mode
 * globally and FlexCAN can request to resume the clocks. When FlexCAN is in a
 * low-power mode other than Disable mode, this bit cannot be written as it is
 * blocked by hardware.
 *
 * Values:
 * - 0 - FlexCAN Self Wake Up feature is disabled.
 * - 1 - FlexCAN Self Wake Up feature is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SLFWAK field. */
#define CAN_RD_MCR_SLFWAK(base) ((CAN_MCR_REG(base) & CAN_MCR_SLFWAK_MASK) >> CAN_MCR_SLFWAK_SHIFT)
#define CAN_BRD_MCR_SLFWAK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SLFWAK_SHIFT))

/*! @brief Set the SLFWAK field to a new value. */
#define CAN_WR_MCR_SLFWAK(base, value) (CAN_RMW_MCR(base, CAN_MCR_SLFWAK_MASK, CAN_MCR_SLFWAK(value)))
#define CAN_BWR_MCR_SLFWAK(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SLFWAK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field SUPV[23] (RW)
 *
 * This bit configures the FlexCAN to be either in Supervisor or User mode. The
 * registers affected by this bit are marked as S/U in the Access Type column of
 * the module memory map. Reset value of this bit is 1, so the affected registers
 * start with Supervisor access allowance only. This bit can be written only in
 * Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - FlexCAN is in User mode. Affected registers allow both Supervisor and
 *     Unrestricted accesses.
 * - 1 - FlexCAN is in Supervisor mode. Affected registers allow only Supervisor
 *     access. Unrestricted access behaves as though the access was done to an
 *     unimplemented register location.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SUPV field. */
#define CAN_RD_MCR_SUPV(base) ((CAN_MCR_REG(base) & CAN_MCR_SUPV_MASK) >> CAN_MCR_SUPV_SHIFT)
#define CAN_BRD_MCR_SUPV(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SUPV_SHIFT))

/*! @brief Set the SUPV field to a new value. */
#define CAN_WR_MCR_SUPV(base, value) (CAN_RMW_MCR(base, CAN_MCR_SUPV_MASK, CAN_MCR_SUPV(value)))
#define CAN_BWR_MCR_SUPV(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SUPV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZACK[24] (RO)
 *
 * This read-only bit indicates that FlexCAN is in Freeze mode and its prescaler
 * is stopped. The Freeze mode request cannot be granted until current
 * transmission or reception processes have finished. Therefore the software can poll the
 * FRZACK bit to know when FlexCAN has actually entered Freeze mode. If Freeze
 * Mode request is negated, then this bit is negated after the FlexCAN prescaler is
 * running again. If Freeze mode is requested while FlexCAN is in a low power
 * mode, then the FRZACK bit will be set only when the low-power mode is exited.
 * See Section "Freeze Mode". This bit is not affected by soft reset. FRZACK will
 * be asserted within 178 CAN bits from the freeze mode request by the CPU, and
 * negated within 2 CAN bits after the freeze mode request removal (see Section
 * "Protocol Timing").
 *
 * Values:
 * - 0 - FlexCAN not in Freeze mode, prescaler running.
 * - 1 - FlexCAN in Freeze mode, prescaler stopped.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZACK field. */
#define CAN_RD_MCR_FRZACK(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZACK_MASK) >> CAN_MCR_FRZACK_SHIFT)
#define CAN_BRD_MCR_FRZACK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZACK_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field SOFTRST[25] (RW)
 *
 * When this bit is asserted, FlexCAN resets its internal state machines and
 * some of the memory mapped registers. The SOFTRST bit can be asserted directly by
 * the CPU when it writes to the MCR Register, but it is also asserted when
 * global soft reset is requested at chip level. Because soft reset is synchronous and
 * has to follow a request/acknowledge procedure across clock domains, it may
 * take some time to fully propagate its effect. The SOFTRST bit remains asserted
 * while reset is pending, and is automatically negated when reset completes.
 * Therefore, software can poll this bit to know when the soft reset has completed.
 * Soft reset cannot be applied while clocks are shut down in a low power mode.
 * The module should be first removed from low power mode, and then soft reset can
 * be applied. This bit is not affected by soft reset.
 *
 * Values:
 * - 0 - No reset request.
 * - 1 - Resets the registers affected by soft reset.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_SOFTRST field. */
#define CAN_RD_MCR_SOFTRST(base) ((CAN_MCR_REG(base) & CAN_MCR_SOFTRST_MASK) >> CAN_MCR_SOFTRST_SHIFT)
#define CAN_BRD_MCR_SOFTRST(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SOFTRST_SHIFT))

/*! @brief Set the SOFTRST field to a new value. */
#define CAN_WR_MCR_SOFTRST(base, value) (CAN_RMW_MCR(base, CAN_MCR_SOFTRST_MASK, CAN_MCR_SOFTRST(value)))
#define CAN_BWR_MCR_SOFTRST(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_SOFTRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field WAKMSK[26] (RW)
 *
 * This bit enables the Wake Up Interrupt generation under Self Wake Up
 * mechanism.
 *
 * Values:
 * - 0 - Wake Up Interrupt is disabled.
 * - 1 - Wake Up Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_WAKMSK field. */
#define CAN_RD_MCR_WAKMSK(base) ((CAN_MCR_REG(base) & CAN_MCR_WAKMSK_MASK) >> CAN_MCR_WAKMSK_SHIFT)
#define CAN_BRD_MCR_WAKMSK(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKMSK_SHIFT))

/*! @brief Set the WAKMSK field to a new value. */
#define CAN_WR_MCR_WAKMSK(base, value) (CAN_RMW_MCR(base, CAN_MCR_WAKMSK_MASK, CAN_MCR_WAKMSK(value)))
#define CAN_BWR_MCR_WAKMSK(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_WAKMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field NOTRDY[27] (RO)
 *
 * This read-only bit indicates that FlexCAN is either in Disable mode, Doze
 * mode , Stop mode or Freeze mode. It is negated once FlexCAN has exited these
 * modes. This bit is not affected by soft reset.
 *
 * Values:
 * - 0 - FlexCAN module is either in Normal mode, Listen-Only mode or Loop-Back
 *     mode.
 * - 1 - FlexCAN module is either in Disable mode, Doze mode , Stop mode or
 *     Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_NOTRDY field. */
#define CAN_RD_MCR_NOTRDY(base) ((CAN_MCR_REG(base) & CAN_MCR_NOTRDY_MASK) >> CAN_MCR_NOTRDY_SHIFT)
#define CAN_BRD_MCR_NOTRDY(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_NOTRDY_SHIFT))
/*@}*/

/*!
 * @name Register CAN_MCR, field HALT[28] (RW)
 *
 * Assertion of this bit puts the FlexCAN module into Freeze mode. The CPU
 * should clear it after initializing the Message Buffers and the Control Registers
 * CAN_CTRL1 and CAN_CTRL2. No reception or transmission is performed by FlexCAN
 * before this bit is cleared. Freeze mode cannot be entered while FlexCAN is in a
 * low power mode. The HALT bit is set by hardware when a non-correctable error
 * is detected and NCEFAFRZ bit in CAN_MECR register is asserted.
 *
 * Values:
 * - 0 - No Freeze mode request.
 * - 1 - Enters Freeze mode if the FRZ bit is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_HALT field. */
#define CAN_RD_MCR_HALT(base) ((CAN_MCR_REG(base) & CAN_MCR_HALT_MASK) >> CAN_MCR_HALT_SHIFT)
#define CAN_BRD_MCR_HALT(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define CAN_WR_MCR_HALT(base, value) (CAN_RMW_MCR(base, CAN_MCR_HALT_MASK, CAN_MCR_HALT(value)))
#define CAN_BWR_MCR_HALT(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field RFEN[29] (RW)
 *
 * This bit controls whether the Rx FIFO feature is enabled or not. When RFEN is
 * set, MBs 0 to 5 cannot be used for normal reception and transmission because
 * the corresponding memory region (0x80-0xDC) is used by the FIFO engine as well
 * as additional MBs (up to 32, depending on CAN_CTRL2[RFFN] setting) which are
 * used as Rx FIFO ID Filter Table elements. RFEN also impacts the definition of
 * the minimum number of peripheral clocks per CAN bit as described in the table
 * "Minimum Ratio Between Peripheral Clock Frequency and CAN Bit Rate" (see
 * Arbitration and matching timing). This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Rx FIFO not enabled.
 * - 1 - Rx FIFO enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_RFEN field. */
#define CAN_RD_MCR_RFEN(base) ((CAN_MCR_REG(base) & CAN_MCR_RFEN_MASK) >> CAN_MCR_RFEN_SHIFT)
#define CAN_BRD_MCR_RFEN(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_RFEN_SHIFT))

/*! @brief Set the RFEN field to a new value. */
#define CAN_WR_MCR_RFEN(base, value) (CAN_RMW_MCR(base, CAN_MCR_RFEN_MASK, CAN_MCR_RFEN(value)))
#define CAN_BWR_MCR_RFEN(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_RFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field FRZ[30] (RW)
 *
 * The FRZ bit specifies the FlexCAN behavior when the HALT bit in the CAN_MCR
 * Register is set or when Debug mode is requested at chip level. When FRZ is
 * asserted, FlexCAN is enabled to enter Freeze mode. Negation of this bit field
 * causes FlexCAN to exit from Freeze mode. This bit is set by hardware when a
 * non-correctable error is detected and NCEFAFRZ bit in CAN_MECR register is asserted.
 *
 * Values:
 * - 0 - Not enabled to enter Freeze mode.
 * - 1 - Enabled to enter Freeze mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_FRZ field. */
#define CAN_RD_MCR_FRZ(base) ((CAN_MCR_REG(base) & CAN_MCR_FRZ_MASK) >> CAN_MCR_FRZ_SHIFT)
#define CAN_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define CAN_WR_MCR_FRZ(base, value) (CAN_RMW_MCR(base, CAN_MCR_FRZ_MASK, CAN_MCR_FRZ(value)))
#define CAN_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_MCR, field MDIS[31] (RW)
 *
 * This bit controls whether FlexCAN is enabled or not. When disabled, FlexCAN
 * disables the clocks to the CAN Protocol Engine and Controller Host Interface
 * sub-modules. This bit is not affected by soft reset.
 *
 * Values:
 * - 0 - Enable the FlexCAN module.
 * - 1 - Disable the FlexCAN module.
 */
/*@{*/
/*! @brief Read current value of the CAN_MCR_MDIS field. */
#define CAN_RD_MCR_MDIS(base) ((CAN_MCR_REG(base) & CAN_MCR_MDIS_MASK) >> CAN_MCR_MDIS_SHIFT)
#define CAN_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define CAN_WR_MCR_MDIS(base, value) (CAN_RMW_MCR(base, CAN_MCR_MDIS_MASK, CAN_MCR_MDIS(value)))
#define CAN_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&CAN_MCR_REG(base), CAN_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL1 - Control 1 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL1 - Control 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is defined for specific FlexCAN control features related to the
 * CAN bus, such as bit-rate, programmable sampling point within an Rx bit, Loop
 * Back mode, Listen-Only mode, Bus Off recovery behavior and interrupt enabling
 * (Bus-Off, Error, Warning). It also determines the Division Factor for the
 * clock prescaler. The CAN bit timing variables (PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW) can also be configured in CAN_CBT register, which extends the range of
 * all these variables. If CAN_CBT[BTF] is set, PRESDIV, PROPSEG, PSEG1, PSEG2 and
 * RJW fields of CAN_CTRL1 become read only. The contents of this register are
 * not affected by soft reset. The CAN bit variables in CAN_CTRL1 and in CAN_CBT
 * are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL1 register
 */
/*@{*/
#define CAN_RD_CTRL1(base)       (CAN_CTRL1_REG(base))
#define CAN_WR_CTRL1(base, value) (CAN_CTRL1_REG(base) = (value))
#define CAN_RMW_CTRL1(base, mask, value) (CAN_WR_CTRL1(base, (CAN_RD_CTRL1(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) |  (value)))
#define CAN_CLR_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) & ~(value)))
#define CAN_TOG_CTRL1(base, value) (CAN_WR_CTRL1(base, CAN_RD_CTRL1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL1 bitfields
 */

/*!
 * @name Register CAN_CTRL1, field PROPSEG[2:0] (RW)
 *
 * This 3-bit field defines the length of the Propagation Segment in the bit
 * time. The valid programmable values are 0-7. This field can be written only in
 * Freeze mode because it is blocked by hardware in other modes. Propagation
 * Segment Time = (PROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PROPSEG field. */
#define CAN_RD_CTRL1_PROPSEG(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PROPSEG_MASK) >> CAN_CTRL1_PROPSEG_SHIFT)
#define CAN_BRD_CTRL1_PROPSEG(base) (CAN_RD_CTRL1_PROPSEG(base))

/*! @brief Set the PROPSEG field to a new value. */
#define CAN_WR_CTRL1_PROPSEG(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PROPSEG_MASK, CAN_CTRL1_PROPSEG(value)))
#define CAN_BWR_CTRL1_PROPSEG(base, value) (CAN_WR_CTRL1_PROPSEG(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LOM[3] (RW)
 *
 * This bit configures FlexCAN to operate in Listen-Only mode. In this mode,
 * transmission is disabled, all error counters described in CAN_ECR register are
 * frozen and the module operates in a CAN Error Passive mode. Only messages
 * acknowledged by another CAN station will be received. If FlexCAN detects a message
 * that has not been acknowledged, it will flag a BIT0 error without changing the
 * receive error counter (RXERRCNT) in CAN_ECR register, as if it was trying to
 * acknowledge the message. Listen-Only mode is acknowledged by the state of
 * CAN_ESR1[FLTCONF] field indicating Passive Error. There can be some delay between
 * the Listen-Only mode request and acknowledge. This bit can be written in Freeze
 * mode only because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Listen-Only mode is deactivated.
 * - 1 - FlexCAN module operates in Listen-Only mode.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LOM field. */
#define CAN_RD_CTRL1_LOM(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LOM_MASK) >> CAN_CTRL1_LOM_SHIFT)
#define CAN_BRD_CTRL1_LOM(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LOM_SHIFT))

/*! @brief Set the LOM field to a new value. */
#define CAN_WR_CTRL1_LOM(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LOM_MASK, CAN_CTRL1_LOM(value)))
#define CAN_BWR_CTRL1_LOM(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LOM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LBUF[4] (RW)
 *
 * This bit defines the ordering mechanism for Message Buffer transmission. When
 * asserted, the CAN_MCR[LPRIOEN] bit does not affect the priority arbitration.
 * This bit can be written in Freeze mode only because it is blocked by hardware
 * in other modes.
 *
 * Values:
 * - 0 - Buffer with highest priority is transmitted first.
 * - 1 - Lowest number buffer is transmitted first.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LBUF field. */
#define CAN_RD_CTRL1_LBUF(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LBUF_MASK) >> CAN_CTRL1_LBUF_SHIFT)
#define CAN_BRD_CTRL1_LBUF(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LBUF_SHIFT))

/*! @brief Set the LBUF field to a new value. */
#define CAN_WR_CTRL1_LBUF(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LBUF_MASK, CAN_CTRL1_LBUF(value)))
#define CAN_BWR_CTRL1_LBUF(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LBUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TSYN[5] (RW)
 *
 * This bit enables a mechanism that resets the free-running timer each time a
 * message is received in Message Buffer 0. This feature provides means to
 * synchronize multiple FlexCAN stations with a special "SYNC" message, that is, global
 * network time. If the RFEN bit in CAN_MCR is set (Rx FIFO enabled), the first
 * available Mailbox, according to CAN_CTRL2[RFFN] setting, is used for timer
 * synchronization instead of MB0. This bit can be written in Freeze mode only
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Timer Sync feature disabled
 * - 1 - Timer Sync feature enabled
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TSYN field. */
#define CAN_RD_CTRL1_TSYN(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TSYN_MASK) >> CAN_CTRL1_TSYN_SHIFT)
#define CAN_BRD_CTRL1_TSYN(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TSYN_SHIFT))

/*! @brief Set the TSYN field to a new value. */
#define CAN_WR_CTRL1_TSYN(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TSYN_MASK, CAN_CTRL1_TSYN(value)))
#define CAN_BWR_CTRL1_TSYN(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TSYN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFREC[6] (RW)
 *
 * This bit defines how FlexCAN recovers from Bus Off state. If this bit is
 * negated, automatic recovering from Bus Off state occurs according to the CAN
 * Specification 2.0B. If the bit is asserted, automatic recovering from Bus Off is
 * disabled and the module remains in Bus Off state until the bit is negated by the
 * user. If the negation occurs before 128 sequences of 11 recessive bits are
 * detected on the CAN bus, then Bus Off recovery happens as if the BOFFREC bit had
 * never been asserted. If the negation occurs after 128 sequences of 11
 * recessive bits occurred, then FlexCAN will re-synchronize to the bus by waiting for
 * 11 recessive bits before joining the bus. After negation, the BOFFREC bit can
 * be re-asserted again during Bus Off, but it will be effective only the next
 * time the module enters Bus Off. If BOFFREC was negated when the module entered
 * Bus Off, asserting it during Bus Off will not be effective for the current Bus
 * Off recovery.
 *
 * Values:
 * - 0 - Automatic recovering from Bus Off state enabled.
 * - 1 - Automatic recovering from Bus Off state disabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFREC field. */
#define CAN_RD_CTRL1_BOFFREC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFREC_MASK) >> CAN_CTRL1_BOFFREC_SHIFT)
#define CAN_BRD_CTRL1_BOFFREC(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFREC_SHIFT))

/*! @brief Set the BOFFREC field to a new value. */
#define CAN_WR_CTRL1_BOFFREC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFREC_MASK, CAN_CTRL1_BOFFREC(value)))
#define CAN_BWR_CTRL1_BOFFREC(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFREC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field SMP[7] (RW)
 *
 * This bit defines the sampling mode of CAN bits at the Rx input. It can be
 * written in Freeze mode only because it is blocked by hardware in other modes. For
 * proper operation, to assert SMP it is necessary to guarantee a minimum value
 * of 2 TQs in CAN_CTRL1[PSEG1] (or CAN_CBT[EPSEG1]).
 *
 * Values:
 * - 0 - Just one sample is used to determine the bit value.
 * - 1 - Three samples are used to determine the value of the received bit: the
 *     regular one (sample point) and 2 preceding samples; a majority rule is
 *     used.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_SMP field. */
#define CAN_RD_CTRL1_SMP(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_SMP_MASK) >> CAN_CTRL1_SMP_SHIFT)
#define CAN_BRD_CTRL1_SMP(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_SMP_SHIFT))

/*! @brief Set the SMP field to a new value. */
#define CAN_WR_CTRL1_SMP(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_SMP_MASK, CAN_CTRL1_SMP(value)))
#define CAN_BWR_CTRL1_SMP(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_SMP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RWRNMSK[10] (RW)
 *
 * This bit provides a mask for the Rx Warning Interrupt associated with the
 * RWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0 - Rx Warning Interrupt disabled.
 * - 1 - Rx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RWRNMSK field. */
#define CAN_RD_CTRL1_RWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RWRNMSK_MASK) >> CAN_CTRL1_RWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_RWRNMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_RWRNMSK_SHIFT))

/*! @brief Set the RWRNMSK field to a new value. */
#define CAN_WR_CTRL1_RWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RWRNMSK_MASK, CAN_CTRL1_RWRNMSK(value)))
#define CAN_BWR_CTRL1_RWRNMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_RWRNMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field TWRNMSK[11] (RW)
 *
 * This bit provides a mask for the Tx Warning Interrupt associated with the
 * TWRNINT flag in the Error and Status Register 1 (ESR1). This bit is read as zero
 * when CAN_MCR[WRNEN] bit is negated. This bit can be written only if
 * CAN_MCR[WRNEN] bit is asserted.
 *
 * Values:
 * - 0 - Tx Warning Interrupt disabled.
 * - 1 - Tx Warning Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_TWRNMSK field. */
#define CAN_RD_CTRL1_TWRNMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_TWRNMSK_MASK) >> CAN_CTRL1_TWRNMSK_SHIFT)
#define CAN_BRD_CTRL1_TWRNMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TWRNMSK_SHIFT))

/*! @brief Set the TWRNMSK field to a new value. */
#define CAN_WR_CTRL1_TWRNMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_TWRNMSK_MASK, CAN_CTRL1_TWRNMSK(value)))
#define CAN_BWR_CTRL1_TWRNMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_TWRNMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field LPB[12] (RW)
 *
 * This bit configures FlexCAN to operate in Loop-Back mode. In this mode,
 * FlexCAN performs an internal loop back that can be used for self test operation.
 * The bit stream output of the transmitter is fed back internally to the receiver
 * input. The Rx CAN input pin is ignored and the Tx CAN output goes to the
 * recessive state (logic 1). FlexCAN behaves as it normally does when transmitting,
 * and treats its own transmitted message as a message received from a remote
 * node. In this mode, FlexCAN ignores the bit sent during the ACK slot in the CAN
 * frame acknowledge field, generating an internal acknowledge bit to ensure proper
 * reception of its own message. Both transmit and receive interrupts are
 * generated. This bit can be written only in Freeze mode because it is blocked by
 * hardware in other modes. In this mode, the CAN_MCR[SRXDIS] cannot be asserted
 * because this will impede the self reception of a transmitted message.
 *
 * Values:
 * - 0 - Loop Back disabled.
 * - 1 - Loop Back enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_LPB field. */
#define CAN_RD_CTRL1_LPB(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_LPB_MASK) >> CAN_CTRL1_LPB_SHIFT)
#define CAN_BRD_CTRL1_LPB(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LPB_SHIFT))

/*! @brief Set the LPB field to a new value. */
#define CAN_WR_CTRL1_LPB(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_LPB_MASK, CAN_CTRL1_LPB(value)))
#define CAN_BWR_CTRL1_LPB(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_LPB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field CLKSRC[13] (RW)
 *
 * This bit selects the clock source to the CAN Protocol Engine (PE) to be
 * either the peripheral clock or the oscillator clock. The selected clock is the one
 * fed to the prescaler to generate the Serial Clock (Sclock). In order to
 * guarantee reliable operation, this bit can be written only in Disable mode because
 * it is blocked by hardware in other modes. See Protocol timing".
 *
 * Values:
 * - 0 - The CAN engine clock source is the oscillator clock. Under this
 *     condition, the oscillator clock frequency must be lower than the bus clock.
 * - 1 - The CAN engine clock source is the peripheral clock.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_CLKSRC field. */
#define CAN_RD_CTRL1_CLKSRC(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_CLKSRC_MASK) >> CAN_CTRL1_CLKSRC_SHIFT)
#define CAN_BRD_CTRL1_CLKSRC(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_CLKSRC_SHIFT))

/*! @brief Set the CLKSRC field to a new value. */
#define CAN_WR_CTRL1_CLKSRC(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_CLKSRC_MASK, CAN_CTRL1_CLKSRC(value)))
#define CAN_BWR_CTRL1_CLKSRC(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_CLKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field ERRMSK[14] (RW)
 *
 * This bit provides a mask for the Error Interrupt ERRINT in the CAN_ESR1
 * register.
 *
 * Values:
 * - 0 - Error interrupt disabled.
 * - 1 - Error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_ERRMSK field. */
#define CAN_RD_CTRL1_ERRMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_ERRMSK_MASK) >> CAN_CTRL1_ERRMSK_SHIFT)
#define CAN_BRD_CTRL1_ERRMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_ERRMSK_SHIFT))

/*! @brief Set the ERRMSK field to a new value. */
#define CAN_WR_CTRL1_ERRMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_ERRMSK_MASK, CAN_CTRL1_ERRMSK(value)))
#define CAN_BWR_CTRL1_ERRMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_ERRMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field BOFFMSK[15] (RW)
 *
 * This bit provides a mask for the Bus Off Interrupt BOFFINT in CAN_ESR1
 * register.
 *
 * Values:
 * - 0 - Bus Off interrupt disabled.
 * - 1 - Bus Off interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_BOFFMSK field. */
#define CAN_RD_CTRL1_BOFFMSK(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_BOFFMSK_MASK) >> CAN_CTRL1_BOFFMSK_SHIFT)
#define CAN_BRD_CTRL1_BOFFMSK(base) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFMSK_SHIFT))

/*! @brief Set the BOFFMSK field to a new value. */
#define CAN_WR_CTRL1_BOFFMSK(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_BOFFMSK_MASK, CAN_CTRL1_BOFFMSK(value)))
#define CAN_BWR_CTRL1_BOFFMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL1_REG(base), CAN_CTRL1_BOFFMSK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG2[18:16] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 2 in the bit time. The
 * valid programmable values are 1-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 2 =
 * (PSEG2 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG2 field. */
#define CAN_RD_CTRL1_PSEG2(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG2_MASK) >> CAN_CTRL1_PSEG2_SHIFT)
#define CAN_BRD_CTRL1_PSEG2(base) (CAN_RD_CTRL1_PSEG2(base))

/*! @brief Set the PSEG2 field to a new value. */
#define CAN_WR_CTRL1_PSEG2(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG2_MASK, CAN_CTRL1_PSEG2(value)))
#define CAN_BWR_CTRL1_PSEG2(base, value) (CAN_WR_CTRL1_PSEG2(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PSEG1[21:19] (RW)
 *
 * This 3-bit field defines the length of Phase Segment 1 in the bit time. The
 * valid programmable values are 0-7. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Phase Buffer Segment 1 =
 * (PSEG1 + 1) * Time-Quanta.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PSEG1 field. */
#define CAN_RD_CTRL1_PSEG1(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PSEG1_MASK) >> CAN_CTRL1_PSEG1_SHIFT)
#define CAN_BRD_CTRL1_PSEG1(base) (CAN_RD_CTRL1_PSEG1(base))

/*! @brief Set the PSEG1 field to a new value. */
#define CAN_WR_CTRL1_PSEG1(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PSEG1_MASK, CAN_CTRL1_PSEG1(value)))
#define CAN_BWR_CTRL1_PSEG1(base, value) (CAN_WR_CTRL1_PSEG1(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field RJW[23:22] (RW)
 *
 * This 2-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization. One time quantum is equal to the
 * Sclock period. The valid programmable values are 0-3. This field can be written
 * only in Freeze mode because it is blocked by hardware in other modes. Resync Jump
 * Width = RJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_RJW field. */
#define CAN_RD_CTRL1_RJW(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_RJW_MASK) >> CAN_CTRL1_RJW_SHIFT)
#define CAN_BRD_CTRL1_RJW(base) (CAN_RD_CTRL1_RJW(base))

/*! @brief Set the RJW field to a new value. */
#define CAN_WR_CTRL1_RJW(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_RJW_MASK, CAN_CTRL1_RJW(value)))
#define CAN_BWR_CTRL1_RJW(base, value) (CAN_WR_CTRL1_RJW(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL1, field PRESDIV[31:24] (RW)
 *
 * This 8-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency. The Sclock period defines the time quantum of
 * the CAN protocol. For the reset value, the Sclock frequency is equal to the PE
 * clock frequency. The Maximum value of this field is 0xFF, that gives a minimum
 * Sclock frequency equal to the PE clock frequency divided by 256. See Section
 * "Protocol Timing". This field can be written only in Freeze mode because it is
 * blocked by hardware in other modes. Sclock frequency = PE clock frequency /
 * (PRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL1_PRESDIV field. */
#define CAN_RD_CTRL1_PRESDIV(base) ((CAN_CTRL1_REG(base) & CAN_CTRL1_PRESDIV_MASK) >> CAN_CTRL1_PRESDIV_SHIFT)
#define CAN_BRD_CTRL1_PRESDIV(base) (CAN_RD_CTRL1_PRESDIV(base))

/*! @brief Set the PRESDIV field to a new value. */
#define CAN_WR_CTRL1_PRESDIV(base, value) (CAN_RMW_CTRL1(base, CAN_CTRL1_PRESDIV_MASK, CAN_CTRL1_PRESDIV(value)))
#define CAN_BWR_CTRL1_PRESDIV(base, value) (CAN_WR_CTRL1_PRESDIV(base, value))
/*@}*/

/*******************************************************************************
 * CAN_TIMER - Free Running Timer
 ******************************************************************************/

/*!
 * @brief CAN_TIMER - Free Running Timer (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register represents a 16-bit free running counter that can be read and
 * written by the CPU. The timer starts from 0x0 after Reset, counts linearly to
 * 0xFFFF, and wraps around. The timer is incremented by the CAN bit clock, which
 * defines the baud rate on the CAN bus. During a message transmission/reception,
 * it increments by one for each bit that is received or transmitted. When there
 * is no message on the bus, it counts using the previously programmed baud
 * rate. The timer is not incremented during Disable, Doze , Stop and Freeze modes.
 * The timer value is captured when the second bit of the identifier field of any
 * frame is on the CAN bus. This captured value is written into the Time Stamp
 * entry in a message buffer after a successful reception or transmission of a
 * message. If bit CAN_CTRL1[TSYN] is asserted, the Timer is reset whenever a message
 * is received in the first available Mailbox, according to CAN_CTRL2[RFFN]
 * setting. The CPU can write to this register anytime. However, if the write occurs
 * at the same time that the Timer is being reset by a reception in the first
 * Mailbox, then the write value is discarded. Reading this register affects the
 * Mailbox Unlocking procedure, see Section "Mailbox Lock Mechanism".
 */
/*!
 * @name Constants and macros for entire CAN_TIMER register
 */
/*@{*/
#define CAN_RD_TIMER(base)       (CAN_TIMER_REG(base))
#define CAN_WR_TIMER(base, value) (CAN_TIMER_REG(base) = (value))
#define CAN_RMW_TIMER(base, mask, value) (CAN_WR_TIMER(base, (CAN_RD_TIMER(base) & ~(mask)) | (value)))
#define CAN_SET_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) |  (value)))
#define CAN_CLR_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) & ~(value)))
#define CAN_TOG_TIMER(base, value) (CAN_WR_TIMER(base, CAN_RD_TIMER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_TIMER bitfields
 */

/*!
 * @name Register CAN_TIMER, field TIMER[15:0] (RW)
 *
 * Contains the free-running counter value.
 */
/*@{*/
/*! @brief Read current value of the CAN_TIMER_TIMER field. */
#define CAN_RD_TIMER_TIMER(base) ((CAN_TIMER_REG(base) & CAN_TIMER_TIMER_MASK) >> CAN_TIMER_TIMER_SHIFT)
#define CAN_BRD_TIMER_TIMER(base) (CAN_RD_TIMER_TIMER(base))

/*! @brief Set the TIMER field to a new value. */
#define CAN_WR_TIMER_TIMER(base, value) (CAN_RMW_TIMER(base, CAN_TIMER_TIMER_MASK, CAN_TIMER_TIMER(value)))
#define CAN_BWR_TIMER_TIMER(base, value) (CAN_WR_TIMER_TIMER(base, value))
/*@}*/

/*******************************************************************************
 * CAN_RXMGMASK - Rx Mailboxes Global Mask Register
 ******************************************************************************/

/*!
 * @brief CAN_RXMGMASK - Rx Mailboxes Global Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RXMGMASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is negated, RXMGMASK is always in effect
 * (the bits in the MG field will mask the Mailbox filter bits). When the
 * CAN_MCR[IRMQ] bit is asserted, RXMGMASK has no effect (the bits in the MG field will
 * not mask the Mailbox filter bits). RXMGMASK is used to mask the filter fields
 * of all Rx MBs, excluding MBs 14-15, which have individual mask registers. This
 * register can only be written in Freeze mode as it is blocked by hardware in
 * other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXMGMASK register
 */
/*@{*/
#define CAN_RD_RXMGMASK(base)    (CAN_RXMGMASK_REG(base))
#define CAN_WR_RXMGMASK(base, value) (CAN_RXMGMASK_REG(base) = (value))
#define CAN_RMW_RXMGMASK(base, mask, value) (CAN_WR_RXMGMASK(base, (CAN_RD_RXMGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) |  (value)))
#define CAN_CLR_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) & ~(value)))
#define CAN_TOG_RXMGMASK(base, value) (CAN_WR_RXMGMASK(base, CAN_RD_RXMGMASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RX14MASK - Rx 14 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX14MASK - Rx 14 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX14MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX14MASK has no effect.
 * RX14MASK is used to mask the filter fields of Message Buffer 14. This register can
 * only be programmed while the module is in Freeze mode as it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX14MASK register
 */
/*@{*/
#define CAN_RD_RX14MASK(base)    (CAN_RX14MASK_REG(base))
#define CAN_WR_RX14MASK(base, value) (CAN_RX14MASK_REG(base) = (value))
#define CAN_RMW_RX14MASK(base, mask, value) (CAN_WR_RX14MASK(base, (CAN_RD_RX14MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) |  (value)))
#define CAN_CLR_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) & ~(value)))
#define CAN_TOG_RX14MASK(base, value) (CAN_WR_RX14MASK(base, CAN_RD_RX14MASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RX15MASK - Rx 15 Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RX15MASK - Rx 15 Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. RX15MASK is provided for legacy application
 * support. When the CAN_MCR[IRMQ] bit is asserted, RX15MASK has no effect.
 * RX15MASK is used to mask the filter fields of Message Buffer 15. This register can
 * be programmed only while the module is in Freeze mode because it is blocked by
 * hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RX15MASK register
 */
/*@{*/
#define CAN_RD_RX15MASK(base)    (CAN_RX15MASK_REG(base))
#define CAN_WR_RX15MASK(base, value) (CAN_RX15MASK_REG(base) = (value))
#define CAN_RMW_RX15MASK(base, mask, value) (CAN_WR_RX15MASK(base, (CAN_RD_RX15MASK(base) & ~(mask)) | (value)))
#define CAN_SET_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) |  (value)))
#define CAN_CLR_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) & ~(value)))
#define CAN_TOG_RX15MASK(base, value) (CAN_WR_RX15MASK(base, CAN_RD_RX15MASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_ECR - Error Counter
 ******************************************************************************/

/*!
 * @brief CAN_ECR - Error Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has two 8-bit fields reflecting the value of the FlexCAN error
 * counters: Transmit Error Counter (TXERRCNT field) Receive Error Counter
 * (RXERRCNT field) The Fault Confinement State (FLTCONF field in Error and Status
 * Register 1 - CAN_ESR1) is updated based on TXERRCNT and RXERRCNT counters.
 * TXERRCNT and RXERRCNT counters can be written in Freeze mode only. The rules for
 * increasing and decreasing these counters are described in the CAN protocol and are
 * completely implemented in the FlexCAN module. The following are the basic
 * rules for FlexCAN bus state transitions: If the value of TXERRCNT or RXERRCNT
 * increases to be greater than or equal to 128, the FLTCONF field in the Error and
 * Status Register is updated to reflect "Error Passive" state. If the FlexCAN
 * state is "Error Passive", and either TXERRCNT or RXERRCNT decrements to a value
 * less than or equal to 127 while the other already satisfies this condition,
 * the FLTCONF field in the Error and Status Register is updated to reflect "Error
 * Active" state. If the value of TXERRCNT increases to be greater than 255, the
 * FLTCONF field in the Error and Status Register is updated to reflect "Bus Off"
 * state, and an interrupt may be issued. The value of TXERRCNT is then reset to
 * zero. If FlexCAN is in "Bus Off' state, then TXERRCNT is cascaded together
 * with another internal counter to count the 128th occurrences of 11 consecutive
 * recessive bits on the bus. Hence, TXERRCNT is reset to zero and counts in a
 * manner where the internal counter counts 11 such bits and then wraps around while
 * incrementing the TXERRCNT. When TXERRCNT reaches the value of 128, the
 * FLTCONF field in the Error and Status Register is updated to be "Error Active" and
 * both error counters are reset to zero. At any instance of dominant bit
 * following a stream of less than 11 consecutive recessive bits, the internal counter
 * resets itself to zero without affecting the TXERRCNT value. If during system
 * start-up, only one node is operating, then its TXERRCNT increases in each message
 * it is trying to transmit, as a result of acknowledge errors (indicated by the
 * ACKERR bit in the Error and Status Register). After the transition to "Error
 * Passive" state, the TXERRCNT does not increment anymore by acknowledge errors.
 * Therefore the device never goes to the "Bus Off" state. If the RXERRCNT
 * increases to a value greater than 127, it is not incremented further, even if more
 * errors are detected while being a receiver. At the next successful message
 * reception, the counter is set to a value between 119 and 127 to resume to "Error
 * Active" state.
 */
/*!
 * @name Constants and macros for entire CAN_ECR register
 */
/*@{*/
#define CAN_RD_ECR(base)         (CAN_ECR_REG(base))
#define CAN_WR_ECR(base, value)  (CAN_ECR_REG(base) = (value))
#define CAN_RMW_ECR(base, mask, value) (CAN_WR_ECR(base, (CAN_RD_ECR(base) & ~(mask)) | (value)))
#define CAN_SET_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) |  (value)))
#define CAN_CLR_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) & ~(value)))
#define CAN_TOG_ECR(base, value) (CAN_WR_ECR(base, CAN_RD_ECR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ECR bitfields
 */

/*!
 * @name Register CAN_ECR, field TXERRCNT[7:0] (RW)
 *
 * Transmit Error Counter for all errors detected in transmitted messages. The
 * TXERRCNT counter is read-only except in Freeze mode, where it can be written by
 * the CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_TXERRCNT field. */
#define CAN_RD_ECR_TXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_TXERRCNT_MASK) >> CAN_ECR_TXERRCNT_SHIFT)
#define CAN_BRD_ECR_TXERRCNT(base) (CAN_RD_ECR_TXERRCNT(base))

/*! @brief Set the TXERRCNT field to a new value. */
#define CAN_WR_ECR_TXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_TXERRCNT_MASK, CAN_ECR_TXERRCNT(value)))
#define CAN_BWR_ECR_TXERRCNT(base, value) (CAN_WR_ECR_TXERRCNT(base, value))
/*@}*/

/*!
 * @name Register CAN_ECR, field RXERRCNT[15:8] (RW)
 *
 * Receive Error Counter for all errors detected in received messages. The
 * RXERRCNT counter is read-only except in Freeze mode, where it can be written by the
 * CPU.
 */
/*@{*/
/*! @brief Read current value of the CAN_ECR_RXERRCNT field. */
#define CAN_RD_ECR_RXERRCNT(base) ((CAN_ECR_REG(base) & CAN_ECR_RXERRCNT_MASK) >> CAN_ECR_RXERRCNT_SHIFT)
#define CAN_BRD_ECR_RXERRCNT(base) (CAN_RD_ECR_RXERRCNT(base))

/*! @brief Set the RXERRCNT field to a new value. */
#define CAN_WR_ECR_RXERRCNT(base, value) (CAN_RMW_ECR(base, CAN_ECR_RXERRCNT_MASK, CAN_ECR_RXERRCNT(value)))
#define CAN_BWR_ECR_RXERRCNT(base, value) (CAN_WR_ECR_RXERRCNT(base, value))
/*@}*/

/*******************************************************************************
 * CAN_ESR1 - Error and Status 1 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR1 - Error and Status 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register reports various error conditions detected in the reception and
 * transmission of a CAN frame, some general status of the device and it is the
 * source of some interrupts to the CPU. The reported error conditions are
 * BIT1ERR, BIT0ERR, ACKKERR, CRCERR, FRMERR and STFERR. An error detected in a single
 * CAN frame may be reported by one or more error flags. Also, error reporting is
 * cummulative in case more error events happen in the next frames while the CPU
 * does not attempt to read this register. TXWRN, RXWRN, IDLE, TX, FLTCONF, RX
 * and SYNCH are status bits. BOFFINT, BOFFDONEINT, ERRINT, WAKINT, TWRNINT and
 * RWRNINT are interrupt bits. It is recommended the CPU to use the following
 * procedure when servicing interrupt requests generated by these bits: Read this
 * register to capture all error condition and status bits. This action clear the
 * respective bits that were set since the last read access. Write 1 to clear the
 * interrupt bit that has triggered the interrupt request. Write 1 to clear the
 * ERR_OVR bit if it is set. Starting from all error flags cleared, a first error
 * event sets the ERRINT (provided the corresponding mask bit is asserted). If other
 * error events in subsequent frames happen before the CPU to serve the
 * interrupt request, the ERR_OVR bit is set to indicate that errors from different
 * frames had accumulated. SYNCH IDLE TX RX FlexCAN State 0 0 0 0 Not synchronized to
 * CAN bus 1 1 x x Idle 1 0 1 0 Transmitting 1 0 0 1 Receiving
 */
/*!
 * @name Constants and macros for entire CAN_ESR1 register
 */
/*@{*/
#define CAN_RD_ESR1(base)        (CAN_ESR1_REG(base))
#define CAN_WR_ESR1(base, value) (CAN_ESR1_REG(base) = (value))
#define CAN_RMW_ESR1(base, mask, value) (CAN_WR_ESR1(base, (CAN_RD_ESR1(base) & ~(mask)) | (value)))
#define CAN_SET_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) |  (value)))
#define CAN_CLR_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) & ~(value)))
#define CAN_TOG_ESR1(base, value) (CAN_WR_ESR1(base, CAN_RD_ESR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR1 bitfields
 */

/*!
 * @name Register CAN_ESR1, field WAKINT[0] (W1C)
 *
 * This field applies when FlexCAN is in low-power mode under Self Wake Up
 * mechanism: Doze mode Stop mode When a recessive-to-dominant transition is detected
 * on the CAN bus and if the CAN_MCR[WAKMSK] bit is set, an interrupt is
 * generated to the CPU. This bit is cleared by writing it to 1. When CAN_MCR[SLFWAK] is
 * negated, this flag is masked. The CPU must clear this flag before disabling
 * the bit. Otherwise it will be set when the SLFWAK is set again. Writing 0 has no
 * effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - Indicates a recessive to dominant transition was received on the CAN
 *     bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_WAKINT field. */
#define CAN_RD_ESR1_WAKINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_WAKINT_MASK) >> CAN_ESR1_WAKINT_SHIFT)
#define CAN_BRD_ESR1_WAKINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_WAKINT_SHIFT))

/*! @brief Set the WAKINT field to a new value. */
#define CAN_WR_ESR1_WAKINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_WAKINT(value)))
#define CAN_BWR_ESR1_WAKINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_WAKINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERRINT[1] (W1C)
 *
 * This bit indicates that at least one of the Error Bits (BIT1ERR, BIT0ERR,
 * ACKERR. CRCERR, FRMERR or STFERR) is set. If the corresponding mask bit
 * CAN_CTRL1[ERRMSK] is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - Indicates setting of any Error Bit in the Error and Status Register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERRINT field. */
#define CAN_RD_ESR1_ERRINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERRINT_MASK) >> CAN_ESR1_ERRINT_SHIFT)
#define CAN_BRD_ESR1_ERRINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_SHIFT))

/*! @brief Set the ERRINT field to a new value. */
#define CAN_WR_ESR1_ERRINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERRINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_ERRINT(value)))
#define CAN_BWR_ESR1_ERRINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERRINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFINT[2] (W1C)
 *
 * This bit is set when FlexCAN enters 'Bus Off' state. If the corresponding
 * mask bit in the Control Register 1 (CAN_CTRL1[BOFFMSK]) is set, an interrupt is
 * generated to the CPU. This bit is cleared by writing it to 1. Writing 0 has no
 * effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - FlexCAN module entered Bus Off state.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFINT field. */
#define CAN_RD_ESR1_BOFFINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFINT_MASK) >> CAN_ESR1_BOFFINT_SHIFT)
#define CAN_BRD_ESR1_BOFFINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFINT_SHIFT))

/*! @brief Set the BOFFINT field to a new value. */
#define CAN_WR_ESR1_BOFFINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFINT(value)))
#define CAN_BWR_ESR1_BOFFINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RX[3] (RO)
 *
 * This bit indicates if FlexCAN is receiving a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not receiving a message.
 * - 1 - FlexCAN is receiving a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RX field. */
#define CAN_RD_ESR1_RX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RX_MASK) >> CAN_ESR1_RX_SHIFT)
#define CAN_BRD_ESR1_RX(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RX_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FLTCONF[5:4] (RO)
 *
 * This 2-bit field indicates the Confinement State of the FlexCAN module. If
 * the LOM bit in the Control Register 1 is asserted, after some delay that depends
 * on the CAN bit timing the FLTCONF field will indicate "Error Passive". The
 * very same delay affects the way how FLTCONF reflects an update to CAN_ECR
 * register by the CPU. It may be necessary up to one CAN bit time to get them coherent
 * again. This bit field is affected by soft reset, but if the LOM bit is
 * asserted, its reset value lasts just one CAN bit. After this time, FLTCONF reports
 * "Error Passive".
 *
 * Values:
 * - 00 - Error Active
 * - 01 - Error Passive
 * - 1x - Bus Off
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FLTCONF field. */
#define CAN_RD_ESR1_FLTCONF(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FLTCONF_MASK) >> CAN_ESR1_FLTCONF_SHIFT)
#define CAN_BRD_ESR1_FLTCONF(base) (CAN_RD_ESR1_FLTCONF(base))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TX[6] (RO)
 *
 * This bit indicates if FlexCAN is transmitting a message. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not transmitting a message.
 * - 1 - FlexCAN is transmitting a message.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TX field. */
#define CAN_RD_ESR1_TX(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TX_MASK) >> CAN_ESR1_TX_SHIFT)
#define CAN_BRD_ESR1_TX(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TX_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field IDLE[7] (RO)
 *
 * This bit indicates when CAN bus is in IDLE state. See the table in the
 * overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - CAN bus is now IDLE.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_IDLE field. */
#define CAN_RD_ESR1_IDLE(base) ((CAN_ESR1_REG(base) & CAN_ESR1_IDLE_MASK) >> CAN_ESR1_IDLE_SHIFT)
#define CAN_BRD_ESR1_IDLE(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_IDLE_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RXWRN[8] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * reception and is affected by the value of RXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - RXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RXWRN field. */
#define CAN_RD_ESR1_RXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RXWRN_MASK) >> CAN_ESR1_RXWRN_SHIFT)
#define CAN_BRD_ESR1_RXWRN(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RXWRN_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TXWRN[9] (RO)
 *
 * This bit indicates when repetitive errors are occurring during message
 * transmission and is affected by the value of TXERRCNT in CAN_ECR register only. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - TXERRCNT is greater than or equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TXWRN field. */
#define CAN_RD_ESR1_TXWRN(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TXWRN_MASK) >> CAN_ESR1_TXWRN_SHIFT)
#define CAN_BRD_ESR1_TXWRN(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TXWRN_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field STFERR[10] (RO)
 *
 * This bit indicates that a Stuffing Error has been detected by the receiver
 * node.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A Stuffing Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_STFERR field. */
#define CAN_RD_ESR1_STFERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_STFERR_MASK) >> CAN_ESR1_STFERR_SHIFT)
#define CAN_BRD_ESR1_STFERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_STFERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field FRMERR[11] (RO)
 *
 * This bit indicates that a Form Error has been detected by the receiver node,
 * that is, a fixed-form bit field contains at least one illegal bit.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A Form Error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_FRMERR field. */
#define CAN_RD_ESR1_FRMERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_FRMERR_MASK) >> CAN_ESR1_FRMERR_SHIFT)
#define CAN_BRD_ESR1_FRMERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_FRMERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field CRCERR[12] (RO)
 *
 * This bit indicates that a CRC Error has been detected by the receiver node,
 * that is, the calculated CRC is different from the received.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - A CRC error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_CRCERR field. */
#define CAN_RD_ESR1_CRCERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_CRCERR_MASK) >> CAN_ESR1_CRCERR_SHIFT)
#define CAN_BRD_ESR1_CRCERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_CRCERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ACKERR[13] (RO)
 *
 * This bit indicates that an Acknowledge Error has been detected by the
 * transmitter node, that is, a dominant bit has not been detected during the ACK SLOT.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - An ACK error occurred since last read of this register.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ACKERR field. */
#define CAN_RD_ESR1_ACKERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ACKERR_MASK) >> CAN_ESR1_ACKERR_SHIFT)
#define CAN_BRD_ESR1_ACKERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ACKERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT0ERR[14] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - At least one bit sent as dominant is received as recessive.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT0ERR field. */
#define CAN_RD_ESR1_BIT0ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT0ERR_MASK) >> CAN_ESR1_BIT0ERR_SHIFT)
#define CAN_BRD_ESR1_BIT0ERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT0ERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BIT1ERR[15] (RO)
 *
 * This bit indicates when an inconsistency occurs between the transmitted and
 * the received bit in a message. This bit is not set by a transmitter in case of
 * arbitration field or ACK slot, or in case of a node sending a passive error
 * flag that detects dominant bits.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - At least one bit sent as recessive is received as dominant.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BIT1ERR field. */
#define CAN_RD_ESR1_BIT1ERR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BIT1ERR_MASK) >> CAN_ESR1_BIT1ERR_SHIFT)
#define CAN_BRD_ESR1_BIT1ERR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BIT1ERR_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field RWRNINT[16] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the RWRNINT bit is set when the
 * RXWRN flag transitions from 0 to 1, meaning that the Rx error counters reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[RWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing
 * it to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - The Rx error counter transitioned from less than 96 to greater than or
 *     equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_RWRNINT field. */
#define CAN_RD_ESR1_RWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_RWRNINT_MASK) >> CAN_ESR1_RWRNINT_SHIFT)
#define CAN_BRD_ESR1_RWRNINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RWRNINT_SHIFT))

/*! @brief Set the RWRNINT field to a new value. */
#define CAN_WR_ESR1_RWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_RWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_RWRNINT(value)))
#define CAN_BWR_ESR1_RWRNINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_RWRNINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field TWRNINT[17] (W1C)
 *
 * If the WRNEN bit in CAN_MCR is asserted, the TWRNINT bit is set when the
 * TXWRN flag transitions from 0 to 1, meaning that the Tx error counter reached 96.
 * If the corresponding mask bit in the Control 1 Register (CAN_CTRL1[TWRNMSK])
 * is set, an interrupt is generated to the CPU. This bit is cleared by writing it
 * to 1. When WRNEN is negated, this flag is masked. CPU must clear this flag
 * before disabling the bit. Otherwise it will be set when the WRNEN is set again.
 * Writing 0 has no effect. This flag is not generated during Bus Off state. This
 * bit is not updated during Freeze mode.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - The Tx error counter transitioned from less than 96 to greater than or
 *     equal to 96.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_TWRNINT field. */
#define CAN_RD_ESR1_TWRNINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_TWRNINT_MASK) >> CAN_ESR1_TWRNINT_SHIFT)
#define CAN_BRD_ESR1_TWRNINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TWRNINT_SHIFT))

/*! @brief Set the TWRNINT field to a new value. */
#define CAN_WR_ESR1_TWRNINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_TWRNINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_TWRNINT(value)))
#define CAN_BWR_ESR1_TWRNINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_TWRNINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field SYNCH[18] (RO)
 *
 * This read-only flag indicates whether the FlexCAN is synchronized to the CAN
 * bus and able to participate in the communication process. It is set and
 * cleared by the FlexCAN. See the table in the overall CAN_ESR1 register description.
 *
 * Values:
 * - 0 - FlexCAN is not synchronized to the CAN bus.
 * - 1 - FlexCAN is synchronized to the CAN bus.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_SYNCH field. */
#define CAN_RD_ESR1_SYNCH(base) ((CAN_ESR1_REG(base) & CAN_ESR1_SYNCH_MASK) >> CAN_ESR1_SYNCH_SHIFT)
#define CAN_BRD_ESR1_SYNCH(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_SYNCH_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR1, field BOFFDONEINT[19] (W1C)
 *
 * This bit is set when the Tx Error Counter (TXERRCNT) has finished counting
 * 128 occurrences of 11 consecutive recessive bits on the CAN bus and is ready to
 * leave Bus Off. If the corresponding mask bit in the Control 2 Register
 * (BOFFDONEMSK) is set, an interrupt is generated to the CPU. This bit is cleared by
 * writing it to 1. Writing 0 has no effect.
 *
 * Values:
 * - 0 - No such occurrence.
 * - 1 - FlexCAN module has completed Bus Off process.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_BOFFDONEINT field. */
#define CAN_RD_ESR1_BOFFDONEINT(base) ((CAN_ESR1_REG(base) & CAN_ESR1_BOFFDONEINT_MASK) >> CAN_ESR1_BOFFDONEINT_SHIFT)
#define CAN_BRD_ESR1_BOFFDONEINT(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFDONEINT_SHIFT))

/*! @brief Set the BOFFDONEINT field to a new value. */
#define CAN_WR_ESR1_BOFFDONEINT(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_BOFFDONEINT_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_ERROVR_MASK), CAN_ESR1_BOFFDONEINT(value)))
#define CAN_BWR_ESR1_BOFFDONEINT(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_BOFFDONEINT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_ESR1, field ERROVR[21] (W1C)
 *
 * This bit indicates that an error condition occurred when any error flag is
 * already set. This bit is cleared by writing it to 1.
 *
 * Values:
 * - 0 - Overrun has not occurred.
 * - 1 - Overrun has occured.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR1_ERROVR field. */
#define CAN_RD_ESR1_ERROVR(base) ((CAN_ESR1_REG(base) & CAN_ESR1_ERROVR_MASK) >> CAN_ESR1_ERROVR_SHIFT)
#define CAN_BRD_ESR1_ERROVR(base) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERROVR_SHIFT))

/*! @brief Set the ERROVR field to a new value. */
#define CAN_WR_ESR1_ERROVR(base, value) (CAN_RMW_ESR1(base, (CAN_ESR1_ERROVR_MASK | CAN_ESR1_WAKINT_MASK | CAN_ESR1_ERRINT_MASK | CAN_ESR1_BOFFINT_MASK | CAN_ESR1_RWRNINT_MASK | CAN_ESR1_TWRNINT_MASK | CAN_ESR1_BOFFDONEINT_MASK), CAN_ESR1_ERROVR(value)))
#define CAN_BWR_ESR1_ERROVR(base, value) (BITBAND_ACCESS32(&CAN_ESR1_REG(base), CAN_ESR1_ERROVR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_IMASK1 - Interrupt Masks 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IMASK1 - Interrupt Masks 1 register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register allows any number of a range of the 16 Message Buffer
 * Interrupts to be enabled or disabled for MB15 to MB0. It contains one interrupt mask
 * bit per buffer, enabling the CPU to determine which buffer generates an
 * interrupt after a successful transmission or reception, that is, when the
 * corresponding CAN_IFLAG1 bit is set.
 */
/*!
 * @name Constants and macros for entire CAN_IMASK1 register
 */
/*@{*/
#define CAN_RD_IMASK1(base)      (CAN_IMASK1_REG(base))
#define CAN_WR_IMASK1(base, value) (CAN_IMASK1_REG(base) = (value))
#define CAN_RMW_IMASK1(base, mask, value) (CAN_WR_IMASK1(base, (CAN_RD_IMASK1(base) & ~(mask)) | (value)))
#define CAN_SET_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) |  (value)))
#define CAN_CLR_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) & ~(value)))
#define CAN_TOG_IMASK1(base, value) (CAN_WR_IMASK1(base, CAN_RD_IMASK1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_IFLAG1 - Interrupt Flags 1 register
 ******************************************************************************/

/*!
 * @brief CAN_IFLAG1 - Interrupt Flags 1 register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the flags for the 16 Message Buffer interrupts for MB15
 * to MB0. It contains one interrupt flag bit per buffer. Each successful
 * transmission or reception sets the corresponding CAN_IFLAG1 bit. If the
 * corresponding CAN_IMASK1 bit is set, an interrupt will be generated. The interrupt flag
 * must be cleared by writing 1 to it. Writing 0 has no effect. There is an
 * exception when DMA for Rx FIFO is enabled, as described below. The BUF7I to BUF5I
 * flags are also used to represent FIFO interrupts when the Rx FIFO is enabled.
 * When the bit CAN_MCR[RFEN] is set and the bit CAN_MCR[DMA] is negated, the
 * function of the 8 least significant interrupt flags changes: BUF7I, BUF6I and BUF5I
 * indicate operating conditions of the FIFO, BUF0I is used to empty FIFO, and
 * BUF4I to BUF1I bits are reserved. Before enabling the CAN_MCR[RFEN], the CPU
 * must service the IFLAG bits asserted in the Rx FIFO region; see Section "Rx
 * FIFO". Otherwise, these IFLAG bits will mistakenly show the related MBs now
 * belonging to FIFO as having contents to be serviced. When the CAN_MCR[RFEN] bit is
 * negated, the FIFO flags must be cleared. The same care must be taken when an
 * CAN_CTRL2[RFFN] value is selected extending Rx FIFO filters beyond MB7. For
 * example, when RFFN is 0x8, the MB0-23 range is occupied by Rx FIFO filters and
 * related IFLAG bits must be cleared. When both the CAN_MCR[RFEN] and CAN_MCR[DMA]
 * bits are asserted (DMA feature for Rx FIFO enabled), the function of the 8
 * least significant interrupt flags (BUF7I - BUF0I) are changed to support the DMA
 * operation. BUF7I and BUF6I are not used, as well as, BUF4I to BUF1I. BUF5I
 * indicates operating condition of FIFO, and BUF0I is used to empty FIFO. Moreover,
 * BUF5I does not generate a CPU interrupt, but generates a DMA request. IMASK1
 * bits in Rx FIFO region are not considered when bit CAN_MCR[DMA] is enabled. In
 * addition the CPU must not clear the flag BUF5I when DMA is enabled. Before
 * enabling the bit CAN_MCR[DMA], the CPU must service the IFLAGs asserted in the Rx
 * FIFO region. When the bit CAN_MCR[DMA] is negated, the FIFO must be empty.
 * Before updating CAN_MCR[MAXMB] field, CPU must service the CAN_IFLAG1 bits whose
 * MB value is greater than the CAN_MCR[MAXMB] to be updated; otherwise, they
 * will remain set and be inconsistent with the number of MBs available.
 */
/*!
 * @name Constants and macros for entire CAN_IFLAG1 register
 */
/*@{*/
#define CAN_RD_IFLAG1(base)      (CAN_IFLAG1_REG(base))
#define CAN_WR_IFLAG1(base, value) (CAN_IFLAG1_REG(base) = (value))
#define CAN_RMW_IFLAG1(base, mask, value) (CAN_WR_IFLAG1(base, (CAN_RD_IFLAG1(base) & ~(mask)) | (value)))
#define CAN_SET_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) |  (value)))
#define CAN_CLR_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) & ~(value)))
#define CAN_TOG_IFLAG1(base, value) (CAN_WR_IFLAG1(base, CAN_RD_IFLAG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_IFLAG1 bitfields
 */

/*!
 * @name Register CAN_IFLAG1, field BUF0I[0] (W1C)
 *
 * When the RFEN bit in MCR is cleared (Rx FIFO disabled), this bit flags the
 * interrupt for MB0. If the Rx FIFO is enabled, this bit is used to trigger the
 * clear FIFO operation. This operation empties FIFO contents. Before performing
 * this operation the CPU must service all FIFO related IFLAGs. When the bit
 * MCR[DMA] is enabled this operation also clears the BUF5I flag and consequently abort
 * the DMA request. The clear FIFO operation occurs when the CPU writes 1 in
 * BUF0I. It is only allowed in Freeze Mode and is blocked by hardware in other
 * conditions.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF0I field. */
#define CAN_RD_IFLAG1_BUF0I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF0I_MASK) >> CAN_IFLAG1_BUF0I_SHIFT)
#define CAN_BRD_IFLAG1_BUF0I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF0I_SHIFT))

/*! @brief Set the BUF0I field to a new value. */
#define CAN_WR_IFLAG1_BUF0I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF0I(value)))
#define CAN_BWR_IFLAG1_BUF0I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF0I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF4TO1I[4:1] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled),
 * these bits flag the interrupts for MB4 to MB1. These flags are cleared by the
 * FlexCAN whenever the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF4TO1I
 * flags are reserved when CAN_MCR[RFEN] is set.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception when MCR[RFEN]=0.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception when MCR[RFEN]=0.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF4TO1I field. */
#define CAN_RD_IFLAG1_BUF4TO1I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF4TO1I_MASK) >> CAN_IFLAG1_BUF4TO1I_SHIFT)
#define CAN_BRD_IFLAG1_BUF4TO1I(base) (CAN_RD_IFLAG1_BUF4TO1I(base))

/*! @brief Set the BUF4TO1I field to a new value. */
#define CAN_WR_IFLAG1_BUF4TO1I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF4TO1I(value)))
#define CAN_BWR_IFLAG1_BUF4TO1I(base, value) (CAN_WR_IFLAG1_BUF4TO1I(base, value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF5I[5] (W1C)
 *
 * When the RFEN bit in the MCR is cleared (Rx FIFO disabled), this bit flags
 * the interrupt for MB5. This flag is cleared by the FlexCAN whenever the bit
 * MCR[RFEN] is changed by CPU writes. When MCR[RFEN] is set (Rx FIFO enabled), the
 * BUF5I flag represents "Frames available in Rx FIFO" and indicates that at least
 * one frame is available to be read from the Rx FIFO. When the MCR[DMA] bit is
 * enabled, this flag generates a DMA request and the CPU must not clear this bit
 * by writing 1 in BUF5I.
 *
 * Values:
 * - 0 - No occurrence of MB5 completing transmission/reception when
 *     MCR[RFEN]=0, or of frame(s) available in the FIFO, when MCR[RFEN]=1
 * - 1 - MB5 completed transmission/reception when MCR[RFEN]=0, or frame(s)
 *     available in the Rx FIFO when MCR[RFEN]=1. It generates a DMA request in case
 *     of MCR[RFEN] and MCR[DMA] are enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF5I field. */
#define CAN_RD_IFLAG1_BUF5I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF5I_MASK) >> CAN_IFLAG1_BUF5I_SHIFT)
#define CAN_BRD_IFLAG1_BUF5I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF5I_SHIFT))

/*! @brief Set the BUF5I field to a new value. */
#define CAN_WR_IFLAG1_BUF5I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF5I(value)))
#define CAN_BWR_IFLAG1_BUF5I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF5I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF6I[6] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB6. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF6I flag represents "Rx
 * FIFO Warning" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * when the number of unread messages within the Rx FIFO is increased to 5 from 4
 * due to the reception of a new one, meaning that the Rx FIFO is almost full. Note
 * that if the flag is cleared while the number of unread messages is greater
 * than 4, it does not assert again until the number of unread messages within the
 * Rx FIFO is decreased to be equal to or less than 4.
 *
 * Values:
 * - 0 - No occurrence of MB6 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1
 * - 1 - MB6 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     almost full when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF6I field. */
#define CAN_RD_IFLAG1_BUF6I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF6I_MASK) >> CAN_IFLAG1_BUF6I_SHIFT)
#define CAN_BRD_IFLAG1_BUF6I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF6I_SHIFT))

/*! @brief Set the BUF6I field to a new value. */
#define CAN_WR_IFLAG1_BUF6I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF6I(value)))
#define CAN_BWR_IFLAG1_BUF6I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF6I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF7I[7] (W1C)
 *
 * When the RFEN bit in the CAN_MCR register is cleared (Rx FIFO disabled), this
 * bit flags the interrupt for MB7. This flag is cleared by the FlexCAN whenever
 * the bit CAN_MCR[RFEN] is changed by CPU writes. The BUF7I flag represents "Rx
 * FIFO Overflow" when CAN_MCR[RFEN] is set. In this case, the flag indicates
 * that a message was lost because the Rx FIFO is full. Note that the flag will not
 * be asserted when the Rx FIFO is full and the message was captured by a
 * Mailbox.
 *
 * Values:
 * - 0 - No occurrence of MB7 completing transmission/reception when
 *     MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1
 * - 1 - MB7 completed transmission/reception when MCR[RFEN]=0, or Rx FIFO
 *     overflow when MCR[RFEN]=1
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF7I field. */
#define CAN_RD_IFLAG1_BUF7I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF7I_MASK) >> CAN_IFLAG1_BUF7I_SHIFT)
#define CAN_BRD_IFLAG1_BUF7I(base) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF7I_SHIFT))

/*! @brief Set the BUF7I field to a new value. */
#define CAN_WR_IFLAG1_BUF7I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF7I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF31TO8I_MASK), CAN_IFLAG1_BUF7I(value)))
#define CAN_BWR_IFLAG1_BUF7I(base, value) (BITBAND_ACCESS32(&CAN_IFLAG1_REG(base), CAN_IFLAG1_BUF7I_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_IFLAG1, field BUF31TO8I[31:8] (W1C)
 *
 * Each bit flags the corresponding FlexCAN Message Buffer interrupt for MB15 to
 * MB8.
 *
 * Values:
 * - 0 - The corresponding buffer has no occurrence of successfully completed
 *     transmission or reception.
 * - 1 - The corresponding buffer has successfully completed transmission or
 *     reception.
 */
/*@{*/
/*! @brief Read current value of the CAN_IFLAG1_BUF31TO8I field. */
#define CAN_RD_IFLAG1_BUF31TO8I(base) ((CAN_IFLAG1_REG(base) & CAN_IFLAG1_BUF31TO8I_MASK) >> CAN_IFLAG1_BUF31TO8I_SHIFT)
#define CAN_BRD_IFLAG1_BUF31TO8I(base) (CAN_RD_IFLAG1_BUF31TO8I(base))

/*! @brief Set the BUF31TO8I field to a new value. */
#define CAN_WR_IFLAG1_BUF31TO8I(base, value) (CAN_RMW_IFLAG1(base, (CAN_IFLAG1_BUF31TO8I_MASK | CAN_IFLAG1_BUF0I_MASK | CAN_IFLAG1_BUF4TO1I_MASK | CAN_IFLAG1_BUF5I_MASK | CAN_IFLAG1_BUF6I_MASK | CAN_IFLAG1_BUF7I_MASK), CAN_IFLAG1_BUF31TO8I(value)))
#define CAN_BWR_IFLAG1_BUF31TO8I(base, value) (CAN_WR_IFLAG1_BUF31TO8I(base, value))
/*@}*/

/*******************************************************************************
 * CAN_CTRL2 - Control 2 register
 ******************************************************************************/

/*!
 * @brief CAN_CTRL2 - Control 2 register (RW)
 *
 * Reset value: 0x00B00000U
 *
 * This register complements Control1 Register providing control bits for memory
 * write access in Freeze Mode, for extending FIFO filter quantity, and for
 * adjust the operation of internal FlexCAN processes like matching and arbitration.
 * The contents of this register are not affected by soft reset.
 */
/*!
 * @name Constants and macros for entire CAN_CTRL2 register
 */
/*@{*/
#define CAN_RD_CTRL2(base)       (CAN_CTRL2_REG(base))
#define CAN_WR_CTRL2(base, value) (CAN_CTRL2_REG(base) = (value))
#define CAN_RMW_CTRL2(base, mask, value) (CAN_WR_CTRL2(base, (CAN_RD_CTRL2(base) & ~(mask)) | (value)))
#define CAN_SET_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) |  (value)))
#define CAN_CLR_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) & ~(value)))
#define CAN_TOG_CTRL2(base, value) (CAN_WR_CTRL2(base, CAN_RD_CTRL2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CTRL2 bitfields
 */

/*!
 * @name Register CAN_CTRL2, field EACEN[16] (RW)
 *
 * This bit controls the comparison of IDE and RTR bits within Rx Mailboxes
 * filters with their corresponding bits in the incoming frame by the matching
 * process. This bit does not affect matching for Rx FIFO. This bit can be written only
 * in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Rx Mailbox filter's IDE bit is always compared and RTR is never
 *     compared despite mask bits.
 * - 1 - Enables the comparison of both Rx Mailbox filter's IDE and RTR bit with
 *     their corresponding bits within the incoming frame. Mask bits do apply.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_EACEN field. */
#define CAN_RD_CTRL2_EACEN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_EACEN_MASK) >> CAN_CTRL2_EACEN_SHIFT)
#define CAN_BRD_CTRL2_EACEN(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EACEN_SHIFT))

/*! @brief Set the EACEN field to a new value. */
#define CAN_WR_CTRL2_EACEN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_EACEN_MASK, CAN_CTRL2_EACEN(value)))
#define CAN_BWR_CTRL2_EACEN(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_EACEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RRS[17] (RW)
 *
 * If this bit is asserted Remote Request Frame is submitted to a matching
 * process and stored in the corresponding Message Buffer in the same fashion of a
 * Data Frame. No automatic Remote Response Frame will be generated. If this bit is
 * negated the Remote Request Frame is submitted to a matching process and an
 * automatic Remote Response Frame is generated if a Message Buffer with CODE=0b1010
 * is found with the same ID. This bit can be written only in Freeze mode
 * because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Remote Response Frame is generated.
 * - 1 - Remote Request Frame is stored.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RRS field. */
#define CAN_RD_CTRL2_RRS(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RRS_MASK) >> CAN_CTRL2_RRS_SHIFT)
#define CAN_BRD_CTRL2_RRS(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_RRS_SHIFT))

/*! @brief Set the RRS field to a new value. */
#define CAN_WR_CTRL2_RRS(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RRS_MASK, CAN_CTRL2_RRS(value)))
#define CAN_BWR_CTRL2_RRS(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_RRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field MRP[18] (RW)
 *
 * If this bit is set the matching process starts from the Mailboxes and if no
 * match occurs the matching continues on the Rx FIFO. This bit can be written
 * only in Freeze mode because it is blocked by hardware in other modes.
 *
 * Values:
 * - 0 - Matching starts from Rx FIFO and continues on Mailboxes.
 * - 1 - Matching starts from Mailboxes and continues on Rx FIFO.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_MRP field. */
#define CAN_RD_CTRL2_MRP(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_MRP_MASK) >> CAN_CTRL2_MRP_SHIFT)
#define CAN_BRD_CTRL2_MRP(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_MRP_SHIFT))

/*! @brief Set the MRP field to a new value. */
#define CAN_WR_CTRL2_MRP(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_MRP_MASK, CAN_CTRL2_MRP(value)))
#define CAN_BWR_CTRL2_MRP(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_MRP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field TASD[23:19] (RW)
 *
 * This 5-bit field indicates how many CAN bits the Tx arbitration process start
 * point can be delayed from the first bit of CRC field on CAN bus. See Tx
 * Arbitration start delay for more details. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_TASD field. */
#define CAN_RD_CTRL2_TASD(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_TASD_MASK) >> CAN_CTRL2_TASD_SHIFT)
#define CAN_BRD_CTRL2_TASD(base) (CAN_RD_CTRL2_TASD(base))

/*! @brief Set the TASD field to a new value. */
#define CAN_WR_CTRL2_TASD(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_TASD_MASK, CAN_CTRL2_TASD(value)))
#define CAN_BWR_CTRL2_TASD(base, value) (CAN_WR_CTRL2_TASD(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field RFFN[27:24] (RW)
 *
 * This 4-bit field defines the number of Rx FIFO filters, as shown in the
 * following table. The maximum selectable number of filters is determined by the
 * chip. This field can only be written in Freeze mode as it is blocked by hardware
 * in other modes. This field must not be programmed with values that make the
 * number of Message Buffers occupied by Rx FIFO and ID Filter exceed the number of
 * Mailboxes present, defined by CAN_MCR[MAXMB]. Each group of eight filters
 * occupies a memory space equivalent to two Message Buffers which means that the
 * more filters are implemented the less Mailboxes will be available. Considering
 * that the Rx FIFO occupies the memory space originally reserved for MB0-5, RFFN
 * should be programmed with a value corresponding to a number of filters not
 * greater than the number of available memory words which can be calculated as
 * follows: (SETUP_MB - 6) * 4 where SETUP_MB is the least between the parameter
 * NUMBER_OF_MB and CAN_MCR[MAXMB]. The number of remaining Mailboxes available will
 * be: (SETUP_MB - 8) - (RFFN * 2) If the Number of Rx FIFO Filters programmed
 * through RFFN exceeds the SETUP_MB value (memory space available) the exceeding
 * ones will not be functional. The number of the last remaining available
 * mailboxes is defined by the least value between the NUMBER_OF_MB minus 1 and the
 * CAN_MCR[MAXMB] field. If Rx Individual Mask Registers are not enabled then all Rx
 * FIFO filters are affected by the Rx FIFO Global Mask. RFFN[3:0] Number of Rx
 * FIFO filter elements Message Buffers occupied by Rx FIFO and ID Filter Table
 * Remaining Available Mailboxes Rx FIFO ID Filter Table Elements Affected by Rx
 * Individual Masks Rx FIFO ID Filter Table Elements Affected by Rx FIFO Global Mask
 * 0x0 8 MB 0-7 MB 8-63 Elements 0-7 none 0x1 16 MB 0-9 MB 10-63 Elements 0-9
 * Elements 10-15 0x2 24 MB 0-11 MB 12-63 Elements 0-11 Elements 12-23 0x3 32 MB
 * 0-13 MB 14-63 Elements 0-13 Elements 14-31 0x4 40 MB 0-15 MB 16-63 Elements 0-15
 * Elements 16-39 0x5 48 MB 0-17 MB 18-63 Elements 0-17 Elements 18-47 0x6 56 MB
 * 0-19 MB 20-63 Elements 0-19 Elements 20-55 0x7 64 MB 0-21 MB 22-63 Elements
 * 0-21 Elements 22-63 0x8 72 MB 0-23 MB 24-63 Elements 0-23 Elements 24-71 0x9 80
 * MB 0-25 MB 26-63 Elements 0-25 Elements 26-79 0xA 88 MB 0-27 MB 28-63
 * Elements 0-27 Elements 28-87 0xB 96 MB 0-29 MB 30-63 Elements 0-29 Elements 30-95 0xC
 * 104 MB 0-31 MB 32-63 Elements 0-31 Elements 32-103 0xD 112 MB 0-33 MB 34-63
 * Elements 0-31 Elements 32-111 0xE 120 MB 0-35 MB 36-63 Elements 0-31 Elements
 * 32-119 0xF 128 MB 0-37 MB 38-63 Elements 0-31 Elements 32-127
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_RFFN field. */
#define CAN_RD_CTRL2_RFFN(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_RFFN_MASK) >> CAN_CTRL2_RFFN_SHIFT)
#define CAN_BRD_CTRL2_RFFN(base) (CAN_RD_CTRL2_RFFN(base))

/*! @brief Set the RFFN field to a new value. */
#define CAN_WR_CTRL2_RFFN(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_RFFN_MASK, CAN_CTRL2_RFFN(value)))
#define CAN_BWR_CTRL2_RFFN(base, value) (CAN_WR_CTRL2_RFFN(base, value))
/*@}*/

/*!
 * @name Register CAN_CTRL2, field BOFFDONEMSK[30] (RW)
 *
 * This bit provides a mask for the Bus Off Done Interrupt in CAN_ESR1 register.
 *
 * Values:
 * - 0 - Bus Off Done interrupt disabled.
 * - 1 - Bus Off Done interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CTRL2_BOFFDONEMSK field. */
#define CAN_RD_CTRL2_BOFFDONEMSK(base) ((CAN_CTRL2_REG(base) & CAN_CTRL2_BOFFDONEMSK_MASK) >> CAN_CTRL2_BOFFDONEMSK_SHIFT)
#define CAN_BRD_CTRL2_BOFFDONEMSK(base) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_BOFFDONEMSK_SHIFT))

/*! @brief Set the BOFFDONEMSK field to a new value. */
#define CAN_WR_CTRL2_BOFFDONEMSK(base, value) (CAN_RMW_CTRL2(base, CAN_CTRL2_BOFFDONEMSK_MASK, CAN_CTRL2_BOFFDONEMSK(value)))
#define CAN_BWR_CTRL2_BOFFDONEMSK(base, value) (BITBAND_ACCESS32(&CAN_CTRL2_REG(base), CAN_CTRL2_BOFFDONEMSK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_ESR2 - Error and Status 2 register
 ******************************************************************************/

/*!
 * @brief CAN_ESR2 - Error and Status 2 register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register reports some general status information.
 */
/*!
 * @name Constants and macros for entire CAN_ESR2 register
 */
/*@{*/
#define CAN_RD_ESR2(base)        (CAN_ESR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_ESR2 bitfields
 */

/*!
 * @name Register CAN_ESR2, field IMB[13] (RO)
 *
 * If ESR2[VPS] is asserted, this bit indicates whether there is any inactive
 * Mailbox (CODE field is either 0b1000 or 0b0000). This bit is asserted in the
 * following cases: During arbitration, if an CAN_ESR2[LPTM] is found and it is
 * inactive. If CAN_ESR2[IMB] is not asserted and a frame is transmitted
 * successfully. This bit is cleared in all start of arbitration (see Section "Arbitration
 * process"). CAN_ESR2[LPTM] mechanism have the following behavior: if an MB is
 * successfully transmitted and CAN_ESR2[IMB]=0 (no inactive Mailbox), then
 * CAN_ESR2[VPS] and CAN_ESR2[IMB] are asserted and the index related to the MB just
 * transmitted is loaded into CAN_ESR2[LPTM].
 *
 * Values:
 * - 0 - If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive Mailbox.
 * - 1 - If ESR2[VPS] is asserted, there is at least one inactive Mailbox. LPTM
 *     content is the number of the first one.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_IMB field. */
#define CAN_RD_ESR2_IMB(base) ((CAN_ESR2_REG(base) & CAN_ESR2_IMB_MASK) >> CAN_ESR2_IMB_SHIFT)
#define CAN_BRD_ESR2_IMB(base) (BITBAND_ACCESS32(&CAN_ESR2_REG(base), CAN_ESR2_IMB_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR2, field VPS[14] (RO)
 *
 * This bit indicates whether CAN_ESR2[IMB] and CAN_ESR2[LPTM] contents are
 * currently valid or not. It is asserted upon every complete Tx arbitration process
 * unless the CPU writes to Control and Status word of a Mailbox that has already
 * been scanned, that is, it is behind Tx Arbitration Pointer, during the Tx
 * arbitration process. If there is no inactive Mailbox and only one Tx Mailbox that
 * is being transmitted then VPS is not asserted. This bit is negated upon the
 * start of every Tx arbitration process or upon a write to Control and Status
 * word of any Mailbox. CAN_ESR2[VPS] is not affected by any CPU write into Control
 * Status (C/S) of a MB thatis blocked by abort mechanism. When CAN_MCR[AEN] is
 * asserted, the abort code write in C/S of a MB that is being transmitted
 * (pending abort), or any write attempt into a Tx MB with CAN_IFLAG set is blocked.
 *
 * Values:
 * - 0 - Contents of IMB and LPTM are invalid.
 * - 1 - Contents of IMB and LPTM are valid.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_VPS field. */
#define CAN_RD_ESR2_VPS(base) ((CAN_ESR2_REG(base) & CAN_ESR2_VPS_MASK) >> CAN_ESR2_VPS_SHIFT)
#define CAN_BRD_ESR2_VPS(base) (BITBAND_ACCESS32(&CAN_ESR2_REG(base), CAN_ESR2_VPS_SHIFT))
/*@}*/

/*!
 * @name Register CAN_ESR2, field LPTM[22:16] (RO)
 *
 * If CAN_ESR2[VPS] is asserted, this field indicates the lowest number inactive
 * Mailbox (see the CAN_ESR2[IMB] bit description). If there is no inactive
 * Mailbox then the Mailbox indicated depends on CAN_CTRL1[LBUF] bit value. If
 * CAN_CTRL1[LBUF] bit is negated then the Mailbox indicated is the one that has the
 * greatest arbitration value (see the "Highest priority Mailbox first" section).
 * If CAN_CTRL1[LBUF] bit is asserted then the Mailbox indicated is the highest
 * number active Tx Mailbox. If a Tx Mailbox is being transmitted it is not
 * considered in LPTM calculation. If CAN_ESR2[IMB] is not asserted and a frame is
 * transmitted successfully, LPTM is updated with its Mailbox number.
 */
/*@{*/
/*! @brief Read current value of the CAN_ESR2_LPTM field. */
#define CAN_RD_ESR2_LPTM(base) ((CAN_ESR2_REG(base) & CAN_ESR2_LPTM_MASK) >> CAN_ESR2_LPTM_SHIFT)
#define CAN_BRD_ESR2_LPTM(base) (CAN_RD_ESR2_LPTM(base))
/*@}*/

/*******************************************************************************
 * CAN_CRCR - CRC Register
 ******************************************************************************/

/*!
 * @brief CAN_CRCR - CRC Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register provides information about the CRC of transmitted messages.
 * This register is updated at the same time the Tx Interrupt Flag is asserted.
 */
/*!
 * @name Constants and macros for entire CAN_CRCR register
 */
/*@{*/
#define CAN_RD_CRCR(base)        (CAN_CRCR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_CRCR bitfields
 */

/*!
 * @name Register CAN_CRCR, field TXCRC[14:0] (RO)
 *
 * This field indicates the CRC value of the last transmitted message.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_TXCRC field. */
#define CAN_RD_CRCR_TXCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_TXCRC_MASK) >> CAN_CRCR_TXCRC_SHIFT)
#define CAN_BRD_CRCR_TXCRC(base) (CAN_RD_CRCR_TXCRC(base))
/*@}*/

/*!
 * @name Register CAN_CRCR, field MBCRC[22:16] (RO)
 *
 * This field indicates the number of the Mailbox corresponding to the value in
 * CAN_CRCR[TXCRC] field.
 */
/*@{*/
/*! @brief Read current value of the CAN_CRCR_MBCRC field. */
#define CAN_RD_CRCR_MBCRC(base) ((CAN_CRCR_REG(base) & CAN_CRCR_MBCRC_MASK) >> CAN_CRCR_MBCRC_SHIFT)
#define CAN_BRD_CRCR_MBCRC(base) (CAN_RD_CRCR_MBCRC(base))
/*@}*/

/*******************************************************************************
 * CAN_RXFGMASK - Rx FIFO Global Mask register
 ******************************************************************************/

/*!
 * @brief CAN_RXFGMASK - Rx FIFO Global Mask register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is located in RAM. If Rx FIFO is enabled, RXFGMASK is used to
 * mask the Rx FIFO ID Filter Table elements that do not have a corresponding
 * RXIMR according to CAN_CTRL2[RFFN] field setting. This register can only be
 * written in Freeze mode as it is blocked by hardware in other modes.
 */
/*!
 * @name Constants and macros for entire CAN_RXFGMASK register
 */
/*@{*/
#define CAN_RD_RXFGMASK(base)    (CAN_RXFGMASK_REG(base))
#define CAN_WR_RXFGMASK(base, value) (CAN_RXFGMASK_REG(base) = (value))
#define CAN_RMW_RXFGMASK(base, mask, value) (CAN_WR_RXFGMASK(base, (CAN_RD_RXFGMASK(base) & ~(mask)) | (value)))
#define CAN_SET_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) |  (value)))
#define CAN_CLR_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) & ~(value)))
#define CAN_TOG_RXFGMASK(base, value) (CAN_WR_RXFGMASK(base, CAN_RD_RXFGMASK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CAN_RXFIR - Rx FIFO Information Register
 ******************************************************************************/

/*!
 * @brief CAN_RXFIR - Rx FIFO Information Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFIR provides information on Rx FIFO. This register is the port through
 * which the CPU accesses the output of the RXFIR FIFO located in RAM. The RXFIR FIFO
 * is written by the FlexCAN whenever a new message is moved into the Rx FIFO as
 * well as its output is updated whenever the output of the Rx FIFO is updated
 * with the next message. See Section "Rx FIFO" for instructions on reading this
 * register.
 */
/*!
 * @name Constants and macros for entire CAN_RXFIR register
 */
/*@{*/
#define CAN_RD_RXFIR(base)       (CAN_RXFIR_REG(base))
/*@}*/

/*
 * Constants & macros for individual CAN_RXFIR bitfields
 */

/*!
 * @name Register CAN_RXFIR, field IDHIT[8:0] (RO)
 *
 * This field indicates which Identifier Acceptance Filter was hit by the
 * received message that is in the output of the Rx FIFO. If multiple filters match the
 * incoming message ID then the first matching IDAF found (lowest number) by the
 * matching process is indicated. This field is valid only while the
 * CAN_IFLAG1[BUF5I] is asserted.
 */
/*@{*/
/*! @brief Read current value of the CAN_RXFIR_IDHIT field. */
#define CAN_RD_RXFIR_IDHIT(base) ((CAN_RXFIR_REG(base) & CAN_RXFIR_IDHIT_MASK) >> CAN_RXFIR_IDHIT_SHIFT)
#define CAN_BRD_RXFIR_IDHIT(base) (CAN_RD_RXFIR_IDHIT(base))
/*@}*/

/*******************************************************************************
 * CAN_CBT - CAN Bit Timing Register
 ******************************************************************************/

/*!
 * @brief CAN_CBT - CAN Bit Timing Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is an alternative way to store the CAN bit timing variables
 * described in CAN_CTRL1 register. EPRESDIV, EPROPSEG, EPSEG1, EPSEG2 and ERJW are
 * extended versions of PRESDIV, PROPSEG, PSEG1, PSEG2 and RJW bit fields
 * respectively. The BTF bit selects the use of the timing variables defined in this
 * register. The contents of this register are not affected by soft reset. The CAN
 * bit variables in CAN_CTRL1 and in CAN_CBT are stored in the same register.
 */
/*!
 * @name Constants and macros for entire CAN_CBT register
 */
/*@{*/
#define CAN_RD_CBT(base)         (CAN_CBT_REG(base))
#define CAN_WR_CBT(base, value)  (CAN_CBT_REG(base) = (value))
#define CAN_RMW_CBT(base, mask, value) (CAN_WR_CBT(base, (CAN_RD_CBT(base) & ~(mask)) | (value)))
#define CAN_SET_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) |  (value)))
#define CAN_CLR_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) & ~(value)))
#define CAN_TOG_CBT(base, value) (CAN_WR_CBT(base, CAN_RD_CBT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CBT bitfields
 */

/*!
 * @name Register CAN_CBT, field EPSEG2[4:0] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 2 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG2] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG2 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG2 field. */
#define CAN_RD_CBT_EPSEG2(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG2_MASK) >> CAN_CBT_EPSEG2_SHIFT)
#define CAN_BRD_CBT_EPSEG2(base) (CAN_RD_CBT_EPSEG2(base))

/*! @brief Set the EPSEG2 field to a new value. */
#define CAN_WR_CBT_EPSEG2(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG2_MASK, CAN_CBT_EPSEG2(value)))
#define CAN_BWR_CBT_EPSEG2(base, value) (CAN_WR_CBT_EPSEG2(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPSEG1[9:5] (RW)
 *
 * This 5-bit field defines the length of Phase Segment 1 in the bit time when
 * CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends the
 * CAN_CTRL1[PSEG1] value range. This field can be written only in Freeze mode because
 * it is blocked by hardware in other modes. Phase Buffer Segment 1 = (EPSEG1 +
 * 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPSEG1 field. */
#define CAN_RD_CBT_EPSEG1(base) ((CAN_CBT_REG(base) & CAN_CBT_EPSEG1_MASK) >> CAN_CBT_EPSEG1_SHIFT)
#define CAN_BRD_CBT_EPSEG1(base) (CAN_RD_CBT_EPSEG1(base))

/*! @brief Set the EPSEG1 field to a new value. */
#define CAN_WR_CBT_EPSEG1(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPSEG1_MASK, CAN_CBT_EPSEG1(value)))
#define CAN_BWR_CBT_EPSEG1(base, value) (CAN_WR_CBT_EPSEG1(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPROPSEG[15:10] (RW)
 *
 * This 6-bit field defines the length of the Propagation Segment in the bit
 * time when CAN_CBT[BTF] bit is asserted, otherwise it has no effect. It extends
 * the CAN_CTRL1[PROPSEG] value range. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Propagation Segment Time =
 * (EPROPSEG + 1) * Time-Quanta. Time-Quantum = one Sclock period.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPROPSEG field. */
#define CAN_RD_CBT_EPROPSEG(base) ((CAN_CBT_REG(base) & CAN_CBT_EPROPSEG_MASK) >> CAN_CBT_EPROPSEG_SHIFT)
#define CAN_BRD_CBT_EPROPSEG(base) (CAN_RD_CBT_EPROPSEG(base))

/*! @brief Set the EPROPSEG field to a new value. */
#define CAN_WR_CBT_EPROPSEG(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPROPSEG_MASK, CAN_CBT_EPROPSEG(value)))
#define CAN_BWR_CBT_EPROPSEG(base, value) (CAN_WR_CBT_EPROPSEG(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field ERJW[19:16] (RW)
 *
 * This 4-bit field defines the maximum number of time quanta that a bit time
 * can be changed by one re-synchronization when CAN_CBT[BTF] bit is asserted,
 * otherwise it has no effect. It extends the CAN_CTRL1[RJW] value range. One time
 * quantum is equal to the Sclock period. This field can be written only in Freeze
 * mode because it is blocked by hardware in other modes. Resync Jump Width =
 * ERJW + 1.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_ERJW field. */
#define CAN_RD_CBT_ERJW(base) ((CAN_CBT_REG(base) & CAN_CBT_ERJW_MASK) >> CAN_CBT_ERJW_SHIFT)
#define CAN_BRD_CBT_ERJW(base) (CAN_RD_CBT_ERJW(base))

/*! @brief Set the ERJW field to a new value. */
#define CAN_WR_CBT_ERJW(base, value) (CAN_RMW_CBT(base, CAN_CBT_ERJW_MASK, CAN_CBT_ERJW(value)))
#define CAN_BWR_CBT_ERJW(base, value) (CAN_WR_CBT_ERJW(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field EPRESDIV[30:21] (RW)
 *
 * This 10-bit field defines the ratio between the PE clock frequency and the
 * Serial Clock (Sclock) frequency when CAN_CBT[BTF] bit is asserted, otherwise it
 * has no effect. It extends the CAN_CTRL1[PRESDIV] value range. The Sclock
 * period defines the time quantum of the CAN protocol. For the reset value, the
 * Sclock frequency is equal to the PE clock frequency (see Protocol timing). This
 * field can be written only in Freeze mode because it is blocked by hardware in
 * other modes. Sclock frequency = PE clock frequency / (EPRESDIV + 1)
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_EPRESDIV field. */
#define CAN_RD_CBT_EPRESDIV(base) ((CAN_CBT_REG(base) & CAN_CBT_EPRESDIV_MASK) >> CAN_CBT_EPRESDIV_SHIFT)
#define CAN_BRD_CBT_EPRESDIV(base) (CAN_RD_CBT_EPRESDIV(base))

/*! @brief Set the EPRESDIV field to a new value. */
#define CAN_WR_CBT_EPRESDIV(base, value) (CAN_RMW_CBT(base, CAN_CBT_EPRESDIV_MASK, CAN_CBT_EPRESDIV(value)))
#define CAN_BWR_CBT_EPRESDIV(base, value) (CAN_WR_CBT_EPRESDIV(base, value))
/*@}*/

/*!
 * @name Register CAN_CBT, field BTF[31] (RW)
 *
 * Enables the use of extended CAN bit timing fields EPRESDIV, EPROPSEG, EPSEG1,
 * EPSEG2 and ERJW replacing the CAN bit timing variables defined in CAN_CTRL1
 * register. This field can be written in Freeze mode only.
 *
 * Values:
 * - 0 - Extended bit time definitions disabled.
 * - 1 - Extended bit time definitions enabled.
 */
/*@{*/
/*! @brief Read current value of the CAN_CBT_BTF field. */
#define CAN_RD_CBT_BTF(base) ((CAN_CBT_REG(base) & CAN_CBT_BTF_MASK) >> CAN_CBT_BTF_SHIFT)
#define CAN_BRD_CBT_BTF(base) (BITBAND_ACCESS32(&CAN_CBT_REG(base), CAN_CBT_BTF_SHIFT))

/*! @brief Set the BTF field to a new value. */
#define CAN_WR_CBT_BTF(base, value) (CAN_RMW_CBT(base, CAN_CBT_BTF_MASK, CAN_CBT_BTF(value)))
#define CAN_BWR_CBT_BTF(base, value) (BITBAND_ACCESS32(&CAN_CBT_REG(base), CAN_CBT_BTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CAN_CS - Message Buffer 0 CS Register
 ******************************************************************************/

/*!
 * @brief CAN_CS - Message Buffer 0 CS Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_CS register
 */
/*@{*/
#define CAN_RD_CS(base, index)   (CAN_CS_REG(base, index))
#define CAN_WR_CS(base, index, value) (CAN_CS_REG(base, index) = (value))
#define CAN_RMW_CS(base, index, mask, value) (CAN_WR_CS(base, index, (CAN_RD_CS(base, index) & ~(mask)) | (value)))
#define CAN_SET_CS(base, index, value) (CAN_WR_CS(base, index, CAN_RD_CS(base, index) |  (value)))
#define CAN_CLR_CS(base, index, value) (CAN_WR_CS(base, index, CAN_RD_CS(base, index) & ~(value)))
#define CAN_TOG_CS(base, index, value) (CAN_WR_CS(base, index, CAN_RD_CS(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_CS bitfields
 */

/*!
 * @name Register CAN_CS, field TIME_STAMP[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_TIME_STAMP field. */
#define CAN_RD_CS_TIME_STAMP(base, index) ((CAN_CS_REG(base, index) & CAN_CS_TIME_STAMP_MASK) >> CAN_CS_TIME_STAMP_SHIFT)
#define CAN_BRD_CS_TIME_STAMP(base, index) (CAN_RD_CS_TIME_STAMP(base, index))

/*! @brief Set the TIME_STAMP field to a new value. */
#define CAN_WR_CS_TIME_STAMP(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_TIME_STAMP_MASK, CAN_CS_TIME_STAMP(value)))
#define CAN_BWR_CS_TIME_STAMP(base, index, value) (CAN_WR_CS_TIME_STAMP(base, index, value))
/*@}*/

/*!
 * @name Register CAN_CS, field DLC[19:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_DLC field. */
#define CAN_RD_CS_DLC(base, index) ((CAN_CS_REG(base, index) & CAN_CS_DLC_MASK) >> CAN_CS_DLC_SHIFT)
#define CAN_BRD_CS_DLC(base, index) (CAN_RD_CS_DLC(base, index))

/*! @brief Set the DLC field to a new value. */
#define CAN_WR_CS_DLC(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_DLC_MASK, CAN_CS_DLC(value)))
#define CAN_BWR_CS_DLC(base, index, value) (CAN_WR_CS_DLC(base, index, value))
/*@}*/

/*!
 * @name Register CAN_CS, field RTR[20] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_RTR field. */
#define CAN_RD_CS_RTR(base, index) ((CAN_CS_REG(base, index) & CAN_CS_RTR_MASK) >> CAN_CS_RTR_SHIFT)
#define CAN_BRD_CS_RTR(base, index) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_RTR_SHIFT))

/*! @brief Set the RTR field to a new value. */
#define CAN_WR_CS_RTR(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_RTR_MASK, CAN_CS_RTR(value)))
#define CAN_BWR_CS_RTR(base, index, value) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_RTR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CS, field IDE[21] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_IDE field. */
#define CAN_RD_CS_IDE(base, index) ((CAN_CS_REG(base, index) & CAN_CS_IDE_MASK) >> CAN_CS_IDE_SHIFT)
#define CAN_BRD_CS_IDE(base, index) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_IDE_SHIFT))

/*! @brief Set the IDE field to a new value. */
#define CAN_WR_CS_IDE(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_IDE_MASK, CAN_CS_IDE(value)))
#define CAN_BWR_CS_IDE(base, index, value) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_IDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CS, field SRR[22] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_SRR field. */
#define CAN_RD_CS_SRR(base, index) ((CAN_CS_REG(base, index) & CAN_CS_SRR_MASK) >> CAN_CS_SRR_SHIFT)
#define CAN_BRD_CS_SRR(base, index) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_SRR_SHIFT))

/*! @brief Set the SRR field to a new value. */
#define CAN_WR_CS_SRR(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_SRR_MASK, CAN_CS_SRR(value)))
#define CAN_BWR_CS_SRR(base, index, value) (BITBAND_ACCESS32(&CAN_CS_REG(base, index), CAN_CS_SRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CAN_CS, field CODE[27:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_CS_CODE field. */
#define CAN_RD_CS_CODE(base, index) ((CAN_CS_REG(base, index) & CAN_CS_CODE_MASK) >> CAN_CS_CODE_SHIFT)
#define CAN_BRD_CS_CODE(base, index) (CAN_RD_CS_CODE(base, index))

/*! @brief Set the CODE field to a new value. */
#define CAN_WR_CS_CODE(base, index, value) (CAN_RMW_CS(base, index, CAN_CS_CODE_MASK, CAN_CS_CODE(value)))
#define CAN_BWR_CS_CODE(base, index, value) (CAN_WR_CS_CODE(base, index, value))
/*@}*/

/*******************************************************************************
 * CAN_ID - Message Buffer 0 ID Register
 ******************************************************************************/

/*!
 * @brief CAN_ID - Message Buffer 0 ID Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_ID register
 */
/*@{*/
#define CAN_RD_ID(base, index)   (CAN_ID_REG(base, index))
#define CAN_WR_ID(base, index, value) (CAN_ID_REG(base, index) = (value))
#define CAN_RMW_ID(base, index, mask, value) (CAN_WR_ID(base, index, (CAN_RD_ID(base, index) & ~(mask)) | (value)))
#define CAN_SET_ID(base, index, value) (CAN_WR_ID(base, index, CAN_RD_ID(base, index) |  (value)))
#define CAN_CLR_ID(base, index, value) (CAN_WR_ID(base, index, CAN_RD_ID(base, index) & ~(value)))
#define CAN_TOG_ID(base, index, value) (CAN_WR_ID(base, index, CAN_RD_ID(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_ID bitfields
 */

/*!
 * @name Register CAN_ID, field EXT[17:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_EXT field. */
#define CAN_RD_ID_EXT(base, index) ((CAN_ID_REG(base, index) & CAN_ID_EXT_MASK) >> CAN_ID_EXT_SHIFT)
#define CAN_BRD_ID_EXT(base, index) (CAN_RD_ID_EXT(base, index))

/*! @brief Set the EXT field to a new value. */
#define CAN_WR_ID_EXT(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_EXT_MASK, CAN_ID_EXT(value)))
#define CAN_BWR_ID_EXT(base, index, value) (CAN_WR_ID_EXT(base, index, value))
/*@}*/

/*!
 * @name Register CAN_ID, field STD[28:18] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_STD field. */
#define CAN_RD_ID_STD(base, index) ((CAN_ID_REG(base, index) & CAN_ID_STD_MASK) >> CAN_ID_STD_SHIFT)
#define CAN_BRD_ID_STD(base, index) (CAN_RD_ID_STD(base, index))

/*! @brief Set the STD field to a new value. */
#define CAN_WR_ID_STD(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_STD_MASK, CAN_ID_STD(value)))
#define CAN_BWR_ID_STD(base, index, value) (CAN_WR_ID_STD(base, index, value))
/*@}*/

/*!
 * @name Register CAN_ID, field PRIO[31:29] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_ID_PRIO field. */
#define CAN_RD_ID_PRIO(base, index) ((CAN_ID_REG(base, index) & CAN_ID_PRIO_MASK) >> CAN_ID_PRIO_SHIFT)
#define CAN_BRD_ID_PRIO(base, index) (CAN_RD_ID_PRIO(base, index))

/*! @brief Set the PRIO field to a new value. */
#define CAN_WR_ID_PRIO(base, index, value) (CAN_RMW_ID(base, index, CAN_ID_PRIO_MASK, CAN_ID_PRIO(value)))
#define CAN_BWR_ID_PRIO(base, index, value) (CAN_WR_ID_PRIO(base, index, value))
/*@}*/

/*******************************************************************************
 * CAN_WORD0 - Message Buffer 0 WORD0 Register
 ******************************************************************************/

/*!
 * @brief CAN_WORD0 - Message Buffer 0 WORD0 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_WORD0 register
 */
/*@{*/
#define CAN_RD_WORD0(base, index) (CAN_WORD0_REG(base, index))
#define CAN_WR_WORD0(base, index, value) (CAN_WORD0_REG(base, index) = (value))
#define CAN_RMW_WORD0(base, index, mask, value) (CAN_WR_WORD0(base, index, (CAN_RD_WORD0(base, index) & ~(mask)) | (value)))
#define CAN_SET_WORD0(base, index, value) (CAN_WR_WORD0(base, index, CAN_RD_WORD0(base, index) |  (value)))
#define CAN_CLR_WORD0(base, index, value) (CAN_WR_WORD0(base, index, CAN_RD_WORD0(base, index) & ~(value)))
#define CAN_TOG_WORD0(base, index, value) (CAN_WR_WORD0(base, index, CAN_RD_WORD0(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD0 bitfields
 */

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_3[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_3 field. */
#define CAN_RD_WORD0_DATA_BYTE_3(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_3_MASK) >> CAN_WORD0_DATA_BYTE_3_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_3(base, index) (CAN_RD_WORD0_DATA_BYTE_3(base, index))

/*! @brief Set the DATA_BYTE_3 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_3(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_3_MASK, CAN_WORD0_DATA_BYTE_3(value)))
#define CAN_BWR_WORD0_DATA_BYTE_3(base, index, value) (CAN_WR_WORD0_DATA_BYTE_3(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_2[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_2 field. */
#define CAN_RD_WORD0_DATA_BYTE_2(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_2_MASK) >> CAN_WORD0_DATA_BYTE_2_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_2(base, index) (CAN_RD_WORD0_DATA_BYTE_2(base, index))

/*! @brief Set the DATA_BYTE_2 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_2(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_2_MASK, CAN_WORD0_DATA_BYTE_2(value)))
#define CAN_BWR_WORD0_DATA_BYTE_2(base, index, value) (CAN_WR_WORD0_DATA_BYTE_2(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_1[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_1 field. */
#define CAN_RD_WORD0_DATA_BYTE_1(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_1_MASK) >> CAN_WORD0_DATA_BYTE_1_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_1(base, index) (CAN_RD_WORD0_DATA_BYTE_1(base, index))

/*! @brief Set the DATA_BYTE_1 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_1(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_1_MASK, CAN_WORD0_DATA_BYTE_1(value)))
#define CAN_BWR_WORD0_DATA_BYTE_1(base, index, value) (CAN_WR_WORD0_DATA_BYTE_1(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD0, field DATA_BYTE_0[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD0_DATA_BYTE_0 field. */
#define CAN_RD_WORD0_DATA_BYTE_0(base, index) ((CAN_WORD0_REG(base, index) & CAN_WORD0_DATA_BYTE_0_MASK) >> CAN_WORD0_DATA_BYTE_0_SHIFT)
#define CAN_BRD_WORD0_DATA_BYTE_0(base, index) (CAN_RD_WORD0_DATA_BYTE_0(base, index))

/*! @brief Set the DATA_BYTE_0 field to a new value. */
#define CAN_WR_WORD0_DATA_BYTE_0(base, index, value) (CAN_RMW_WORD0(base, index, CAN_WORD0_DATA_BYTE_0_MASK, CAN_WORD0_DATA_BYTE_0(value)))
#define CAN_BWR_WORD0_DATA_BYTE_0(base, index, value) (CAN_WR_WORD0_DATA_BYTE_0(base, index, value))
/*@}*/

/*******************************************************************************
 * CAN_WORD1 - Message Buffer 0 WORD1 Register
 ******************************************************************************/

/*!
 * @brief CAN_WORD1 - Message Buffer 0 WORD1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire CAN_WORD1 register
 */
/*@{*/
#define CAN_RD_WORD1(base, index) (CAN_WORD1_REG(base, index))
#define CAN_WR_WORD1(base, index, value) (CAN_WORD1_REG(base, index) = (value))
#define CAN_RMW_WORD1(base, index, mask, value) (CAN_WR_WORD1(base, index, (CAN_RD_WORD1(base, index) & ~(mask)) | (value)))
#define CAN_SET_WORD1(base, index, value) (CAN_WR_WORD1(base, index, CAN_RD_WORD1(base, index) |  (value)))
#define CAN_CLR_WORD1(base, index, value) (CAN_WR_WORD1(base, index, CAN_RD_WORD1(base, index) & ~(value)))
#define CAN_TOG_WORD1(base, index, value) (CAN_WR_WORD1(base, index, CAN_RD_WORD1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CAN_WORD1 bitfields
 */

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_7[7:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_7 field. */
#define CAN_RD_WORD1_DATA_BYTE_7(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_7_MASK) >> CAN_WORD1_DATA_BYTE_7_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_7(base, index) (CAN_RD_WORD1_DATA_BYTE_7(base, index))

/*! @brief Set the DATA_BYTE_7 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_7(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_7_MASK, CAN_WORD1_DATA_BYTE_7(value)))
#define CAN_BWR_WORD1_DATA_BYTE_7(base, index, value) (CAN_WR_WORD1_DATA_BYTE_7(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_6[15:8] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_6 field. */
#define CAN_RD_WORD1_DATA_BYTE_6(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_6_MASK) >> CAN_WORD1_DATA_BYTE_6_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_6(base, index) (CAN_RD_WORD1_DATA_BYTE_6(base, index))

/*! @brief Set the DATA_BYTE_6 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_6(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_6_MASK, CAN_WORD1_DATA_BYTE_6(value)))
#define CAN_BWR_WORD1_DATA_BYTE_6(base, index, value) (CAN_WR_WORD1_DATA_BYTE_6(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_5[23:16] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_5 field. */
#define CAN_RD_WORD1_DATA_BYTE_5(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_5_MASK) >> CAN_WORD1_DATA_BYTE_5_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_5(base, index) (CAN_RD_WORD1_DATA_BYTE_5(base, index))

/*! @brief Set the DATA_BYTE_5 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_5(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_5_MASK, CAN_WORD1_DATA_BYTE_5(value)))
#define CAN_BWR_WORD1_DATA_BYTE_5(base, index, value) (CAN_WR_WORD1_DATA_BYTE_5(base, index, value))
/*@}*/

/*!
 * @name Register CAN_WORD1, field DATA_BYTE_4[31:24] (RW)
 */
/*@{*/
/*! @brief Read current value of the CAN_WORD1_DATA_BYTE_4 field. */
#define CAN_RD_WORD1_DATA_BYTE_4(base, index) ((CAN_WORD1_REG(base, index) & CAN_WORD1_DATA_BYTE_4_MASK) >> CAN_WORD1_DATA_BYTE_4_SHIFT)
#define CAN_BRD_WORD1_DATA_BYTE_4(base, index) (CAN_RD_WORD1_DATA_BYTE_4(base, index))

/*! @brief Set the DATA_BYTE_4 field to a new value. */
#define CAN_WR_WORD1_DATA_BYTE_4(base, index, value) (CAN_RMW_WORD1(base, index, CAN_WORD1_DATA_BYTE_4_MASK, CAN_WORD1_DATA_BYTE_4(value)))
#define CAN_BWR_WORD1_DATA_BYTE_4(base, index, value) (CAN_WR_WORD1_DATA_BYTE_4(base, index, value))
/*@}*/

/*******************************************************************************
 * CAN_RXIMR - Rx Individual Mask Registers
 ******************************************************************************/

/*!
 * @brief CAN_RXIMR - Rx Individual Mask Registers (RW)
 *
 * Reset value: 0x00000000U
 *
 * The RX Individual Mask Registers are used to store the acceptance masks for
 * ID filtering in Rx MBs and the Rx FIFO. When the Rx FIFO is disabled
 * (CAN_MCR[RFEN] bit is negated), an individual mask is provided for each available Rx
 * Mailbox on a one-to-one correspondence. When the Rx FIFO is enabled
 * (CAN_MCR[RFEN] bit is asserted), an individual mask is provided for each Rx FIFO ID Filter
 * Table Element on a one-to-one correspondence depending on the setting of
 * CAN_CTRL2[RFFN] (see Rx FIFO). CAN_RXIMR0 stores the individual mask associated to
 * either MB0 or ID Filter Table Element 0, CAN_RXIMR1 stores the individual mask
 * associated to either MB1 or ID Filter Table Element 1 and so on. CAN_RXIMR
 * registers can only be accessed by the CPU while the module is in Freeze mode,
 * otherwise, they are blocked by hardware. These registers are not affected by
 * reset. They are located in RAM and must be explicitly initialized prior to any
 * reception.
 */
/*!
 * @name Constants and macros for entire CAN_RXIMR register
 */
/*@{*/
#define CAN_RD_RXIMR(base, index) (CAN_RXIMR_REG(base, index))
#define CAN_WR_RXIMR(base, index, value) (CAN_RXIMR_REG(base, index) = (value))
#define CAN_RMW_RXIMR(base, index, mask, value) (CAN_WR_RXIMR(base, index, (CAN_RD_RXIMR(base, index) & ~(mask)) | (value)))
#define CAN_SET_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) |  (value)))
#define CAN_CLR_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) & ~(value)))
#define CAN_TOG_RXIMR(base, index, value) (CAN_WR_RXIMR(base, index, CAN_RD_RXIMR(base, index) ^  (value)))
/*@}*/

/*
 * MKS22F25612 CMP
 *
 * High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX)
 *
 * Registers defined in this header file:
 * - CMP_CR0 - CMP Control Register 0
 * - CMP_CR1 - CMP Control Register 1
 * - CMP_FPR - CMP Filter Period Register
 * - CMP_SCR - CMP Status and Control Register
 * - CMP_DACCR - DAC Control Register
 * - CMP_MUXCR - MUX Control Register
 */

#define CMP_INSTANCE_COUNT (1U) /*!< Number of instances of the CMP module. */
#define CMP0_IDX (0U) /*!< Instance number for CMP0. */

/*******************************************************************************
 * CMP_CR0 - CMP Control Register 0
 ******************************************************************************/

/*!
 * @brief CMP_CR0 - CMP Control Register 0 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR0 register
 */
/*@{*/
#define CMP_RD_CR0(base)         (CMP_CR0_REG(base))
#define CMP_WR_CR0(base, value)  (CMP_CR0_REG(base) = (value))
#define CMP_RMW_CR0(base, mask, value) (CMP_WR_CR0(base, (CMP_RD_CR0(base) & ~(mask)) | (value)))
#define CMP_SET_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) |  (value)))
#define CMP_CLR_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) & ~(value)))
#define CMP_TOG_CR0(base, value) (CMP_WR_CR0(base, CMP_RD_CR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR0 bitfields
 */

/*!
 * @name Register CMP_CR0, field HYSTCTR[1:0] (RW)
 *
 * Defines the programmable hysteresis level. The hysteresis values associated
 * with each level are device-specific. See the Data Sheet of the device for the
 * exact values.
 *
 * Values:
 * - 00 - Level 0
 * - 01 - Level 1
 * - 10 - Level 2
 * - 11 - Level 3
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_HYSTCTR field. */
#define CMP_RD_CR0_HYSTCTR(base) ((CMP_CR0_REG(base) & CMP_CR0_HYSTCTR_MASK) >> CMP_CR0_HYSTCTR_SHIFT)
#define CMP_BRD_CR0_HYSTCTR(base) (CMP_RD_CR0_HYSTCTR(base))

/*! @brief Set the HYSTCTR field to a new value. */
#define CMP_WR_CR0_HYSTCTR(base, value) (CMP_RMW_CR0(base, CMP_CR0_HYSTCTR_MASK, CMP_CR0_HYSTCTR(value)))
#define CMP_BWR_CR0_HYSTCTR(base, value) (CMP_WR_CR0_HYSTCTR(base, value))
/*@}*/

/*!
 * @name Register CMP_CR0, field FILTER_CNT[6:4] (RW)
 *
 * Represents the number of consecutive samples that must agree prior to the
 * comparator ouput filter accepting a new output state. For information regarding
 * filter programming and latency, see the Functional descriptionThe CMP module
 * can be used to compare two analog input voltages applied to INP and INM. .
 *
 * Values:
 * - 000 - Filter is disabled. If SE = 1, then COUT is a logic 0. This is not a
 *     legal state, and is not recommended. If SE = 0, COUT = COUTA.
 * - 001 - One sample must agree. The comparator output is simply sampled.
 * - 010 - 2 consecutive samples must agree.
 * - 011 - 3 consecutive samples must agree.
 * - 100 - 4 consecutive samples must agree.
 * - 101 - 5 consecutive samples must agree.
 * - 110 - 6 consecutive samples must agree.
 * - 111 - 7 consecutive samples must agree.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR0_FILTER_CNT field. */
#define CMP_RD_CR0_FILTER_CNT(base) ((CMP_CR0_REG(base) & CMP_CR0_FILTER_CNT_MASK) >> CMP_CR0_FILTER_CNT_SHIFT)
#define CMP_BRD_CR0_FILTER_CNT(base) (CMP_RD_CR0_FILTER_CNT(base))

/*! @brief Set the FILTER_CNT field to a new value. */
#define CMP_WR_CR0_FILTER_CNT(base, value) (CMP_RMW_CR0(base, CMP_CR0_FILTER_CNT_MASK, CMP_CR0_FILTER_CNT(value)))
#define CMP_BWR_CR0_FILTER_CNT(base, value) (CMP_WR_CR0_FILTER_CNT(base, value))
/*@}*/

/*******************************************************************************
 * CMP_CR1 - CMP Control Register 1
 ******************************************************************************/

/*!
 * @brief CMP_CR1 - CMP Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_CR1 register
 */
/*@{*/
#define CMP_RD_CR1(base)         (CMP_CR1_REG(base))
#define CMP_WR_CR1(base, value)  (CMP_CR1_REG(base) = (value))
#define CMP_RMW_CR1(base, mask, value) (CMP_WR_CR1(base, (CMP_RD_CR1(base) & ~(mask)) | (value)))
#define CMP_SET_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) |  (value)))
#define CMP_CLR_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) & ~(value)))
#define CMP_TOG_CR1(base, value) (CMP_WR_CR1(base, CMP_RD_CR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_CR1 bitfields
 */

/*!
 * @name Register CMP_CR1, field EN[0] (RW)
 *
 * Enables the Analog Comparator module. When the module is not enabled, it
 * remains in the off state, and consumes no power. When the user selects the same
 * input from analog mux to the positive and negative port, the comparator is
 * disabled automatically.
 *
 * Values:
 * - 0 - Analog Comparator is disabled.
 * - 1 - Analog Comparator is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_EN field. */
#define CMP_RD_CR1_EN(base)  ((CMP_CR1_REG(base) & CMP_CR1_EN_MASK) >> CMP_CR1_EN_SHIFT)
#define CMP_BRD_CR1_EN(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT))

/*! @brief Set the EN field to a new value. */
#define CMP_WR_CR1_EN(base, value) (CMP_RMW_CR1(base, CMP_CR1_EN_MASK, CMP_CR1_EN(value)))
#define CMP_BWR_CR1_EN(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field OPE[1] (RW)
 *
 * Values:
 * - 0 - CMPO is not available on the associated CMPO output pin. If the
 *     comparator does not own the pin, this field has no effect.
 * - 1 - CMPO is available on the associated CMPO output pin. The comparator
 *     output (CMPO) is driven out on the associated CMPO output pin if the
 *     comparator owns the pin. If the comparator does not own the field, this bit has no
 *     effect.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_OPE field. */
#define CMP_RD_CR1_OPE(base) ((CMP_CR1_REG(base) & CMP_CR1_OPE_MASK) >> CMP_CR1_OPE_SHIFT)
#define CMP_BRD_CR1_OPE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT))

/*! @brief Set the OPE field to a new value. */
#define CMP_WR_CR1_OPE(base, value) (CMP_RMW_CR1(base, CMP_CR1_OPE_MASK, CMP_CR1_OPE(value)))
#define CMP_BWR_CR1_OPE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_OPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field COS[2] (RW)
 *
 * Values:
 * - 0 - Set the filtered comparator output (CMPO) to equal COUT.
 * - 1 - Set the unfiltered comparator output (CMPO) to equal COUTA.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_COS field. */
#define CMP_RD_CR1_COS(base) ((CMP_CR1_REG(base) & CMP_CR1_COS_MASK) >> CMP_CR1_COS_SHIFT)
#define CMP_BRD_CR1_COS(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT))

/*! @brief Set the COS field to a new value. */
#define CMP_WR_CR1_COS(base, value) (CMP_RMW_CR1(base, CMP_CR1_COS_MASK, CMP_CR1_COS(value)))
#define CMP_BWR_CR1_COS(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_COS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field INV[3] (RW)
 *
 * Allows selection of the polarity of the analog comparator function. It is
 * also driven to the COUT output, on both the device pin and as SCR[COUT], when
 * OPE=0.
 *
 * Values:
 * - 0 - Does not invert the comparator output.
 * - 1 - Inverts the comparator output.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_INV field. */
#define CMP_RD_CR1_INV(base) ((CMP_CR1_REG(base) & CMP_CR1_INV_MASK) >> CMP_CR1_INV_SHIFT)
#define CMP_BRD_CR1_INV(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT))

/*! @brief Set the INV field to a new value. */
#define CMP_WR_CR1_INV(base, value) (CMP_RMW_CR1(base, CMP_CR1_INV_MASK, CMP_CR1_INV(value)))
#define CMP_BWR_CR1_INV(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_INV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field PMODE[4] (RW)
 *
 * See the electrical specifications table in the device Data Sheet for details.
 *
 * Values:
 * - 0 - Low-Speed (LS) Comparison mode selected. In this mode, CMP has slower
 *     output propagation delay and lower current consumption.
 * - 1 - High-Speed (HS) Comparison mode selected. In this mode, CMP has faster
 *     output propagation delay and higher current consumption.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_PMODE field. */
#define CMP_RD_CR1_PMODE(base) ((CMP_CR1_REG(base) & CMP_CR1_PMODE_MASK) >> CMP_CR1_PMODE_SHIFT)
#define CMP_BRD_CR1_PMODE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT))

/*! @brief Set the PMODE field to a new value. */
#define CMP_WR_CR1_PMODE(base, value) (CMP_RMW_CR1(base, CMP_CR1_PMODE_MASK, CMP_CR1_PMODE(value)))
#define CMP_BWR_CR1_PMODE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_PMODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field TRIGM[5] (RW)
 *
 * CMP and DAC are configured to CMP Trigger mode when CMP_CR1[TRIGM] is set to
 * 1. In addition, the CMP should be enabled. If the DAC is to be used as a
 * reference to the CMP, it should also be enabled. CMP Trigger mode depends on an
 * external timer resource to periodically enable the CMP and 6-bit DAC in order to
 * generate a triggered compare. Upon setting TRIGM, the CMP and DAC are placed
 * in a standby state until an external timer resource trigger is received. See
 * the chip configuration for details about the external timer resource.
 *
 * Values:
 * - 0 - Trigger mode is disabled.
 * - 1 - Trigger mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_TRIGM field. */
#define CMP_RD_CR1_TRIGM(base) ((CMP_CR1_REG(base) & CMP_CR1_TRIGM_MASK) >> CMP_CR1_TRIGM_SHIFT)
#define CMP_BRD_CR1_TRIGM(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT))

/*! @brief Set the TRIGM field to a new value. */
#define CMP_WR_CR1_TRIGM(base, value) (CMP_RMW_CR1(base, CMP_CR1_TRIGM_MASK, CMP_CR1_TRIGM(value)))
#define CMP_BWR_CR1_TRIGM(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_TRIGM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field WE[6] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Windowing mode is not selected.
 * - 1 - Windowing mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_WE field. */
#define CMP_RD_CR1_WE(base)  ((CMP_CR1_REG(base) & CMP_CR1_WE_MASK) >> CMP_CR1_WE_SHIFT)
#define CMP_BRD_CR1_WE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT))

/*! @brief Set the WE field to a new value. */
#define CMP_WR_CR1_WE(base, value) (CMP_RMW_CR1(base, CMP_CR1_WE_MASK, CMP_CR1_WE(value)))
#define CMP_BWR_CR1_WE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_WE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_CR1, field SE[7] (RW)
 *
 * At any given time, either SE or WE can be set. If a write to this register
 * attempts to set both, then SE is set and WE is cleared. However, avoid writing
 * 1s to both field locations because this "11" case is reserved and may change in
 * future implementations.
 *
 * Values:
 * - 0 - Sampling mode is not selected.
 * - 1 - Sampling mode is selected.
 */
/*@{*/
/*! @brief Read current value of the CMP_CR1_SE field. */
#define CMP_RD_CR1_SE(base)  ((CMP_CR1_REG(base) & CMP_CR1_SE_MASK) >> CMP_CR1_SE_SHIFT)
#define CMP_BRD_CR1_SE(base) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT))

/*! @brief Set the SE field to a new value. */
#define CMP_WR_CR1_SE(base, value) (CMP_RMW_CR1(base, CMP_CR1_SE_MASK, CMP_CR1_SE(value)))
#define CMP_BWR_CR1_SE(base, value) (BITBAND_ACCESS8(&CMP_CR1_REG(base), CMP_CR1_SE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_FPR - CMP Filter Period Register
 ******************************************************************************/

/*!
 * @brief CMP_FPR - CMP Filter Period Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_FPR register
 */
/*@{*/
#define CMP_RD_FPR(base)         (CMP_FPR_REG(base))
#define CMP_WR_FPR(base, value)  (CMP_FPR_REG(base) = (value))
#define CMP_RMW_FPR(base, mask, value) (CMP_WR_FPR(base, (CMP_RD_FPR(base) & ~(mask)) | (value)))
#define CMP_SET_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) |  (value)))
#define CMP_CLR_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) & ~(value)))
#define CMP_TOG_FPR(base, value) (CMP_WR_FPR(base, CMP_RD_FPR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CMP_SCR - CMP Status and Control Register
 ******************************************************************************/

/*!
 * @brief CMP_SCR - CMP Status and Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_SCR register
 */
/*@{*/
#define CMP_RD_SCR(base)         (CMP_SCR_REG(base))
#define CMP_WR_SCR(base, value)  (CMP_SCR_REG(base) = (value))
#define CMP_RMW_SCR(base, mask, value) (CMP_WR_SCR(base, (CMP_RD_SCR(base) & ~(mask)) | (value)))
#define CMP_SET_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) |  (value)))
#define CMP_CLR_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) & ~(value)))
#define CMP_TOG_SCR(base, value) (CMP_WR_SCR(base, CMP_RD_SCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_SCR bitfields
 */

/*!
 * @name Register CMP_SCR, field COUT[0] (RO)
 *
 * Returns the current value of the Analog Comparator output, when read. The
 * field is reset to 0 and will read as CR1[INV] when the Analog Comparator module
 * is disabled, that is, when CR1[EN] = 0. Writes to this field are ignored.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_COUT field. */
#define CMP_RD_SCR_COUT(base) ((CMP_SCR_REG(base) & CMP_SCR_COUT_MASK) >> CMP_SCR_COUT_SHIFT)
#define CMP_BRD_SCR_COUT(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_COUT_SHIFT))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFF[1] (W1C)
 *
 * Detects a falling-edge on COUT, when set, during normal operation. CFF is
 * cleared by writing 1 to it. During Stop modes, CFF is level sensitive .
 *
 * Values:
 * - 0 - Falling-edge on COUT has not been detected.
 * - 1 - Falling-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFF field. */
#define CMP_RD_SCR_CFF(base) ((CMP_SCR_REG(base) & CMP_SCR_CFF_MASK) >> CMP_SCR_CFF_SHIFT)
#define CMP_BRD_SCR_CFF(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT))

/*! @brief Set the CFF field to a new value. */
#define CMP_WR_SCR_CFF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_CFF(value)))
#define CMP_BWR_SCR_CFF(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field CFR[2] (W1C)
 *
 * Detects a rising-edge on COUT, when set, during normal operation. CFR is
 * cleared by writing 1 to it. During Stop modes, CFR is level sensitive .
 *
 * Values:
 * - 0 - Rising-edge on COUT has not been detected.
 * - 1 - Rising-edge on COUT has occurred.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_CFR field. */
#define CMP_RD_SCR_CFR(base) ((CMP_SCR_REG(base) & CMP_SCR_CFR_MASK) >> CMP_SCR_CFR_SHIFT)
#define CMP_BRD_SCR_CFR(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT))

/*! @brief Set the CFR field to a new value. */
#define CMP_WR_SCR_CFR(base, value) (CMP_RMW_SCR(base, (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK), CMP_SCR_CFR(value)))
#define CMP_BWR_SCR_CFR(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_CFR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field IEF[3] (RW)
 *
 * Enables the CFF interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFF is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IEF field. */
#define CMP_RD_SCR_IEF(base) ((CMP_SCR_REG(base) & CMP_SCR_IEF_MASK) >> CMP_SCR_IEF_SHIFT)
#define CMP_BRD_SCR_IEF(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT))

/*! @brief Set the IEF field to a new value. */
#define CMP_WR_SCR_IEF(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IEF_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IEF(value)))
#define CMP_BWR_SCR_IEF(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field IER[4] (RW)
 *
 * Enables the CFR interrupt from the CMP. When this field is set, an interrupt
 * will be asserted when CFR is set.
 *
 * Values:
 * - 0 - Interrupt is disabled.
 * - 1 - Interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_IER field. */
#define CMP_RD_SCR_IER(base) ((CMP_SCR_REG(base) & CMP_SCR_IER_MASK) >> CMP_SCR_IER_SHIFT)
#define CMP_BRD_SCR_IER(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT))

/*! @brief Set the IER field to a new value. */
#define CMP_WR_SCR_IER(base, value) (CMP_RMW_SCR(base, (CMP_SCR_IER_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_IER(value)))
#define CMP_BWR_SCR_IER(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_IER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_SCR, field DMAEN[6] (RW)
 *
 * Enables the DMA transfer triggered from the CMP module. When this field is
 * set, a DMA request is asserted when CFR or CFF is set.
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_SCR_DMAEN field. */
#define CMP_RD_SCR_DMAEN(base) ((CMP_SCR_REG(base) & CMP_SCR_DMAEN_MASK) >> CMP_SCR_DMAEN_SHIFT)
#define CMP_BRD_SCR_DMAEN(base) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define CMP_WR_SCR_DMAEN(base, value) (CMP_RMW_SCR(base, (CMP_SCR_DMAEN_MASK | CMP_SCR_CFF_MASK | CMP_SCR_CFR_MASK), CMP_SCR_DMAEN(value)))
#define CMP_BWR_SCR_DMAEN(base, value) (BITBAND_ACCESS8(&CMP_SCR_REG(base), CMP_SCR_DMAEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_DACCR - DAC Control Register
 ******************************************************************************/

/*!
 * @brief CMP_DACCR - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_DACCR register
 */
/*@{*/
#define CMP_RD_DACCR(base)       (CMP_DACCR_REG(base))
#define CMP_WR_DACCR(base, value) (CMP_DACCR_REG(base) = (value))
#define CMP_RMW_DACCR(base, mask, value) (CMP_WR_DACCR(base, (CMP_RD_DACCR(base) & ~(mask)) | (value)))
#define CMP_SET_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) |  (value)))
#define CMP_CLR_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) & ~(value)))
#define CMP_TOG_DACCR(base, value) (CMP_WR_DACCR(base, CMP_RD_DACCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_DACCR bitfields
 */

/*!
 * @name Register CMP_DACCR, field VOSEL[5:0] (RW)
 *
 * Selects an output voltage from one of 64 distinct levels. DACO = (V in /64) *
 * (VOSEL[5:0] + 1) , so the DACO range is from V in /64 to V in .
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VOSEL field. */
#define CMP_RD_DACCR_VOSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VOSEL_MASK) >> CMP_DACCR_VOSEL_SHIFT)
#define CMP_BRD_DACCR_VOSEL(base) (CMP_RD_DACCR_VOSEL(base))

/*! @brief Set the VOSEL field to a new value. */
#define CMP_WR_DACCR_VOSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VOSEL_MASK, CMP_DACCR_VOSEL(value)))
#define CMP_BWR_DACCR_VOSEL(base, value) (CMP_WR_DACCR_VOSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_DACCR, field VRSEL[6] (RW)
 *
 * Values:
 * - 0 - Vin1 is selected as resistor ladder network supply reference.
 * - 1 - Vin2 is selected as resistor ladder network supply reference.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_VRSEL field. */
#define CMP_RD_DACCR_VRSEL(base) ((CMP_DACCR_REG(base) & CMP_DACCR_VRSEL_MASK) >> CMP_DACCR_VRSEL_SHIFT)
#define CMP_BRD_DACCR_VRSEL(base) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT))

/*! @brief Set the VRSEL field to a new value. */
#define CMP_WR_DACCR_VRSEL(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_VRSEL_MASK, CMP_DACCR_VRSEL(value)))
#define CMP_BWR_DACCR_VRSEL(base, value) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_VRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CMP_DACCR, field DACEN[7] (RW)
 *
 * Enables the DAC. When the DAC is disabled, it is powered down to conserve
 * power.
 *
 * Values:
 * - 0 - DAC is disabled.
 * - 1 - DAC is enabled.
 */
/*@{*/
/*! @brief Read current value of the CMP_DACCR_DACEN field. */
#define CMP_RD_DACCR_DACEN(base) ((CMP_DACCR_REG(base) & CMP_DACCR_DACEN_MASK) >> CMP_DACCR_DACEN_SHIFT)
#define CMP_BRD_DACCR_DACEN(base) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT))

/*! @brief Set the DACEN field to a new value. */
#define CMP_WR_DACCR_DACEN(base, value) (CMP_RMW_DACCR(base, CMP_DACCR_DACEN_MASK, CMP_DACCR_DACEN(value)))
#define CMP_BWR_DACCR_DACEN(base, value) (BITBAND_ACCESS8(&CMP_DACCR_REG(base), CMP_DACCR_DACEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * CMP_MUXCR - MUX Control Register
 ******************************************************************************/

/*!
 * @brief CMP_MUXCR - MUX Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CMP_MUXCR register
 */
/*@{*/
#define CMP_RD_MUXCR(base)       (CMP_MUXCR_REG(base))
#define CMP_WR_MUXCR(base, value) (CMP_MUXCR_REG(base) = (value))
#define CMP_RMW_MUXCR(base, mask, value) (CMP_WR_MUXCR(base, (CMP_RD_MUXCR(base) & ~(mask)) | (value)))
#define CMP_SET_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) |  (value)))
#define CMP_CLR_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) & ~(value)))
#define CMP_TOG_MUXCR(base, value) (CMP_WR_MUXCR(base, CMP_RD_MUXCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CMP_MUXCR bitfields
 */

/*!
 * @name Register CMP_MUXCR, field MSEL[2:0] (RW)
 *
 * Determines which input is selected for the minus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_MSEL field. */
#define CMP_RD_MUXCR_MSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_MSEL_MASK) >> CMP_MUXCR_MSEL_SHIFT)
#define CMP_BRD_MUXCR_MSEL(base) (CMP_RD_MUXCR_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define CMP_WR_MUXCR_MSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_MSEL_MASK, CMP_MUXCR_MSEL(value)))
#define CMP_BWR_MUXCR_MSEL(base, value) (CMP_WR_MUXCR_MSEL(base, value))
/*@}*/

/*!
 * @name Register CMP_MUXCR, field PSEL[5:3] (RW)
 *
 * Determines which input is selected for the plus input of the comparator. For
 * INx inputs, see CMP, DAC, and ANMUX block diagrams. When an inappropriate
 * operation selects the same input for both muxes, the comparator automatically
 * shuts down to prevent itself from becoming a noise generator.
 *
 * Values:
 * - 000 - IN0
 * - 001 - IN1
 * - 010 - IN2
 * - 011 - IN3
 * - 100 - IN4
 * - 101 - IN5
 * - 110 - IN6
 * - 111 - IN7
 */
/*@{*/
/*! @brief Read current value of the CMP_MUXCR_PSEL field. */
#define CMP_RD_MUXCR_PSEL(base) ((CMP_MUXCR_REG(base) & CMP_MUXCR_PSEL_MASK) >> CMP_MUXCR_PSEL_SHIFT)
#define CMP_BRD_MUXCR_PSEL(base) (CMP_RD_MUXCR_PSEL(base))

/*! @brief Set the PSEL field to a new value. */
#define CMP_WR_MUXCR_PSEL(base, value) (CMP_RMW_MUXCR(base, CMP_MUXCR_PSEL_MASK, CMP_MUXCR_PSEL(value)))
#define CMP_BWR_MUXCR_PSEL(base, value) (CMP_WR_MUXCR_PSEL(base, value))
/*@}*/

/*
 * MKS22F25612 CRC
 *
 * Cyclic Redundancy Check
 *
 * Registers defined in this header file:
 * - CRC_DATAL - CRC_DATAL register.
 * - CRC_DATAH - CRC_DATAH register.
 * - CRC_DATALL - CRC_DATALL register.
 * - CRC_DATALU - CRC_DATALU register.
 * - CRC_DATAHL - CRC_DATAHL register.
 * - CRC_DATAHU - CRC_DATAHU register.
 * - CRC_DATA - CRC Data register
 * - CRC_GPOLY - CRC Polynomial register
 * - CRC_GPOLYL - CRC_GPOLYL register.
 * - CRC_GPOLYH - CRC_GPOLYH register.
 * - CRC_GPOLYLL - CRC_GPOLYLL register.
 * - CRC_GPOLYLU - CRC_GPOLYLU register.
 * - CRC_GPOLYHL - CRC_GPOLYHL register.
 * - CRC_GPOLYHU - CRC_GPOLYHU register.
 * - CRC_CTRL - CRC Control register
 * - CRC_CTRLHU - CRC_CTRLHU register.
 */

#define CRC_INSTANCE_COUNT (1U) /*!< Number of instances of the CRC module. */
#define CRC_IDX (0U) /*!< Instance number for CRC. */

/*******************************************************************************
 * CRC_DATALL - CRC_DATALL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALL - CRC_DATALL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALL register
 */
/*@{*/
#define CRC_RD_DATALL(base)      (CRC_DATALL_REG(base))
#define CRC_WR_DATALL(base, value) (CRC_DATALL_REG(base) = (value))
#define CRC_RMW_DATALL(base, mask, value) (CRC_WR_DATALL(base, (CRC_RD_DATALL(base) & ~(mask)) | (value)))
#define CRC_SET_DATALL(base, value) (CRC_WR_DATALL(base, CRC_RD_DATALL(base) |  (value)))
#define CRC_CLR_DATALL(base, value) (CRC_WR_DATALL(base, CRC_RD_DATALL(base) & ~(value)))
#define CRC_TOG_DATALL(base, value) (CRC_WR_DATALL(base, CRC_RD_DATALL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAL - CRC_DATAL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAL - CRC_DATAL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAL register
 */
/*@{*/
#define CRC_RD_DATAL(base)       (CRC_DATAL_REG(base))
#define CRC_WR_DATAL(base, value) (CRC_DATAL_REG(base) = (value))
#define CRC_RMW_DATAL(base, mask, value) (CRC_WR_DATAL(base, (CRC_RD_DATAL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAL(base, value) (CRC_WR_DATAL(base, CRC_RD_DATAL(base) |  (value)))
#define CRC_CLR_DATAL(base, value) (CRC_WR_DATAL(base, CRC_RD_DATAL(base) & ~(value)))
#define CRC_TOG_DATAL(base, value) (CRC_WR_DATAL(base, CRC_RD_DATAL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_DATA - CRC Data register
 ******************************************************************************/

/*!
 * @brief CRC_DATA - CRC Data register (RW)
 *
 * Reset value: 0xFFFFFFFFU
 *
 * The CRC Data register contains the value of the seed, data, and checksum.
 * When CTRL[WAS] is set, any write to the data register is regarded as the seed
 * value. When CTRL[WAS] is cleared, any write to the data register is regarded as
 * data for general CRC computation. In 16-bit CRC mode, the HU and HL fields are
 * not used for programming the seed value, and reads of these fields return an
 * indeterminate value. In 32-bit CRC mode, all fields are used for programming
 * the seed value. When programming data values, the values can be written 8 bits,
 * 16 bits, or 32 bits at a time, provided all bytes are contiguous; with MSB of
 * data value written first. After all data values are written, the CRC result
 * can be read from this data register. In 16-bit CRC mode, the CRC result is
 * available in the LU and LL fields. In 32-bit CRC mode, all fields contain the
 * result. Reads of this register at any time return the intermediate CRC value,
 * provided the CRC module is configured.
 */
/*!
 * @name Constants and macros for entire CRC_DATA register
 */
/*@{*/
#define CRC_RD_DATA(base)        (CRC_DATA_REG(base))
#define CRC_WR_DATA(base, value) (CRC_DATA_REG(base) = (value))
#define CRC_RMW_DATA(base, mask, value) (CRC_WR_DATA(base, (CRC_RD_DATA(base) & ~(mask)) | (value)))
#define CRC_SET_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) |  (value)))
#define CRC_CLR_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) & ~(value)))
#define CRC_TOG_DATA(base, value) (CRC_WR_DATA(base, CRC_RD_DATA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_DATA bitfields
 */

/*!
 * @name Register CRC_DATA, field LL[7:0] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LL field. */
#define CRC_RD_DATA_LL(base) ((CRC_DATA_REG(base) & CRC_DATA_LL_MASK) >> CRC_DATA_LL_SHIFT)
#define CRC_BRD_DATA_LL(base) (CRC_RD_DATA_LL(base))

/*! @brief Set the LL field to a new value. */
#define CRC_WR_DATA_LL(base, value) (CRC_RMW_DATA(base, CRC_DATA_LL_MASK, CRC_DATA_LL(value)))
#define CRC_BWR_DATA_LL(base, value) (CRC_WR_DATA_LL(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field LU[15:8] (RW)
 *
 * When CTRL[WAS] is 1, values written to this field are part of the seed value.
 * When CTRL[WAS] is 0, data written to this field is used for CRC checksum
 * generation.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_LU field. */
#define CRC_RD_DATA_LU(base) ((CRC_DATA_REG(base) & CRC_DATA_LU_MASK) >> CRC_DATA_LU_SHIFT)
#define CRC_BRD_DATA_LU(base) (CRC_RD_DATA_LU(base))

/*! @brief Set the LU field to a new value. */
#define CRC_WR_DATA_LU(base, value) (CRC_RMW_DATA(base, CRC_DATA_LU_MASK, CRC_DATA_LU(value)))
#define CRC_BWR_DATA_LU(base, value) (CRC_WR_DATA_LU(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field HL[23:16] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HL field. */
#define CRC_RD_DATA_HL(base) ((CRC_DATA_REG(base) & CRC_DATA_HL_MASK) >> CRC_DATA_HL_SHIFT)
#define CRC_BRD_DATA_HL(base) (CRC_RD_DATA_HL(base))

/*! @brief Set the HL field to a new value. */
#define CRC_WR_DATA_HL(base, value) (CRC_RMW_DATA(base, CRC_DATA_HL_MASK, CRC_DATA_HL(value)))
#define CRC_BWR_DATA_HL(base, value) (CRC_WR_DATA_HL(base, value))
/*@}*/

/*!
 * @name Register CRC_DATA, field HU[31:24] (RW)
 *
 * In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for programming
 * a seed value. In 32-bit CRC mode (CTRL[TCRC] is 1), values written to this
 * field are part of the seed value when CTRL[WAS] is 1. When CTRL[WAS] is 0, data
 * written to this field is used for CRC checksum generation in both 16-bit and
 * 32-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_DATA_HU field. */
#define CRC_RD_DATA_HU(base) ((CRC_DATA_REG(base) & CRC_DATA_HU_MASK) >> CRC_DATA_HU_SHIFT)
#define CRC_BRD_DATA_HU(base) (CRC_RD_DATA_HU(base))

/*! @brief Set the HU field to a new value. */
#define CRC_WR_DATA_HU(base, value) (CRC_RMW_DATA(base, CRC_DATA_HU_MASK, CRC_DATA_HU(value)))
#define CRC_BWR_DATA_HU(base, value) (CRC_WR_DATA_HU(base, value))
/*@}*/

/*******************************************************************************
 * CRC_DATALU - CRC_DATALU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATALU - CRC_DATALU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATALU register
 */
/*@{*/
#define CRC_RD_DATALU(base)      (CRC_DATALU_REG(base))
#define CRC_WR_DATALU(base, value) (CRC_DATALU_REG(base) = (value))
#define CRC_RMW_DATALU(base, mask, value) (CRC_WR_DATALU(base, (CRC_RD_DATALU(base) & ~(mask)) | (value)))
#define CRC_SET_DATALU(base, value) (CRC_WR_DATALU(base, CRC_RD_DATALU(base) |  (value)))
#define CRC_CLR_DATALU(base, value) (CRC_WR_DATALU(base, CRC_RD_DATALU(base) & ~(value)))
#define CRC_TOG_DATALU(base, value) (CRC_WR_DATALU(base, CRC_RD_DATALU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHL - CRC_DATAHL register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHL - CRC_DATAHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHL register
 */
/*@{*/
#define CRC_RD_DATAHL(base)      (CRC_DATAHL_REG(base))
#define CRC_WR_DATAHL(base, value) (CRC_DATAHL_REG(base) = (value))
#define CRC_RMW_DATAHL(base, mask, value) (CRC_WR_DATAHL(base, (CRC_RD_DATAHL(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHL(base, value) (CRC_WR_DATAHL(base, CRC_RD_DATAHL(base) |  (value)))
#define CRC_CLR_DATAHL(base, value) (CRC_WR_DATAHL(base, CRC_RD_DATAHL(base) & ~(value)))
#define CRC_TOG_DATAHL(base, value) (CRC_WR_DATAHL(base, CRC_RD_DATAHL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAH - CRC_DATAH register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAH - CRC_DATAH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAH register
 */
/*@{*/
#define CRC_RD_DATAH(base)       (CRC_DATAH_REG(base))
#define CRC_WR_DATAH(base, value) (CRC_DATAH_REG(base) = (value))
#define CRC_RMW_DATAH(base, mask, value) (CRC_WR_DATAH(base, (CRC_RD_DATAH(base) & ~(mask)) | (value)))
#define CRC_SET_DATAH(base, value) (CRC_WR_DATAH(base, CRC_RD_DATAH(base) |  (value)))
#define CRC_CLR_DATAH(base, value) (CRC_WR_DATAH(base, CRC_RD_DATAH(base) & ~(value)))
#define CRC_TOG_DATAH(base, value) (CRC_WR_DATAH(base, CRC_RD_DATAH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_DATAHU - CRC_DATAHU register.
 ******************************************************************************/

/*!
 * @brief CRC_DATAHU - CRC_DATAHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_DATAHU register
 */
/*@{*/
#define CRC_RD_DATAHU(base)      (CRC_DATAHU_REG(base))
#define CRC_WR_DATAHU(base, value) (CRC_DATAHU_REG(base) = (value))
#define CRC_RMW_DATAHU(base, mask, value) (CRC_WR_DATAHU(base, (CRC_RD_DATAHU(base) & ~(mask)) | (value)))
#define CRC_SET_DATAHU(base, value) (CRC_WR_DATAHU(base, CRC_RD_DATAHU(base) |  (value)))
#define CRC_CLR_DATAHU(base, value) (CRC_WR_DATAHU(base, CRC_RD_DATAHU(base) & ~(value)))
#define CRC_TOG_DATAHU(base, value) (CRC_WR_DATAHU(base, CRC_RD_DATAHU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLL - CRC_GPOLYLL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLL - CRC_GPOLYLL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLL register
 */
/*@{*/
#define CRC_RD_GPOLYLL(base)     (CRC_GPOLYLL_REG(base))
#define CRC_WR_GPOLYLL(base, value) (CRC_GPOLYLL_REG(base) = (value))
#define CRC_RMW_GPOLYLL(base, mask, value) (CRC_WR_GPOLYLL(base, (CRC_RD_GPOLYLL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) |  (value)))
#define CRC_CLR_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) & ~(value)))
#define CRC_TOG_GPOLYLL(base, value) (CRC_WR_GPOLYLL(base, CRC_RD_GPOLYLL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLY - CRC Polynomial register
 ******************************************************************************/

/*!
 * @brief CRC_GPOLY - CRC Polynomial register (RW)
 *
 * Reset value: 0x00001021U
 *
 * This register contains the value of the polynomial for the CRC calculation.
 * The HIGH field contains the upper 16 bits of the CRC polynomial, which are used
 * only in 32-bit CRC mode. Writes to the HIGH field are ignored in 16-bit CRC
 * mode. The LOW field contains the lower 16 bits of the CRC polynomial, which are
 * used in both 16- and 32-bit CRC modes.
 */
/*!
 * @name Constants and macros for entire CRC_GPOLY register
 */
/*@{*/
#define CRC_RD_GPOLY(base)       (CRC_GPOLY_REG(base))
#define CRC_WR_GPOLY(base, value) (CRC_GPOLY_REG(base) = (value))
#define CRC_RMW_GPOLY(base, mask, value) (CRC_WR_GPOLY(base, (CRC_RD_GPOLY(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) |  (value)))
#define CRC_CLR_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) & ~(value)))
#define CRC_TOG_GPOLY(base, value) (CRC_WR_GPOLY(base, CRC_RD_GPOLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_GPOLY bitfields
 */

/*!
 * @name Register CRC_GPOLY, field LOW[15:0] (RW)
 *
 * Writable and readable in both 32-bit and 16-bit CRC modes.
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_LOW field. */
#define CRC_RD_GPOLY_LOW(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_LOW_MASK) >> CRC_GPOLY_LOW_SHIFT)
#define CRC_BRD_GPOLY_LOW(base) (CRC_RD_GPOLY_LOW(base))

/*! @brief Set the LOW field to a new value. */
#define CRC_WR_GPOLY_LOW(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_LOW_MASK, CRC_GPOLY_LOW(value)))
#define CRC_BWR_GPOLY_LOW(base, value) (CRC_WR_GPOLY_LOW(base, value))
/*@}*/

/*!
 * @name Register CRC_GPOLY, field HIGH[31:16] (RW)
 *
 * Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1). This field is not
 * writable in 16-bit CRC mode (CTRL[TCRC] is 0).
 */
/*@{*/
/*! @brief Read current value of the CRC_GPOLY_HIGH field. */
#define CRC_RD_GPOLY_HIGH(base) ((CRC_GPOLY_REG(base) & CRC_GPOLY_HIGH_MASK) >> CRC_GPOLY_HIGH_SHIFT)
#define CRC_BRD_GPOLY_HIGH(base) (CRC_RD_GPOLY_HIGH(base))

/*! @brief Set the HIGH field to a new value. */
#define CRC_WR_GPOLY_HIGH(base, value) (CRC_RMW_GPOLY(base, CRC_GPOLY_HIGH_MASK, CRC_GPOLY_HIGH(value)))
#define CRC_BWR_GPOLY_HIGH(base, value) (CRC_WR_GPOLY_HIGH(base, value))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYL - CRC_GPOLYL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYL - CRC_GPOLYL register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYL register
 */
/*@{*/
#define CRC_RD_GPOLYL(base)      (CRC_GPOLYL_REG(base))
#define CRC_WR_GPOLYL(base, value) (CRC_GPOLYL_REG(base) = (value))
#define CRC_RMW_GPOLYL(base, mask, value) (CRC_WR_GPOLYL(base, (CRC_RD_GPOLYL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) |  (value)))
#define CRC_CLR_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) & ~(value)))
#define CRC_TOG_GPOLYL(base, value) (CRC_WR_GPOLYL(base, CRC_RD_GPOLYL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYLU - CRC_GPOLYLU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYLU - CRC_GPOLYLU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYLU register
 */
/*@{*/
#define CRC_RD_GPOLYLU(base)     (CRC_GPOLYLU_REG(base))
#define CRC_WR_GPOLYLU(base, value) (CRC_GPOLYLU_REG(base) = (value))
#define CRC_RMW_GPOLYLU(base, mask, value) (CRC_WR_GPOLYLU(base, (CRC_RD_GPOLYLU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) |  (value)))
#define CRC_CLR_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) & ~(value)))
#define CRC_TOG_GPOLYLU(base, value) (CRC_WR_GPOLYLU(base, CRC_RD_GPOLYLU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYH - CRC_GPOLYH register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYH - CRC_GPOLYH register. (RW)
 *
 * Reset value: 0xFFFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYH register
 */
/*@{*/
#define CRC_RD_GPOLYH(base)      (CRC_GPOLYH_REG(base))
#define CRC_WR_GPOLYH(base, value) (CRC_GPOLYH_REG(base) = (value))
#define CRC_RMW_GPOLYH(base, mask, value) (CRC_WR_GPOLYH(base, (CRC_RD_GPOLYH(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) |  (value)))
#define CRC_CLR_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) & ~(value)))
#define CRC_TOG_GPOLYH(base, value) (CRC_WR_GPOLYH(base, CRC_RD_GPOLYH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHL - CRC_GPOLYHL register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHL - CRC_GPOLYHL register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHL register
 */
/*@{*/
#define CRC_RD_GPOLYHL(base)     (CRC_GPOLYHL_REG(base))
#define CRC_WR_GPOLYHL(base, value) (CRC_GPOLYHL_REG(base) = (value))
#define CRC_RMW_GPOLYHL(base, mask, value) (CRC_WR_GPOLYHL(base, (CRC_RD_GPOLYHL(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) |  (value)))
#define CRC_CLR_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) & ~(value)))
#define CRC_TOG_GPOLYHL(base, value) (CRC_WR_GPOLYHL(base, CRC_RD_GPOLYHL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_GPOLYHU - CRC_GPOLYHU register.
 ******************************************************************************/

/*!
 * @brief CRC_GPOLYHU - CRC_GPOLYHU register. (RW)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire CRC_GPOLYHU register
 */
/*@{*/
#define CRC_RD_GPOLYHU(base)     (CRC_GPOLYHU_REG(base))
#define CRC_WR_GPOLYHU(base, value) (CRC_GPOLYHU_REG(base) = (value))
#define CRC_RMW_GPOLYHU(base, mask, value) (CRC_WR_GPOLYHU(base, (CRC_RD_GPOLYHU(base) & ~(mask)) | (value)))
#define CRC_SET_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) |  (value)))
#define CRC_CLR_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) & ~(value)))
#define CRC_TOG_GPOLYHU(base, value) (CRC_WR_GPOLYHU(base, CRC_RD_GPOLYHU(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * CRC_CTRL - CRC Control register
 ******************************************************************************/

/*!
 * @brief CRC_CTRL - CRC Control register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the configuration and working of the CRC module.
 * Appropriate bits must be set before starting a new CRC calculation. A new CRC
 * calculation is initialized by asserting CTRL[WAS] and then writing the seed into
 * the CRC data register.
 */
/*!
 * @name Constants and macros for entire CRC_CTRL register
 */
/*@{*/
#define CRC_RD_CTRL(base)        (CRC_CTRL_REG(base))
#define CRC_WR_CTRL(base, value) (CRC_CTRL_REG(base) = (value))
#define CRC_RMW_CTRL(base, mask, value) (CRC_WR_CTRL(base, (CRC_RD_CTRL(base) & ~(mask)) | (value)))
#define CRC_SET_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) |  (value)))
#define CRC_CLR_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) & ~(value)))
#define CRC_TOG_CTRL(base, value) (CRC_WR_CTRL(base, CRC_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRL bitfields
 */

/*!
 * @name Register CRC_CTRL, field TCRC[24] (RW)
 *
 * Width of CRC protocol.
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TCRC field. */
#define CRC_RD_CTRL_TCRC(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TCRC_MASK) >> CRC_CTRL_TCRC_SHIFT)
#define CRC_BRD_CTRL_TCRC(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRL_TCRC(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TCRC_MASK, CRC_CTRL_TCRC(value)))
#define CRC_BWR_CTRL_TCRC(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_TCRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field WAS[25] (RW)
 *
 * When asserted, a value written to the CRC data register is considered a seed
 * value. When deasserted, a value written to the CRC data register is taken as
 * data for CRC computation.
 *
 * Values:
 * - 0 - Writes to the CRC data register are data values.
 * - 1 - Writes to the CRC data register are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_WAS field. */
#define CRC_RD_CTRL_WAS(base) ((CRC_CTRL_REG(base) & CRC_CTRL_WAS_MASK) >> CRC_CTRL_WAS_SHIFT)
#define CRC_BRD_CTRL_WAS(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRL_WAS(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_WAS_MASK, CRC_CTRL_WAS(value)))
#define CRC_BWR_CTRL_WAS(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_WAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field FXOR[26] (RW)
 *
 * Some CRC protocols require the final checksum to be XORed with 0xFFFFFFFF or
 * 0xFFFF. Asserting this bit enables on the fly complementing of read data.
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of the CRC Data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_FXOR field. */
#define CRC_RD_CTRL_FXOR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_FXOR_MASK) >> CRC_CTRL_FXOR_SHIFT)
#define CRC_BRD_CTRL_FXOR(base) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRL_FXOR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_FXOR_MASK, CRC_CTRL_FXOR(value)))
#define CRC_BWR_CTRL_FXOR(base, value) (BITBAND_ACCESS32(&CRC_CTRL_REG(base), CRC_CTRL_FXOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOTR[29:28] (RW)
 *
 * Identifies the transpose configuration of the value read from the CRC Data
 * register. See the description of the transpose feature for the available
 * transpose options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOTR field. */
#define CRC_RD_CTRL_TOTR(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOTR_MASK) >> CRC_CTRL_TOTR_SHIFT)
#define CRC_BRD_CTRL_TOTR(base) (CRC_RD_CTRL_TOTR(base))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRL_TOTR(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOTR_MASK, CRC_CTRL_TOTR(value)))
#define CRC_BWR_CTRL_TOTR(base, value) (CRC_WR_CTRL_TOTR(base, value))
/*@}*/

/*!
 * @name Register CRC_CTRL, field TOT[31:30] (RW)
 *
 * Defines the transpose configuration of the data written to the CRC data
 * register. See the description of the transpose feature for the available transpose
 * options.
 *
 * Values:
 * - 00 - No transposition.
 * - 01 - Bits in bytes are transposed; bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRL_TOT field. */
#define CRC_RD_CTRL_TOT(base) ((CRC_CTRL_REG(base) & CRC_CTRL_TOT_MASK) >> CRC_CTRL_TOT_SHIFT)
#define CRC_BRD_CTRL_TOT(base) (CRC_RD_CTRL_TOT(base))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRL_TOT(base, value) (CRC_RMW_CTRL(base, CRC_CTRL_TOT_MASK, CRC_CTRL_TOT(value)))
#define CRC_BWR_CTRL_TOT(base, value) (CRC_WR_CTRL_TOT(base, value))
/*@}*/

/*******************************************************************************
 * CRC_CTRLHU - CRC_CTRLHU register.
 ******************************************************************************/

/*!
 * @brief CRC_CTRLHU - CRC_CTRLHU register. (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire CRC_CTRLHU register
 */
/*@{*/
#define CRC_RD_CTRLHU(base)      (CRC_CTRLHU_REG(base))
#define CRC_WR_CTRLHU(base, value) (CRC_CTRLHU_REG(base) = (value))
#define CRC_RMW_CTRLHU(base, mask, value) (CRC_WR_CTRLHU(base, (CRC_RD_CTRLHU(base) & ~(mask)) | (value)))
#define CRC_SET_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) |  (value)))
#define CRC_CLR_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) & ~(value)))
#define CRC_TOG_CTRLHU(base, value) (CRC_WR_CTRLHU(base, CRC_RD_CTRLHU(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual CRC_CTRLHU bitfields
 */

/*!
 * @name Register CRC_CTRLHU, field TCRC[0] (RW)
 *
 * Values:
 * - 0 - 16-bit CRC protocol.
 * - 1 - 32-bit CRC protocol.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TCRC field. */
#define CRC_RD_CTRLHU_TCRC(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TCRC_MASK) >> CRC_CTRLHU_TCRC_SHIFT)
#define CRC_BRD_CTRLHU_TCRC(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT))

/*! @brief Set the TCRC field to a new value. */
#define CRC_WR_CTRLHU_TCRC(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TCRC_MASK, CRC_CTRLHU_TCRC(value)))
#define CRC_BWR_CTRLHU_TCRC(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_TCRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field WAS[1] (RW)
 *
 * Values:
 * - 0 - Writes to CRC data register are data values.
 * - 1 - Writes to CRC data reguster are seed values.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_WAS field. */
#define CRC_RD_CTRLHU_WAS(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_WAS_MASK) >> CRC_CTRLHU_WAS_SHIFT)
#define CRC_BRD_CTRLHU_WAS(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT))

/*! @brief Set the WAS field to a new value. */
#define CRC_WR_CTRLHU_WAS(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_WAS_MASK, CRC_CTRLHU_WAS(value)))
#define CRC_BWR_CTRLHU_WAS(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_WAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field FXOR[2] (RW)
 *
 * Values:
 * - 0 - No XOR on reading.
 * - 1 - Invert or complement the read value of CRC data register.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_FXOR field. */
#define CRC_RD_CTRLHU_FXOR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_FXOR_MASK) >> CRC_CTRLHU_FXOR_SHIFT)
#define CRC_BRD_CTRLHU_FXOR(base) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT))

/*! @brief Set the FXOR field to a new value. */
#define CRC_WR_CTRLHU_FXOR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_FXOR_MASK, CRC_CTRLHU_FXOR(value)))
#define CRC_BWR_CTRLHU_FXOR(base, value) (BITBAND_ACCESS8(&CRC_CTRLHU_REG(base), CRC_CTRLHU_FXOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOTR[5:4] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOTR field. */
#define CRC_RD_CTRLHU_TOTR(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOTR_MASK) >> CRC_CTRLHU_TOTR_SHIFT)
#define CRC_BRD_CTRLHU_TOTR(base) (CRC_RD_CTRLHU_TOTR(base))

/*! @brief Set the TOTR field to a new value. */
#define CRC_WR_CTRLHU_TOTR(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOTR_MASK, CRC_CTRLHU_TOTR(value)))
#define CRC_BWR_CTRLHU_TOTR(base, value) (CRC_WR_CTRLHU_TOTR(base, value))
/*@}*/

/*!
 * @name Register CRC_CTRLHU, field TOT[7:6] (RW)
 *
 * Values:
 * - 00 - No Transposition.
 * - 01 - Bits in bytes are transposed, bytes are not transposed.
 * - 10 - Both bits in bytes and bytes are transposed.
 * - 11 - Only bytes are transposed; no bits in a byte are transposed.
 */
/*@{*/
/*! @brief Read current value of the CRC_CTRLHU_TOT field. */
#define CRC_RD_CTRLHU_TOT(base) ((CRC_CTRLHU_REG(base) & CRC_CTRLHU_TOT_MASK) >> CRC_CTRLHU_TOT_SHIFT)
#define CRC_BRD_CTRLHU_TOT(base) (CRC_RD_CTRLHU_TOT(base))

/*! @brief Set the TOT field to a new value. */
#define CRC_WR_CTRLHU_TOT(base, value) (CRC_RMW_CTRLHU(base, CRC_CTRLHU_TOT_MASK, CRC_CTRLHU_TOT(value)))
#define CRC_BWR_CTRLHU_TOT(base, value) (CRC_WR_CTRLHU_TOT(base, value))
/*@}*/

/*
 * MKS22F25612 DAC
 *
 * 12-Bit Digital-to-Analog Converter
 *
 * Registers defined in this header file:
 * - DAC_DATL - DAC Data Low Register
 * - DAC_DATH - DAC Data High Register
 * - DAC_SR - DAC Status Register
 * - DAC_C0 - DAC Control Register
 * - DAC_C1 - DAC Control Register 1
 * - DAC_C2 - DAC Control Register 2
 */

#define DAC_INSTANCE_COUNT (1U) /*!< Number of instances of the DAC module. */
#define DAC0_IDX (0U) /*!< Instance number for DAC0. */

/*******************************************************************************
 * DAC_DATL - DAC Data Low Register
 ******************************************************************************/

/*!
 * @brief DAC_DATL - DAC Data Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATL register
 */
/*@{*/
#define DAC_RD_DATL(base, index) (DAC_DATL_REG(base, index))
#define DAC_WR_DATL(base, index, value) (DAC_DATL_REG(base, index) = (value))
#define DAC_RMW_DATL(base, index, mask, value) (DAC_WR_DATL(base, index, (DAC_RD_DATL(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATL(base, index, value) (DAC_WR_DATL(base, index, DAC_RD_DATL(base, index) |  (value)))
#define DAC_CLR_DATL(base, index, value) (DAC_WR_DATL(base, index, DAC_RD_DATL(base, index) & ~(value)))
#define DAC_TOG_DATL(base, index, value) (DAC_WR_DATL(base, index, DAC_RD_DATL(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DAC_DATH - DAC Data High Register
 ******************************************************************************/

/*!
 * @brief DAC_DATH - DAC Data High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_DATH register
 */
/*@{*/
#define DAC_RD_DATH(base, index) (DAC_DATH_REG(base, index))
#define DAC_WR_DATH(base, index, value) (DAC_DATH_REG(base, index) = (value))
#define DAC_RMW_DATH(base, index, mask, value) (DAC_WR_DATH(base, index, (DAC_RD_DATH(base, index) & ~(mask)) | (value)))
#define DAC_SET_DATH(base, index, value) (DAC_WR_DATH(base, index, DAC_RD_DATH(base, index) |  (value)))
#define DAC_CLR_DATH(base, index, value) (DAC_WR_DATH(base, index, DAC_RD_DATH(base, index) & ~(value)))
#define DAC_TOG_DATH(base, index, value) (DAC_WR_DATH(base, index, DAC_RD_DATH(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DAC_DATH bitfields
 */

/*!
 * @name Register DAC_DATH, field DATA1[3:0] (RW)
 *
 * When the DAC Buffer is not enabled, DATA[11:0] controls the output voltage
 * based on the following formula. V out = V in * (1 + DACDAT0[11:0])/4096 When the
 * DAC buffer is enabled, DATA[11:0] is mapped to the 16-word buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_DATH_DATA1 field. */
#define DAC_RD_DATH_DATA1(base, index) ((DAC_DATH_REG(base, index) & DAC_DATH_DATA1_MASK) >> DAC_DATH_DATA1_SHIFT)
#define DAC_BRD_DATH_DATA1(base, index) (DAC_RD_DATH_DATA1(base, index))

/*! @brief Set the DATA1 field to a new value. */
#define DAC_WR_DATH_DATA1(base, index, value) (DAC_RMW_DATH(base, index, DAC_DATH_DATA1_MASK, DAC_DATH_DATA1(value)))
#define DAC_BWR_DATH_DATA1(base, index, value) (DAC_WR_DATH_DATA1(base, index, value))
/*@}*/

/*******************************************************************************
 * DAC_SR - DAC Status Register
 ******************************************************************************/

/*!
 * @brief DAC_SR - DAC Status Register (RW)
 *
 * Reset value: 0x02U
 *
 * If DMA is enabled, the flags can be cleared automatically by DMA when the DMA
 * request is done. Writing 0 to a field clears it whereas writing 1 has no
 * effect. After reset, DACBFRPTF is set and can be cleared by software, if needed.
 * The flags are set only when the data buffer status is changed.
 */
/*!
 * @name Constants and macros for entire DAC_SR register
 */
/*@{*/
#define DAC_RD_SR(base)          (DAC_SR_REG(base))
#define DAC_WR_SR(base, value)   (DAC_SR_REG(base) = (value))
#define DAC_RMW_SR(base, mask, value) (DAC_WR_SR(base, (DAC_RD_SR(base) & ~(mask)) | (value)))
#define DAC_SET_SR(base, value)  (DAC_WR_SR(base, DAC_RD_SR(base) |  (value)))
#define DAC_CLR_SR(base, value)  (DAC_WR_SR(base, DAC_RD_SR(base) & ~(value)))
#define DAC_TOG_SR(base, value)  (DAC_WR_SR(base, DAC_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DAC_SR bitfields
 */

/*!
 * @name Register DAC_SR, field DACBFRPBF[0] (RW)
 *
 * In FIFO mode, it is FIFO FULL status bit. It means FIFO read pointer equals
 * Write Pointer because of Write Pointer increase. If this bit is set, any write
 * to FIFO from either DMA or CPU is ignored by DAC. It is cleared if there is
 * any DAC trigger making the DAC read pointer increase. Write to this bit is
 * ignored in FIFO mode.
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not equal to C2[DACBFUP].
 * - 1 - The DAC buffer read pointer is equal to C2[DACBFUP].
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPBF field. */
#define DAC_RD_SR_DACBFRPBF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPBF_MASK) >> DAC_SR_DACBFRPBF_SHIFT)
#define DAC_BRD_SR_DACBFRPBF(base) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT))

/*! @brief Set the DACBFRPBF field to a new value. */
#define DAC_WR_SR_DACBFRPBF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPBF_MASK, DAC_SR_DACBFRPBF(value)))
#define DAC_BWR_SR_DACBFRPBF(base, value) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFRPBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFRPTF[1] (RW)
 *
 * In FIFO mode, it is FIFO nearly empty flag. It is set when only one data
 * remains in FIFO. Any DAC trigger does not increase the Read Pointer if this bit is
 * set to avoid any possible glitch or abrupt change at DAC output. It is
 * cleared automatically if FIFO is not empty.
 *
 * Values:
 * - 0 - The DAC buffer read pointer is not zero.
 * - 1 - The DAC buffer read pointer is zero.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFRPTF field. */
#define DAC_RD_SR_DACBFRPTF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFRPTF_MASK) >> DAC_SR_DACBFRPTF_SHIFT)
#define DAC_BRD_SR_DACBFRPTF(base) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT))

/*! @brief Set the DACBFRPTF field to a new value. */
#define DAC_WR_SR_DACBFRPTF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFRPTF_MASK, DAC_SR_DACBFRPTF(value)))
#define DAC_BWR_SR_DACBFRPTF(base, value) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFRPTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_SR, field DACBFWMF[2] (RW)
 *
 * This bit is set if the remaining FIFO data is less than the watermark
 * setting. It is cleared automatically by writing data into FIFO by DMA or CPU. Write
 * to this bit is ignored in FIFO mode.
 *
 * Values:
 * - 0 - The DAC buffer read pointer has not reached the watermark level.
 * - 1 - The DAC buffer read pointer has reached the watermark level.
 */
/*@{*/
/*! @brief Read current value of the DAC_SR_DACBFWMF field. */
#define DAC_RD_SR_DACBFWMF(base) ((DAC_SR_REG(base) & DAC_SR_DACBFWMF_MASK) >> DAC_SR_DACBFWMF_SHIFT)
#define DAC_BRD_SR_DACBFWMF(base) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFWMF_SHIFT))

/*! @brief Set the DACBFWMF field to a new value. */
#define DAC_WR_SR_DACBFWMF(base, value) (DAC_RMW_SR(base, DAC_SR_DACBFWMF_MASK, DAC_SR_DACBFWMF(value)))
#define DAC_BWR_SR_DACBFWMF(base, value) (BITBAND_ACCESS8(&DAC_SR_REG(base), DAC_SR_DACBFWMF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DAC_C0 - DAC Control Register
 ******************************************************************************/

/*!
 * @brief DAC_C0 - DAC Control Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_C0 register
 */
/*@{*/
#define DAC_RD_C0(base)          (DAC_C0_REG(base))
#define DAC_WR_C0(base, value)   (DAC_C0_REG(base) = (value))
#define DAC_RMW_C0(base, mask, value) (DAC_WR_C0(base, (DAC_RD_C0(base) & ~(mask)) | (value)))
#define DAC_SET_C0(base, value)  (DAC_WR_C0(base, DAC_RD_C0(base) |  (value)))
#define DAC_CLR_C0(base, value)  (DAC_WR_C0(base, DAC_RD_C0(base) & ~(value)))
#define DAC_TOG_C0(base, value)  (DAC_WR_C0(base, DAC_RD_C0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C0 bitfields
 */

/*!
 * @name Register DAC_C0, field DACBBIEN[0] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer bottom flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer bottom flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBBIEN field. */
#define DAC_RD_C0_DACBBIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBBIEN_MASK) >> DAC_C0_DACBBIEN_SHIFT)
#define DAC_BRD_C0_DACBBIEN(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT))

/*! @brief Set the DACBBIEN field to a new value. */
#define DAC_WR_C0_DACBBIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBBIEN_MASK, DAC_C0_DACBBIEN(value)))
#define DAC_BWR_C0_DACBBIEN(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBBIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBTIEN[1] (RW)
 *
 * Values:
 * - 0 - The DAC buffer read pointer top flag interrupt is disabled.
 * - 1 - The DAC buffer read pointer top flag interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBTIEN field. */
#define DAC_RD_C0_DACBTIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBTIEN_MASK) >> DAC_C0_DACBTIEN_SHIFT)
#define DAC_BRD_C0_DACBTIEN(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT))

/*! @brief Set the DACBTIEN field to a new value. */
#define DAC_WR_C0_DACBTIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBTIEN_MASK, DAC_C0_DACBTIEN(value)))
#define DAC_BWR_C0_DACBTIEN(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBTIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACBWIEN[2] (RW)
 *
 * Values:
 * - 0 - The DAC buffer watermark interrupt is disabled.
 * - 1 - The DAC buffer watermark interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACBWIEN field. */
#define DAC_RD_C0_DACBWIEN(base) ((DAC_C0_REG(base) & DAC_C0_DACBWIEN_MASK) >> DAC_C0_DACBWIEN_SHIFT)
#define DAC_BRD_C0_DACBWIEN(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBWIEN_SHIFT))

/*! @brief Set the DACBWIEN field to a new value. */
#define DAC_WR_C0_DACBWIEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACBWIEN_MASK, DAC_C0_DACBWIEN(value)))
#define DAC_BWR_C0_DACBWIEN(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACBWIEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field LPEN[3] (RW)
 *
 * See the 12-bit DAC electrical characteristics of the device data sheet for
 * details on the impact of the modes below.
 *
 * Values:
 * - 0 - High-Power mode
 * - 1 - Low-Power mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_LPEN field. */
#define DAC_RD_C0_LPEN(base) ((DAC_C0_REG(base) & DAC_C0_LPEN_MASK) >> DAC_C0_LPEN_SHIFT)
#define DAC_BRD_C0_LPEN(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT))

/*! @brief Set the LPEN field to a new value. */
#define DAC_WR_C0_LPEN(base, value) (DAC_RMW_C0(base, DAC_C0_LPEN_MASK, DAC_C0_LPEN(value)))
#define DAC_BWR_C0_LPEN(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_LPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACSWTRG[4] (WORZ)
 *
 * Active high. This is a write-only field, which always reads 0. If DAC
 * software trigger is selected and buffer is enabled, writing 1 to this field will
 * advance the buffer read pointer once.
 *
 * Values:
 * - 0 - The DAC soft trigger is not valid.
 * - 1 - The DAC soft trigger is valid.
 */
/*@{*/
/*! @brief Set the DACSWTRG field to a new value. */
#define DAC_WR_C0_DACSWTRG(base, value) (DAC_RMW_C0(base, DAC_C0_DACSWTRG_MASK, DAC_C0_DACSWTRG(value)))
#define DAC_BWR_C0_DACSWTRG(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACSWTRG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACTRGSEL[5] (RW)
 *
 * Values:
 * - 0 - The DAC hardware trigger is selected.
 * - 1 - The DAC software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACTRGSEL field. */
#define DAC_RD_C0_DACTRGSEL(base) ((DAC_C0_REG(base) & DAC_C0_DACTRGSEL_MASK) >> DAC_C0_DACTRGSEL_SHIFT)
#define DAC_BRD_C0_DACTRGSEL(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT))

/*! @brief Set the DACTRGSEL field to a new value. */
#define DAC_WR_C0_DACTRGSEL(base, value) (DAC_RMW_C0(base, DAC_C0_DACTRGSEL_MASK, DAC_C0_DACTRGSEL(value)))
#define DAC_BWR_C0_DACTRGSEL(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACTRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACRFS[6] (RW)
 *
 * Values:
 * - 0 - The DAC selects DACREF_1 as the reference voltage.
 * - 1 - The DAC selects DACREF_2 as the reference voltage.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACRFS field. */
#define DAC_RD_C0_DACRFS(base) ((DAC_C0_REG(base) & DAC_C0_DACRFS_MASK) >> DAC_C0_DACRFS_SHIFT)
#define DAC_BRD_C0_DACRFS(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT))

/*! @brief Set the DACRFS field to a new value. */
#define DAC_WR_C0_DACRFS(base, value) (DAC_RMW_C0(base, DAC_C0_DACRFS_MASK, DAC_C0_DACRFS(value)))
#define DAC_BWR_C0_DACRFS(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACRFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C0, field DACEN[7] (RW)
 *
 * Starts the Programmable Reference Generator operation.
 *
 * Values:
 * - 0 - The DAC system is disabled.
 * - 1 - The DAC system is enabled.
 */
/*@{*/
/*! @brief Read current value of the DAC_C0_DACEN field. */
#define DAC_RD_C0_DACEN(base) ((DAC_C0_REG(base) & DAC_C0_DACEN_MASK) >> DAC_C0_DACEN_SHIFT)
#define DAC_BRD_C0_DACEN(base) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT))

/*! @brief Set the DACEN field to a new value. */
#define DAC_WR_C0_DACEN(base, value) (DAC_RMW_C0(base, DAC_C0_DACEN_MASK, DAC_C0_DACEN(value)))
#define DAC_BWR_C0_DACEN(base, value) (BITBAND_ACCESS8(&DAC_C0_REG(base), DAC_C0_DACEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DAC_C1 - DAC Control Register 1
 ******************************************************************************/

/*!
 * @brief DAC_C1 - DAC Control Register 1 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire DAC_C1 register
 */
/*@{*/
#define DAC_RD_C1(base)          (DAC_C1_REG(base))
#define DAC_WR_C1(base, value)   (DAC_C1_REG(base) = (value))
#define DAC_RMW_C1(base, mask, value) (DAC_WR_C1(base, (DAC_RD_C1(base) & ~(mask)) | (value)))
#define DAC_SET_C1(base, value)  (DAC_WR_C1(base, DAC_RD_C1(base) |  (value)))
#define DAC_CLR_C1(base, value)  (DAC_WR_C1(base, DAC_RD_C1(base) & ~(value)))
#define DAC_TOG_C1(base, value)  (DAC_WR_C1(base, DAC_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C1 bitfields
 */

/*!
 * @name Register DAC_C1, field DACBFEN[0] (RW)
 *
 * Values:
 * - 0 - Buffer read pointer is disabled. The converted data is always the first
 *     word of the buffer.
 * - 1 - Buffer read pointer is enabled. The converted data is the word that the
 *     read pointer points to. It means converted data can be from any word of
 *     the buffer.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFEN field. */
#define DAC_RD_C1_DACBFEN(base) ((DAC_C1_REG(base) & DAC_C1_DACBFEN_MASK) >> DAC_C1_DACBFEN_SHIFT)
#define DAC_BRD_C1_DACBFEN(base) (BITBAND_ACCESS8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT))

/*! @brief Set the DACBFEN field to a new value. */
#define DAC_WR_C1_DACBFEN(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFEN_MASK, DAC_C1_DACBFEN(value)))
#define DAC_BWR_C1_DACBFEN(base, value) (BITBAND_ACCESS8(&DAC_C1_REG(base), DAC_C1_DACBFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFMD[2:1] (RW)
 *
 * Values:
 * - 00 - Normal mode
 * - 01 - Swing mode
 * - 10 - One-Time Scan mode
 * - 11 - FIFO mode
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFMD field. */
#define DAC_RD_C1_DACBFMD(base) ((DAC_C1_REG(base) & DAC_C1_DACBFMD_MASK) >> DAC_C1_DACBFMD_SHIFT)
#define DAC_BRD_C1_DACBFMD(base) (DAC_RD_C1_DACBFMD(base))

/*! @brief Set the DACBFMD field to a new value. */
#define DAC_WR_C1_DACBFMD(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFMD_MASK, DAC_C1_DACBFMD(value)))
#define DAC_BWR_C1_DACBFMD(base, value) (DAC_WR_C1_DACBFMD(base, value))
/*@}*/

/*!
 * @name Register DAC_C1, field DACBFWM[4:3] (RW)
 *
 * In normal mode it controls when SR[DACBFWMF] is set. When the DAC buffer read
 * pointer reaches the word defined by this field, which is 1-4 words away from
 * the upper limit (DACBUP), SR[DACBFWMF] will be set. This allows user
 * configuration of the watermark interrupt. In FIFO mode, it is FIFO watermark select
 * field.
 *
 * Values:
 * - 00 - In normal mode, 1 word . In FIFO mode, 2 or less than 2 data remaining
 *     in FIFO will set watermark status bit.
 * - 01 - In normal mode, 2 words . In FIFO mode, Max/4 or less than Max/4 data
 *     remaining in FIFO will set watermark status bit.
 * - 10 - In normal mode, 3 words . In FIFO mode, Max/2 or less than Max/2 data
 *     remaining in FIFO will set watermark status bit.
 * - 11 - In normal mode, 4 words . In FIFO mode, Max-2 or less than Max-2 data
 *     remaining in FIFO will set watermark status bit.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DACBFWM field. */
#define DAC_RD_C1_DACBFWM(base) ((DAC_C1_REG(base) & DAC_C1_DACBFWM_MASK) >> DAC_C1_DACBFWM_SHIFT)
#define DAC_BRD_C1_DACBFWM(base) (DAC_RD_C1_DACBFWM(base))

/*! @brief Set the DACBFWM field to a new value. */
#define DAC_WR_C1_DACBFWM(base, value) (DAC_RMW_C1(base, DAC_C1_DACBFWM_MASK, DAC_C1_DACBFWM(value)))
#define DAC_BWR_C1_DACBFWM(base, value) (DAC_WR_C1_DACBFWM(base, value))
/*@}*/

/*!
 * @name Register DAC_C1, field DMAEN[7] (RW)
 *
 * Values:
 * - 0 - DMA is disabled.
 * - 1 - DMA is enabled. When DMA is enabled, the DMA request will be generated
 *     by original interrupts. The interrupts will not be presented on this
 *     module at the same time.
 */
/*@{*/
/*! @brief Read current value of the DAC_C1_DMAEN field. */
#define DAC_RD_C1_DMAEN(base) ((DAC_C1_REG(base) & DAC_C1_DMAEN_MASK) >> DAC_C1_DMAEN_SHIFT)
#define DAC_BRD_C1_DMAEN(base) (BITBAND_ACCESS8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define DAC_WR_C1_DMAEN(base, value) (DAC_RMW_C1(base, DAC_C1_DMAEN_MASK, DAC_C1_DMAEN(value)))
#define DAC_BWR_C1_DMAEN(base, value) (BITBAND_ACCESS8(&DAC_C1_REG(base), DAC_C1_DMAEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DAC_C2 - DAC Control Register 2
 ******************************************************************************/

/*!
 * @brief DAC_C2 - DAC Control Register 2 (RW)
 *
 * Reset value: 0x0FU
 */
/*!
 * @name Constants and macros for entire DAC_C2 register
 */
/*@{*/
#define DAC_RD_C2(base)          (DAC_C2_REG(base))
#define DAC_WR_C2(base, value)   (DAC_C2_REG(base) = (value))
#define DAC_RMW_C2(base, mask, value) (DAC_WR_C2(base, (DAC_RD_C2(base) & ~(mask)) | (value)))
#define DAC_SET_C2(base, value)  (DAC_WR_C2(base, DAC_RD_C2(base) |  (value)))
#define DAC_CLR_C2(base, value)  (DAC_WR_C2(base, DAC_RD_C2(base) & ~(value)))
#define DAC_TOG_C2(base, value)  (DAC_WR_C2(base, DAC_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DAC_C2 bitfields
 */

/*!
 * @name Register DAC_C2, field DACBFUP[3:0] (RW)
 *
 * In normal mode it selects the upper limit of the DAC buffer. The buffer read
 * pointer cannot exceed it. In FIFO mode it is the FIFO write pointer. User
 * cannot set Buffer Up limit in FIFO mode. In Normal mode its reset value is MAX.
 * When IP is configured to FIFO mode, this register becomes Write_Pointer, and its
 * value is initially set to equal READ_POINTER automatically, and the FIFO
 * status is empty. It is writable and user can configure it to the same address to
 * reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFUP field. */
#define DAC_RD_C2_DACBFUP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFUP_MASK) >> DAC_C2_DACBFUP_SHIFT)
#define DAC_BRD_C2_DACBFUP(base) (DAC_RD_C2_DACBFUP(base))

/*! @brief Set the DACBFUP field to a new value. */
#define DAC_WR_C2_DACBFUP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFUP_MASK, DAC_C2_DACBFUP(value)))
#define DAC_BWR_C2_DACBFUP(base, value) (DAC_WR_C2_DACBFUP(base, value))
/*@}*/

/*!
 * @name Register DAC_C2, field DACBFRP[7:4] (RW)
 *
 * In normal mode it keeps the current value of the buffer read pointer. FIFO
 * mode, it is the FIFO read pointer. It is writable in FIFO mode. User can
 * configure it to same address to reset FIFO as empty.
 */
/*@{*/
/*! @brief Read current value of the DAC_C2_DACBFRP field. */
#define DAC_RD_C2_DACBFRP(base) ((DAC_C2_REG(base) & DAC_C2_DACBFRP_MASK) >> DAC_C2_DACBFRP_SHIFT)
#define DAC_BRD_C2_DACBFRP(base) (DAC_RD_C2_DACBFRP(base))

/*! @brief Set the DACBFRP field to a new value. */
#define DAC_WR_C2_DACBFRP(base, value) (DAC_RMW_C2(base, DAC_C2_DACBFRP_MASK, DAC_C2_DACBFRP(value)))
#define DAC_BWR_C2_DACBFRP(base, value) (DAC_WR_C2_DACBFRP(base, value))
/*@}*/

/*
 * MKS22F25612 DMA
 *
 * Enhanced direct memory access controller
 *
 * Registers defined in this header file:
 * - DMA_CR - Control Register
 * - DMA_ES - Error Status Register
 * - DMA_ERQ - Enable Request Register
 * - DMA_EEI - Enable Error Interrupt Register
 * - DMA_CEEI - Clear Enable Error Interrupt Register
 * - DMA_SEEI - Set Enable Error Interrupt Register
 * - DMA_CERQ - Clear Enable Request Register
 * - DMA_SERQ - Set Enable Request Register
 * - DMA_CDNE - Clear DONE Status Bit Register
 * - DMA_SSRT - Set START Bit Register
 * - DMA_CERR - Clear Error Register
 * - DMA_CINT - Clear Interrupt Request Register
 * - DMA_INT - Interrupt Request Register
 * - DMA_ERR - Error Register
 * - DMA_HRS - Hardware Request Status Register
 * - DMA_EARS - Enable Asynchronous Request in Stop Register
 * - DMA_DCHPRI3 - Channel n Priority Register
 * - DMA_DCHPRI2 - Channel n Priority Register
 * - DMA_DCHPRI1 - Channel n Priority Register
 * - DMA_DCHPRI0 - Channel n Priority Register
 * - DMA_DCHPRI7 - Channel n Priority Register
 * - DMA_DCHPRI6 - Channel n Priority Register
 * - DMA_DCHPRI5 - Channel n Priority Register
 * - DMA_DCHPRI4 - Channel n Priority Register
 * - DMA_DCHPRI11 - Channel n Priority Register
 * - DMA_DCHPRI10 - Channel n Priority Register
 * - DMA_DCHPRI9 - Channel n Priority Register
 * - DMA_DCHPRI8 - Channel n Priority Register
 * - DMA_DCHPRI15 - Channel n Priority Register
 * - DMA_DCHPRI14 - Channel n Priority Register
 * - DMA_DCHPRI13 - Channel n Priority Register
 * - DMA_DCHPRI12 - Channel n Priority Register
 * - DMA_SADDR - TCD Source Address
 * - DMA_SOFF - TCD Signed Source Address Offset
 * - DMA_ATTR - TCD Transfer Attributes
 * - DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 * - DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 * - DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 * - DMA_SLAST - TCD Last Source Address Adjustment
 * - DMA_DADDR - TCD Destination Address
 * - DMA_DOFF - TCD Signed Destination Address Offset
 * - DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 * - DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 * - DMA_CSR - TCD Control and Status
 * - DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 * - DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 */

#define DMA_INSTANCE_COUNT (1U) /*!< Number of instances of the DMA module. */
#define DMA_IDX (0U) /*!< Instance number for DMA. */

/*******************************************************************************
 * DMA_CR - Control Register
 ******************************************************************************/

/*!
 * @brief DMA_CR - Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CR defines the basic operating configuration of the DMA. Arbitration can
 * be configured to use either a fixed-priority or a round-robin scheme. For
 * fixed-priority arbitration, the highest priority channel requesting service is
 * selected to execute. The channel priority registers assign the priorities; see
 * the DCHPRIn registers. For round-robin arbitration, the channel priorities are
 * ignored and channels are cycled through (from high to low channel number)
 * without regard to priority. For correct operation, writes to the CR register must
 * be performed only when the DMA channels are inactive; that is, when
 * TCDn_CSR[ACTIVE] bits are cleared. Minor loop offsets are address offset values added to
 * the final source address (TCDn_SADDR) or destination address (TCDn_DADDR) upon
 * minor loop completion. When minor loop offsets are enabled, the minor loop
 * offset (MLOFF) is added to the final source address (TCDn_SADDR), to the final
 * destination address (TCDn_DADDR), or to both prior to the addresses being
 * written back into the TCD. If the major loop is complete, the minor loop offset is
 * ignored and the major loop address offsets (TCDn_SLAST and TCDn_DLAST_SGA) are
 * used to compute the next TCDn_SADDR and TCDn_DADDR values. When minor loop
 * mapping is enabled (EMLM is 1), TCDn word2 is redefined. A portion of TCDn word2
 * is used to specify multiple fields: a source enable bit (SMLOE) to specify
 * the minor loop offset should be applied to the source address (TCDn_SADDR) upon
 * minor loop completion, a destination enable bit (DMLOE) to specify the minor
 * loop offset should be applied to the destination address (TCDn_DADDR) upon
 * minor loop completion, and the sign extended minor loop offset value (MLOFF). The
 * same offset value (MLOFF) is used for both source and destination minor loop
 * offsets. When either minor loop offset is enabled (SMLOE set or DMLOE set), the
 * NBYTES field is reduced to 10 bits. When both minor loop offsets are disabled
 * (SMLOE cleared and DMLOE cleared), the NBYTES field is a 30-bit vector. When
 * minor loop mapping is disabled (EMLM is 0), all 32 bits of TCDn word2 are
 * assigned to the NBYTES field.
 */
/*!
 * @name Constants and macros for entire DMA_CR register
 */
/*@{*/
#define DMA_RD_CR(base)          (DMA_CR_REG(base))
#define DMA_WR_CR(base, value)   (DMA_CR_REG(base) = (value))
#define DMA_RMW_CR(base, mask, value) (DMA_WR_CR(base, (DMA_RD_CR(base) & ~(mask)) | (value)))
#define DMA_SET_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) |  (value)))
#define DMA_CLR_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) & ~(value)))
#define DMA_TOG_CR(base, value)  (DMA_WR_CR(base, DMA_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CR bitfields
 */

/*!
 * @name Register DMA_CR, field EDBG[1] (RW)
 *
 * Values:
 * - 0 - When in debug mode, the DMA continues to operate.
 * - 1 - When in debug mode, the DMA stalls the start of a new channel.
 *     Executing channels are allowed to complete. Channel execution resumes when the
 *     system exits debug mode or the EDBG bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EDBG field. */
#define DMA_RD_CR_EDBG(base) ((DMA_CR_REG(base) & DMA_CR_EDBG_MASK) >> DMA_CR_EDBG_SHIFT)
#define DMA_BRD_CR_EDBG(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT))

/*! @brief Set the EDBG field to a new value. */
#define DMA_WR_CR_EDBG(base, value) (DMA_RMW_CR(base, DMA_CR_EDBG_MASK, DMA_CR_EDBG(value)))
#define DMA_BWR_CR_EDBG(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EDBG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ERCA[2] (RW)
 *
 * Values:
 * - 0 - Fixed priority arbitration is used for channel selection .
 * - 1 - Round robin arbitration is used for channel selection .
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ERCA field. */
#define DMA_RD_CR_ERCA(base) ((DMA_CR_REG(base) & DMA_CR_ERCA_MASK) >> DMA_CR_ERCA_SHIFT)
#define DMA_BRD_CR_ERCA(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT))

/*! @brief Set the ERCA field to a new value. */
#define DMA_WR_CR_ERCA(base, value) (DMA_RMW_CR(base, DMA_CR_ERCA_MASK, DMA_CR_ERCA(value)))
#define DMA_BWR_CR_ERCA(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ERCA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HOE[4] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Any error causes the HALT bit to set. Subsequently, all service
 *     requests are ignored until the HALT bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HOE field. */
#define DMA_RD_CR_HOE(base)  ((DMA_CR_REG(base) & DMA_CR_HOE_MASK) >> DMA_CR_HOE_SHIFT)
#define DMA_BRD_CR_HOE(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT))

/*! @brief Set the HOE field to a new value. */
#define DMA_WR_CR_HOE(base, value) (DMA_RMW_CR(base, DMA_CR_HOE_MASK, DMA_CR_HOE(value)))
#define DMA_BWR_CR_HOE(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field HALT[5] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Stall the start of any new channels. Executing channels are allowed to
 *     complete. Channel execution resumes when this bit is cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_HALT field. */
#define DMA_RD_CR_HALT(base) ((DMA_CR_REG(base) & DMA_CR_HALT_MASK) >> DMA_CR_HALT_SHIFT)
#define DMA_BRD_CR_HALT(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define DMA_WR_CR_HALT(base, value) (DMA_RMW_CR(base, DMA_CR_HALT_MASK, DMA_CR_HALT(value)))
#define DMA_BWR_CR_HALT(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CLM[6] (RW)
 *
 * Do not use continuous link mode with a channel linking to itself if there is
 * only one minor loop iteration per service request, e.g., if the channel's
 * NBYTES value is the same as either the source or destination size. The same data
 * transfer profile can be achieved by simply increasing the NBYTES value, which
 * provides more efficient, faster processing.
 *
 * Values:
 * - 0 - A minor loop channel link made to itself goes through channel
 *     arbitration before being activated again.
 * - 1 - A minor loop channel link made to itself does not go through channel
 *     arbitration before being activated again. Upon minor loop completion, the
 *     channel activates again if that channel has a minor loop channel link
 *     enabled and the link channel is itself. This effectively applies the minor loop
 *     offsets and restarts the next minor loop.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CLM field. */
#define DMA_RD_CR_CLM(base)  ((DMA_CR_REG(base) & DMA_CR_CLM_MASK) >> DMA_CR_CLM_SHIFT)
#define DMA_BRD_CR_CLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT))

/*! @brief Set the CLM field to a new value. */
#define DMA_WR_CR_CLM(base, value) (DMA_RMW_CR(base, DMA_CR_CLM_MASK, DMA_CR_CLM(value)))
#define DMA_BWR_CR_CLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field EMLM[7] (RW)
 *
 * Values:
 * - 0 - Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.
 * - 1 - Enabled. TCDn.word2 is redefined to include individual enable fields,
 *     an offset field, and the NBYTES field. The individual enable fields allow
 *     the minor loop offset to be applied to the source address, the destination
 *     address, or both. The NBYTES field is reduced when either offset is
 *     enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_EMLM field. */
#define DMA_RD_CR_EMLM(base) ((DMA_CR_REG(base) & DMA_CR_EMLM_MASK) >> DMA_CR_EMLM_SHIFT)
#define DMA_BRD_CR_EMLM(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT))

/*! @brief Set the EMLM field to a new value. */
#define DMA_WR_CR_EMLM(base, value) (DMA_RMW_CR(base, DMA_CR_EMLM_MASK, DMA_CR_EMLM(value)))
#define DMA_BWR_CR_EMLM(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_EMLM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field ECX[16] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer in the same fashion as the CX bit.
 *     Stop the executing channel and force the minor loop to finish. The cancel
 *     takes effect after the last write of the current read/write sequence. The
 *     ECX bit clears itself after the cancel is honored. In addition to
 *     cancelling the transfer, ECX treats the cancel as an error condition, thus updating
 *     the Error Status register (DMAx_ES) and generating an optional error
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_ECX field. */
#define DMA_RD_CR_ECX(base)  ((DMA_CR_REG(base) & DMA_CR_ECX_MASK) >> DMA_CR_ECX_SHIFT)
#define DMA_BRD_CR_ECX(base) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT))

/*! @brief Set the ECX field to a new value. */
#define DMA_WR_CR_ECX(base, value) (DMA_RMW_CR(base, DMA_CR_ECX_MASK, DMA_CR_ECX(value)))
#define DMA_BWR_CR_ECX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_ECX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CR, field CX[17] (RW)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - Cancel the remaining data transfer. Stop the executing channel and
 *     force the minor loop to finish. The cancel takes effect after the last write
 *     of the current read/write sequence. The CX bit clears itself after the
 *     cancel has been honored. This cancel retires the channel normally as if the
 *     minor loop was completed.
 */
/*@{*/
/*! @brief Read current value of the DMA_CR_CX field. */
#define DMA_RD_CR_CX(base)   ((DMA_CR_REG(base) & DMA_CR_CX_MASK) >> DMA_CR_CX_SHIFT)
#define DMA_BRD_CR_CX(base)  (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT))

/*! @brief Set the CX field to a new value. */
#define DMA_WR_CR_CX(base, value) (DMA_RMW_CR(base, DMA_CR_CX_MASK, DMA_CR_CX(value)))
#define DMA_BWR_CR_CX(base, value) (BITBAND_ACCESS32(&DMA_CR_REG(base), DMA_CR_CX_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ES - Error Status Register
 ******************************************************************************/

/*!
 * @brief DMA_ES - Error Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The ES provides information concerning the last recorded channel error.
 * Channel errors can be caused by: A configuration error, that is: An illegal setting
 * in the transfer-control descriptor, or An illegal priority register setting
 * in fixed-arbitration An error termination to a bus master read or write cycle
 * See the Error Reporting and Handling section for more details.
 */
/*!
 * @name Constants and macros for entire DMA_ES register
 */
/*@{*/
#define DMA_RD_ES(base)          (DMA_ES_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_ES bitfields
 */

/*!
 * @name Register DMA_ES, field DBE[0] (RO)
 *
 * Values:
 * - 0 - No destination bus error
 * - 1 - The last recorded error was a bus error on a destination write
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DBE field. */
#define DMA_RD_ES_DBE(base)  ((DMA_ES_REG(base) & DMA_ES_DBE_MASK) >> DMA_ES_DBE_SHIFT)
#define DMA_BRD_ES_DBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SBE[1] (RO)
 *
 * Values:
 * - 0 - No source bus error
 * - 1 - The last recorded error was a bus error on a source read
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SBE field. */
#define DMA_RD_ES_SBE(base)  ((DMA_ES_REG(base) & DMA_ES_SBE_MASK) >> DMA_ES_SBE_SHIFT)
#define DMA_BRD_ES_SBE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SBE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SGE[2] (RO)
 *
 * Values:
 * - 0 - No scatter/gather configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DLASTSGA field. This field is checked at the beginning of a scatter/gather
 *     operation after major loop completion if TCDn_CSR[ESG] is enabled.
 *     TCDn_DLASTSGA is not on a 32 byte boundary.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SGE field. */
#define DMA_RD_ES_SGE(base)  ((DMA_ES_REG(base) & DMA_ES_SGE_MASK) >> DMA_ES_SGE_SHIFT)
#define DMA_BRD_ES_SGE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SGE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field NCE[3] (RO)
 *
 * Values:
 * - 0 - No NBYTES/CITER configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_NBYTES or TCDn_CITER fields. TCDn_NBYTES is not a multiple of
 *     TCDn_ATTR[SSIZE] and TCDn_ATTR[DSIZE], or TCDn_CITER[CITER] is equal to zero, or
 *     TCDn_CITER[ELINK] is not equal to TCDn_BITER[ELINK]
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_NCE field. */
#define DMA_RD_ES_NCE(base)  ((DMA_ES_REG(base) & DMA_ES_NCE_MASK) >> DMA_ES_NCE_SHIFT)
#define DMA_BRD_ES_NCE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_NCE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DOE[4] (RO)
 *
 * Values:
 * - 0 - No destination offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DOFF field. TCDn_DOFF is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DOE field. */
#define DMA_RD_ES_DOE(base)  ((DMA_ES_REG(base) & DMA_ES_DOE_MASK) >> DMA_ES_DOE_SHIFT)
#define DMA_BRD_ES_DOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field DAE[5] (RO)
 *
 * Values:
 * - 0 - No destination address configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_DADDR field. TCDn_DADDR is inconsistent with TCDn_ATTR[DSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_DAE field. */
#define DMA_RD_ES_DAE(base)  ((DMA_ES_REG(base) & DMA_ES_DAE_MASK) >> DMA_ES_DAE_SHIFT)
#define DMA_BRD_ES_DAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_DAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SOE[6] (RO)
 *
 * Values:
 * - 0 - No source offset configuration error
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SOFF field. TCDn_SOFF is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SOE field. */
#define DMA_RD_ES_SOE(base)  ((DMA_ES_REG(base) & DMA_ES_SOE_MASK) >> DMA_ES_SOE_SHIFT)
#define DMA_BRD_ES_SOE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SOE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field SAE[7] (RO)
 *
 * Values:
 * - 0 - No source address configuration error.
 * - 1 - The last recorded error was a configuration error detected in the
 *     TCDn_SADDR field. TCDn_SADDR is inconsistent with TCDn_ATTR[SSIZE].
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_SAE field. */
#define DMA_RD_ES_SAE(base)  ((DMA_ES_REG(base) & DMA_ES_SAE_MASK) >> DMA_ES_SAE_SHIFT)
#define DMA_BRD_ES_SAE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_SAE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ERRCHN[11:8] (RO)
 *
 * The channel number of the last recorded error, excluding CPE errors, or last
 * recorded error canceled transfer.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ERRCHN field. */
#define DMA_RD_ES_ERRCHN(base) ((DMA_ES_REG(base) & DMA_ES_ERRCHN_MASK) >> DMA_ES_ERRCHN_SHIFT)
#define DMA_BRD_ES_ERRCHN(base) (DMA_RD_ES_ERRCHN(base))
/*@}*/

/*!
 * @name Register DMA_ES, field CPE[14] (RO)
 *
 * Values:
 * - 0 - No channel priority error
 * - 1 - The last recorded error was a configuration error in the channel
 *     priorities . Channel priorities are not unique.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_CPE field. */
#define DMA_RD_ES_CPE(base)  ((DMA_ES_REG(base) & DMA_ES_CPE_MASK) >> DMA_ES_CPE_SHIFT)
#define DMA_BRD_ES_CPE(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_CPE_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field ECX[16] (RO)
 *
 * Values:
 * - 0 - No canceled transfers
 * - 1 - The last recorded entry was a canceled transfer by the error cancel
 *     transfer input
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_ECX field. */
#define DMA_RD_ES_ECX(base)  ((DMA_ES_REG(base) & DMA_ES_ECX_MASK) >> DMA_ES_ECX_SHIFT)
#define DMA_BRD_ES_ECX(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_ECX_SHIFT))
/*@}*/

/*!
 * @name Register DMA_ES, field VLD[31] (RO)
 *
 * Logical OR of all ERR status bits
 *
 * Values:
 * - 0 - No ERR bits are set.
 * - 1 - At least one ERR bit is set indicating a valid error exists that has
 *     not been cleared.
 */
/*@{*/
/*! @brief Read current value of the DMA_ES_VLD field. */
#define DMA_RD_ES_VLD(base)  ((DMA_ES_REG(base) & DMA_ES_VLD_MASK) >> DMA_ES_VLD_SHIFT)
#define DMA_BRD_ES_VLD(base) (BITBAND_ACCESS32(&DMA_ES_REG(base), DMA_ES_VLD_SHIFT))
/*@}*/

/*******************************************************************************
 * DMA_ERQ - Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_ERQ - Enable Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERQ register provides a bit map for the 16 channels to enable the request
 * signal for each channel. The state of any given channel enable is directly
 * affected by writes to this register; it is also affected by writes to the SERQ
 * and CERQ registers. These registers are provided so the request enable for a
 * single channel can easily be modified without needing to perform a
 * read-modify-write sequence to the ERQ. DMA request input signals and this enable request
 * flag must be asserted before a channel's hardware service request is accepted.
 * The state of the DMA enable request flag does not affect a channel service
 * request made explicitly through software or a linked channel request.
 */
/*!
 * @name Constants and macros for entire DMA_ERQ register
 */
/*@{*/
#define DMA_RD_ERQ(base)         (DMA_ERQ_REG(base))
#define DMA_WR_ERQ(base, value)  (DMA_ERQ_REG(base) = (value))
#define DMA_RMW_ERQ(base, mask, value) (DMA_WR_ERQ(base, (DMA_RD_ERQ(base) & ~(mask)) | (value)))
#define DMA_SET_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) |  (value)))
#define DMA_CLR_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) & ~(value)))
#define DMA_TOG_ERQ(base, value) (DMA_WR_ERQ(base, DMA_RD_ERQ(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERQ bitfields
 */

/*!
 * @name Register DMA_ERQ, field ERQ0[0] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ0 field. */
#define DMA_RD_ERQ_ERQ0(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ0_MASK) >> DMA_ERQ_ERQ0_SHIFT)
#define DMA_BRD_ERQ_ERQ0(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT))

/*! @brief Set the ERQ0 field to a new value. */
#define DMA_WR_ERQ_ERQ0(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ0_MASK, DMA_ERQ_ERQ0(value)))
#define DMA_BWR_ERQ_ERQ0(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ1[1] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ1 field. */
#define DMA_RD_ERQ_ERQ1(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ1_MASK) >> DMA_ERQ_ERQ1_SHIFT)
#define DMA_BRD_ERQ_ERQ1(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT))

/*! @brief Set the ERQ1 field to a new value. */
#define DMA_WR_ERQ_ERQ1(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ1_MASK, DMA_ERQ_ERQ1(value)))
#define DMA_BWR_ERQ_ERQ1(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ2[2] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ2 field. */
#define DMA_RD_ERQ_ERQ2(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ2_MASK) >> DMA_ERQ_ERQ2_SHIFT)
#define DMA_BRD_ERQ_ERQ2(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT))

/*! @brief Set the ERQ2 field to a new value. */
#define DMA_WR_ERQ_ERQ2(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ2_MASK, DMA_ERQ_ERQ2(value)))
#define DMA_BWR_ERQ_ERQ2(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ3[3] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ3 field. */
#define DMA_RD_ERQ_ERQ3(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ3_MASK) >> DMA_ERQ_ERQ3_SHIFT)
#define DMA_BRD_ERQ_ERQ3(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT))

/*! @brief Set the ERQ3 field to a new value. */
#define DMA_WR_ERQ_ERQ3(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ3_MASK, DMA_ERQ_ERQ3(value)))
#define DMA_BWR_ERQ_ERQ3(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ4[4] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ4 field. */
#define DMA_RD_ERQ_ERQ4(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ4_MASK) >> DMA_ERQ_ERQ4_SHIFT)
#define DMA_BRD_ERQ_ERQ4(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT))

/*! @brief Set the ERQ4 field to a new value. */
#define DMA_WR_ERQ_ERQ4(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ4_MASK, DMA_ERQ_ERQ4(value)))
#define DMA_BWR_ERQ_ERQ4(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ5[5] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ5 field. */
#define DMA_RD_ERQ_ERQ5(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ5_MASK) >> DMA_ERQ_ERQ5_SHIFT)
#define DMA_BRD_ERQ_ERQ5(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT))

/*! @brief Set the ERQ5 field to a new value. */
#define DMA_WR_ERQ_ERQ5(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ5_MASK, DMA_ERQ_ERQ5(value)))
#define DMA_BWR_ERQ_ERQ5(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ6[6] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ6 field. */
#define DMA_RD_ERQ_ERQ6(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ6_MASK) >> DMA_ERQ_ERQ6_SHIFT)
#define DMA_BRD_ERQ_ERQ6(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT))

/*! @brief Set the ERQ6 field to a new value. */
#define DMA_WR_ERQ_ERQ6(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ6_MASK, DMA_ERQ_ERQ6(value)))
#define DMA_BWR_ERQ_ERQ6(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ7[7] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ7 field. */
#define DMA_RD_ERQ_ERQ7(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ7_MASK) >> DMA_ERQ_ERQ7_SHIFT)
#define DMA_BRD_ERQ_ERQ7(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT))

/*! @brief Set the ERQ7 field to a new value. */
#define DMA_WR_ERQ_ERQ7(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ7_MASK, DMA_ERQ_ERQ7(value)))
#define DMA_BWR_ERQ_ERQ7(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ8[8] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ8 field. */
#define DMA_RD_ERQ_ERQ8(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ8_MASK) >> DMA_ERQ_ERQ8_SHIFT)
#define DMA_BRD_ERQ_ERQ8(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ8_SHIFT))

/*! @brief Set the ERQ8 field to a new value. */
#define DMA_WR_ERQ_ERQ8(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ8_MASK, DMA_ERQ_ERQ8(value)))
#define DMA_BWR_ERQ_ERQ8(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ9[9] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ9 field. */
#define DMA_RD_ERQ_ERQ9(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ9_MASK) >> DMA_ERQ_ERQ9_SHIFT)
#define DMA_BRD_ERQ_ERQ9(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ9_SHIFT))

/*! @brief Set the ERQ9 field to a new value. */
#define DMA_WR_ERQ_ERQ9(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ9_MASK, DMA_ERQ_ERQ9(value)))
#define DMA_BWR_ERQ_ERQ9(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ10[10] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ10 field. */
#define DMA_RD_ERQ_ERQ10(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ10_MASK) >> DMA_ERQ_ERQ10_SHIFT)
#define DMA_BRD_ERQ_ERQ10(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ10_SHIFT))

/*! @brief Set the ERQ10 field to a new value. */
#define DMA_WR_ERQ_ERQ10(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ10_MASK, DMA_ERQ_ERQ10(value)))
#define DMA_BWR_ERQ_ERQ10(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ11[11] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ11 field. */
#define DMA_RD_ERQ_ERQ11(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ11_MASK) >> DMA_ERQ_ERQ11_SHIFT)
#define DMA_BRD_ERQ_ERQ11(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ11_SHIFT))

/*! @brief Set the ERQ11 field to a new value. */
#define DMA_WR_ERQ_ERQ11(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ11_MASK, DMA_ERQ_ERQ11(value)))
#define DMA_BWR_ERQ_ERQ11(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ12[12] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ12 field. */
#define DMA_RD_ERQ_ERQ12(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ12_MASK) >> DMA_ERQ_ERQ12_SHIFT)
#define DMA_BRD_ERQ_ERQ12(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ12_SHIFT))

/*! @brief Set the ERQ12 field to a new value. */
#define DMA_WR_ERQ_ERQ12(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ12_MASK, DMA_ERQ_ERQ12(value)))
#define DMA_BWR_ERQ_ERQ12(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ13[13] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ13 field. */
#define DMA_RD_ERQ_ERQ13(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ13_MASK) >> DMA_ERQ_ERQ13_SHIFT)
#define DMA_BRD_ERQ_ERQ13(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ13_SHIFT))

/*! @brief Set the ERQ13 field to a new value. */
#define DMA_WR_ERQ_ERQ13(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ13_MASK, DMA_ERQ_ERQ13(value)))
#define DMA_BWR_ERQ_ERQ13(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ14[14] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ14 field. */
#define DMA_RD_ERQ_ERQ14(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ14_MASK) >> DMA_ERQ_ERQ14_SHIFT)
#define DMA_BRD_ERQ_ERQ14(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ14_SHIFT))

/*! @brief Set the ERQ14 field to a new value. */
#define DMA_WR_ERQ_ERQ14(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ14_MASK, DMA_ERQ_ERQ14(value)))
#define DMA_BWR_ERQ_ERQ14(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERQ, field ERQ15[15] (RW)
 *
 * Values:
 * - 0 - The DMA request signal for the corresponding channel is disabled
 * - 1 - The DMA request signal for the corresponding channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ERQ_ERQ15 field. */
#define DMA_RD_ERQ_ERQ15(base) ((DMA_ERQ_REG(base) & DMA_ERQ_ERQ15_MASK) >> DMA_ERQ_ERQ15_SHIFT)
#define DMA_BRD_ERQ_ERQ15(base) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ15_SHIFT))

/*! @brief Set the ERQ15 field to a new value. */
#define DMA_WR_ERQ_ERQ15(base, value) (DMA_RMW_ERQ(base, DMA_ERQ_ERQ15_MASK, DMA_ERQ_ERQ15(value)))
#define DMA_BWR_ERQ_ERQ15(base, value) (BITBAND_ACCESS32(&DMA_ERQ_REG(base), DMA_ERQ_ERQ15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_EEI - Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_EEI - Enable Error Interrupt Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The EEI register provides a bit map for the 16 channels to enable the error
 * interrupt signal for each channel. The state of any given channel's error
 * interrupt enable is directly affected by writes to this register; it is also
 * affected by writes to the SEEI and CEEI. These registers are provided so that the
 * error interrupt enable for a single channel can easily be modified without the
 * need to perform a read-modify-write sequence to the EEI register. The DMA error
 * indicator and the error interrupt enable flag must be asserted before an
 * error interrupt request for a given channel is asserted to the interrupt
 * controller.
 */
/*!
 * @name Constants and macros for entire DMA_EEI register
 */
/*@{*/
#define DMA_RD_EEI(base)         (DMA_EEI_REG(base))
#define DMA_WR_EEI(base, value)  (DMA_EEI_REG(base) = (value))
#define DMA_RMW_EEI(base, mask, value) (DMA_WR_EEI(base, (DMA_RD_EEI(base) & ~(mask)) | (value)))
#define DMA_SET_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) |  (value)))
#define DMA_CLR_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) & ~(value)))
#define DMA_TOG_EEI(base, value) (DMA_WR_EEI(base, DMA_RD_EEI(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EEI bitfields
 */

/*!
 * @name Register DMA_EEI, field EEI0[0] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI0 field. */
#define DMA_RD_EEI_EEI0(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI0_MASK) >> DMA_EEI_EEI0_SHIFT)
#define DMA_BRD_EEI_EEI0(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT))

/*! @brief Set the EEI0 field to a new value. */
#define DMA_WR_EEI_EEI0(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI0_MASK, DMA_EEI_EEI0(value)))
#define DMA_BWR_EEI_EEI0(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI1[1] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI1 field. */
#define DMA_RD_EEI_EEI1(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI1_MASK) >> DMA_EEI_EEI1_SHIFT)
#define DMA_BRD_EEI_EEI1(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT))

/*! @brief Set the EEI1 field to a new value. */
#define DMA_WR_EEI_EEI1(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI1_MASK, DMA_EEI_EEI1(value)))
#define DMA_BWR_EEI_EEI1(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI2[2] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI2 field. */
#define DMA_RD_EEI_EEI2(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI2_MASK) >> DMA_EEI_EEI2_SHIFT)
#define DMA_BRD_EEI_EEI2(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT))

/*! @brief Set the EEI2 field to a new value. */
#define DMA_WR_EEI_EEI2(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI2_MASK, DMA_EEI_EEI2(value)))
#define DMA_BWR_EEI_EEI2(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI3[3] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI3 field. */
#define DMA_RD_EEI_EEI3(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI3_MASK) >> DMA_EEI_EEI3_SHIFT)
#define DMA_BRD_EEI_EEI3(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT))

/*! @brief Set the EEI3 field to a new value. */
#define DMA_WR_EEI_EEI3(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI3_MASK, DMA_EEI_EEI3(value)))
#define DMA_BWR_EEI_EEI3(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI4[4] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI4 field. */
#define DMA_RD_EEI_EEI4(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI4_MASK) >> DMA_EEI_EEI4_SHIFT)
#define DMA_BRD_EEI_EEI4(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT))

/*! @brief Set the EEI4 field to a new value. */
#define DMA_WR_EEI_EEI4(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI4_MASK, DMA_EEI_EEI4(value)))
#define DMA_BWR_EEI_EEI4(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI5[5] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI5 field. */
#define DMA_RD_EEI_EEI5(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI5_MASK) >> DMA_EEI_EEI5_SHIFT)
#define DMA_BRD_EEI_EEI5(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT))

/*! @brief Set the EEI5 field to a new value. */
#define DMA_WR_EEI_EEI5(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI5_MASK, DMA_EEI_EEI5(value)))
#define DMA_BWR_EEI_EEI5(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI6[6] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI6 field. */
#define DMA_RD_EEI_EEI6(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI6_MASK) >> DMA_EEI_EEI6_SHIFT)
#define DMA_BRD_EEI_EEI6(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT))

/*! @brief Set the EEI6 field to a new value. */
#define DMA_WR_EEI_EEI6(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI6_MASK, DMA_EEI_EEI6(value)))
#define DMA_BWR_EEI_EEI6(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI7[7] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI7 field. */
#define DMA_RD_EEI_EEI7(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI7_MASK) >> DMA_EEI_EEI7_SHIFT)
#define DMA_BRD_EEI_EEI7(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT))

/*! @brief Set the EEI7 field to a new value. */
#define DMA_WR_EEI_EEI7(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI7_MASK, DMA_EEI_EEI7(value)))
#define DMA_BWR_EEI_EEI7(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI8[8] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI8 field. */
#define DMA_RD_EEI_EEI8(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI8_MASK) >> DMA_EEI_EEI8_SHIFT)
#define DMA_BRD_EEI_EEI8(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI8_SHIFT))

/*! @brief Set the EEI8 field to a new value. */
#define DMA_WR_EEI_EEI8(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI8_MASK, DMA_EEI_EEI8(value)))
#define DMA_BWR_EEI_EEI8(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI9[9] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI9 field. */
#define DMA_RD_EEI_EEI9(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI9_MASK) >> DMA_EEI_EEI9_SHIFT)
#define DMA_BRD_EEI_EEI9(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI9_SHIFT))

/*! @brief Set the EEI9 field to a new value. */
#define DMA_WR_EEI_EEI9(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI9_MASK, DMA_EEI_EEI9(value)))
#define DMA_BWR_EEI_EEI9(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI10[10] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI10 field. */
#define DMA_RD_EEI_EEI10(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI10_MASK) >> DMA_EEI_EEI10_SHIFT)
#define DMA_BRD_EEI_EEI10(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI10_SHIFT))

/*! @brief Set the EEI10 field to a new value. */
#define DMA_WR_EEI_EEI10(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI10_MASK, DMA_EEI_EEI10(value)))
#define DMA_BWR_EEI_EEI10(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI11[11] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI11 field. */
#define DMA_RD_EEI_EEI11(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI11_MASK) >> DMA_EEI_EEI11_SHIFT)
#define DMA_BRD_EEI_EEI11(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI11_SHIFT))

/*! @brief Set the EEI11 field to a new value. */
#define DMA_WR_EEI_EEI11(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI11_MASK, DMA_EEI_EEI11(value)))
#define DMA_BWR_EEI_EEI11(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI12[12] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI12 field. */
#define DMA_RD_EEI_EEI12(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI12_MASK) >> DMA_EEI_EEI12_SHIFT)
#define DMA_BRD_EEI_EEI12(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI12_SHIFT))

/*! @brief Set the EEI12 field to a new value. */
#define DMA_WR_EEI_EEI12(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI12_MASK, DMA_EEI_EEI12(value)))
#define DMA_BWR_EEI_EEI12(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI13[13] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI13 field. */
#define DMA_RD_EEI_EEI13(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI13_MASK) >> DMA_EEI_EEI13_SHIFT)
#define DMA_BRD_EEI_EEI13(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI13_SHIFT))

/*! @brief Set the EEI13 field to a new value. */
#define DMA_WR_EEI_EEI13(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI13_MASK, DMA_EEI_EEI13(value)))
#define DMA_BWR_EEI_EEI13(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI14[14] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI14 field. */
#define DMA_RD_EEI_EEI14(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI14_MASK) >> DMA_EEI_EEI14_SHIFT)
#define DMA_BRD_EEI_EEI14(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI14_SHIFT))

/*! @brief Set the EEI14 field to a new value. */
#define DMA_WR_EEI_EEI14(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI14_MASK, DMA_EEI_EEI14(value)))
#define DMA_BWR_EEI_EEI14(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EEI, field EEI15[15] (RW)
 *
 * Values:
 * - 0 - The error signal for corresponding channel does not generate an error
 *     interrupt
 * - 1 - The assertion of the error signal for corresponding channel generates
 *     an error interrupt request
 */
/*@{*/
/*! @brief Read current value of the DMA_EEI_EEI15 field. */
#define DMA_RD_EEI_EEI15(base) ((DMA_EEI_REG(base) & DMA_EEI_EEI15_MASK) >> DMA_EEI_EEI15_SHIFT)
#define DMA_BRD_EEI_EEI15(base) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI15_SHIFT))

/*! @brief Set the EEI15 field to a new value. */
#define DMA_WR_EEI_EEI15(base, value) (DMA_RMW_EEI(base, DMA_EEI_EEI15_MASK, DMA_EEI_EEI15(value)))
#define DMA_BWR_EEI_EEI15(base, value) (BITBAND_ACCESS32(&DMA_EEI_REG(base), DMA_EEI_EEI15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CEEI - Clear Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_CEEI - Clear Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CEEI provides a simple memory-mapped mechanism to clear a given bit in
 * the EEI to disable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be cleared. Setting
 * the CAEE bit provides a global clear function, forcing the EEI contents to be
 * cleared, disabling all DMA request inputs. If the NOP bit is set, the command
 * is ignored. This allows you to write multiple-byte registers as a 32-bit word.
 * Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CEEI register
 */
/*@{*/
#define DMA_RD_CEEI(base)        (DMA_CEEI_REG(base))
#define DMA_WR_CEEI(base, value) (DMA_CEEI_REG(base) = (value))
#define DMA_RMW_CEEI(base, mask, value) (DMA_WR_CEEI(base, (DMA_RD_CEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CEEI bitfields
 */

/*!
 * @name Register DMA_CEEI, field CEEI[3:0] (WORZ)
 *
 * Clears the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the CEEI field to a new value. */
#define DMA_WR_CEEI_CEEI(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CEEI_MASK, DMA_CEEI_CEEI(value)))
#define DMA_BWR_CEEI_CEEI(base, value) (DMA_WR_CEEI_CEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field CAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the EEI bit specified in the CEEI field
 * - 1 - Clear all bits in EEI
 */
/*@{*/
/*! @brief Set the CAEE field to a new value. */
#define DMA_WR_CEEI_CAEE(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_CAEE_MASK, DMA_CEEI_CAEE(value)))
#define DMA_BWR_CEEI_CAEE(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_CAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CEEI_NOP(base, value) (DMA_RMW_CEEI(base, DMA_CEEI_NOP_MASK, DMA_CEEI_NOP(value)))
#define DMA_BWR_CEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_CEEI_REG(base), DMA_CEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SEEI - Set Enable Error Interrupt Register
 ******************************************************************************/

/*!
 * @brief DMA_SEEI - Set Enable Error Interrupt Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SEEI provides a simple memory-mapped mechanism to set a given bit in the
 * EEI to enable the error interrupt for a given channel. The data value on a
 * register write causes the corresponding bit in the EEI to be set. Setting the
 * SAEE bit provides a global set function, forcing the entire EEI contents to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SEEI register
 */
/*@{*/
#define DMA_RD_SEEI(base)        (DMA_SEEI_REG(base))
#define DMA_WR_SEEI(base, value) (DMA_SEEI_REG(base) = (value))
#define DMA_RMW_SEEI(base, mask, value) (DMA_WR_SEEI(base, (DMA_RD_SEEI(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SEEI bitfields
 */

/*!
 * @name Register DMA_SEEI, field SEEI[3:0] (WORZ)
 *
 * Sets the corresponding bit in EEI
 */
/*@{*/
/*! @brief Set the SEEI field to a new value. */
#define DMA_WR_SEEI_SEEI(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SEEI_MASK, DMA_SEEI_SEEI(value)))
#define DMA_BWR_SEEI_SEEI(base, value) (DMA_WR_SEEI_SEEI(base, value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field SAEE[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the EEI bit specified in the SEEI field.
 * - 1 - Sets all bits in EEI
 */
/*@{*/
/*! @brief Set the SAEE field to a new value. */
#define DMA_WR_SEEI_SAEE(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_SAEE_MASK, DMA_SEEI_SAEE(value)))
#define DMA_BWR_SEEI_SAEE(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_SAEE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SEEI, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SEEI_NOP(base, value) (DMA_RMW_SEEI(base, DMA_SEEI_NOP_MASK, DMA_SEEI_NOP(value)))
#define DMA_BWR_SEEI_NOP(base, value) (BITBAND_ACCESS8(&DMA_SEEI_REG(base), DMA_SEEI_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERQ - Clear Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CERQ - Clear Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERQ provides a simple memory-mapped mechanism to clear a given bit in
 * the ERQ to disable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be cleared. Setting the
 * CAER bit provides a global clear function, forcing the entire contents of the
 * ERQ to be cleared, disabling all DMA request inputs. If NOP is set, the
 * command is ignored. This allows you to write multiple-byte registers as a 32-bit
 * word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERQ register
 */
/*@{*/
#define DMA_RD_CERQ(base)        (DMA_CERQ_REG(base))
#define DMA_WR_CERQ(base, value) (DMA_CERQ_REG(base) = (value))
#define DMA_RMW_CERQ(base, mask, value) (DMA_WR_CERQ(base, (DMA_RD_CERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERQ bitfields
 */

/*!
 * @name Register DMA_CERQ, field CERQ[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the CERQ field to a new value. */
#define DMA_WR_CERQ_CERQ(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CERQ_MASK, DMA_CERQ_CERQ(value)))
#define DMA_BWR_CERQ_CERQ(base, value) (DMA_WR_CERQ_CERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field CAER[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERQ bit specified in the CERQ field
 * - 1 - Clear all bits in ERQ
 */
/*@{*/
/*! @brief Set the CAER field to a new value. */
#define DMA_WR_CERQ_CAER(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_CAER_MASK, DMA_CERQ_CAER(value)))
#define DMA_BWR_CERQ_CAER(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_CAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERQ_NOP(base, value) (DMA_RMW_CERQ(base, DMA_CERQ_NOP_MASK, DMA_CERQ_NOP(value)))
#define DMA_BWR_CERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERQ_REG(base), DMA_CERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SERQ - Set Enable Request Register
 ******************************************************************************/

/*!
 * @brief DMA_SERQ - Set Enable Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SERQ provides a simple memory-mapped mechanism to set a given bit in the
 * ERQ to enable the DMA request for a given channel. The data value on a
 * register write causes the corresponding bit in the ERQ to be set. Setting the SAER
 * bit provides a global set function, forcing the entire contents of ERQ to be
 * set. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SERQ register
 */
/*@{*/
#define DMA_RD_SERQ(base)        (DMA_SERQ_REG(base))
#define DMA_WR_SERQ(base, value) (DMA_SERQ_REG(base) = (value))
#define DMA_RMW_SERQ(base, mask, value) (DMA_WR_SERQ(base, (DMA_RD_SERQ(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SERQ bitfields
 */

/*!
 * @name Register DMA_SERQ, field SERQ[3:0] (WORZ)
 *
 * Sets the corresponding bit in ERQ.
 */
/*@{*/
/*! @brief Set the SERQ field to a new value. */
#define DMA_WR_SERQ_SERQ(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SERQ_MASK, DMA_SERQ_SERQ(value)))
#define DMA_BWR_SERQ_SERQ(base, value) (DMA_WR_SERQ_SERQ(base, value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field SAER[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the ERQ bit specified in the SERQ field
 * - 1 - Set all bits in ERQ
 */
/*@{*/
/*! @brief Set the SAER field to a new value. */
#define DMA_WR_SERQ_SAER(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_SAER_MASK, DMA_SERQ_SAER(value)))
#define DMA_BWR_SERQ_SAER(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_SAER_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SERQ, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SERQ_NOP(base, value) (DMA_RMW_SERQ(base, DMA_SERQ_NOP_MASK, DMA_SERQ_NOP(value)))
#define DMA_BWR_SERQ_NOP(base, value) (BITBAND_ACCESS8(&DMA_SERQ_REG(base), DMA_SERQ_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CDNE - Clear DONE Status Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_CDNE - Clear DONE Status Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CDNE provides a simple memory-mapped mechanism to clear the DONE bit in
 * the TCD of the given channel. The data value on a register write causes the
 * DONE bit in the corresponding transfer control descriptor to be cleared. Setting
 * the CADN bit provides a global clear function, forcing all DONE bits to be
 * cleared. If the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all
 * zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CDNE register
 */
/*@{*/
#define DMA_RD_CDNE(base)        (DMA_CDNE_REG(base))
#define DMA_WR_CDNE(base, value) (DMA_CDNE_REG(base) = (value))
#define DMA_RMW_CDNE(base, mask, value) (DMA_WR_CDNE(base, (DMA_RD_CDNE(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CDNE bitfields
 */

/*!
 * @name Register DMA_CDNE, field CDNE[3:0] (WORZ)
 *
 * Clears the corresponding bit in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CDNE field to a new value. */
#define DMA_WR_CDNE_CDNE(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CDNE_MASK, DMA_CDNE_CDNE(value)))
#define DMA_BWR_CDNE_CDNE(base, value) (DMA_WR_CDNE_CDNE(base, value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field CADN[6] (WORZ)
 *
 * Values:
 * - 0 - Clears only the TCDn_CSR[DONE] bit specified in the CDNE field
 * - 1 - Clears all bits in TCDn_CSR[DONE]
 */
/*@{*/
/*! @brief Set the CADN field to a new value. */
#define DMA_WR_CDNE_CADN(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_CADN_MASK, DMA_CDNE_CADN(value)))
#define DMA_BWR_CDNE_CADN(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_CADN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CDNE, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CDNE_NOP(base, value) (DMA_RMW_CDNE(base, DMA_CDNE_NOP_MASK, DMA_CDNE_NOP(value)))
#define DMA_BWR_CDNE_NOP(base, value) (BITBAND_ACCESS8(&DMA_CDNE_REG(base), DMA_CDNE_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SSRT - Set START Bit Register
 ******************************************************************************/

/*!
 * @brief DMA_SSRT - Set START Bit Register (WO)
 *
 * Reset value: 0x00U
 *
 * The SSRT provides a simple memory-mapped mechanism to set the START bit in
 * the TCD of the given channel. The data value on a register write causes the
 * START bit in the corresponding transfer control descriptor to be set. Setting the
 * SAST bit provides a global set function, forcing all START bits to be set. If
 * the NOP bit is set, the command is ignored. This allows you to write
 * multiple-byte registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_SSRT register
 */
/*@{*/
#define DMA_RD_SSRT(base)        (DMA_SSRT_REG(base))
#define DMA_WR_SSRT(base, value) (DMA_SSRT_REG(base) = (value))
#define DMA_RMW_SSRT(base, mask, value) (DMA_WR_SSRT(base, (DMA_RD_SSRT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_SSRT bitfields
 */

/*!
 * @name Register DMA_SSRT, field SSRT[3:0] (WORZ)
 *
 * Sets the corresponding bit in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SSRT field to a new value. */
#define DMA_WR_SSRT_SSRT(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SSRT_MASK, DMA_SSRT_SSRT(value)))
#define DMA_BWR_SSRT_SSRT(base, value) (DMA_WR_SSRT_SSRT(base, value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field SAST[6] (WORZ)
 *
 * Values:
 * - 0 - Set only the TCDn_CSR[START] bit specified in the SSRT field
 * - 1 - Set all bits in TCDn_CSR[START]
 */
/*@{*/
/*! @brief Set the SAST field to a new value. */
#define DMA_WR_SSRT_SAST(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_SAST_MASK, DMA_SSRT_SAST(value)))
#define DMA_BWR_SSRT_SAST(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_SAST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_SSRT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_SSRT_NOP(base, value) (DMA_RMW_SSRT(base, DMA_SSRT_NOP_MASK, DMA_SSRT_NOP(value)))
#define DMA_BWR_SSRT_NOP(base, value) (BITBAND_ACCESS8(&DMA_SSRT_REG(base), DMA_SSRT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CERR - Clear Error Register
 ******************************************************************************/

/*!
 * @brief DMA_CERR - Clear Error Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CERR provides a simple memory-mapped mechanism to clear a given bit in
 * the ERR to disable the error condition flag for a given channel. The given value
 * on a register write causes the corresponding bit in the ERR to be cleared.
 * Setting the CAEI bit provides a global clear function, forcing the ERR contents
 * to be cleared, clearing all channel error indicators. If the NOP bit is set,
 * the command is ignored. This allows you to write multiple-byte registers as a
 * 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CERR register
 */
/*@{*/
#define DMA_RD_CERR(base)        (DMA_CERR_REG(base))
#define DMA_WR_CERR(base, value) (DMA_CERR_REG(base) = (value))
#define DMA_RMW_CERR(base, mask, value) (DMA_WR_CERR(base, (DMA_RD_CERR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CERR bitfields
 */

/*!
 * @name Register DMA_CERR, field CERR[3:0] (WORZ)
 *
 * Clears the corresponding bit in ERR
 */
/*@{*/
/*! @brief Set the CERR field to a new value. */
#define DMA_WR_CERR_CERR(base, value) (DMA_RMW_CERR(base, DMA_CERR_CERR_MASK, DMA_CERR_CERR(value)))
#define DMA_BWR_CERR_CERR(base, value) (DMA_WR_CERR_CERR(base, value))
/*@}*/

/*!
 * @name Register DMA_CERR, field CAEI[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the ERR bit specified in the CERR field
 * - 1 - Clear all bits in ERR
 */
/*@{*/
/*! @brief Set the CAEI field to a new value. */
#define DMA_WR_CERR_CAEI(base, value) (DMA_RMW_CERR(base, DMA_CERR_CAEI_MASK, DMA_CERR_CAEI(value)))
#define DMA_BWR_CERR_CAEI(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_CAEI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CERR, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CERR_NOP(base, value) (DMA_RMW_CERR(base, DMA_CERR_NOP_MASK, DMA_CERR_NOP(value)))
#define DMA_BWR_CERR_NOP(base, value) (BITBAND_ACCESS8(&DMA_CERR_REG(base), DMA_CERR_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CINT - Clear Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_CINT - Clear Interrupt Request Register (WO)
 *
 * Reset value: 0x00U
 *
 * The CINT provides a simple, memory-mapped mechanism to clear a given bit in
 * the INT to disable the interrupt request for a given channel. The given value
 * on a register write causes the corresponding bit in the INT to be cleared.
 * Setting the CAIR bit provides a global clear function, forcing the entire contents
 * of the INT to be cleared, disabling all DMA interrupt requests. If the NOP
 * bit is set, the command is ignored. This allows you to write multiple-byte
 * registers as a 32-bit word. Reads of this register return all zeroes.
 */
/*!
 * @name Constants and macros for entire DMA_CINT register
 */
/*@{*/
#define DMA_RD_CINT(base)        (DMA_CINT_REG(base))
#define DMA_WR_CINT(base, value) (DMA_CINT_REG(base) = (value))
#define DMA_RMW_CINT(base, mask, value) (DMA_WR_CINT(base, (DMA_RD_CINT(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CINT bitfields
 */

/*!
 * @name Register DMA_CINT, field CINT[3:0] (WORZ)
 *
 * Clears the corresponding bit in INT
 */
/*@{*/
/*! @brief Set the CINT field to a new value. */
#define DMA_WR_CINT_CINT(base, value) (DMA_RMW_CINT(base, DMA_CINT_CINT_MASK, DMA_CINT_CINT(value)))
#define DMA_BWR_CINT_CINT(base, value) (DMA_WR_CINT_CINT(base, value))
/*@}*/

/*!
 * @name Register DMA_CINT, field CAIR[6] (WORZ)
 *
 * Values:
 * - 0 - Clear only the INT bit specified in the CINT field
 * - 1 - Clear all bits in INT
 */
/*@{*/
/*! @brief Set the CAIR field to a new value. */
#define DMA_WR_CINT_CAIR(base, value) (DMA_RMW_CINT(base, DMA_CINT_CAIR_MASK, DMA_CINT_CAIR(value)))
#define DMA_BWR_CINT_CAIR(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_CAIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CINT, field NOP[7] (WORZ)
 *
 * Values:
 * - 0 - Normal operation
 * - 1 - No operation, ignore the other bits in this register
 */
/*@{*/
/*! @brief Set the NOP field to a new value. */
#define DMA_WR_CINT_NOP(base, value) (DMA_RMW_CINT(base, DMA_CINT_NOP_MASK, DMA_CINT_NOP(value)))
#define DMA_BWR_CINT_NOP(base, value) (BITBAND_ACCESS8(&DMA_CINT_REG(base), DMA_CINT_NOP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_INT - Interrupt Request Register
 ******************************************************************************/

/*!
 * @brief DMA_INT - Interrupt Request Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The INT register provides a bit map for the 16 channels signaling the
 * presence of an interrupt request for each channel. Depending on the appropriate bit
 * setting in the transfer-control descriptors, the eDMA engine generates an
 * interrupt on data transfer completion. The outputs of this register are directly
 * routed to the interrupt controller. During the interrupt-service routine
 * associated with any given channel, it is the software's responsibility to clear the
 * appropriate bit, negating the interrupt request. Typically, a write to the CINT
 * register in the interrupt service routine is used for this purpose. The state
 * of any given channel's interrupt request is directly affected by writes to
 * this register; it is also affected by writes to the CINT register. On writes to
 * INT, a 1 in any bit position clears the corresponding channel's interrupt
 * request. A zero in any bit position has no affect on the corresponding channel's
 * current interrupt status. The CINT register is provided so the interrupt
 * request for a single channel can easily be cleared without the need to perform a
 * read-modify-write sequence to the INT register.
 */
/*!
 * @name Constants and macros for entire DMA_INT register
 */
/*@{*/
#define DMA_RD_INT(base)         (DMA_INT_REG(base))
#define DMA_WR_INT(base, value)  (DMA_INT_REG(base) = (value))
#define DMA_RMW_INT(base, mask, value) (DMA_WR_INT(base, (DMA_RD_INT(base) & ~(mask)) | (value)))
#define DMA_SET_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) |  (value)))
#define DMA_CLR_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) & ~(value)))
#define DMA_TOG_INT(base, value) (DMA_WR_INT(base, DMA_RD_INT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_INT bitfields
 */

/*!
 * @name Register DMA_INT, field INT0[0] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT0 field. */
#define DMA_RD_INT_INT0(base) ((DMA_INT_REG(base) & DMA_INT_INT0_MASK) >> DMA_INT_INT0_SHIFT)
#define DMA_BRD_INT_INT0(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT))

/*! @brief Set the INT0 field to a new value. */
#define DMA_WR_INT_INT0(base, value) (DMA_RMW_INT(base, (DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT0(value)))
#define DMA_BWR_INT_INT0(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT1[1] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT1 field. */
#define DMA_RD_INT_INT1(base) ((DMA_INT_REG(base) & DMA_INT_INT1_MASK) >> DMA_INT_INT1_SHIFT)
#define DMA_BRD_INT_INT1(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT))

/*! @brief Set the INT1 field to a new value. */
#define DMA_WR_INT_INT1(base, value) (DMA_RMW_INT(base, (DMA_INT_INT1_MASK | DMA_INT_INT0_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT1(value)))
#define DMA_BWR_INT_INT1(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT2[2] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT2 field. */
#define DMA_RD_INT_INT2(base) ((DMA_INT_REG(base) & DMA_INT_INT2_MASK) >> DMA_INT_INT2_SHIFT)
#define DMA_BRD_INT_INT2(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT))

/*! @brief Set the INT2 field to a new value. */
#define DMA_WR_INT_INT2(base, value) (DMA_RMW_INT(base, (DMA_INT_INT2_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT2(value)))
#define DMA_BWR_INT_INT2(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT3[3] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT3 field. */
#define DMA_RD_INT_INT3(base) ((DMA_INT_REG(base) & DMA_INT_INT3_MASK) >> DMA_INT_INT3_SHIFT)
#define DMA_BRD_INT_INT3(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT))

/*! @brief Set the INT3 field to a new value. */
#define DMA_WR_INT_INT3(base, value) (DMA_RMW_INT(base, (DMA_INT_INT3_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT3(value)))
#define DMA_BWR_INT_INT3(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT4[4] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT4 field. */
#define DMA_RD_INT_INT4(base) ((DMA_INT_REG(base) & DMA_INT_INT4_MASK) >> DMA_INT_INT4_SHIFT)
#define DMA_BRD_INT_INT4(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT))

/*! @brief Set the INT4 field to a new value. */
#define DMA_WR_INT_INT4(base, value) (DMA_RMW_INT(base, (DMA_INT_INT4_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT4(value)))
#define DMA_BWR_INT_INT4(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT5[5] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT5 field. */
#define DMA_RD_INT_INT5(base) ((DMA_INT_REG(base) & DMA_INT_INT5_MASK) >> DMA_INT_INT5_SHIFT)
#define DMA_BRD_INT_INT5(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT))

/*! @brief Set the INT5 field to a new value. */
#define DMA_WR_INT_INT5(base, value) (DMA_RMW_INT(base, (DMA_INT_INT5_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT5(value)))
#define DMA_BWR_INT_INT5(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT6[6] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT6 field. */
#define DMA_RD_INT_INT6(base) ((DMA_INT_REG(base) & DMA_INT_INT6_MASK) >> DMA_INT_INT6_SHIFT)
#define DMA_BRD_INT_INT6(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT))

/*! @brief Set the INT6 field to a new value. */
#define DMA_WR_INT_INT6(base, value) (DMA_RMW_INT(base, (DMA_INT_INT6_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT6(value)))
#define DMA_BWR_INT_INT6(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT7[7] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT7 field. */
#define DMA_RD_INT_INT7(base) ((DMA_INT_REG(base) & DMA_INT_INT7_MASK) >> DMA_INT_INT7_SHIFT)
#define DMA_BRD_INT_INT7(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT))

/*! @brief Set the INT7 field to a new value. */
#define DMA_WR_INT_INT7(base, value) (DMA_RMW_INT(base, (DMA_INT_INT7_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT7(value)))
#define DMA_BWR_INT_INT7(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT8[8] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT8 field. */
#define DMA_RD_INT_INT8(base) ((DMA_INT_REG(base) & DMA_INT_INT8_MASK) >> DMA_INT_INT8_SHIFT)
#define DMA_BRD_INT_INT8(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT8_SHIFT))

/*! @brief Set the INT8 field to a new value. */
#define DMA_WR_INT_INT8(base, value) (DMA_RMW_INT(base, (DMA_INT_INT8_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT8(value)))
#define DMA_BWR_INT_INT8(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT9[9] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT9 field. */
#define DMA_RD_INT_INT9(base) ((DMA_INT_REG(base) & DMA_INT_INT9_MASK) >> DMA_INT_INT9_SHIFT)
#define DMA_BRD_INT_INT9(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT9_SHIFT))

/*! @brief Set the INT9 field to a new value. */
#define DMA_WR_INT_INT9(base, value) (DMA_RMW_INT(base, (DMA_INT_INT9_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT9(value)))
#define DMA_BWR_INT_INT9(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT10[10] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT10 field. */
#define DMA_RD_INT_INT10(base) ((DMA_INT_REG(base) & DMA_INT_INT10_MASK) >> DMA_INT_INT10_SHIFT)
#define DMA_BRD_INT_INT10(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT10_SHIFT))

/*! @brief Set the INT10 field to a new value. */
#define DMA_WR_INT_INT10(base, value) (DMA_RMW_INT(base, (DMA_INT_INT10_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT10(value)))
#define DMA_BWR_INT_INT10(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT11[11] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT11 field. */
#define DMA_RD_INT_INT11(base) ((DMA_INT_REG(base) & DMA_INT_INT11_MASK) >> DMA_INT_INT11_SHIFT)
#define DMA_BRD_INT_INT11(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT11_SHIFT))

/*! @brief Set the INT11 field to a new value. */
#define DMA_WR_INT_INT11(base, value) (DMA_RMW_INT(base, (DMA_INT_INT11_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT11(value)))
#define DMA_BWR_INT_INT11(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT12[12] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT12 field. */
#define DMA_RD_INT_INT12(base) ((DMA_INT_REG(base) & DMA_INT_INT12_MASK) >> DMA_INT_INT12_SHIFT)
#define DMA_BRD_INT_INT12(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT12_SHIFT))

/*! @brief Set the INT12 field to a new value. */
#define DMA_WR_INT_INT12(base, value) (DMA_RMW_INT(base, (DMA_INT_INT12_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT12(value)))
#define DMA_BWR_INT_INT12(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT13[13] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT13 field. */
#define DMA_RD_INT_INT13(base) ((DMA_INT_REG(base) & DMA_INT_INT13_MASK) >> DMA_INT_INT13_SHIFT)
#define DMA_BRD_INT_INT13(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT13_SHIFT))

/*! @brief Set the INT13 field to a new value. */
#define DMA_WR_INT_INT13(base, value) (DMA_RMW_INT(base, (DMA_INT_INT13_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT14_MASK | DMA_INT_INT15_MASK), DMA_INT_INT13(value)))
#define DMA_BWR_INT_INT13(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT14[14] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT14 field. */
#define DMA_RD_INT_INT14(base) ((DMA_INT_REG(base) & DMA_INT_INT14_MASK) >> DMA_INT_INT14_SHIFT)
#define DMA_BRD_INT_INT14(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT14_SHIFT))

/*! @brief Set the INT14 field to a new value. */
#define DMA_WR_INT_INT14(base, value) (DMA_RMW_INT(base, (DMA_INT_INT14_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT15_MASK), DMA_INT_INT14(value)))
#define DMA_BWR_INT_INT14(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_INT, field INT15[15] (W1C)
 *
 * Values:
 * - 0 - The interrupt request for corresponding channel is cleared
 * - 1 - The interrupt request for corresponding channel is active
 */
/*@{*/
/*! @brief Read current value of the DMA_INT_INT15 field. */
#define DMA_RD_INT_INT15(base) ((DMA_INT_REG(base) & DMA_INT_INT15_MASK) >> DMA_INT_INT15_SHIFT)
#define DMA_BRD_INT_INT15(base) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT15_SHIFT))

/*! @brief Set the INT15 field to a new value. */
#define DMA_WR_INT_INT15(base, value) (DMA_RMW_INT(base, (DMA_INT_INT15_MASK | DMA_INT_INT0_MASK | DMA_INT_INT1_MASK | DMA_INT_INT2_MASK | DMA_INT_INT3_MASK | DMA_INT_INT4_MASK | DMA_INT_INT5_MASK | DMA_INT_INT6_MASK | DMA_INT_INT7_MASK | DMA_INT_INT8_MASK | DMA_INT_INT9_MASK | DMA_INT_INT10_MASK | DMA_INT_INT11_MASK | DMA_INT_INT12_MASK | DMA_INT_INT13_MASK | DMA_INT_INT14_MASK), DMA_INT_INT15(value)))
#define DMA_BWR_INT_INT15(base, value) (BITBAND_ACCESS32(&DMA_INT_REG(base), DMA_INT_INT15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_ERR - Error Register
 ******************************************************************************/

/*!
 * @brief DMA_ERR - Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The ERR provides a bit map for the 16 channels, signaling the presence of an
 * error for each channel. The eDMA engine signals the occurrence of an error
 * condition by setting the appropriate bit in this register. The outputs of this
 * register are enabled by the contents of the EEI, and then routed to the
 * interrupt controller. During the execution of the interrupt-service routine associated
 * with any DMA errors, it is software's responsibility to clear the appropriate
 * bit, negating the error-interrupt request. Typically, a write to the CERR in
 * the interrupt-service routine is used for this purpose. The normal DMA channel
 * completion indicators (setting the transfer control descriptor DONE flag and
 * the possible assertion of an interrupt request) are not affected when an error
 * is detected. The contents of this register can also be polled because a
 * non-zero value indicates the presence of a channel error regardless of the state of
 * the EEI. The state of any given channel's error indicators is affected by
 * writes to this register; it is also affected by writes to the CERR. On writes to
 * the ERR, a one in any bit position clears the corresponding channel's error
 * status. A zero in any bit position has no affect on the corresponding channel's
 * current error status. The CERR is provided so the error indicator for a single
 * channel can easily be cleared.
 */
/*!
 * @name Constants and macros for entire DMA_ERR register
 */
/*@{*/
#define DMA_RD_ERR(base)         (DMA_ERR_REG(base))
#define DMA_WR_ERR(base, value)  (DMA_ERR_REG(base) = (value))
#define DMA_RMW_ERR(base, mask, value) (DMA_WR_ERR(base, (DMA_RD_ERR(base) & ~(mask)) | (value)))
#define DMA_SET_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) |  (value)))
#define DMA_CLR_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) & ~(value)))
#define DMA_TOG_ERR(base, value) (DMA_WR_ERR(base, DMA_RD_ERR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ERR bitfields
 */

/*!
 * @name Register DMA_ERR, field ERR0[0] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR0 field. */
#define DMA_RD_ERR_ERR0(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR0_MASK) >> DMA_ERR_ERR0_SHIFT)
#define DMA_BRD_ERR_ERR0(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT))

/*! @brief Set the ERR0 field to a new value. */
#define DMA_WR_ERR_ERR0(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR0(value)))
#define DMA_BWR_ERR_ERR0(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR1[1] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR1 field. */
#define DMA_RD_ERR_ERR1(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR1_MASK) >> DMA_ERR_ERR1_SHIFT)
#define DMA_BRD_ERR_ERR1(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT))

/*! @brief Set the ERR1 field to a new value. */
#define DMA_WR_ERR_ERR1(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR1_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR1(value)))
#define DMA_BWR_ERR_ERR1(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR2[2] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR2 field. */
#define DMA_RD_ERR_ERR2(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR2_MASK) >> DMA_ERR_ERR2_SHIFT)
#define DMA_BRD_ERR_ERR2(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT))

/*! @brief Set the ERR2 field to a new value. */
#define DMA_WR_ERR_ERR2(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR2_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR2(value)))
#define DMA_BWR_ERR_ERR2(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR3[3] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR3 field. */
#define DMA_RD_ERR_ERR3(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR3_MASK) >> DMA_ERR_ERR3_SHIFT)
#define DMA_BRD_ERR_ERR3(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT))

/*! @brief Set the ERR3 field to a new value. */
#define DMA_WR_ERR_ERR3(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR3_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR3(value)))
#define DMA_BWR_ERR_ERR3(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR4[4] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR4 field. */
#define DMA_RD_ERR_ERR4(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR4_MASK) >> DMA_ERR_ERR4_SHIFT)
#define DMA_BRD_ERR_ERR4(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT))

/*! @brief Set the ERR4 field to a new value. */
#define DMA_WR_ERR_ERR4(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR4_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR4(value)))
#define DMA_BWR_ERR_ERR4(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR5[5] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR5 field. */
#define DMA_RD_ERR_ERR5(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR5_MASK) >> DMA_ERR_ERR5_SHIFT)
#define DMA_BRD_ERR_ERR5(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT))

/*! @brief Set the ERR5 field to a new value. */
#define DMA_WR_ERR_ERR5(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR5_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR5(value)))
#define DMA_BWR_ERR_ERR5(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR6[6] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR6 field. */
#define DMA_RD_ERR_ERR6(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR6_MASK) >> DMA_ERR_ERR6_SHIFT)
#define DMA_BRD_ERR_ERR6(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT))

/*! @brief Set the ERR6 field to a new value. */
#define DMA_WR_ERR_ERR6(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR6_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR6(value)))
#define DMA_BWR_ERR_ERR6(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR7[7] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR7 field. */
#define DMA_RD_ERR_ERR7(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR7_MASK) >> DMA_ERR_ERR7_SHIFT)
#define DMA_BRD_ERR_ERR7(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT))

/*! @brief Set the ERR7 field to a new value. */
#define DMA_WR_ERR_ERR7(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR7_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR7(value)))
#define DMA_BWR_ERR_ERR7(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR8[8] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR8 field. */
#define DMA_RD_ERR_ERR8(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR8_MASK) >> DMA_ERR_ERR8_SHIFT)
#define DMA_BRD_ERR_ERR8(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR8_SHIFT))

/*! @brief Set the ERR8 field to a new value. */
#define DMA_WR_ERR_ERR8(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR8_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR8(value)))
#define DMA_BWR_ERR_ERR8(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR9[9] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR9 field. */
#define DMA_RD_ERR_ERR9(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR9_MASK) >> DMA_ERR_ERR9_SHIFT)
#define DMA_BRD_ERR_ERR9(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR9_SHIFT))

/*! @brief Set the ERR9 field to a new value. */
#define DMA_WR_ERR_ERR9(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR9_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR9(value)))
#define DMA_BWR_ERR_ERR9(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR10[10] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR10 field. */
#define DMA_RD_ERR_ERR10(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR10_MASK) >> DMA_ERR_ERR10_SHIFT)
#define DMA_BRD_ERR_ERR10(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR10_SHIFT))

/*! @brief Set the ERR10 field to a new value. */
#define DMA_WR_ERR_ERR10(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR10_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR10(value)))
#define DMA_BWR_ERR_ERR10(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR11[11] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR11 field. */
#define DMA_RD_ERR_ERR11(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR11_MASK) >> DMA_ERR_ERR11_SHIFT)
#define DMA_BRD_ERR_ERR11(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR11_SHIFT))

/*! @brief Set the ERR11 field to a new value. */
#define DMA_WR_ERR_ERR11(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR11_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR11(value)))
#define DMA_BWR_ERR_ERR11(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR12[12] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR12 field. */
#define DMA_RD_ERR_ERR12(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR12_MASK) >> DMA_ERR_ERR12_SHIFT)
#define DMA_BRD_ERR_ERR12(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR12_SHIFT))

/*! @brief Set the ERR12 field to a new value. */
#define DMA_WR_ERR_ERR12(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR12_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR12(value)))
#define DMA_BWR_ERR_ERR12(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR13[13] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR13 field. */
#define DMA_RD_ERR_ERR13(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR13_MASK) >> DMA_ERR_ERR13_SHIFT)
#define DMA_BRD_ERR_ERR13(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR13_SHIFT))

/*! @brief Set the ERR13 field to a new value. */
#define DMA_WR_ERR_ERR13(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR13_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR14_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR13(value)))
#define DMA_BWR_ERR_ERR13(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR14[14] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR14 field. */
#define DMA_RD_ERR_ERR14(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR14_MASK) >> DMA_ERR_ERR14_SHIFT)
#define DMA_BRD_ERR_ERR14(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR14_SHIFT))

/*! @brief Set the ERR14 field to a new value. */
#define DMA_WR_ERR_ERR14(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR14_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR15_MASK), DMA_ERR_ERR14(value)))
#define DMA_BWR_ERR_ERR14(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_ERR, field ERR15[15] (W1C)
 *
 * Values:
 * - 0 - An error in this channel has not occurred
 * - 1 - An error in this channel has occurred
 */
/*@{*/
/*! @brief Read current value of the DMA_ERR_ERR15 field. */
#define DMA_RD_ERR_ERR15(base) ((DMA_ERR_REG(base) & DMA_ERR_ERR15_MASK) >> DMA_ERR_ERR15_SHIFT)
#define DMA_BRD_ERR_ERR15(base) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR15_SHIFT))

/*! @brief Set the ERR15 field to a new value. */
#define DMA_WR_ERR_ERR15(base, value) (DMA_RMW_ERR(base, (DMA_ERR_ERR15_MASK | DMA_ERR_ERR0_MASK | DMA_ERR_ERR1_MASK | DMA_ERR_ERR2_MASK | DMA_ERR_ERR3_MASK | DMA_ERR_ERR4_MASK | DMA_ERR_ERR5_MASK | DMA_ERR_ERR6_MASK | DMA_ERR_ERR7_MASK | DMA_ERR_ERR8_MASK | DMA_ERR_ERR9_MASK | DMA_ERR_ERR10_MASK | DMA_ERR_ERR11_MASK | DMA_ERR_ERR12_MASK | DMA_ERR_ERR13_MASK | DMA_ERR_ERR14_MASK), DMA_ERR_ERR15(value)))
#define DMA_BWR_ERR_ERR15(base, value) (BITBAND_ACCESS32(&DMA_ERR_REG(base), DMA_ERR_ERR15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_HRS - Hardware Request Status Register
 ******************************************************************************/

/*!
 * @brief DMA_HRS - Hardware Request Status Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The HRS register provides a bit map for the DMA channels, signaling the
 * presence of a hardware request for each channel. The hardware request status bits
 * reflect the current state of the register and qualified (via the ERQ fields)
 * DMA request signals as seen by the DMA's arbitration logic. This view into the
 * hardware request signals may be used for debug purposes. These bits reflect the
 * state of the request as seen by the arbitration logic. Therefore, this status
 * is affected by the ERQ bits.
 */
/*!
 * @name Constants and macros for entire DMA_HRS register
 */
/*@{*/
#define DMA_RD_HRS(base)         (DMA_HRS_REG(base))
/*@}*/

/*
 * Constants & macros for individual DMA_HRS bitfields
 */

/*!
 * @name Register DMA_HRS, field HRS0[0] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 0 is not present
 * - 1 - A hardware service request for channel 0 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS0 field. */
#define DMA_RD_HRS_HRS0(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS0_MASK) >> DMA_HRS_HRS0_SHIFT)
#define DMA_BRD_HRS_HRS0(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS0_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS1[1] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 1 is not present
 * - 1 - A hardware service request for channel 1 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS1 field. */
#define DMA_RD_HRS_HRS1(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS1_MASK) >> DMA_HRS_HRS1_SHIFT)
#define DMA_BRD_HRS_HRS1(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS1_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS2[2] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 2 is not present
 * - 1 - A hardware service request for channel 2 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS2 field. */
#define DMA_RD_HRS_HRS2(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS2_MASK) >> DMA_HRS_HRS2_SHIFT)
#define DMA_BRD_HRS_HRS2(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS2_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS3[3] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 3 is not present
 * - 1 - A hardware service request for channel 3 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS3 field. */
#define DMA_RD_HRS_HRS3(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS3_MASK) >> DMA_HRS_HRS3_SHIFT)
#define DMA_BRD_HRS_HRS3(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS3_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS4[4] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 4 is not present
 * - 1 - A hardware service request for channel 4 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS4 field. */
#define DMA_RD_HRS_HRS4(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS4_MASK) >> DMA_HRS_HRS4_SHIFT)
#define DMA_BRD_HRS_HRS4(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS4_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS5[5] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 5 is not present
 * - 1 - A hardware service request for channel 5 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS5 field. */
#define DMA_RD_HRS_HRS5(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS5_MASK) >> DMA_HRS_HRS5_SHIFT)
#define DMA_BRD_HRS_HRS5(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS5_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS6[6] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 6 is not present
 * - 1 - A hardware service request for channel 6 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS6 field. */
#define DMA_RD_HRS_HRS6(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS6_MASK) >> DMA_HRS_HRS6_SHIFT)
#define DMA_BRD_HRS_HRS6(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS6_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS7[7] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 7 is not present
 * - 1 - A hardware service request for channel 7 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS7 field. */
#define DMA_RD_HRS_HRS7(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS7_MASK) >> DMA_HRS_HRS7_SHIFT)
#define DMA_BRD_HRS_HRS7(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS7_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS8[8] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 8 is not present
 * - 1 - A hardware service request for channel 8 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS8 field. */
#define DMA_RD_HRS_HRS8(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS8_MASK) >> DMA_HRS_HRS8_SHIFT)
#define DMA_BRD_HRS_HRS8(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS8_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS9[9] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 9 is not present
 * - 1 - A hardware service request for channel 9 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS9 field. */
#define DMA_RD_HRS_HRS9(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS9_MASK) >> DMA_HRS_HRS9_SHIFT)
#define DMA_BRD_HRS_HRS9(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS9_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS10[10] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 10 is not present
 * - 1 - A hardware service request for channel 10 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS10 field. */
#define DMA_RD_HRS_HRS10(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS10_MASK) >> DMA_HRS_HRS10_SHIFT)
#define DMA_BRD_HRS_HRS10(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS10_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS11[11] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 11 is not present
 * - 1 - A hardware service request for channel 11 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS11 field. */
#define DMA_RD_HRS_HRS11(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS11_MASK) >> DMA_HRS_HRS11_SHIFT)
#define DMA_BRD_HRS_HRS11(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS11_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS12[12] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 12 is not present
 * - 1 - A hardware service request for channel 12 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS12 field. */
#define DMA_RD_HRS_HRS12(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS12_MASK) >> DMA_HRS_HRS12_SHIFT)
#define DMA_BRD_HRS_HRS12(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS12_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS13[13] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 13 is not present
 * - 1 - A hardware service request for channel 13 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS13 field. */
#define DMA_RD_HRS_HRS13(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS13_MASK) >> DMA_HRS_HRS13_SHIFT)
#define DMA_BRD_HRS_HRS13(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS13_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS14[14] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 14 is not present
 * - 1 - A hardware service request for channel 14 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS14 field. */
#define DMA_RD_HRS_HRS14(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS14_MASK) >> DMA_HRS_HRS14_SHIFT)
#define DMA_BRD_HRS_HRS14(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS14_SHIFT))
/*@}*/

/*!
 * @name Register DMA_HRS, field HRS15[15] (RO)
 *
 * The HRS bit for its respective channel remains asserted for the period when a
 * Hardware Request is Present on the Channel. After the Request is completed
 * and Channel is free, the HRS bit is automatically cleared by hardware.
 *
 * Values:
 * - 0 - A hardware service request for channel 15 is not present
 * - 1 - A hardware service request for channel 15 is present
 */
/*@{*/
/*! @brief Read current value of the DMA_HRS_HRS15 field. */
#define DMA_RD_HRS_HRS15(base) ((DMA_HRS_REG(base) & DMA_HRS_HRS15_MASK) >> DMA_HRS_HRS15_SHIFT)
#define DMA_BRD_HRS_HRS15(base) (BITBAND_ACCESS32(&DMA_HRS_REG(base), DMA_HRS_HRS15_SHIFT))
/*@}*/

/*******************************************************************************
 * DMA_EARS - Enable Asynchronous Request in Stop Register
 ******************************************************************************/

/*!
 * @brief DMA_EARS - Enable Asynchronous Request in Stop Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_EARS register
 */
/*@{*/
#define DMA_RD_EARS(base)        (DMA_EARS_REG(base))
#define DMA_WR_EARS(base, value) (DMA_EARS_REG(base) = (value))
#define DMA_RMW_EARS(base, mask, value) (DMA_WR_EARS(base, (DMA_RD_EARS(base) & ~(mask)) | (value)))
#define DMA_SET_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) |  (value)))
#define DMA_CLR_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) & ~(value)))
#define DMA_TOG_EARS(base, value) (DMA_WR_EARS(base, DMA_RD_EARS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_EARS bitfields
 */

/*!
 * @name Register DMA_EARS, field EDREQ_0[0] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 0.
 * - 1 - Enable asynchronous DMA request for channel 0.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_0 field. */
#define DMA_RD_EARS_EDREQ_0(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_0_MASK) >> DMA_EARS_EDREQ_0_SHIFT)
#define DMA_BRD_EARS_EDREQ_0(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT))

/*! @brief Set the EDREQ_0 field to a new value. */
#define DMA_WR_EARS_EDREQ_0(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_0_MASK, DMA_EARS_EDREQ_0(value)))
#define DMA_BWR_EARS_EDREQ_0(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_1[1] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 1
 * - 1 - Enable asynchronous DMA request for channel 1.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_1 field. */
#define DMA_RD_EARS_EDREQ_1(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_1_MASK) >> DMA_EARS_EDREQ_1_SHIFT)
#define DMA_BRD_EARS_EDREQ_1(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT))

/*! @brief Set the EDREQ_1 field to a new value. */
#define DMA_WR_EARS_EDREQ_1(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_1_MASK, DMA_EARS_EDREQ_1(value)))
#define DMA_BWR_EARS_EDREQ_1(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_2[2] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 2.
 * - 1 - Enable asynchronous DMA request for channel 2.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_2 field. */
#define DMA_RD_EARS_EDREQ_2(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_2_MASK) >> DMA_EARS_EDREQ_2_SHIFT)
#define DMA_BRD_EARS_EDREQ_2(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT))

/*! @brief Set the EDREQ_2 field to a new value. */
#define DMA_WR_EARS_EDREQ_2(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_2_MASK, DMA_EARS_EDREQ_2(value)))
#define DMA_BWR_EARS_EDREQ_2(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_3[3] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 3.
 * - 1 - Enable asynchronous DMA request for channel 3.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_3 field. */
#define DMA_RD_EARS_EDREQ_3(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_3_MASK) >> DMA_EARS_EDREQ_3_SHIFT)
#define DMA_BRD_EARS_EDREQ_3(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT))

/*! @brief Set the EDREQ_3 field to a new value. */
#define DMA_WR_EARS_EDREQ_3(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_3_MASK, DMA_EARS_EDREQ_3(value)))
#define DMA_BWR_EARS_EDREQ_3(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_4[4] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 4.
 * - 1 - Enable asynchronous DMA request for channel 4.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_4 field. */
#define DMA_RD_EARS_EDREQ_4(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_4_MASK) >> DMA_EARS_EDREQ_4_SHIFT)
#define DMA_BRD_EARS_EDREQ_4(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT))

/*! @brief Set the EDREQ_4 field to a new value. */
#define DMA_WR_EARS_EDREQ_4(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_4_MASK, DMA_EARS_EDREQ_4(value)))
#define DMA_BWR_EARS_EDREQ_4(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_5[5] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 5.
 * - 1 - Enable asynchronous DMA request for channel 5.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_5 field. */
#define DMA_RD_EARS_EDREQ_5(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_5_MASK) >> DMA_EARS_EDREQ_5_SHIFT)
#define DMA_BRD_EARS_EDREQ_5(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT))

/*! @brief Set the EDREQ_5 field to a new value. */
#define DMA_WR_EARS_EDREQ_5(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_5_MASK, DMA_EARS_EDREQ_5(value)))
#define DMA_BWR_EARS_EDREQ_5(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_6[6] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 6.
 * - 1 - Enable asynchronous DMA request for channel 6.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_6 field. */
#define DMA_RD_EARS_EDREQ_6(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_6_MASK) >> DMA_EARS_EDREQ_6_SHIFT)
#define DMA_BRD_EARS_EDREQ_6(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT))

/*! @brief Set the EDREQ_6 field to a new value. */
#define DMA_WR_EARS_EDREQ_6(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_6_MASK, DMA_EARS_EDREQ_6(value)))
#define DMA_BWR_EARS_EDREQ_6(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_7[7] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 7.
 * - 1 - Enable asynchronous DMA request for channel 7.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_7 field. */
#define DMA_RD_EARS_EDREQ_7(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_7_MASK) >> DMA_EARS_EDREQ_7_SHIFT)
#define DMA_BRD_EARS_EDREQ_7(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT))

/*! @brief Set the EDREQ_7 field to a new value. */
#define DMA_WR_EARS_EDREQ_7(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_7_MASK, DMA_EARS_EDREQ_7(value)))
#define DMA_BWR_EARS_EDREQ_7(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_8[8] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 8.
 * - 1 - Enable asynchronous DMA request for channel 8.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_8 field. */
#define DMA_RD_EARS_EDREQ_8(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_8_MASK) >> DMA_EARS_EDREQ_8_SHIFT)
#define DMA_BRD_EARS_EDREQ_8(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_8_SHIFT))

/*! @brief Set the EDREQ_8 field to a new value. */
#define DMA_WR_EARS_EDREQ_8(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_8_MASK, DMA_EARS_EDREQ_8(value)))
#define DMA_BWR_EARS_EDREQ_8(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_9[9] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 9.
 * - 1 - Enable asynchronous DMA request for channel 9.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_9 field. */
#define DMA_RD_EARS_EDREQ_9(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_9_MASK) >> DMA_EARS_EDREQ_9_SHIFT)
#define DMA_BRD_EARS_EDREQ_9(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_9_SHIFT))

/*! @brief Set the EDREQ_9 field to a new value. */
#define DMA_WR_EARS_EDREQ_9(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_9_MASK, DMA_EARS_EDREQ_9(value)))
#define DMA_BWR_EARS_EDREQ_9(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_10[10] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 10.
 * - 1 - Enable asynchronous DMA request for channel 10.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_10 field. */
#define DMA_RD_EARS_EDREQ_10(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_10_MASK) >> DMA_EARS_EDREQ_10_SHIFT)
#define DMA_BRD_EARS_EDREQ_10(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_10_SHIFT))

/*! @brief Set the EDREQ_10 field to a new value. */
#define DMA_WR_EARS_EDREQ_10(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_10_MASK, DMA_EARS_EDREQ_10(value)))
#define DMA_BWR_EARS_EDREQ_10(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_11[11] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 11.
 * - 1 - Enable asynchronous DMA request for channel 11.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_11 field. */
#define DMA_RD_EARS_EDREQ_11(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_11_MASK) >> DMA_EARS_EDREQ_11_SHIFT)
#define DMA_BRD_EARS_EDREQ_11(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_11_SHIFT))

/*! @brief Set the EDREQ_11 field to a new value. */
#define DMA_WR_EARS_EDREQ_11(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_11_MASK, DMA_EARS_EDREQ_11(value)))
#define DMA_BWR_EARS_EDREQ_11(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_12[12] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 12.
 * - 1 - Enable asynchronous DMA request for channel 12.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_12 field. */
#define DMA_RD_EARS_EDREQ_12(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_12_MASK) >> DMA_EARS_EDREQ_12_SHIFT)
#define DMA_BRD_EARS_EDREQ_12(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_12_SHIFT))

/*! @brief Set the EDREQ_12 field to a new value. */
#define DMA_WR_EARS_EDREQ_12(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_12_MASK, DMA_EARS_EDREQ_12(value)))
#define DMA_BWR_EARS_EDREQ_12(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_13[13] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 13.
 * - 1 - Enable asynchronous DMA request for channel 13.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_13 field. */
#define DMA_RD_EARS_EDREQ_13(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_13_MASK) >> DMA_EARS_EDREQ_13_SHIFT)
#define DMA_BRD_EARS_EDREQ_13(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_13_SHIFT))

/*! @brief Set the EDREQ_13 field to a new value. */
#define DMA_WR_EARS_EDREQ_13(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_13_MASK, DMA_EARS_EDREQ_13(value)))
#define DMA_BWR_EARS_EDREQ_13(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_14[14] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 14.
 * - 1 - Enable asynchronous DMA request for channel 14.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_14 field. */
#define DMA_RD_EARS_EDREQ_14(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_14_MASK) >> DMA_EARS_EDREQ_14_SHIFT)
#define DMA_BRD_EARS_EDREQ_14(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_14_SHIFT))

/*! @brief Set the EDREQ_14 field to a new value. */
#define DMA_WR_EARS_EDREQ_14(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_14_MASK, DMA_EARS_EDREQ_14(value)))
#define DMA_BWR_EARS_EDREQ_14(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_EARS, field EDREQ_15[15] (RW)
 *
 * Values:
 * - 0 - Disable asynchronous DMA request for channel 15.
 * - 1 - Enable asynchronous DMA request for channel 15.
 */
/*@{*/
/*! @brief Read current value of the DMA_EARS_EDREQ_15 field. */
#define DMA_RD_EARS_EDREQ_15(base) ((DMA_EARS_REG(base) & DMA_EARS_EDREQ_15_MASK) >> DMA_EARS_EDREQ_15_SHIFT)
#define DMA_BRD_EARS_EDREQ_15(base) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_15_SHIFT))

/*! @brief Set the EDREQ_15 field to a new value. */
#define DMA_WR_EARS_EDREQ_15(base, value) (DMA_RMW_EARS(base, DMA_EARS_EDREQ_15_MASK, DMA_EARS_EDREQ_15(value)))
#define DMA_BWR_EARS_EDREQ_15(base, value) (BITBAND_ACCESS32(&DMA_EARS_REG(base), DMA_EARS_EDREQ_15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI3 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI3 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI3 register
 */
/*@{*/
#define DMA_RD_DCHPRI3(base)     (DMA_DCHPRI3_REG(base))
#define DMA_WR_DCHPRI3(base, value) (DMA_DCHPRI3_REG(base) = (value))
#define DMA_RMW_DCHPRI3(base, mask, value) (DMA_WR_DCHPRI3(base, (DMA_RD_DCHPRI3(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) |  (value)))
#define DMA_CLR_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) & ~(value)))
#define DMA_TOG_DCHPRI3(base, value) (DMA_WR_DCHPRI3(base, DMA_RD_DCHPRI3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI3 bitfields
 */

/*!
 * @name Register DMA_DCHPRI3, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_CHPRI field. */
#define DMA_RD_DCHPRI3_CHPRI(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_CHPRI_MASK) >> DMA_DCHPRI3_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI3_CHPRI(base) (DMA_RD_DCHPRI3_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI3_CHPRI(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_CHPRI_MASK, DMA_DCHPRI3_CHPRI(value)))
#define DMA_BWR_DCHPRI3_CHPRI(base, value) (DMA_WR_DCHPRI3_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_DPA field. */
#define DMA_RD_DCHPRI3_DPA(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_DPA_MASK) >> DMA_DCHPRI3_DPA_SHIFT)
#define DMA_BRD_DCHPRI3_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI3_DPA(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_DPA_MASK, DMA_DCHPRI3_DPA(value)))
#define DMA_BWR_DCHPRI3_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI3, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI3_ECP field. */
#define DMA_RD_DCHPRI3_ECP(base) ((DMA_DCHPRI3_REG(base) & DMA_DCHPRI3_ECP_MASK) >> DMA_DCHPRI3_ECP_SHIFT)
#define DMA_BRD_DCHPRI3_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI3_ECP(base, value) (DMA_RMW_DCHPRI3(base, DMA_DCHPRI3_ECP_MASK, DMA_DCHPRI3_ECP(value)))
#define DMA_BWR_DCHPRI3_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI3_REG(base), DMA_DCHPRI3_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI2 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI2 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI2 register
 */
/*@{*/
#define DMA_RD_DCHPRI2(base)     (DMA_DCHPRI2_REG(base))
#define DMA_WR_DCHPRI2(base, value) (DMA_DCHPRI2_REG(base) = (value))
#define DMA_RMW_DCHPRI2(base, mask, value) (DMA_WR_DCHPRI2(base, (DMA_RD_DCHPRI2(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) |  (value)))
#define DMA_CLR_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) & ~(value)))
#define DMA_TOG_DCHPRI2(base, value) (DMA_WR_DCHPRI2(base, DMA_RD_DCHPRI2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI2 bitfields
 */

/*!
 * @name Register DMA_DCHPRI2, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_CHPRI field. */
#define DMA_RD_DCHPRI2_CHPRI(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_CHPRI_MASK) >> DMA_DCHPRI2_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI2_CHPRI(base) (DMA_RD_DCHPRI2_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI2_CHPRI(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_CHPRI_MASK, DMA_DCHPRI2_CHPRI(value)))
#define DMA_BWR_DCHPRI2_CHPRI(base, value) (DMA_WR_DCHPRI2_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_DPA field. */
#define DMA_RD_DCHPRI2_DPA(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_DPA_MASK) >> DMA_DCHPRI2_DPA_SHIFT)
#define DMA_BRD_DCHPRI2_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI2_DPA(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_DPA_MASK, DMA_DCHPRI2_DPA(value)))
#define DMA_BWR_DCHPRI2_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI2, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI2_ECP field. */
#define DMA_RD_DCHPRI2_ECP(base) ((DMA_DCHPRI2_REG(base) & DMA_DCHPRI2_ECP_MASK) >> DMA_DCHPRI2_ECP_SHIFT)
#define DMA_BRD_DCHPRI2_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI2_ECP(base, value) (DMA_RMW_DCHPRI2(base, DMA_DCHPRI2_ECP_MASK, DMA_DCHPRI2_ECP(value)))
#define DMA_BWR_DCHPRI2_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI2_REG(base), DMA_DCHPRI2_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI1 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI1 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI1 register
 */
/*@{*/
#define DMA_RD_DCHPRI1(base)     (DMA_DCHPRI1_REG(base))
#define DMA_WR_DCHPRI1(base, value) (DMA_DCHPRI1_REG(base) = (value))
#define DMA_RMW_DCHPRI1(base, mask, value) (DMA_WR_DCHPRI1(base, (DMA_RD_DCHPRI1(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) |  (value)))
#define DMA_CLR_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) & ~(value)))
#define DMA_TOG_DCHPRI1(base, value) (DMA_WR_DCHPRI1(base, DMA_RD_DCHPRI1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI1 bitfields
 */

/*!
 * @name Register DMA_DCHPRI1, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_CHPRI field. */
#define DMA_RD_DCHPRI1_CHPRI(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_CHPRI_MASK) >> DMA_DCHPRI1_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI1_CHPRI(base) (DMA_RD_DCHPRI1_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI1_CHPRI(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_CHPRI_MASK, DMA_DCHPRI1_CHPRI(value)))
#define DMA_BWR_DCHPRI1_CHPRI(base, value) (DMA_WR_DCHPRI1_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_DPA field. */
#define DMA_RD_DCHPRI1_DPA(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_DPA_MASK) >> DMA_DCHPRI1_DPA_SHIFT)
#define DMA_BRD_DCHPRI1_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI1_DPA(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_DPA_MASK, DMA_DCHPRI1_DPA(value)))
#define DMA_BWR_DCHPRI1_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI1, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI1_ECP field. */
#define DMA_RD_DCHPRI1_ECP(base) ((DMA_DCHPRI1_REG(base) & DMA_DCHPRI1_ECP_MASK) >> DMA_DCHPRI1_ECP_SHIFT)
#define DMA_BRD_DCHPRI1_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI1_ECP(base, value) (DMA_RMW_DCHPRI1(base, DMA_DCHPRI1_ECP_MASK, DMA_DCHPRI1_ECP(value)))
#define DMA_BWR_DCHPRI1_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI1_REG(base), DMA_DCHPRI1_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI0 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI0 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI0 register
 */
/*@{*/
#define DMA_RD_DCHPRI0(base)     (DMA_DCHPRI0_REG(base))
#define DMA_WR_DCHPRI0(base, value) (DMA_DCHPRI0_REG(base) = (value))
#define DMA_RMW_DCHPRI0(base, mask, value) (DMA_WR_DCHPRI0(base, (DMA_RD_DCHPRI0(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) |  (value)))
#define DMA_CLR_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) & ~(value)))
#define DMA_TOG_DCHPRI0(base, value) (DMA_WR_DCHPRI0(base, DMA_RD_DCHPRI0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI0 bitfields
 */

/*!
 * @name Register DMA_DCHPRI0, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_CHPRI field. */
#define DMA_RD_DCHPRI0_CHPRI(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI0_CHPRI(base) (DMA_RD_DCHPRI0_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI0_CHPRI(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_CHPRI_MASK, DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRI0_CHPRI(base, value) (DMA_WR_DCHPRI0_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_DPA field. */
#define DMA_RD_DCHPRI0_DPA(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRI0_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI0_DPA(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_DPA_MASK, DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRI0_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI0, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI0_ECP field. */
#define DMA_RD_DCHPRI0_ECP(base) ((DMA_DCHPRI0_REG(base) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRI0_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI0_ECP(base, value) (DMA_RMW_DCHPRI0(base, DMA_DCHPRI0_ECP_MASK, DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRI0_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI0_REG(base), DMA_DCHPRI0_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI7 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI7 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI7 register
 */
/*@{*/
#define DMA_RD_DCHPRI7(base)     (DMA_DCHPRI7_REG(base))
#define DMA_WR_DCHPRI7(base, value) (DMA_DCHPRI7_REG(base) = (value))
#define DMA_RMW_DCHPRI7(base, mask, value) (DMA_WR_DCHPRI7(base, (DMA_RD_DCHPRI7(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI7(base, value) (DMA_WR_DCHPRI7(base, DMA_RD_DCHPRI7(base) |  (value)))
#define DMA_CLR_DCHPRI7(base, value) (DMA_WR_DCHPRI7(base, DMA_RD_DCHPRI7(base) & ~(value)))
#define DMA_TOG_DCHPRI7(base, value) (DMA_WR_DCHPRI7(base, DMA_RD_DCHPRI7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI7 bitfields
 */

/*!
 * @name Register DMA_DCHPRI7, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_CHPRI field. */
#define DMA_RD_DCHPRI7_CHPRI(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_CHPRI_MASK) >> DMA_DCHPRI7_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI7_CHPRI(base) (DMA_RD_DCHPRI7_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI7_CHPRI(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_CHPRI_MASK, DMA_DCHPRI7_CHPRI(value)))
#define DMA_BWR_DCHPRI7_CHPRI(base, value) (DMA_WR_DCHPRI7_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_DPA field. */
#define DMA_RD_DCHPRI7_DPA(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_DPA_MASK) >> DMA_DCHPRI7_DPA_SHIFT)
#define DMA_BRD_DCHPRI7_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI7_DPA(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_DPA_MASK, DMA_DCHPRI7_DPA(value)))
#define DMA_BWR_DCHPRI7_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI7, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI7_ECP field. */
#define DMA_RD_DCHPRI7_ECP(base) ((DMA_DCHPRI7_REG(base) & DMA_DCHPRI7_ECP_MASK) >> DMA_DCHPRI7_ECP_SHIFT)
#define DMA_BRD_DCHPRI7_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI7_ECP(base, value) (DMA_RMW_DCHPRI7(base, DMA_DCHPRI7_ECP_MASK, DMA_DCHPRI7_ECP(value)))
#define DMA_BWR_DCHPRI7_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI7_REG(base), DMA_DCHPRI7_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI6 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI6 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI6 register
 */
/*@{*/
#define DMA_RD_DCHPRI6(base)     (DMA_DCHPRI6_REG(base))
#define DMA_WR_DCHPRI6(base, value) (DMA_DCHPRI6_REG(base) = (value))
#define DMA_RMW_DCHPRI6(base, mask, value) (DMA_WR_DCHPRI6(base, (DMA_RD_DCHPRI6(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI6(base, value) (DMA_WR_DCHPRI6(base, DMA_RD_DCHPRI6(base) |  (value)))
#define DMA_CLR_DCHPRI6(base, value) (DMA_WR_DCHPRI6(base, DMA_RD_DCHPRI6(base) & ~(value)))
#define DMA_TOG_DCHPRI6(base, value) (DMA_WR_DCHPRI6(base, DMA_RD_DCHPRI6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI6 bitfields
 */

/*!
 * @name Register DMA_DCHPRI6, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_CHPRI field. */
#define DMA_RD_DCHPRI6_CHPRI(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_CHPRI_MASK) >> DMA_DCHPRI6_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI6_CHPRI(base) (DMA_RD_DCHPRI6_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI6_CHPRI(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_CHPRI_MASK, DMA_DCHPRI6_CHPRI(value)))
#define DMA_BWR_DCHPRI6_CHPRI(base, value) (DMA_WR_DCHPRI6_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_DPA field. */
#define DMA_RD_DCHPRI6_DPA(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_DPA_MASK) >> DMA_DCHPRI6_DPA_SHIFT)
#define DMA_BRD_DCHPRI6_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI6_DPA(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_DPA_MASK, DMA_DCHPRI6_DPA(value)))
#define DMA_BWR_DCHPRI6_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI6, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI6_ECP field. */
#define DMA_RD_DCHPRI6_ECP(base) ((DMA_DCHPRI6_REG(base) & DMA_DCHPRI6_ECP_MASK) >> DMA_DCHPRI6_ECP_SHIFT)
#define DMA_BRD_DCHPRI6_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI6_ECP(base, value) (DMA_RMW_DCHPRI6(base, DMA_DCHPRI6_ECP_MASK, DMA_DCHPRI6_ECP(value)))
#define DMA_BWR_DCHPRI6_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI6_REG(base), DMA_DCHPRI6_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI5 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI5 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI5 register
 */
/*@{*/
#define DMA_RD_DCHPRI5(base)     (DMA_DCHPRI5_REG(base))
#define DMA_WR_DCHPRI5(base, value) (DMA_DCHPRI5_REG(base) = (value))
#define DMA_RMW_DCHPRI5(base, mask, value) (DMA_WR_DCHPRI5(base, (DMA_RD_DCHPRI5(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI5(base, value) (DMA_WR_DCHPRI5(base, DMA_RD_DCHPRI5(base) |  (value)))
#define DMA_CLR_DCHPRI5(base, value) (DMA_WR_DCHPRI5(base, DMA_RD_DCHPRI5(base) & ~(value)))
#define DMA_TOG_DCHPRI5(base, value) (DMA_WR_DCHPRI5(base, DMA_RD_DCHPRI5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI5 bitfields
 */

/*!
 * @name Register DMA_DCHPRI5, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_CHPRI field. */
#define DMA_RD_DCHPRI5_CHPRI(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_CHPRI_MASK) >> DMA_DCHPRI5_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI5_CHPRI(base) (DMA_RD_DCHPRI5_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI5_CHPRI(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_CHPRI_MASK, DMA_DCHPRI5_CHPRI(value)))
#define DMA_BWR_DCHPRI5_CHPRI(base, value) (DMA_WR_DCHPRI5_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_DPA field. */
#define DMA_RD_DCHPRI5_DPA(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_DPA_MASK) >> DMA_DCHPRI5_DPA_SHIFT)
#define DMA_BRD_DCHPRI5_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI5_DPA(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_DPA_MASK, DMA_DCHPRI5_DPA(value)))
#define DMA_BWR_DCHPRI5_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI5, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI5_ECP field. */
#define DMA_RD_DCHPRI5_ECP(base) ((DMA_DCHPRI5_REG(base) & DMA_DCHPRI5_ECP_MASK) >> DMA_DCHPRI5_ECP_SHIFT)
#define DMA_BRD_DCHPRI5_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI5_ECP(base, value) (DMA_RMW_DCHPRI5(base, DMA_DCHPRI5_ECP_MASK, DMA_DCHPRI5_ECP(value)))
#define DMA_BWR_DCHPRI5_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI5_REG(base), DMA_DCHPRI5_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI4 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI4 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI4 register
 */
/*@{*/
#define DMA_RD_DCHPRI4(base)     (DMA_DCHPRI4_REG(base))
#define DMA_WR_DCHPRI4(base, value) (DMA_DCHPRI4_REG(base) = (value))
#define DMA_RMW_DCHPRI4(base, mask, value) (DMA_WR_DCHPRI4(base, (DMA_RD_DCHPRI4(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI4(base, value) (DMA_WR_DCHPRI4(base, DMA_RD_DCHPRI4(base) |  (value)))
#define DMA_CLR_DCHPRI4(base, value) (DMA_WR_DCHPRI4(base, DMA_RD_DCHPRI4(base) & ~(value)))
#define DMA_TOG_DCHPRI4(base, value) (DMA_WR_DCHPRI4(base, DMA_RD_DCHPRI4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI4 bitfields
 */

/*!
 * @name Register DMA_DCHPRI4, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_CHPRI field. */
#define DMA_RD_DCHPRI4_CHPRI(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_CHPRI_MASK) >> DMA_DCHPRI4_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI4_CHPRI(base) (DMA_RD_DCHPRI4_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI4_CHPRI(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_CHPRI_MASK, DMA_DCHPRI4_CHPRI(value)))
#define DMA_BWR_DCHPRI4_CHPRI(base, value) (DMA_WR_DCHPRI4_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_DPA field. */
#define DMA_RD_DCHPRI4_DPA(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_DPA_MASK) >> DMA_DCHPRI4_DPA_SHIFT)
#define DMA_BRD_DCHPRI4_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI4_DPA(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_DPA_MASK, DMA_DCHPRI4_DPA(value)))
#define DMA_BWR_DCHPRI4_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI4, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI4_ECP field. */
#define DMA_RD_DCHPRI4_ECP(base) ((DMA_DCHPRI4_REG(base) & DMA_DCHPRI4_ECP_MASK) >> DMA_DCHPRI4_ECP_SHIFT)
#define DMA_BRD_DCHPRI4_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI4_ECP(base, value) (DMA_RMW_DCHPRI4(base, DMA_DCHPRI4_ECP_MASK, DMA_DCHPRI4_ECP(value)))
#define DMA_BWR_DCHPRI4_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI4_REG(base), DMA_DCHPRI4_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI11 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI11 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI11 register
 */
/*@{*/
#define DMA_RD_DCHPRI11(base)    (DMA_DCHPRI11_REG(base))
#define DMA_WR_DCHPRI11(base, value) (DMA_DCHPRI11_REG(base) = (value))
#define DMA_RMW_DCHPRI11(base, mask, value) (DMA_WR_DCHPRI11(base, (DMA_RD_DCHPRI11(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI11(base, value) (DMA_WR_DCHPRI11(base, DMA_RD_DCHPRI11(base) |  (value)))
#define DMA_CLR_DCHPRI11(base, value) (DMA_WR_DCHPRI11(base, DMA_RD_DCHPRI11(base) & ~(value)))
#define DMA_TOG_DCHPRI11(base, value) (DMA_WR_DCHPRI11(base, DMA_RD_DCHPRI11(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI11 bitfields
 */

/*!
 * @name Register DMA_DCHPRI11, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_CHPRI field. */
#define DMA_RD_DCHPRI11_CHPRI(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_CHPRI_MASK) >> DMA_DCHPRI11_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI11_CHPRI(base) (DMA_RD_DCHPRI11_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI11_CHPRI(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_CHPRI_MASK, DMA_DCHPRI11_CHPRI(value)))
#define DMA_BWR_DCHPRI11_CHPRI(base, value) (DMA_WR_DCHPRI11_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI11, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_DPA field. */
#define DMA_RD_DCHPRI11_DPA(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_DPA_MASK) >> DMA_DCHPRI11_DPA_SHIFT)
#define DMA_BRD_DCHPRI11_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI11_DPA(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_DPA_MASK, DMA_DCHPRI11_DPA(value)))
#define DMA_BWR_DCHPRI11_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI11, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI11_ECP field. */
#define DMA_RD_DCHPRI11_ECP(base) ((DMA_DCHPRI11_REG(base) & DMA_DCHPRI11_ECP_MASK) >> DMA_DCHPRI11_ECP_SHIFT)
#define DMA_BRD_DCHPRI11_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI11_ECP(base, value) (DMA_RMW_DCHPRI11(base, DMA_DCHPRI11_ECP_MASK, DMA_DCHPRI11_ECP(value)))
#define DMA_BWR_DCHPRI11_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI11_REG(base), DMA_DCHPRI11_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI10 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI10 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI10 register
 */
/*@{*/
#define DMA_RD_DCHPRI10(base)    (DMA_DCHPRI10_REG(base))
#define DMA_WR_DCHPRI10(base, value) (DMA_DCHPRI10_REG(base) = (value))
#define DMA_RMW_DCHPRI10(base, mask, value) (DMA_WR_DCHPRI10(base, (DMA_RD_DCHPRI10(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI10(base, value) (DMA_WR_DCHPRI10(base, DMA_RD_DCHPRI10(base) |  (value)))
#define DMA_CLR_DCHPRI10(base, value) (DMA_WR_DCHPRI10(base, DMA_RD_DCHPRI10(base) & ~(value)))
#define DMA_TOG_DCHPRI10(base, value) (DMA_WR_DCHPRI10(base, DMA_RD_DCHPRI10(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI10 bitfields
 */

/*!
 * @name Register DMA_DCHPRI10, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_CHPRI field. */
#define DMA_RD_DCHPRI10_CHPRI(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_CHPRI_MASK) >> DMA_DCHPRI10_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI10_CHPRI(base) (DMA_RD_DCHPRI10_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI10_CHPRI(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_CHPRI_MASK, DMA_DCHPRI10_CHPRI(value)))
#define DMA_BWR_DCHPRI10_CHPRI(base, value) (DMA_WR_DCHPRI10_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI10, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_DPA field. */
#define DMA_RD_DCHPRI10_DPA(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_DPA_MASK) >> DMA_DCHPRI10_DPA_SHIFT)
#define DMA_BRD_DCHPRI10_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI10_DPA(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_DPA_MASK, DMA_DCHPRI10_DPA(value)))
#define DMA_BWR_DCHPRI10_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI10, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI10_ECP field. */
#define DMA_RD_DCHPRI10_ECP(base) ((DMA_DCHPRI10_REG(base) & DMA_DCHPRI10_ECP_MASK) >> DMA_DCHPRI10_ECP_SHIFT)
#define DMA_BRD_DCHPRI10_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI10_ECP(base, value) (DMA_RMW_DCHPRI10(base, DMA_DCHPRI10_ECP_MASK, DMA_DCHPRI10_ECP(value)))
#define DMA_BWR_DCHPRI10_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI10_REG(base), DMA_DCHPRI10_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI9 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI9 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI9 register
 */
/*@{*/
#define DMA_RD_DCHPRI9(base)     (DMA_DCHPRI9_REG(base))
#define DMA_WR_DCHPRI9(base, value) (DMA_DCHPRI9_REG(base) = (value))
#define DMA_RMW_DCHPRI9(base, mask, value) (DMA_WR_DCHPRI9(base, (DMA_RD_DCHPRI9(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI9(base, value) (DMA_WR_DCHPRI9(base, DMA_RD_DCHPRI9(base) |  (value)))
#define DMA_CLR_DCHPRI9(base, value) (DMA_WR_DCHPRI9(base, DMA_RD_DCHPRI9(base) & ~(value)))
#define DMA_TOG_DCHPRI9(base, value) (DMA_WR_DCHPRI9(base, DMA_RD_DCHPRI9(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI9 bitfields
 */

/*!
 * @name Register DMA_DCHPRI9, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_CHPRI field. */
#define DMA_RD_DCHPRI9_CHPRI(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_CHPRI_MASK) >> DMA_DCHPRI9_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI9_CHPRI(base) (DMA_RD_DCHPRI9_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI9_CHPRI(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_CHPRI_MASK, DMA_DCHPRI9_CHPRI(value)))
#define DMA_BWR_DCHPRI9_CHPRI(base, value) (DMA_WR_DCHPRI9_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI9, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_DPA field. */
#define DMA_RD_DCHPRI9_DPA(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_DPA_MASK) >> DMA_DCHPRI9_DPA_SHIFT)
#define DMA_BRD_DCHPRI9_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI9_DPA(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_DPA_MASK, DMA_DCHPRI9_DPA(value)))
#define DMA_BWR_DCHPRI9_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI9, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI9_ECP field. */
#define DMA_RD_DCHPRI9_ECP(base) ((DMA_DCHPRI9_REG(base) & DMA_DCHPRI9_ECP_MASK) >> DMA_DCHPRI9_ECP_SHIFT)
#define DMA_BRD_DCHPRI9_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI9_ECP(base, value) (DMA_RMW_DCHPRI9(base, DMA_DCHPRI9_ECP_MASK, DMA_DCHPRI9_ECP(value)))
#define DMA_BWR_DCHPRI9_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI9_REG(base), DMA_DCHPRI9_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI8 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI8 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI8 register
 */
/*@{*/
#define DMA_RD_DCHPRI8(base)     (DMA_DCHPRI8_REG(base))
#define DMA_WR_DCHPRI8(base, value) (DMA_DCHPRI8_REG(base) = (value))
#define DMA_RMW_DCHPRI8(base, mask, value) (DMA_WR_DCHPRI8(base, (DMA_RD_DCHPRI8(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI8(base, value) (DMA_WR_DCHPRI8(base, DMA_RD_DCHPRI8(base) |  (value)))
#define DMA_CLR_DCHPRI8(base, value) (DMA_WR_DCHPRI8(base, DMA_RD_DCHPRI8(base) & ~(value)))
#define DMA_TOG_DCHPRI8(base, value) (DMA_WR_DCHPRI8(base, DMA_RD_DCHPRI8(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI8 bitfields
 */

/*!
 * @name Register DMA_DCHPRI8, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_CHPRI field. */
#define DMA_RD_DCHPRI8_CHPRI(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_CHPRI_MASK) >> DMA_DCHPRI8_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI8_CHPRI(base) (DMA_RD_DCHPRI8_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI8_CHPRI(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_CHPRI_MASK, DMA_DCHPRI8_CHPRI(value)))
#define DMA_BWR_DCHPRI8_CHPRI(base, value) (DMA_WR_DCHPRI8_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI8, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_DPA field. */
#define DMA_RD_DCHPRI8_DPA(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_DPA_MASK) >> DMA_DCHPRI8_DPA_SHIFT)
#define DMA_BRD_DCHPRI8_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI8_DPA(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_DPA_MASK, DMA_DCHPRI8_DPA(value)))
#define DMA_BWR_DCHPRI8_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI8, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI8_ECP field. */
#define DMA_RD_DCHPRI8_ECP(base) ((DMA_DCHPRI8_REG(base) & DMA_DCHPRI8_ECP_MASK) >> DMA_DCHPRI8_ECP_SHIFT)
#define DMA_BRD_DCHPRI8_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI8_ECP(base, value) (DMA_RMW_DCHPRI8(base, DMA_DCHPRI8_ECP_MASK, DMA_DCHPRI8_ECP(value)))
#define DMA_BWR_DCHPRI8_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI8_REG(base), DMA_DCHPRI8_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI15 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI15 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI15 register
 */
/*@{*/
#define DMA_RD_DCHPRI15(base)    (DMA_DCHPRI15_REG(base))
#define DMA_WR_DCHPRI15(base, value) (DMA_DCHPRI15_REG(base) = (value))
#define DMA_RMW_DCHPRI15(base, mask, value) (DMA_WR_DCHPRI15(base, (DMA_RD_DCHPRI15(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI15(base, value) (DMA_WR_DCHPRI15(base, DMA_RD_DCHPRI15(base) |  (value)))
#define DMA_CLR_DCHPRI15(base, value) (DMA_WR_DCHPRI15(base, DMA_RD_DCHPRI15(base) & ~(value)))
#define DMA_TOG_DCHPRI15(base, value) (DMA_WR_DCHPRI15(base, DMA_RD_DCHPRI15(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI15 bitfields
 */

/*!
 * @name Register DMA_DCHPRI15, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_CHPRI field. */
#define DMA_RD_DCHPRI15_CHPRI(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_CHPRI_MASK) >> DMA_DCHPRI15_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI15_CHPRI(base) (DMA_RD_DCHPRI15_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI15_CHPRI(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_CHPRI_MASK, DMA_DCHPRI15_CHPRI(value)))
#define DMA_BWR_DCHPRI15_CHPRI(base, value) (DMA_WR_DCHPRI15_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI15, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_DPA field. */
#define DMA_RD_DCHPRI15_DPA(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_DPA_MASK) >> DMA_DCHPRI15_DPA_SHIFT)
#define DMA_BRD_DCHPRI15_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI15_DPA(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_DPA_MASK, DMA_DCHPRI15_DPA(value)))
#define DMA_BWR_DCHPRI15_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI15, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI15_ECP field. */
#define DMA_RD_DCHPRI15_ECP(base) ((DMA_DCHPRI15_REG(base) & DMA_DCHPRI15_ECP_MASK) >> DMA_DCHPRI15_ECP_SHIFT)
#define DMA_BRD_DCHPRI15_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI15_ECP(base, value) (DMA_RMW_DCHPRI15(base, DMA_DCHPRI15_ECP_MASK, DMA_DCHPRI15_ECP(value)))
#define DMA_BWR_DCHPRI15_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI15_REG(base), DMA_DCHPRI15_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI14 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI14 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI14 register
 */
/*@{*/
#define DMA_RD_DCHPRI14(base)    (DMA_DCHPRI14_REG(base))
#define DMA_WR_DCHPRI14(base, value) (DMA_DCHPRI14_REG(base) = (value))
#define DMA_RMW_DCHPRI14(base, mask, value) (DMA_WR_DCHPRI14(base, (DMA_RD_DCHPRI14(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI14(base, value) (DMA_WR_DCHPRI14(base, DMA_RD_DCHPRI14(base) |  (value)))
#define DMA_CLR_DCHPRI14(base, value) (DMA_WR_DCHPRI14(base, DMA_RD_DCHPRI14(base) & ~(value)))
#define DMA_TOG_DCHPRI14(base, value) (DMA_WR_DCHPRI14(base, DMA_RD_DCHPRI14(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI14 bitfields
 */

/*!
 * @name Register DMA_DCHPRI14, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_CHPRI field. */
#define DMA_RD_DCHPRI14_CHPRI(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_CHPRI_MASK) >> DMA_DCHPRI14_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI14_CHPRI(base) (DMA_RD_DCHPRI14_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI14_CHPRI(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_CHPRI_MASK, DMA_DCHPRI14_CHPRI(value)))
#define DMA_BWR_DCHPRI14_CHPRI(base, value) (DMA_WR_DCHPRI14_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI14, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_DPA field. */
#define DMA_RD_DCHPRI14_DPA(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_DPA_MASK) >> DMA_DCHPRI14_DPA_SHIFT)
#define DMA_BRD_DCHPRI14_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI14_DPA(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_DPA_MASK, DMA_DCHPRI14_DPA(value)))
#define DMA_BWR_DCHPRI14_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI14, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI14_ECP field. */
#define DMA_RD_DCHPRI14_ECP(base) ((DMA_DCHPRI14_REG(base) & DMA_DCHPRI14_ECP_MASK) >> DMA_DCHPRI14_ECP_SHIFT)
#define DMA_BRD_DCHPRI14_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI14_ECP(base, value) (DMA_RMW_DCHPRI14(base, DMA_DCHPRI14_ECP_MASK, DMA_DCHPRI14_ECP(value)))
#define DMA_BWR_DCHPRI14_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI14_REG(base), DMA_DCHPRI14_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI13 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI13 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI13 register
 */
/*@{*/
#define DMA_RD_DCHPRI13(base)    (DMA_DCHPRI13_REG(base))
#define DMA_WR_DCHPRI13(base, value) (DMA_DCHPRI13_REG(base) = (value))
#define DMA_RMW_DCHPRI13(base, mask, value) (DMA_WR_DCHPRI13(base, (DMA_RD_DCHPRI13(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI13(base, value) (DMA_WR_DCHPRI13(base, DMA_RD_DCHPRI13(base) |  (value)))
#define DMA_CLR_DCHPRI13(base, value) (DMA_WR_DCHPRI13(base, DMA_RD_DCHPRI13(base) & ~(value)))
#define DMA_TOG_DCHPRI13(base, value) (DMA_WR_DCHPRI13(base, DMA_RD_DCHPRI13(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI13 bitfields
 */

/*!
 * @name Register DMA_DCHPRI13, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_CHPRI field. */
#define DMA_RD_DCHPRI13_CHPRI(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_CHPRI_MASK) >> DMA_DCHPRI13_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI13_CHPRI(base) (DMA_RD_DCHPRI13_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI13_CHPRI(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_CHPRI_MASK, DMA_DCHPRI13_CHPRI(value)))
#define DMA_BWR_DCHPRI13_CHPRI(base, value) (DMA_WR_DCHPRI13_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI13, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_DPA field. */
#define DMA_RD_DCHPRI13_DPA(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_DPA_MASK) >> DMA_DCHPRI13_DPA_SHIFT)
#define DMA_BRD_DCHPRI13_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI13_DPA(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_DPA_MASK, DMA_DCHPRI13_DPA(value)))
#define DMA_BWR_DCHPRI13_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI13, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI13_ECP field. */
#define DMA_RD_DCHPRI13_ECP(base) ((DMA_DCHPRI13_REG(base) & DMA_DCHPRI13_ECP_MASK) >> DMA_DCHPRI13_ECP_SHIFT)
#define DMA_BRD_DCHPRI13_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI13_ECP(base, value) (DMA_RMW_DCHPRI13(base, DMA_DCHPRI13_ECP_MASK, DMA_DCHPRI13_ECP(value)))
#define DMA_BWR_DCHPRI13_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI13_REG(base), DMA_DCHPRI13_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DCHPRI12 - Channel n Priority Register
 ******************************************************************************/

/*!
 * @brief DMA_DCHPRI12 - Channel n Priority Register (RW)
 *
 * Reset value: 0x00U
 *
 * When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the
 * contents of these registers define the unique priorities associated with each
 * channel. The channel priorities are evaluated by numeric value; for example, 0 is
 * the lowest priority, 1 is the next higher priority, then 2, 3, etc. Software
 * must program the channel priorities with unique values; otherwise, a
 * configuration error is reported. The range of the priority value is limited to the values
 * of 0 through 15.
 */
/*!
 * @name Constants and macros for entire DMA_DCHPRI12 register
 */
/*@{*/
#define DMA_RD_DCHPRI12(base)    (DMA_DCHPRI12_REG(base))
#define DMA_WR_DCHPRI12(base, value) (DMA_DCHPRI12_REG(base) = (value))
#define DMA_RMW_DCHPRI12(base, mask, value) (DMA_WR_DCHPRI12(base, (DMA_RD_DCHPRI12(base) & ~(mask)) | (value)))
#define DMA_SET_DCHPRI12(base, value) (DMA_WR_DCHPRI12(base, DMA_RD_DCHPRI12(base) |  (value)))
#define DMA_CLR_DCHPRI12(base, value) (DMA_WR_DCHPRI12(base, DMA_RD_DCHPRI12(base) & ~(value)))
#define DMA_TOG_DCHPRI12(base, value) (DMA_WR_DCHPRI12(base, DMA_RD_DCHPRI12(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_DCHPRI12 bitfields
 */

/*!
 * @name Register DMA_DCHPRI12, field CHPRI[3:0] (RW)
 *
 * Channel priority when fixed-priority arbitration is enabled Reset value for
 * the channel priority field, CHPRI, is equal to the corresponding channel number
 * for each priority register, that is, DCHPRI15[CHPRI] = 0b1111.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_CHPRI field. */
#define DMA_RD_DCHPRI12_CHPRI(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_CHPRI_MASK) >> DMA_DCHPRI12_CHPRI_SHIFT)
#define DMA_BRD_DCHPRI12_CHPRI(base) (DMA_RD_DCHPRI12_CHPRI(base))

/*! @brief Set the CHPRI field to a new value. */
#define DMA_WR_DCHPRI12_CHPRI(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_CHPRI_MASK, DMA_DCHPRI12_CHPRI(value)))
#define DMA_BWR_DCHPRI12_CHPRI(base, value) (DMA_WR_DCHPRI12_CHPRI(base, value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI12, field DPA[6] (RW)
 *
 * Values:
 * - 0 - Channel n can suspend a lower priority channel.
 * - 1 - Channel n cannot suspend any channel, regardless of channel priority.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_DPA field. */
#define DMA_RD_DCHPRI12_DPA(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_DPA_MASK) >> DMA_DCHPRI12_DPA_SHIFT)
#define DMA_BRD_DCHPRI12_DPA(base) (BITBAND_ACCESS8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_DPA_SHIFT))

/*! @brief Set the DPA field to a new value. */
#define DMA_WR_DCHPRI12_DPA(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_DPA_MASK, DMA_DCHPRI12_DPA(value)))
#define DMA_BWR_DCHPRI12_DPA(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_DPA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_DCHPRI12, field ECP[7] (RW)
 *
 * Values:
 * - 0 - Channel n cannot be suspended by a higher priority channel's service
 *     request.
 * - 1 - Channel n can be temporarily suspended by the service request of a
 *     higher priority channel.
 */
/*@{*/
/*! @brief Read current value of the DMA_DCHPRI12_ECP field. */
#define DMA_RD_DCHPRI12_ECP(base) ((DMA_DCHPRI12_REG(base) & DMA_DCHPRI12_ECP_MASK) >> DMA_DCHPRI12_ECP_SHIFT)
#define DMA_BRD_DCHPRI12_ECP(base) (BITBAND_ACCESS8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_ECP_SHIFT))

/*! @brief Set the ECP field to a new value. */
#define DMA_WR_DCHPRI12_ECP(base, value) (DMA_RMW_DCHPRI12(base, DMA_DCHPRI12_ECP_MASK, DMA_DCHPRI12_ECP(value)))
#define DMA_BWR_DCHPRI12_ECP(base, value) (BITBAND_ACCESS8(&DMA_DCHPRI12_REG(base), DMA_DCHPRI12_ECP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_SADDR - TCD Source Address
 ******************************************************************************/

/*!
 * @brief DMA_SADDR - TCD Source Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SADDR register
 */
/*@{*/
#define DMA_RD_SADDR(base, index) (DMA_SADDR_REG(base, index))
#define DMA_WR_SADDR(base, index, value) (DMA_SADDR_REG(base, index) = (value))
#define DMA_RMW_SADDR(base, index, mask, value) (DMA_WR_SADDR(base, index, (DMA_RD_SADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) |  (value)))
#define DMA_CLR_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) & ~(value)))
#define DMA_TOG_SADDR(base, index, value) (DMA_WR_SADDR(base, index, DMA_RD_SADDR(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_SOFF - TCD Signed Source Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_SOFF - TCD Signed Source Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_SOFF register
 */
/*@{*/
#define DMA_RD_SOFF(base, index) (DMA_SOFF_REG(base, index))
#define DMA_WR_SOFF(base, index, value) (DMA_SOFF_REG(base, index) = (value))
#define DMA_RMW_SOFF(base, index, mask, value) (DMA_WR_SOFF(base, index, (DMA_RD_SOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) |  (value)))
#define DMA_CLR_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) & ~(value)))
#define DMA_TOG_SOFF(base, index, value) (DMA_WR_SOFF(base, index, DMA_RD_SOFF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_ATTR - TCD Transfer Attributes
 ******************************************************************************/

/*!
 * @brief DMA_ATTR - TCD Transfer Attributes (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_ATTR register
 */
/*@{*/
#define DMA_RD_ATTR(base, index) (DMA_ATTR_REG(base, index))
#define DMA_WR_ATTR(base, index, value) (DMA_ATTR_REG(base, index) = (value))
#define DMA_RMW_ATTR(base, index, mask, value) (DMA_WR_ATTR(base, index, (DMA_RD_ATTR(base, index) & ~(mask)) | (value)))
#define DMA_SET_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) |  (value)))
#define DMA_CLR_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) & ~(value)))
#define DMA_TOG_ATTR(base, index, value) (DMA_WR_ATTR(base, index, DMA_RD_ATTR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_ATTR bitfields
 */

/*!
 * @name Register DMA_ATTR, field DSIZE[2:0] (RW)
 *
 * See the SSIZE definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DSIZE field. */
#define DMA_RD_ATTR_DSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DSIZE_MASK) >> DMA_ATTR_DSIZE_SHIFT)
#define DMA_BRD_ATTR_DSIZE(base, index) (DMA_RD_ATTR_DSIZE(base, index))

/*! @brief Set the DSIZE field to a new value. */
#define DMA_WR_ATTR_DSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DSIZE_MASK, DMA_ATTR_DSIZE(value)))
#define DMA_BWR_ATTR_DSIZE(base, index, value) (DMA_WR_ATTR_DSIZE(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field DMOD[7:3] (RW)
 *
 * See the SMOD definition
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_DMOD field. */
#define DMA_RD_ATTR_DMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_DMOD_MASK) >> DMA_ATTR_DMOD_SHIFT)
#define DMA_BRD_ATTR_DMOD(base, index) (DMA_RD_ATTR_DMOD(base, index))

/*! @brief Set the DMOD field to a new value. */
#define DMA_WR_ATTR_DMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_DMOD_MASK, DMA_ATTR_DMOD(value)))
#define DMA_BWR_ATTR_DMOD(base, index, value) (DMA_WR_ATTR_DMOD(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SSIZE[10:8] (RW)
 *
 * Using a Reserved value causes a configuration error.
 *
 * Values:
 * - 000 - 8-bit
 * - 001 - 16-bit
 * - 010 - 32-bit
 * - 011 - Reserved
 * - 100 - 16-byte burst
 * - 101 - 32-byte burst
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SSIZE field. */
#define DMA_RD_ATTR_SSIZE(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SSIZE_MASK) >> DMA_ATTR_SSIZE_SHIFT)
#define DMA_BRD_ATTR_SSIZE(base, index) (DMA_RD_ATTR_SSIZE(base, index))

/*! @brief Set the SSIZE field to a new value. */
#define DMA_WR_ATTR_SSIZE(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SSIZE_MASK, DMA_ATTR_SSIZE(value)))
#define DMA_BWR_ATTR_SSIZE(base, index, value) (DMA_WR_ATTR_SSIZE(base, index, value))
/*@}*/

/*!
 * @name Register DMA_ATTR, field SMOD[15:11] (RW)
 *
 * Values:
 * - 0 - Source address modulo feature is disabled
 */
/*@{*/
/*! @brief Read current value of the DMA_ATTR_SMOD field. */
#define DMA_RD_ATTR_SMOD(base, index) ((DMA_ATTR_REG(base, index) & DMA_ATTR_SMOD_MASK) >> DMA_ATTR_SMOD_SHIFT)
#define DMA_BRD_ATTR_SMOD(base, index) (DMA_RD_ATTR_SMOD(base, index))

/*! @brief Set the SMOD field to a new value. */
#define DMA_WR_ATTR_SMOD(base, index, value) (DMA_RMW_ATTR(base, index, DMA_ATTR_SMOD_MASK, DMA_ATTR_SMOD(value)))
#define DMA_BWR_ATTR_SMOD(base, index, value) (DMA_WR_ATTR_SMOD(base, index, value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFYES - TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFNO), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and Minor loop offset is enabled (SMLOE
 * or DMLOE = 1) If minor loop mapping is enabled and SMLOE and DMLOE are cleared,
 * then refer to the TCD_NBYTES_MLOFFNO register description. If minor loop
 * mapping is disabled, then refer to the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFYES register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFYES(base, index) (DMA_NBYTES_MLOFFYES_REG(base, index))
#define DMA_WR_NBYTES_MLOFFYES(base, index, value) (DMA_NBYTES_MLOFFYES_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFYES(base, index, mask, value) (DMA_WR_NBYTES_MLOFFYES(base, index, (DMA_RD_NBYTES_MLOFFYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLOFFYES(base, index, value) (DMA_WR_NBYTES_MLOFFYES(base, index, DMA_RD_NBYTES_MLOFFYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFYES bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field NBYTES[9:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_NBYTES_MASK) >> DMA_NBYTES_MLOFFYES_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFYES_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_NBYTES_MASK, DMA_NBYTES_MLOFFYES_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFYES_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFYES_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field MLOFF[29:10] (RW)
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_MLOFF field. */
#define DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_MLOFF_MASK) >> DMA_NBYTES_MLOFFYES_MLOFF_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_MLOFF(base, index) (DMA_RD_NBYTES_MLOFFYES_MLOFF(base, index))

/*! @brief Set the MLOFF field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_MLOFF_MASK, DMA_NBYTES_MLOFFYES_MLOFF(value)))
#define DMA_BWR_NBYTES_MLOFFYES_MLOFF(base, index, value) (DMA_WR_NBYTES_MLOFFYES_MLOFF(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_DMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_DMLOE_MASK) >> DMA_NBYTES_MLOFFYES_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_DMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_DMLOE_MASK, DMA_NBYTES_MLOFFYES_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_DMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFYES, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFYES_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFYES_SMLOE(base, index) ((DMA_NBYTES_MLOFFYES_REG(base, index) & DMA_NBYTES_MLOFFYES_SMLOE_MASK) >> DMA_NBYTES_MLOFFYES_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFYES_SMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFYES_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFYES(base, index, DMA_NBYTES_MLOFFYES_SMLOE_MASK, DMA_NBYTES_MLOFFYES_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFYES_SMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFYES_REG(base, index), DMA_NBYTES_MLOFFYES_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLOFFNO - TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * One of three registers (this register, TCD_NBYTES_MLNO, or
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which register to use
 * depends on whether minor loop mapping is disabled, enabled but not used for
 * this channel, or enabled and used. TCD word 2 is defined as follows if: Minor
 * loop mapping is enabled (CR[EMLM] = 1) and SMLOE = 0 and DMLOE = 0 If minor
 * loop mapping is enabled and SMLOE or DMLOE is set, then refer to the
 * TCD_NBYTES_MLOFFYES register description. If minor loop mapping is disabled, then refer to
 * the TCD_NBYTES_MLNO register description.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLOFFNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLOFFNO(base, index) (DMA_NBYTES_MLOFFNO_REG(base, index))
#define DMA_WR_NBYTES_MLOFFNO(base, index, value) (DMA_NBYTES_MLOFFNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLOFFNO(base, index, mask, value) (DMA_WR_NBYTES_MLOFFNO(base, index, (DMA_RD_NBYTES_MLOFFNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLOFFNO(base, index, value) (DMA_WR_NBYTES_MLOFFNO(base, index, DMA_RD_NBYTES_MLOFFNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_NBYTES_MLOFFNO bitfields
 */

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field NBYTES[29:0] (RW)
 *
 * Number of bytes to be transferred in each service request of the channel. As
 * a channel activates, the appropriate TCD contents load into the eDMA engine,
 * and the appropriate reads and writes perform until the minor byte transfer
 * count has transferred. This is an indivisible operation and cannot be halted. It
 * can, however, be stalled by using the bandwidth control field, or via
 * preemption. After the minor count is exhausted, the SADDR and DADDR values are written
 * back into the TCD memory, the major iteration count is decremented and
 * restored to the TCD memory. If the major iteration count is completed, additional
 * processing is performed.
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_NBYTES field. */
#define DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_NBYTES_MASK) >> DMA_NBYTES_MLOFFNO_NBYTES_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_NBYTES(base, index) (DMA_RD_NBYTES_MLOFFNO_NBYTES(base, index))

/*! @brief Set the NBYTES field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_NBYTES_MASK, DMA_NBYTES_MLOFFNO_NBYTES(value)))
#define DMA_BWR_NBYTES_MLOFFNO_NBYTES(base, index, value) (DMA_WR_NBYTES_MLOFFNO_NBYTES(base, index, value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field DMLOE[30] (RW)
 *
 * Selects whether the minor loop offset is applied to the destination address
 * upon minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the DADDR
 * - 1 - The minor loop offset is applied to the DADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_DMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_DMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_DMLOE_MASK) >> DMA_NBYTES_MLOFFNO_DMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_DMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT))

/*! @brief Set the DMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_DMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_DMLOE_MASK, DMA_NBYTES_MLOFFNO_DMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_DMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_DMLOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_NBYTES_MLOFFNO, field SMLOE[31] (RW)
 *
 * Selects whether the minor loop offset is applied to the source address upon
 * minor loop completion.
 *
 * Values:
 * - 0 - The minor loop offset is not applied to the SADDR
 * - 1 - The minor loop offset is applied to the SADDR
 */
/*@{*/
/*! @brief Read current value of the DMA_NBYTES_MLOFFNO_SMLOE field. */
#define DMA_RD_NBYTES_MLOFFNO_SMLOE(base, index) ((DMA_NBYTES_MLOFFNO_REG(base, index) & DMA_NBYTES_MLOFFNO_SMLOE_MASK) >> DMA_NBYTES_MLOFFNO_SMLOE_SHIFT)
#define DMA_BRD_NBYTES_MLOFFNO_SMLOE(base, index) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT))

/*! @brief Set the SMLOE field to a new value. */
#define DMA_WR_NBYTES_MLOFFNO_SMLOE(base, index, value) (DMA_RMW_NBYTES_MLOFFNO(base, index, DMA_NBYTES_MLOFFNO_SMLOE_MASK, DMA_NBYTES_MLOFFNO_SMLOE(value)))
#define DMA_BWR_NBYTES_MLOFFNO_SMLOE(base, index, value) (BITBAND_ACCESS32(&DMA_NBYTES_MLOFFNO_REG(base, index), DMA_NBYTES_MLOFFNO_SMLOE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_NBYTES_MLNO - TCD Minor Byte Count (Minor Loop Mapping Disabled) (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register, or one of the next two registers (TCD_NBYTES_MLOFFNO,
 * TCD_NBYTES_MLOFFYES), defines the number of bytes to transfer per request. Which
 * register to use depends on whether minor loop mapping is disabled, enabled but not
 * used for this channel, or enabled and used. TCD word 2 is defined as follows
 * if: Minor loop mapping is disabled (CR[EMLM] = 0) If minor loop mapping is
 * enabled, see the TCD_NBYTES_MLOFFNO and TCD_NBYTES_MLOFFYES register descriptions
 * for the definition of TCD word 2.
 */
/*!
 * @name Constants and macros for entire DMA_NBYTES_MLNO register
 */
/*@{*/
#define DMA_RD_NBYTES_MLNO(base, index) (DMA_NBYTES_MLNO_REG(base, index))
#define DMA_WR_NBYTES_MLNO(base, index, value) (DMA_NBYTES_MLNO_REG(base, index) = (value))
#define DMA_RMW_NBYTES_MLNO(base, index, mask, value) (DMA_WR_NBYTES_MLNO(base, index, (DMA_RD_NBYTES_MLNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) |  (value)))
#define DMA_CLR_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) & ~(value)))
#define DMA_TOG_NBYTES_MLNO(base, index, value) (DMA_WR_NBYTES_MLNO(base, index, DMA_RD_NBYTES_MLNO(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_SLAST - TCD Last Source Address Adjustment
 ******************************************************************************/

/*!
 * @brief DMA_SLAST - TCD Last Source Address Adjustment (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_SLAST register
 */
/*@{*/
#define DMA_RD_SLAST(base, index) (DMA_SLAST_REG(base, index))
#define DMA_WR_SLAST(base, index, value) (DMA_SLAST_REG(base, index) = (value))
#define DMA_RMW_SLAST(base, index, mask, value) (DMA_WR_SLAST(base, index, (DMA_RD_SLAST(base, index) & ~(mask)) | (value)))
#define DMA_SET_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) |  (value)))
#define DMA_CLR_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) & ~(value)))
#define DMA_TOG_SLAST(base, index, value) (DMA_WR_SLAST(base, index, DMA_RD_SLAST(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_DADDR - TCD Destination Address
 ******************************************************************************/

/*!
 * @brief DMA_DADDR - TCD Destination Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DADDR register
 */
/*@{*/
#define DMA_RD_DADDR(base, index) (DMA_DADDR_REG(base, index))
#define DMA_WR_DADDR(base, index, value) (DMA_DADDR_REG(base, index) = (value))
#define DMA_RMW_DADDR(base, index, mask, value) (DMA_WR_DADDR(base, index, (DMA_RD_DADDR(base, index) & ~(mask)) | (value)))
#define DMA_SET_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) |  (value)))
#define DMA_CLR_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) & ~(value)))
#define DMA_TOG_DADDR(base, index, value) (DMA_WR_DADDR(base, index, DMA_RD_DADDR(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_DOFF - TCD Signed Destination Address Offset
 ******************************************************************************/

/*!
 * @brief DMA_DOFF - TCD Signed Destination Address Offset (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_DOFF register
 */
/*@{*/
#define DMA_RD_DOFF(base, index) (DMA_DOFF_REG(base, index))
#define DMA_WR_DOFF(base, index, value) (DMA_DOFF_REG(base, index) = (value))
#define DMA_RMW_DOFF(base, index, mask, value) (DMA_WR_DOFF(base, index, (DMA_RD_DOFF(base, index) & ~(mask)) | (value)))
#define DMA_SET_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) |  (value)))
#define DMA_CLR_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) & ~(value)))
#define DMA_TOG_DOFF(base, index, value) (DMA_WR_DOFF(base, index, DMA_RD_DOFF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKNO - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is cleared, the TCDn_CITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_CITER_ELINKNO(base, index) (DMA_CITER_ELINKNO_REG(base, index))
#define DMA_WR_CITER_ELINKNO(base, index, value) (DMA_CITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKNO(base, index, mask, value) (DMA_WR_CITER_ELINKNO(base, index, (DMA_RD_CITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) |  (value)))
#define DMA_CLR_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) & ~(value)))
#define DMA_TOG_CITER_ELINKNO(base, index, value) (DMA_WR_CITER_ELINKNO(base, index, DMA_RD_CITER_ELINKNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKNO, field CITER[14:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_CITER field. */
#define DMA_RD_CITER_ELINKNO_CITER(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_CITER_MASK) >> DMA_CITER_ELINKNO_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKNO_CITER(base, index) (DMA_RD_CITER_ELINKNO_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKNO_CITER(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_CITER_MASK, DMA_CITER_ELINKNO_CITER(value)))
#define DMA_BWR_CITER_ELINKNO_CITER(base, index, value) (DMA_WR_CITER_ELINKNO_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKNO_ELINK field. */
#define DMA_RD_CITER_ELINKNO_ELINK(base, index) ((DMA_CITER_ELINKNO_REG(base, index) & DMA_CITER_ELINKNO_ELINK_MASK) >> DMA_CITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKNO_ELINK(base, index) (BITBAND_ACCESS16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_CITER_ELINKNO(base, index, DMA_CITER_ELINKNO_ELINK_MASK, DMA_CITER_ELINKNO_ELINK(value)))
#define DMA_BWR_CITER_ELINKNO_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CITER_ELINKNO_REG(base, index), DMA_CITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_CITER_ELINKYES - TCD Current Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If TCDn_CITER[ELINK] is set, the TCDn_CITER register is defined as follows.
 */
/*!
 * @name Constants and macros for entire DMA_CITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_CITER_ELINKYES(base, index) (DMA_CITER_ELINKYES_REG(base, index))
#define DMA_WR_CITER_ELINKYES(base, index, value) (DMA_CITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_CITER_ELINKYES(base, index, mask, value) (DMA_WR_CITER_ELINKYES(base, index, (DMA_RD_CITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) |  (value)))
#define DMA_CLR_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) & ~(value)))
#define DMA_TOG_CITER_ELINKYES(base, index, value) (DMA_WR_CITER_ELINKYES(base, index, DMA_RD_CITER_ELINKYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_CITER_ELINKYES, field CITER[8:0] (RW)
 *
 * This 9-bit (ELINK = 1) or 15-bit (ELINK = 0) count represents the current
 * major loop count for the channel. It is decremented each time the minor loop is
 * completed and updated in the transfer control descriptor memory. After the
 * major iteration count is exhausted, the channel performs a number of operations,
 * for example, final source and destination address calculations, optionally
 * generating an interrupt to signal channel completion before reloading the CITER
 * field from the Beginning Iteration Count (BITER) field. When the CITER field is
 * initially loaded by software, it must be set to the same value as that
 * contained in the BITER field. If the channel is configured to execute a single
 * service request, the initial values of BITER and CITER should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_CITER field. */
#define DMA_RD_CITER_ELINKYES_CITER(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_CITER_MASK) >> DMA_CITER_ELINKYES_CITER_SHIFT)
#define DMA_BRD_CITER_ELINKYES_CITER(base, index) (DMA_RD_CITER_ELINKYES_CITER(base, index))

/*! @brief Set the CITER field to a new value. */
#define DMA_WR_CITER_ELINKYES_CITER(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_CITER_MASK, DMA_CITER_ELINKYES_CITER(value)))
#define DMA_BWR_CITER_ELINKYES_CITER(base, index, value) (DMA_WR_CITER_ELINKYES_CITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request to the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_LINKCH field. */
#define DMA_RD_CITER_ELINKYES_LINKCH(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_LINKCH_MASK) >> DMA_CITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_CITER_ELINKYES_LINKCH(base, index) (DMA_RD_CITER_ELINKYES_LINKCH(base, index))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_LINKCH_MASK, DMA_CITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_CITER_ELINKYES_LINKCH(base, index, value) (DMA_WR_CITER_ELINKYES_LINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables linking to another
 * channel, defined by the LINKCH field. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the CITER value
 * is extended to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK
 * channel linking. This bit must be equal to the BITER[ELINK] bit; otherwise, a
 * configuration error is reported.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_CITER_ELINKYES_ELINK field. */
#define DMA_RD_CITER_ELINKYES_ELINK(base, index) ((DMA_CITER_ELINKYES_REG(base, index) & DMA_CITER_ELINKYES_ELINK_MASK) >> DMA_CITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_CITER_ELINKYES_ELINK(base, index) (BITBAND_ACCESS16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_CITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_CITER_ELINKYES(base, index, DMA_CITER_ELINKYES_ELINK_MASK, DMA_CITER_ELINKYES_ELINK(value)))
#define DMA_BWR_CITER_ELINKYES_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CITER_ELINKYES_REG(base, index), DMA_CITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address
 ******************************************************************************/

/*!
 * @brief DMA_DLAST_SGA - TCD Last Destination Address Adjustment/Scatter Gather Address (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire DMA_DLAST_SGA register
 */
/*@{*/
#define DMA_RD_DLAST_SGA(base, index) (DMA_DLAST_SGA_REG(base, index))
#define DMA_WR_DLAST_SGA(base, index, value) (DMA_DLAST_SGA_REG(base, index) = (value))
#define DMA_RMW_DLAST_SGA(base, index, mask, value) (DMA_WR_DLAST_SGA(base, index, (DMA_RD_DLAST_SGA(base, index) & ~(mask)) | (value)))
#define DMA_SET_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) |  (value)))
#define DMA_CLR_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) & ~(value)))
#define DMA_TOG_DLAST_SGA(base, index, value) (DMA_WR_DLAST_SGA(base, index, DMA_RD_DLAST_SGA(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * DMA_CSR - TCD Control and Status
 ******************************************************************************/

/*!
 * @brief DMA_CSR - TCD Control and Status (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire DMA_CSR register
 */
/*@{*/
#define DMA_RD_CSR(base, index)  (DMA_CSR_REG(base, index))
#define DMA_WR_CSR(base, index, value) (DMA_CSR_REG(base, index) = (value))
#define DMA_RMW_CSR(base, index, mask, value) (DMA_WR_CSR(base, index, (DMA_RD_CSR(base, index) & ~(mask)) | (value)))
#define DMA_SET_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) |  (value)))
#define DMA_CLR_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) & ~(value)))
#define DMA_TOG_CSR(base, index, value) (DMA_WR_CSR(base, index, DMA_RD_CSR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_CSR bitfields
 */

/*!
 * @name Register DMA_CSR, field START[0] (RW)
 *
 * If this flag is set, the channel is requesting service. The eDMA hardware
 * automatically clears this flag after the channel begins execution.
 *
 * Values:
 * - 0 - The channel is not explicitly started.
 * - 1 - The channel is explicitly started via a software initiated service
 *     request.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_START field. */
#define DMA_RD_CSR_START(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_START_MASK) >> DMA_CSR_START_SHIFT)
#define DMA_BRD_CSR_START(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT))

/*! @brief Set the START field to a new value. */
#define DMA_WR_CSR_START(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_START_MASK, DMA_CSR_START(value)))
#define DMA_BWR_CSR_START(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_START_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTMAJOR[1] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT when the current major iteration count reaches
 * zero.
 *
 * Values:
 * - 0 - The end-of-major loop interrupt is disabled.
 * - 1 - The end-of-major loop interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTMAJOR field. */
#define DMA_RD_CSR_INTMAJOR(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTMAJOR_MASK) >> DMA_CSR_INTMAJOR_SHIFT)
#define DMA_BRD_CSR_INTMAJOR(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT))

/*! @brief Set the INTMAJOR field to a new value. */
#define DMA_WR_CSR_INTMAJOR(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTMAJOR_MASK, DMA_CSR_INTMAJOR(value)))
#define DMA_BWR_CSR_INTMAJOR(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTMAJOR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field INTHALF[2] (RW)
 *
 * If this flag is set, the channel generates an interrupt request by setting
 * the appropriate bit in the INT register when the current major iteration count
 * reaches the halfway point. Specifically, the comparison performed by the eDMA
 * engine is (CITER == (BITER >> 1)). This halfway point interrupt request is
 * provided to support double-buffered, also known as ping-pong, schemes or other
 * types of data movement where the processor needs an early indication of the
 * transfer's progress. If BITER = 1, do not use INTHALF. Use INTMAJOR instead.
 *
 * Values:
 * - 0 - The half-point interrupt is disabled.
 * - 1 - The half-point interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_INTHALF field. */
#define DMA_RD_CSR_INTHALF(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_INTHALF_MASK) >> DMA_CSR_INTHALF_SHIFT)
#define DMA_BRD_CSR_INTHALF(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT))

/*! @brief Set the INTHALF field to a new value. */
#define DMA_WR_CSR_INTHALF(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_INTHALF_MASK, DMA_CSR_INTHALF(value)))
#define DMA_BWR_CSR_INTHALF(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_INTHALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field DREQ[3] (RW)
 *
 * If this flag is set, the eDMA hardware automatically clears the corresponding
 * ERQ bit when the current major iteration count reaches zero.
 *
 * Values:
 * - 0 - The channel's ERQ bit is not affected.
 * - 1 - The channel's ERQ bit is cleared when the major loop is complete.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DREQ field. */
#define DMA_RD_CSR_DREQ(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DREQ_MASK) >> DMA_CSR_DREQ_SHIFT)
#define DMA_BRD_CSR_DREQ(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT))

/*! @brief Set the DREQ field to a new value. */
#define DMA_WR_CSR_DREQ(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DREQ_MASK, DMA_CSR_DREQ(value)))
#define DMA_BWR_CSR_DREQ(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DREQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field ESG[4] (RW)
 *
 * As the channel completes the major loop, this flag enables scatter/gather
 * processing in the current channel. If enabled, the eDMA engine uses DLASTSGA as a
 * memory pointer to a 0-modulo-32 address containing a 32-byte data structure
 * loaded as the transfer control descriptor into the local memory. To support the
 * dynamic scatter/gather coherency model, this field is forced to zero when
 * written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The current channel's TCD is normal format.
 * - 1 - The current channel's TCD specifies a scatter gather format. The
 *     DLASTSGA field provides a memory pointer to the next TCD to be loaded into this
 *     channel after the major loop completes its execution.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ESG field. */
#define DMA_RD_CSR_ESG(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ESG_MASK) >> DMA_CSR_ESG_SHIFT)
#define DMA_BRD_CSR_ESG(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT))

/*! @brief Set the ESG field to a new value. */
#define DMA_WR_CSR_ESG(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ESG_MASK, DMA_CSR_ESG(value)))
#define DMA_BWR_CSR_ESG(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ESG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORELINK[5] (RW)
 *
 * As the channel completes the major loop, this flag enables the linking to
 * another channel, defined by MAJORLINKCH. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. To support the dynamic linking coherency model,
 * this field is forced to zero when written to while the TCDn_CSR[DONE] bit is set.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled.
 * - 1 - The channel-to-channel linking is enabled.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORELINK field. */
#define DMA_RD_CSR_MAJORELINK(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORELINK_MASK) >> DMA_CSR_MAJORELINK_SHIFT)
#define DMA_BRD_CSR_MAJORELINK(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT))

/*! @brief Set the MAJORELINK field to a new value. */
#define DMA_WR_CSR_MAJORELINK(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORELINK_MASK, DMA_CSR_MAJORELINK(value)))
#define DMA_BWR_CSR_MAJORELINK(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_MAJORELINK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field ACTIVE[6] (RW)
 *
 * This flag signals the channel is currently in execution. It is set when
 * channel service begins, and is cleared by the eDMA as the minor loop completes or
 * when any error condition is detected.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_ACTIVE field. */
#define DMA_RD_CSR_ACTIVE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_ACTIVE_MASK) >> DMA_CSR_ACTIVE_SHIFT)
#define DMA_BRD_CSR_ACTIVE(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT))

/*! @brief Set the ACTIVE field to a new value. */
#define DMA_WR_CSR_ACTIVE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_ACTIVE_MASK, DMA_CSR_ACTIVE(value)))
#define DMA_BWR_CSR_ACTIVE(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_ACTIVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field DONE[7] (RW)
 *
 * This flag indicates the eDMA has completed the major loop. The eDMA engine
 * sets it as the CITER count reaches zero. The software clears it, or the hardware
 * when the channel is activated. This bit must be cleared to write the
 * MAJORELINK or ESG bits.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_DONE field. */
#define DMA_RD_CSR_DONE(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_DONE_MASK) >> DMA_CSR_DONE_SHIFT)
#define DMA_BRD_CSR_DONE(base, index) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT))

/*! @brief Set the DONE field to a new value. */
#define DMA_WR_CSR_DONE(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_DONE_MASK, DMA_CSR_DONE(value)))
#define DMA_BWR_CSR_DONE(base, index, value) (BITBAND_ACCESS16(&DMA_CSR_REG(base, index), DMA_CSR_DONE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMA_CSR, field MAJORLINKCH[11:8] (RW)
 *
 * If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, is
 * performed after the major loop counter is exhausted. Otherwise: After the major
 * loop counter is exhausted, the eDMA engine initiates a channel service request
 * at the channel defined by this field by setting that channel's TCDn_CSR[START]
 * bit.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_MAJORLINKCH field. */
#define DMA_RD_CSR_MAJORLINKCH(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_MAJORLINKCH_MASK) >> DMA_CSR_MAJORLINKCH_SHIFT)
#define DMA_BRD_CSR_MAJORLINKCH(base, index) (DMA_RD_CSR_MAJORLINKCH(base, index))

/*! @brief Set the MAJORLINKCH field to a new value. */
#define DMA_WR_CSR_MAJORLINKCH(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_MAJORLINKCH_MASK, DMA_CSR_MAJORLINKCH(value)))
#define DMA_BWR_CSR_MAJORLINKCH(base, index, value) (DMA_WR_CSR_MAJORLINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_CSR, field BWC[15:14] (RW)
 *
 * Throttles the amount of bus bandwidth consumed by the eDMA. Generally, as the
 * eDMA processes the minor loop, it continuously generates read/write sequences
 * until the minor count is exhausted. This field forces the eDMA to stall after
 * the completion of each read/write access to control the bus request bandwidth
 * seen by the crossbar switch. If the source and destination sizes are equal,
 * this field is ignored between the first and second transfers and after the last
 * write of each minor loop. This behavior is a side effect of reducing start-up
 * latency.
 *
 * Values:
 * - 00 - No eDMA engine stalls.
 * - 01 - Reserved
 * - 10 - eDMA engine stalls for 4 cycles after each R/W.
 * - 11 - eDMA engine stalls for 8 cycles after each R/W.
 */
/*@{*/
/*! @brief Read current value of the DMA_CSR_BWC field. */
#define DMA_RD_CSR_BWC(base, index) ((DMA_CSR_REG(base, index) & DMA_CSR_BWC_MASK) >> DMA_CSR_BWC_SHIFT)
#define DMA_BRD_CSR_BWC(base, index) (DMA_RD_CSR_BWC(base, index))

/*! @brief Set the BWC field to a new value. */
#define DMA_WR_CSR_BWC(base, index, value) (DMA_RMW_CSR(base, index, DMA_CSR_BWC_MASK, DMA_CSR_BWC(value)))
#define DMA_BWR_CSR_BWC(base, index, value) (DMA_WR_CSR_BWC(base, index, value))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKYES - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Enabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is defined as
 * follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKYES register
 */
/*@{*/
#define DMA_RD_BITER_ELINKYES(base, index) (DMA_BITER_ELINKYES_REG(base, index))
#define DMA_WR_BITER_ELINKYES(base, index, value) (DMA_BITER_ELINKYES_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKYES(base, index, mask, value) (DMA_WR_BITER_ELINKYES(base, index, (DMA_RD_BITER_ELINKYES(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) |  (value)))
#define DMA_CLR_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) & ~(value)))
#define DMA_TOG_BITER_ELINKYES(base, index, value) (DMA_WR_BITER_ELINKYES(base, index, DMA_RD_BITER_ELINKYES(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKYES bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKYES, field BITER[8:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field are reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER
 * should be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_BITER field. */
#define DMA_RD_BITER_ELINKYES_BITER(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_BITER_MASK) >> DMA_BITER_ELINKYES_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKYES_BITER(base, index) (DMA_RD_BITER_ELINKYES_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKYES_BITER(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_BITER_MASK, DMA_BITER_ELINKYES_BITER(value)))
#define DMA_BWR_BITER_ELINKYES_BITER(base, index, value) (DMA_WR_BITER_ELINKYES_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field LINKCH[12:9] (RW)
 *
 * If channel-to-channel linking is enabled (ELINK = 1), then after the minor
 * loop is exhausted, the eDMA engine initiates a channel service request at the
 * channel defined by this field by setting that channel's TCDn_CSR[START] bit.
 * When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the major
 * iteration count is exhausted, the contents of this field are reloaded into the
 * CITER field.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_LINKCH field. */
#define DMA_RD_BITER_ELINKYES_LINKCH(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_LINKCH_MASK) >> DMA_BITER_ELINKYES_LINKCH_SHIFT)
#define DMA_BRD_BITER_ELINKYES_LINKCH(base, index) (DMA_RD_BITER_ELINKYES_LINKCH(base, index))

/*! @brief Set the LINKCH field to a new value. */
#define DMA_WR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_LINKCH_MASK, DMA_BITER_ELINKYES_LINKCH(value)))
#define DMA_BWR_BITER_ELINKYES_LINKCH(base, index, value) (DMA_WR_BITER_ELINKYES_LINKCH(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKYES, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking disables, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded into
 * the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKYES_ELINK field. */
#define DMA_RD_BITER_ELINKYES_ELINK(base, index) ((DMA_BITER_ELINKYES_REG(base, index) & DMA_BITER_ELINKYES_ELINK_MASK) >> DMA_BITER_ELINKYES_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKYES_ELINK(base, index) (BITBAND_ACCESS16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKYES_ELINK(base, index, value) (DMA_RMW_BITER_ELINKYES(base, index, DMA_BITER_ELINKYES_ELINK_MASK, DMA_BITER_ELINKYES_ELINK(value)))
#define DMA_BWR_BITER_ELINKYES_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_BITER_ELINKYES_REG(base, index), DMA_BITER_ELINKYES_ELINK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled)
 ******************************************************************************/

/*!
 * @brief DMA_BITER_ELINKNO - TCD Beginning Minor Loop Link, Major Loop Count (Channel Linking Disabled) (RW)
 *
 * Reset value: 0x0000U
 *
 * If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is defined
 * as follows.
 */
/*!
 * @name Constants and macros for entire DMA_BITER_ELINKNO register
 */
/*@{*/
#define DMA_RD_BITER_ELINKNO(base, index) (DMA_BITER_ELINKNO_REG(base, index))
#define DMA_WR_BITER_ELINKNO(base, index, value) (DMA_BITER_ELINKNO_REG(base, index) = (value))
#define DMA_RMW_BITER_ELINKNO(base, index, mask, value) (DMA_WR_BITER_ELINKNO(base, index, (DMA_RD_BITER_ELINKNO(base, index) & ~(mask)) | (value)))
#define DMA_SET_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) |  (value)))
#define DMA_CLR_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) & ~(value)))
#define DMA_TOG_BITER_ELINKNO(base, index, value) (DMA_WR_BITER_ELINKNO(base, index, DMA_RD_BITER_ELINKNO(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMA_BITER_ELINKNO bitfields
 */

/*!
 * @name Register DMA_BITER_ELINKNO, field BITER[14:0] (RW)
 *
 * As the transfer control descriptor is first loaded by software, this 9-bit
 * (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the value in the CITER
 * field. As the major iteration count is exhausted, the contents of this field
 * are reloaded into the CITER field. When the software loads the TCD, this field
 * must be set equal to the corresponding CITER field; otherwise, a configuration
 * error is reported. As the major iteration count is exhausted, the contents of
 * this field is reloaded into the CITER field. If the channel is configured to
 * execute a single service request, the initial values of BITER and CITER should
 * be 0x0001.
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_BITER field. */
#define DMA_RD_BITER_ELINKNO_BITER(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_BITER_MASK) >> DMA_BITER_ELINKNO_BITER_SHIFT)
#define DMA_BRD_BITER_ELINKNO_BITER(base, index) (DMA_RD_BITER_ELINKNO_BITER(base, index))

/*! @brief Set the BITER field to a new value. */
#define DMA_WR_BITER_ELINKNO_BITER(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_BITER_MASK, DMA_BITER_ELINKNO_BITER(value)))
#define DMA_BWR_BITER_ELINKNO_BITER(base, index, value) (DMA_WR_BITER_ELINKNO_BITER(base, index, value))
/*@}*/

/*!
 * @name Register DMA_BITER_ELINKNO, field ELINK[15] (RW)
 *
 * As the channel completes the minor loop, this flag enables the linking to
 * another channel, defined by BITER[LINKCH]. The link target channel initiates a
 * channel service request via an internal mechanism that sets the TCDn_CSR[START]
 * bit of the specified channel. If channel linking is disabled, the BITER value
 * extends to 15 bits in place of a link channel number. If the major loop is
 * exhausted, this link mechanism is suppressed in favor of the MAJORELINK channel
 * linking. When the software loads the TCD, this field must be set equal to the
 * corresponding CITER field; otherwise, a configuration error is reported. As the
 * major iteration count is exhausted, the contents of this field are reloaded
 * into the CITER field.
 *
 * Values:
 * - 0 - The channel-to-channel linking is disabled
 * - 1 - The channel-to-channel linking is enabled
 */
/*@{*/
/*! @brief Read current value of the DMA_BITER_ELINKNO_ELINK field. */
#define DMA_RD_BITER_ELINKNO_ELINK(base, index) ((DMA_BITER_ELINKNO_REG(base, index) & DMA_BITER_ELINKNO_ELINK_MASK) >> DMA_BITER_ELINKNO_ELINK_SHIFT)
#define DMA_BRD_BITER_ELINKNO_ELINK(base, index) (BITBAND_ACCESS16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT))

/*! @brief Set the ELINK field to a new value. */
#define DMA_WR_BITER_ELINKNO_ELINK(base, index, value) (DMA_RMW_BITER_ELINKNO(base, index, DMA_BITER_ELINKNO_ELINK_MASK, DMA_BITER_ELINKNO_ELINK(value)))
#define DMA_BWR_BITER_ELINKNO_ELINK(base, index, value) (BITBAND_ACCESS16(&DMA_BITER_ELINKNO_REG(base, index), DMA_BITER_ELINKNO_ELINK_SHIFT) = (value))
/*@}*/

/* Register macros for indexed access to DMA channel priority registers */
/*
 * Constants and macros for entire DMA_DCHPRIn register
 */
#define DMA_DCHPRIn_INDEX(channel)          (((channel) & ~0x03U) | (3 - ((channel) & 0x03U)))
#define DMA_DCHPRIn_REG(base, index)        (((volatile uint8_t *)&DMA_DCHPRI3_REG(base))[DMA_DCHPRIn_INDEX(index)])
#define DMA_RD_DCHPRIn(base, index)         (DMA_DCHPRIn_REG((base), (index)))
#define DMA_WR_DCHPRIn(base, index, value)  (DMA_DCHPRIn_REG((base), (index)) = (value))
#define DMA_SET_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) |  (value)))
#define DMA_CLR_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) & ~(value)))
#define DMA_TOG_DCHPRIn(base, index, value) (DMA_WR_DCHPRIn((base), (index), DMA_RD_DCHPRIn((base), (index)) ^  (value)))

/*
 * Register DMA_DCHPRIn, bit field CHPRI
 */
/* Read current value of the CHPRI bit field. */
#define DMA_RD_DCHPRIn_CHPRI(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_CHPRI_MASK) >> DMA_DCHPRI0_CHPRI_SHIFT)
#define DMA_BRD_DCHPRIn_CHPRI(base, index) (DMA_RD_DCHPRIn_CHPRI((base), (index)))

/* Set the CHPRI bit field to a new value. */
#define DMA_WR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_CHPRI_MASK) | DMA_DCHPRI0_CHPRI(value)))
#define DMA_BWR_DCHPRIn_CHPRI(base, index, value) (DMA_WR_DCHPRIn_CHPRI((base), (index), (value)))

/*
 * Register DMA_DCHPRIn, bit field DPA
 */
/* Read current value of the DPA bit field. */
#define DMA_RD_DCHPRIn_DPA(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_DPA_MASK) >> DMA_DCHPRI0_DPA_SHIFT)
#define DMA_BRD_DCHPRIn_DPA(base, index) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT))

/* Set the DPA bit field to a new value. */
#define DMA_WR_DCHPRIn_DPA(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_DPA_MASK) | DMA_DCHPRI0_DPA(value)))
#define DMA_BWR_DCHPRIn_DPA(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_DPA_SHIFT) = (value))

/*
 * Register DMA_DCHPRIn, bit field ECP
 */
/* Read current value of the ECP bit field. */
#define DMA_RD_DCHPRIn_ECP(base, index) ((DMA_DCHPRIn_REG((base), (index)) & DMA_DCHPRI0_ECP_MASK) >> DMA_DCHPRI0_ECP_SHIFT)
#define DMA_BRD_DCHPRIn_ECP(base, index) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT))

/* Set the ECP bit field to a new value. */
#define DMA_WR_DCHPRIn_ECP(base, index, value) (DMA_WR_DCHPRIn((base), (index), (DMA_RD_DCHPRIn((base), (index)) & ~DMA_DCHPRI0_ECP_MASK) | DMA_DCHPRI0_ECP(value)))
#define DMA_BWR_DCHPRIn_ECP(base, index, value) (BITBAND_ACCESS8(&DMA_DCHPRIn_REG((base), (index)), DMA_DCHPRI0_ECP_SHIFT) = (value))

/*
 * MKS22F25612 DMAMUX
 *
 * DMA channel multiplexor
 *
 * Registers defined in this header file:
 * - DMAMUX_CHCFG - Channel Configuration register
 */

#define DMAMUX_INSTANCE_COUNT (1U) /*!< Number of instances of the DMAMUX module. */
#define DMAMUX_IDX (0U) /*!< Instance number for DMAMUX. */

/*******************************************************************************
 * DMAMUX_CHCFG - Channel Configuration register
 ******************************************************************************/

/*!
 * @brief DMAMUX_CHCFG - Channel Configuration register (RW)
 *
 * Reset value: 0x00U
 *
 * Each of the DMA channels can be independently enabled/disabled and associated
 * with one of the DMA slots (peripheral slots or always-on slots) in the
 * system. Setting multiple CHCFG registers with the same source value will result in
 * unpredictable behavior. This is true, even if a channel is disabled (ENBL==0).
 * Before changing the trigger or source settings, a DMA channel must be disabled
 * via CHCFGn[ENBL].
 */
/*!
 * @name Constants and macros for entire DMAMUX_CHCFG register
 */
/*@{*/
#define DMAMUX_RD_CHCFG(base, index) (DMAMUX_CHCFG_REG(base, index))
#define DMAMUX_WR_CHCFG(base, index, value) (DMAMUX_CHCFG_REG(base, index) = (value))
#define DMAMUX_RMW_CHCFG(base, index, mask, value) (DMAMUX_WR_CHCFG(base, index, (DMAMUX_RD_CHCFG(base, index) & ~(mask)) | (value)))
#define DMAMUX_SET_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) |  (value)))
#define DMAMUX_CLR_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) & ~(value)))
#define DMAMUX_TOG_CHCFG(base, index, value) (DMAMUX_WR_CHCFG(base, index, DMAMUX_RD_CHCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual DMAMUX_CHCFG bitfields
 */

/*!
 * @name Register DMAMUX_CHCFG, field SOURCE[5:0] (RW)
 *
 * Specifies which DMA source, if any, is routed to a particular DMA channel.
 * See the chip-specific DMAMUX information for details about the peripherals and
 * their slot numbers.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_SOURCE field. */
#define DMAMUX_RD_CHCFG_SOURCE(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_SOURCE_MASK) >> DMAMUX_CHCFG_SOURCE_SHIFT)
#define DMAMUX_BRD_CHCFG_SOURCE(base, index) (DMAMUX_RD_CHCFG_SOURCE(base, index))

/*! @brief Set the SOURCE field to a new value. */
#define DMAMUX_WR_CHCFG_SOURCE(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_SOURCE_MASK, DMAMUX_CHCFG_SOURCE(value)))
#define DMAMUX_BWR_CHCFG_SOURCE(base, index, value) (DMAMUX_WR_CHCFG_SOURCE(base, index, value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field TRIG[6] (RW)
 *
 * Enables the periodic trigger capability for the triggered DMA channel.
 *
 * Values:
 * - 0 - Triggering is disabled. If triggering is disabled and ENBL is set, the
 *     DMA Channel will simply route the specified source to the DMA channel.
 *     (Normal mode)
 * - 1 - Triggering is enabled. If triggering is enabled and ENBL is set, the
 *     DMAMUX is in Periodic Trigger mode.
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_TRIG field. */
#define DMAMUX_RD_CHCFG_TRIG(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_TRIG_MASK) >> DMAMUX_CHCFG_TRIG_SHIFT)
#define DMAMUX_BRD_CHCFG_TRIG(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT))

/*! @brief Set the TRIG field to a new value. */
#define DMAMUX_WR_CHCFG_TRIG(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_TRIG_MASK, DMAMUX_CHCFG_TRIG(value)))
#define DMAMUX_BWR_CHCFG_TRIG(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_TRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register DMAMUX_CHCFG, field ENBL[7] (RW)
 *
 * Enables the DMA channel.
 *
 * Values:
 * - 0 - DMA channel is disabled. This mode is primarily used during
 *     configuration of the DMAMux. The DMA has separate channel enables/disables, which
 *     should be used to disable or reconfigure a DMA channel.
 * - 1 - DMA channel is enabled
 */
/*@{*/
/*! @brief Read current value of the DMAMUX_CHCFG_ENBL field. */
#define DMAMUX_RD_CHCFG_ENBL(base, index) ((DMAMUX_CHCFG_REG(base, index) & DMAMUX_CHCFG_ENBL_MASK) >> DMAMUX_CHCFG_ENBL_SHIFT)
#define DMAMUX_BRD_CHCFG_ENBL(base, index) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT))

/*! @brief Set the ENBL field to a new value. */
#define DMAMUX_WR_CHCFG_ENBL(base, index, value) (DMAMUX_RMW_CHCFG(base, index, DMAMUX_CHCFG_ENBL_MASK, DMAMUX_CHCFG_ENBL(value)))
#define DMAMUX_BWR_CHCFG_ENBL(base, index, value) (BITBAND_ACCESS8(&DMAMUX_CHCFG_REG(base, index), DMAMUX_CHCFG_ENBL_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 EWM
 *
 * External Watchdog Monitor
 *
 * Registers defined in this header file:
 * - EWM_CTRL - Control Register
 * - EWM_SERV - Service Register
 * - EWM_CMPL - Compare Low Register
 * - EWM_CMPH - Compare High Register
 * - EWM_CLKPRESCALER - Clock Prescaler Register
 */

#define EWM_INSTANCE_COUNT (1U) /*!< Number of instances of the EWM module. */
#define EWM_IDX (0U) /*!< Instance number for EWM. */

/*******************************************************************************
 * EWM_CTRL - Control Register
 ******************************************************************************/

/*!
 * @brief EWM_CTRL - Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CTRL register is cleared by any reset. INEN, ASSIN and EWMEN bits can be
 * written once after a CPU reset. Modifying these bits more than once, generates
 * a bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CTRL register
 */
/*@{*/
#define EWM_RD_CTRL(base)        (EWM_CTRL_REG(base))
#define EWM_WR_CTRL(base, value) (EWM_CTRL_REG(base) = (value))
#define EWM_RMW_CTRL(base, mask, value) (EWM_WR_CTRL(base, (EWM_RD_CTRL(base) & ~(mask)) | (value)))
#define EWM_SET_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) |  (value)))
#define EWM_CLR_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) & ~(value)))
#define EWM_TOG_CTRL(base, value) (EWM_WR_CTRL(base, EWM_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual EWM_CTRL bitfields
 */

/*!
 * @name Register EWM_CTRL, field EWMEN[0] (RW)
 *
 * This bit when set, enables the EWM module. This resets the EWM counter to
 * zero and deasserts the EWM_out signal. Clearing EWMEN bit disables the EWM, and
 * therefore it cannot be enabled until a reset occurs, due to the write-once
 * nature of this bit.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_EWMEN field. */
#define EWM_RD_CTRL_EWMEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_EWMEN_MASK) >> EWM_CTRL_EWMEN_SHIFT)
#define EWM_BRD_CTRL_EWMEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT))

/*! @brief Set the EWMEN field to a new value. */
#define EWM_WR_CTRL_EWMEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_EWMEN_MASK, EWM_CTRL_EWMEN(value)))
#define EWM_BWR_CTRL_EWMEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_EWMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field ASSIN[1] (RW)
 *
 * Default assert state of the EWM_in signal is logic zero. Setting ASSIN bit
 * inverts the assert state to a logic one.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_ASSIN field. */
#define EWM_RD_CTRL_ASSIN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_ASSIN_MASK) >> EWM_CTRL_ASSIN_SHIFT)
#define EWM_BRD_CTRL_ASSIN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT))

/*! @brief Set the ASSIN field to a new value. */
#define EWM_WR_CTRL_ASSIN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_ASSIN_MASK, EWM_CTRL_ASSIN(value)))
#define EWM_BWR_CTRL_ASSIN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_ASSIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INEN[2] (RW)
 *
 * This bit when set, enables the EWM_in port.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INEN field. */
#define EWM_RD_CTRL_INEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INEN_MASK) >> EWM_CTRL_INEN_SHIFT)
#define EWM_BRD_CTRL_INEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT))

/*! @brief Set the INEN field to a new value. */
#define EWM_WR_CTRL_INEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INEN_MASK, EWM_CTRL_INEN(value)))
#define EWM_BWR_CTRL_INEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register EWM_CTRL, field INTEN[3] (RW)
 *
 * This bit when set and EWM_out is asserted, an interrupt request is generated.
 * To de-assert interrupt request, user should clear this bit by writing 0.
 */
/*@{*/
/*! @brief Read current value of the EWM_CTRL_INTEN field. */
#define EWM_RD_CTRL_INTEN(base) ((EWM_CTRL_REG(base) & EWM_CTRL_INTEN_MASK) >> EWM_CTRL_INTEN_SHIFT)
#define EWM_BRD_CTRL_INTEN(base) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT))

/*! @brief Set the INTEN field to a new value. */
#define EWM_WR_CTRL_INTEN(base, value) (EWM_RMW_CTRL(base, EWM_CTRL_INTEN_MASK, EWM_CTRL_INTEN(value)))
#define EWM_BWR_CTRL_INTEN(base, value) (BITBAND_ACCESS8(&EWM_CTRL_REG(base), EWM_CTRL_INTEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * EWM_SERV - Service Register
 ******************************************************************************/

/*!
 * @brief EWM_SERV - Service Register (WORZ)
 *
 * Reset value: 0x00U
 *
 * The SERV register provides the interface from the CPU to the EWM module. It
 * is write-only and reads of this register return zero.
 */
/*!
 * @name Constants and macros for entire EWM_SERV register
 */
/*@{*/
#define EWM_RD_SERV(base)        (EWM_SERV_REG(base))
#define EWM_WR_SERV(base, value) (EWM_SERV_REG(base) = (value))
#define EWM_RMW_SERV(base, mask, value) (EWM_WR_SERV(base, (EWM_RD_SERV(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPL - Compare Low Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPL - Compare Low Register (RW)
 *
 * Reset value: 0x00U
 *
 * The CMPL register is reset to zero after a CPU reset. This provides no
 * minimum time for the CPU to service the EWM counter. This register can be written
 * only once after a CPU reset. Writing this register more than once generates a
 * bus transfer error.
 */
/*!
 * @name Constants and macros for entire EWM_CMPL register
 */
/*@{*/
#define EWM_RD_CMPL(base)        (EWM_CMPL_REG(base))
#define EWM_WR_CMPL(base, value) (EWM_CMPL_REG(base) = (value))
#define EWM_RMW_CMPL(base, mask, value) (EWM_WR_CMPL(base, (EWM_RD_CMPL(base) & ~(mask)) | (value)))
#define EWM_SET_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) |  (value)))
#define EWM_CLR_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) & ~(value)))
#define EWM_TOG_CMPL(base, value) (EWM_WR_CMPL(base, EWM_RD_CMPL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * EWM_CMPH - Compare High Register
 ******************************************************************************/

/*!
 * @brief EWM_CMPH - Compare High Register (RW)
 *
 * Reset value: 0xFFU
 *
 * The CMPH register is reset to 0xFF after a CPU reset. This provides a maximum
 * of 256 clocks time, for the CPU to service the EWM counter. This register can
 * be written only once after a CPU reset. Writing this register more than once
 * generates a bus transfer error. The valid values for CMPH are up to 0xFE
 * because the EWM counter never expires when CMPH = 0xFF. The expiration happens only
 * if EWM counter is greater than CMPH.
 */
/*!
 * @name Constants and macros for entire EWM_CMPH register
 */
/*@{*/
#define EWM_RD_CMPH(base)        (EWM_CMPH_REG(base))
#define EWM_WR_CMPH(base, value) (EWM_CMPH_REG(base) = (value))
#define EWM_RMW_CMPH(base, mask, value) (EWM_WR_CMPH(base, (EWM_RD_CMPH(base) & ~(mask)) | (value)))
#define EWM_SET_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) |  (value)))
#define EWM_CLR_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) & ~(value)))
#define EWM_TOG_CMPH(base, value) (EWM_WR_CMPH(base, EWM_RD_CMPH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * EWM_CLKPRESCALER - Clock Prescaler Register
 ******************************************************************************/

/*!
 * @brief EWM_CLKPRESCALER - Clock Prescaler Register (RW)
 *
 * Reset value: 0x00U
 *
 * This CLKPRESCALER register is reset to 0x00 after a CPU reset. This register
 * can be written only once after a CPU reset. Writing this register more than
 * once generates a bus transfer error. Write the required prescaler value before
 * enabling the EWM. The implementation of this register is chip-specific. See the
 * Chip Configuration details.
 */
/*!
 * @name Constants and macros for entire EWM_CLKPRESCALER register
 */
/*@{*/
#define EWM_RD_CLKPRESCALER(base) (EWM_CLKPRESCALER_REG(base))
#define EWM_WR_CLKPRESCALER(base, value) (EWM_CLKPRESCALER_REG(base) = (value))
#define EWM_RMW_CLKPRESCALER(base, mask, value) (EWM_WR_CLKPRESCALER(base, (EWM_RD_CLKPRESCALER(base) & ~(mask)) | (value)))
#define EWM_SET_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) |  (value)))
#define EWM_CLR_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) & ~(value)))
#define EWM_TOG_CLKPRESCALER(base, value) (EWM_WR_CLKPRESCALER(base, EWM_RD_CLKPRESCALER(base) ^  (value)))
/*@}*/

/*
 * MKS22F25612 FLEXIO
 *
 * The FLEXIO Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - FLEXIO_VERID - Version ID Register
 * - FLEXIO_PARAM - Parameter Register
 * - FLEXIO_CTRL - FlexIO Control Register
 * - FLEXIO_PIN - Pin State Register
 * - FLEXIO_SHIFTSTAT - Shifter Status Register
 * - FLEXIO_SHIFTERR - Shifter Error Register
 * - FLEXIO_TIMSTAT - Timer Status Register
 * - FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 * - FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 * - FLEXIO_TIMIEN - Timer Interrupt Enable Register
 * - FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 * - FLEXIO_SHIFTCTL - Shifter Control N Register
 * - FLEXIO_SHIFTCFG - Shifter Configuration N Register
 * - FLEXIO_SHIFTBUF - Shifter Buffer N Register
 * - FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 * - FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 * - FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 * - FLEXIO_TIMCTL - Timer Control N Register
 * - FLEXIO_TIMCFG - Timer Configuration N Register
 * - FLEXIO_TIMCMP - Timer Compare N Register
 */

#define FLEXIO_INSTANCE_COUNT (1U) /*!< Number of instances of the FLEXIO module. */
#define FLEXIO_IDX (0U) /*!< Instance number for FLEXIO. */

/*******************************************************************************
 * FLEXIO_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01010000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_VERID register
 */
/*@{*/
#define FLEXIO_RD_VERID(base)    (FLEXIO_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_VERID bitfields
 */

/*!
 * @name Register FLEXIO_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 0 - Standard features implemented.
 * - 1 - Supports state, logic and parallel modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_FEATURE field. */
#define FLEXIO_RD_VERID_FEATURE(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_FEATURE_MASK) >> FLEXIO_VERID_FEATURE_SHIFT)
#define FLEXIO_BRD_VERID_FEATURE(base) (FLEXIO_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MINOR field. */
#define FLEXIO_RD_VERID_MINOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MINOR_MASK) >> FLEXIO_VERID_MINOR_SHIFT)
#define FLEXIO_BRD_VERID_MINOR(base) (FLEXIO_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register FLEXIO_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_VERID_MAJOR field. */
#define FLEXIO_RD_VERID_MAJOR(base) ((FLEXIO_VERID_REG(base) & FLEXIO_VERID_MAJOR_MASK) >> FLEXIO_VERID_MAJOR_SHIFT)
#define FLEXIO_BRD_VERID_MAJOR(base) (FLEXIO_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x10080404U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_PARAM register
 */
/*@{*/
#define FLEXIO_RD_PARAM(base)    (FLEXIO_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PARAM bitfields
 */

/*!
 * @name Register FLEXIO_PARAM, field SHIFTER[7:0] (RO)
 *
 * Number of Shifters implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_SHIFTER field. */
#define FLEXIO_RD_PARAM_SHIFTER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_SHIFTER_MASK) >> FLEXIO_PARAM_SHIFTER_SHIFT)
#define FLEXIO_BRD_PARAM_SHIFTER(base) (FLEXIO_RD_PARAM_SHIFTER(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TIMER[15:8] (RO)
 *
 * Number of Timers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TIMER field. */
#define FLEXIO_RD_PARAM_TIMER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TIMER_MASK) >> FLEXIO_PARAM_TIMER_SHIFT)
#define FLEXIO_BRD_PARAM_TIMER(base) (FLEXIO_RD_PARAM_TIMER(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field PIN[23:16] (RO)
 *
 * Number of Pins implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_PIN field. */
#define FLEXIO_RD_PARAM_PIN(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_PIN_MASK) >> FLEXIO_PARAM_PIN_SHIFT)
#define FLEXIO_BRD_PARAM_PIN(base) (FLEXIO_RD_PARAM_PIN(base))
/*@}*/

/*!
 * @name Register FLEXIO_PARAM, field TRIGGER[31:24] (RO)
 *
 * Number of external triggers implemented.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PARAM_TRIGGER field. */
#define FLEXIO_RD_PARAM_TRIGGER(base) ((FLEXIO_PARAM_REG(base) & FLEXIO_PARAM_TRIGGER_MASK) >> FLEXIO_PARAM_TRIGGER_SHIFT)
#define FLEXIO_BRD_PARAM_TRIGGER(base) (FLEXIO_RD_PARAM_TRIGGER(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_CTRL - FlexIO Control Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_CTRL - FlexIO Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_CTRL register
 */
/*@{*/
#define FLEXIO_RD_CTRL(base)     (FLEXIO_CTRL_REG(base))
#define FLEXIO_WR_CTRL(base, value) (FLEXIO_CTRL_REG(base) = (value))
#define FLEXIO_RMW_CTRL(base, mask, value) (FLEXIO_WR_CTRL(base, (FLEXIO_RD_CTRL(base) & ~(mask)) | (value)))
#define FLEXIO_SET_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) |  (value)))
#define FLEXIO_CLR_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) & ~(value)))
#define FLEXIO_TOG_CTRL(base, value) (FLEXIO_WR_CTRL(base, FLEXIO_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_CTRL bitfields
 */

/*!
 * @name Register FLEXIO_CTRL, field FLEXEN[0] (RW)
 *
 * Values:
 * - 0 - FlexIO module is disabled.
 * - 1 - FlexIO module is enabled.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FLEXEN field. */
#define FLEXIO_RD_CTRL_FLEXEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FLEXEN_MASK) >> FLEXIO_CTRL_FLEXEN_SHIFT)
#define FLEXIO_BRD_CTRL_FLEXEN(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FLEXEN_SHIFT))

/*! @brief Set the FLEXEN field to a new value. */
#define FLEXIO_WR_CTRL_FLEXEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FLEXEN_MASK, FLEXIO_CTRL_FLEXEN(value)))
#define FLEXIO_BWR_CTRL_FLEXEN(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FLEXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field SWRST[1] (RW)
 *
 * The FlexIO Control Register is not affected by the software reset, all other
 * logic in the FlexIO is affected by the software reset and register accesses
 * are ignored until this bit is cleared. This register bit will remain set until
 * cleared by software, and the reset has cleared in the FlexIO clock domain.
 *
 * Values:
 * - 0 - Software reset is disabled
 * - 1 - Software reset is enabled, all FlexIO registers except the Control
 *     Register are reset.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_SWRST field. */
#define FLEXIO_RD_CTRL_SWRST(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_SWRST_MASK) >> FLEXIO_CTRL_SWRST_SHIFT)
#define FLEXIO_BRD_CTRL_SWRST(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_SWRST_SHIFT))

/*! @brief Set the SWRST field to a new value. */
#define FLEXIO_WR_CTRL_SWRST(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_SWRST_MASK, FLEXIO_CTRL_SWRST(value)))
#define FLEXIO_BWR_CTRL_SWRST(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_SWRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field FASTACC[2] (RW)
 *
 * Enables fast register accesses to FlexIO registers, but requires the FlexIO
 * clock to be at least twice the frequency of the bus clock.
 *
 * Values:
 * - 0 - Configures for normal register accesses to FlexIO
 * - 1 - Configures for fast register accesses to FlexIO
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_FASTACC field. */
#define FLEXIO_RD_CTRL_FASTACC(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_FASTACC_MASK) >> FLEXIO_CTRL_FASTACC_SHIFT)
#define FLEXIO_BRD_CTRL_FASTACC(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FASTACC_SHIFT))

/*! @brief Set the FASTACC field to a new value. */
#define FLEXIO_WR_CTRL_FASTACC(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_FASTACC_MASK, FLEXIO_CTRL_FASTACC(value)))
#define FLEXIO_BWR_CTRL_FASTACC(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_FASTACC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DBGE[30] (RW)
 *
 * Enables FlexIO operation in Debug mode.
 *
 * Values:
 * - 0 - FlexIO is disabled in debug modes.
 * - 1 - FlexIO is enabled in debug modes
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DBGE field. */
#define FLEXIO_RD_CTRL_DBGE(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DBGE_MASK) >> FLEXIO_CTRL_DBGE_SHIFT)
#define FLEXIO_BRD_CTRL_DBGE(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define FLEXIO_WR_CTRL_DBGE(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DBGE_MASK, FLEXIO_CTRL_DBGE(value)))
#define FLEXIO_BWR_CTRL_DBGE(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_CTRL, field DOZEN[31] (RW)
 *
 * Disables FlexIO operation in Doze modes. This field is ignored and the FlexIO
 * always disabled in low-leakage stop modes.
 *
 * Values:
 * - 0 - FlexIO enabled in Doze modes.
 * - 1 - FlexIO disabled in Doze modes.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_CTRL_DOZEN field. */
#define FLEXIO_RD_CTRL_DOZEN(base) ((FLEXIO_CTRL_REG(base) & FLEXIO_CTRL_DOZEN_MASK) >> FLEXIO_CTRL_DOZEN_SHIFT)
#define FLEXIO_BRD_CTRL_DOZEN(base) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DOZEN_SHIFT))

/*! @brief Set the DOZEN field to a new value. */
#define FLEXIO_WR_CTRL_DOZEN(base, value) (FLEXIO_RMW_CTRL(base, FLEXIO_CTRL_DOZEN_MASK, FLEXIO_CTRL_DOZEN(value)))
#define FLEXIO_BWR_CTRL_DOZEN(base, value) (BITBAND_ACCESS32(&FLEXIO_CTRL_REG(base), FLEXIO_CTRL_DOZEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FLEXIO_PIN - Pin State Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_PIN - Pin State Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire FLEXIO_PIN register
 */
/*@{*/
#define FLEXIO_RD_PIN(base)      (FLEXIO_PIN_REG(base))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_PIN bitfields
 */

/*!
 * @name Register FLEXIO_PIN, field PDI[7:0] (RO)
 *
 * Returns the input data on each of the FlexIO pins.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_PIN_PDI field. */
#define FLEXIO_RD_PIN_PDI(base) ((FLEXIO_PIN_REG(base) & FLEXIO_PIN_PDI_MASK) >> FLEXIO_PIN_PDI_SHIFT)
#define FLEXIO_BRD_PIN_PDI(base) (FLEXIO_RD_PIN_PDI(base))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSTAT - Shifter Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSTAT - Shifter Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSTAT register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSTAT(base) (FLEXIO_SHIFTSTAT_REG(base))
#define FLEXIO_WR_SHIFTSTAT(base, value) (FLEXIO_SHIFTSTAT_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSTAT(base, mask, value) (FLEXIO_WR_SHIFTSTAT(base, (FLEXIO_RD_SHIFTSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) |  (value)))
#define FLEXIO_CLR_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSTAT(base, value) (FLEXIO_WR_SHIFTSTAT(base, FLEXIO_RD_SHIFTSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSTAT bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSTAT, field SSF[3:0] (W1C)
 *
 * The shifter status flag is updated when one of the following events occurs:
 * For SMOD=Receive, the status flag is set when SHIFTBUF has been loaded with
 * data from Shifter (SHIFTBUF is full), and the status flag is cleared when
 * SHIFTBUF register is read. For SMOD=Transmit, the status flag is set when SHIFTBUF
 * data has been transferred to the Shifter (SHIFTBUF is empty) or when initially
 * configured for SMOD=Transmit, and the status flag is cleared when the SHIFTBUF
 * register is written. For SMOD=Match Store, the status flag is set when a match
 * has occured between SHIFTBUF and Shifter, and the status flag is cleared when
 * the SHIFTBUF register is read. For SMOD=Match Continuous, returns the current
 * match result between the SHIFTBUF and Shifter. The status flag can also be
 * cleared by writing a logic one to the flag for all modes except Match Continuous.
 *
 * Values:
 * - 0 - Status flag is clear
 * - 1 - Status flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSTAT_SSF field. */
#define FLEXIO_RD_SHIFTSTAT_SSF(base) ((FLEXIO_SHIFTSTAT_REG(base) & FLEXIO_SHIFTSTAT_SSF_MASK) >> FLEXIO_SHIFTSTAT_SSF_SHIFT)
#define FLEXIO_BRD_SHIFTSTAT_SSF(base) (FLEXIO_RD_SHIFTSTAT_SSF(base))

/*! @brief Set the SSF field to a new value. */
#define FLEXIO_WR_SHIFTSTAT_SSF(base, value) (FLEXIO_RMW_SHIFTSTAT(base, FLEXIO_SHIFTSTAT_SSF_MASK, FLEXIO_SHIFTSTAT_SSF(value)))
#define FLEXIO_BWR_SHIFTSTAT_SSF(base, value) (FLEXIO_WR_SHIFTSTAT_SSF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTERR - Shifter Error Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTERR - Shifter Error Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTERR register
 */
/*@{*/
#define FLEXIO_RD_SHIFTERR(base) (FLEXIO_SHIFTERR_REG(base))
#define FLEXIO_WR_SHIFTERR(base, value) (FLEXIO_SHIFTERR_REG(base) = (value))
#define FLEXIO_RMW_SHIFTERR(base, mask, value) (FLEXIO_WR_SHIFTERR(base, (FLEXIO_RD_SHIFTERR(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) |  (value)))
#define FLEXIO_CLR_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) & ~(value)))
#define FLEXIO_TOG_SHIFTERR(base, value) (FLEXIO_WR_SHIFTERR(base, FLEXIO_RD_SHIFTERR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTERR bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTERR, field SEF[3:0] (W1C)
 *
 * The shifter error flag is set when one of the following events occurs: For
 * SMOD=Receive, indicates Shifter was ready to store new data into SHIFTBUF before
 * the previous data was read from SHIFTBUF (SHIFTBUF Overrun), or indicates
 * that the received start or stop bit does not match the expected value. For
 * SMOD=Transmit, indicates Shifter was ready to load new data from SHIFTBUF before new
 * data had been written into SHIFTBUF (SHIFTBUF Underrun). For SMOD=Match
 * Store, indicates a match event occured before the previous match data was read from
 * SHIFTBUF (SHIFTBUF Overrun). For SMOD=Match Continuous, the error flag is set
 * when a match has occured between SHIFTBUF and Shifter. Can be cleared by
 * writing logic one to the flag. For SMOD=Match Continuous, can also be cleared when
 * the SHIFTBUF register is read.
 *
 * Values:
 * - 0 - Shifter Error Flag is clear
 * - 1 - Shifter Error Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTERR_SEF field. */
#define FLEXIO_RD_SHIFTERR_SEF(base) ((FLEXIO_SHIFTERR_REG(base) & FLEXIO_SHIFTERR_SEF_MASK) >> FLEXIO_SHIFTERR_SEF_SHIFT)
#define FLEXIO_BRD_SHIFTERR_SEF(base) (FLEXIO_RD_SHIFTERR_SEF(base))

/*! @brief Set the SEF field to a new value. */
#define FLEXIO_WR_SHIFTERR_SEF(base, value) (FLEXIO_RMW_SHIFTERR(base, FLEXIO_SHIFTERR_SEF_MASK, FLEXIO_SHIFTERR_SEF(value)))
#define FLEXIO_BWR_SHIFTERR_SEF(base, value) (FLEXIO_WR_SHIFTERR_SEF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMSTAT - Timer Status Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMSTAT - Timer Status Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMSTAT register
 */
/*@{*/
#define FLEXIO_RD_TIMSTAT(base)  (FLEXIO_TIMSTAT_REG(base))
#define FLEXIO_WR_TIMSTAT(base, value) (FLEXIO_TIMSTAT_REG(base) = (value))
#define FLEXIO_RMW_TIMSTAT(base, mask, value) (FLEXIO_WR_TIMSTAT(base, (FLEXIO_RD_TIMSTAT(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) |  (value)))
#define FLEXIO_CLR_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) & ~(value)))
#define FLEXIO_TOG_TIMSTAT(base, value) (FLEXIO_WR_TIMSTAT(base, FLEXIO_RD_TIMSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMSTAT bitfields
 */

/*!
 * @name Register FLEXIO_TIMSTAT, field TSF[3:0] (W1C)
 *
 * The timer status flag sets depending on the timer mode, and can be cleared by
 * writing logic one to the flag. In 8-bit counter mode, the timer status flag
 * is set when the upper 8-bit counter equals zero and decrements, this also
 * causes the counter to reload with the value in the compare register. In 8-bit PWM
 * mode, the timer status flag is set when the upper 8-bit counter equals zero and
 * decrements, this also causes the counter to reload with the value in the
 * compare register.. In 16-bit counter mode, the timer status flag is set when the
 * 16-bit counter equals zero and decrements, this also causes the counter to
 * reload with the value in the compare register..
 *
 * Values:
 * - 0 - Timer Status Flag is clear
 * - 1 - Timer Status Flag is set
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMSTAT_TSF field. */
#define FLEXIO_RD_TIMSTAT_TSF(base) ((FLEXIO_TIMSTAT_REG(base) & FLEXIO_TIMSTAT_TSF_MASK) >> FLEXIO_TIMSTAT_TSF_SHIFT)
#define FLEXIO_BRD_TIMSTAT_TSF(base) (FLEXIO_RD_TIMSTAT_TSF(base))

/*! @brief Set the TSF field to a new value. */
#define FLEXIO_WR_TIMSTAT_TSF(base, value) (FLEXIO_RMW_TIMSTAT(base, FLEXIO_TIMSTAT_TSF_MASK, FLEXIO_TIMSTAT_TSF(value)))
#define FLEXIO_BWR_TIMSTAT_TSF(base, value) (FLEXIO_WR_TIMSTAT_TSF(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSIEN - Shifter Status Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSIEN(base) (FLEXIO_SHIFTSIEN_REG(base))
#define FLEXIO_WR_SHIFTSIEN(base, value) (FLEXIO_SHIFTSIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSIEN(base, mask, value) (FLEXIO_WR_SHIFTSIEN(base, (FLEXIO_RD_SHIFTSIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSIEN(base, value) (FLEXIO_WR_SHIFTSIEN(base, FLEXIO_RD_SHIFTSIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSIEN, field SSIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SSF is set.
 *
 * Values:
 * - 0 - Shifter Status Flag interrupt disabled
 * - 1 - Shifter Status Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSIEN_SSIE field. */
#define FLEXIO_RD_SHIFTSIEN_SSIE(base) ((FLEXIO_SHIFTSIEN_REG(base) & FLEXIO_SHIFTSIEN_SSIE_MASK) >> FLEXIO_SHIFTSIEN_SSIE_SHIFT)
#define FLEXIO_BRD_SHIFTSIEN_SSIE(base) (FLEXIO_RD_SHIFTSIEN_SSIE(base))

/*! @brief Set the SSIE field to a new value. */
#define FLEXIO_WR_SHIFTSIEN_SSIE(base, value) (FLEXIO_RMW_SHIFTSIEN(base, FLEXIO_SHIFTSIEN_SSIE_MASK, FLEXIO_SHIFTSIEN_SSIE(value)))
#define FLEXIO_BWR_SHIFTSIEN_SSIE(base, value) (FLEXIO_WR_SHIFTSIEN_SSIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTEIEN - Shifter Error Interrupt Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTEIEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTEIEN(base) (FLEXIO_SHIFTEIEN_REG(base))
#define FLEXIO_WR_SHIFTEIEN(base, value) (FLEXIO_SHIFTEIEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTEIEN(base, mask, value) (FLEXIO_WR_SHIFTEIEN(base, (FLEXIO_RD_SHIFTEIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTEIEN(base, value) (FLEXIO_WR_SHIFTEIEN(base, FLEXIO_RD_SHIFTEIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTEIEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTEIEN, field SEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding SEF is set.
 *
 * Values:
 * - 0 - Shifter Error Flag interrupt disabled
 * - 1 - Shifter Error Flag interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTEIEN_SEIE field. */
#define FLEXIO_RD_SHIFTEIEN_SEIE(base) ((FLEXIO_SHIFTEIEN_REG(base) & FLEXIO_SHIFTEIEN_SEIE_MASK) >> FLEXIO_SHIFTEIEN_SEIE_SHIFT)
#define FLEXIO_BRD_SHIFTEIEN_SEIE(base) (FLEXIO_RD_SHIFTEIEN_SEIE(base))

/*! @brief Set the SEIE field to a new value. */
#define FLEXIO_WR_SHIFTEIEN_SEIE(base, value) (FLEXIO_RMW_SHIFTEIEN(base, FLEXIO_SHIFTEIEN_SEIE_MASK, FLEXIO_SHIFTEIEN_SEIE(value)))
#define FLEXIO_BWR_SHIFTEIEN_SEIE(base, value) (FLEXIO_WR_SHIFTEIEN_SEIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMIEN - Timer Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMIEN - Timer Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMIEN register
 */
/*@{*/
#define FLEXIO_RD_TIMIEN(base)   (FLEXIO_TIMIEN_REG(base))
#define FLEXIO_WR_TIMIEN(base, value) (FLEXIO_TIMIEN_REG(base) = (value))
#define FLEXIO_RMW_TIMIEN(base, mask, value) (FLEXIO_WR_TIMIEN(base, (FLEXIO_RD_TIMIEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) |  (value)))
#define FLEXIO_CLR_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) & ~(value)))
#define FLEXIO_TOG_TIMIEN(base, value) (FLEXIO_WR_TIMIEN(base, FLEXIO_RD_TIMIEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMIEN bitfields
 */

/*!
 * @name Register FLEXIO_TIMIEN, field TEIE[3:0] (RW)
 *
 * Enables interrupt generation when corresponding TSF is set.
 *
 * Values:
 * - 0 - Timer Status Flag interrupt is disabled
 * - 1 - Timer Status Flag interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMIEN_TEIE field. */
#define FLEXIO_RD_TIMIEN_TEIE(base) ((FLEXIO_TIMIEN_REG(base) & FLEXIO_TIMIEN_TEIE_MASK) >> FLEXIO_TIMIEN_TEIE_SHIFT)
#define FLEXIO_BRD_TIMIEN_TEIE(base) (FLEXIO_RD_TIMIEN_TEIE(base))

/*! @brief Set the TEIE field to a new value. */
#define FLEXIO_WR_TIMIEN_TEIE(base, value) (FLEXIO_RMW_TIMIEN(base, FLEXIO_TIMIEN_TEIE_MASK, FLEXIO_TIMIEN_TEIE(value)))
#define FLEXIO_BWR_TIMIEN_TEIE(base, value) (FLEXIO_WR_TIMIEN_TEIE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTSDEN - Shifter Status DMA Enable
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTSDEN - Shifter Status DMA Enable (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTSDEN register
 */
/*@{*/
#define FLEXIO_RD_SHIFTSDEN(base) (FLEXIO_SHIFTSDEN_REG(base))
#define FLEXIO_WR_SHIFTSDEN(base, value) (FLEXIO_SHIFTSDEN_REG(base) = (value))
#define FLEXIO_RMW_SHIFTSDEN(base, mask, value) (FLEXIO_WR_SHIFTSDEN(base, (FLEXIO_RD_SHIFTSDEN(base) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) |  (value)))
#define FLEXIO_CLR_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) & ~(value)))
#define FLEXIO_TOG_SHIFTSDEN(base, value) (FLEXIO_WR_SHIFTSDEN(base, FLEXIO_RD_SHIFTSDEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTSDEN bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTSDEN, field SSDE[3:0] (RW)
 *
 * Enables DMA request generation when corresponding SSF is set.
 *
 * Values:
 * - 0 - Shifter Status Flag DMA request is disabled
 * - 1 - Shifter Status Flag DMA request is enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTSDEN_SSDE field. */
#define FLEXIO_RD_SHIFTSDEN_SSDE(base) ((FLEXIO_SHIFTSDEN_REG(base) & FLEXIO_SHIFTSDEN_SSDE_MASK) >> FLEXIO_SHIFTSDEN_SSDE_SHIFT)
#define FLEXIO_BRD_SHIFTSDEN_SSDE(base) (FLEXIO_RD_SHIFTSDEN_SSDE(base))

/*! @brief Set the SSDE field to a new value. */
#define FLEXIO_WR_SHIFTSDEN_SSDE(base, value) (FLEXIO_RMW_SHIFTSDEN(base, FLEXIO_SHIFTSDEN_SSDE_MASK, FLEXIO_SHIFTSDEN_SSDE(value)))
#define FLEXIO_BWR_SHIFTSDEN_SSDE(base, value) (FLEXIO_WR_SHIFTSDEN_SSDE(base, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCTL - Shifter Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCTL - Shifter Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCTL register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCTL(base, index) (FLEXIO_SHIFTCTL_REG(base, index))
#define FLEXIO_WR_SHIFTCTL(base, index, value) (FLEXIO_SHIFTCTL_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCTL(base, index, mask, value) (FLEXIO_WR_SHIFTCTL(base, index, (FLEXIO_RD_SHIFTCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTCTL(base, index, value) (FLEXIO_WR_SHIFTCTL(base, index, FLEXIO_RD_SHIFTCTL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCTL bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCTL, field SMOD[2:0] (RW)
 *
 * Configures the mode of the Shifter.
 *
 * Values:
 * - 000 - Disabled.
 * - 001 - Receive mode. Captures the current Shifter content into the SHIFTBUF
 *     on expiration of the Timer.
 * - 010 - Transmit mode. Load SHIFTBUF contents into the Shifter on expiration
 *     of the Timer.
 * - 011 - Reserved.
 * - 100 - Match Store mode. Shifter data is compared to SHIFTBUF content on
 *     expiration of the Timer.
 * - 101 - Match Continuous mode. Shifter data is continuously compared to
 *     SHIFTBUF contents.
 * - 110 - Reserved.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_SMOD field. */
#define FLEXIO_RD_SHIFTCTL_SMOD(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_SMOD_MASK) >> FLEXIO_SHIFTCTL_SMOD_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_SMOD(base, index) (FLEXIO_RD_SHIFTCTL_SMOD(base, index))

/*! @brief Set the SMOD field to a new value. */
#define FLEXIO_WR_SHIFTCTL_SMOD(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_SMOD_MASK, FLEXIO_SHIFTCTL_SMOD(value)))
#define FLEXIO_BWR_SHIFTCTL_SMOD(base, index, value) (FLEXIO_WR_SHIFTCTL_SMOD(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0 - Pin is active high
 * - 1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINPOL field. */
#define FLEXIO_RD_SHIFTCTL_PINPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINPOL_MASK) >> FLEXIO_SHIFTCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINPOL_SHIFT))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINPOL_MASK, FLEXIO_SHIFTCTL_PINPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_PINPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Shifter input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINSEL field. */
#define FLEXIO_RD_SHIFTCTL_PINSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINSEL_MASK) >> FLEXIO_SHIFTCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINSEL(base, index) (FLEXIO_RD_SHIFTCTL_PINSEL(base, index))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINSEL_MASK, FLEXIO_SHIFTCTL_PINSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_PINSEL(base, index, value) (FLEXIO_WR_SHIFTCTL_PINSEL(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 00 - Shifter pin output disabled
 * - 01 - Shifter pin open drain or bidirectional output enable
 * - 10 - Shifter pin bidirectional output data
 * - 11 - Shifter pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_PINCFG field. */
#define FLEXIO_RD_SHIFTCTL_PINCFG(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_PINCFG_MASK) >> FLEXIO_SHIFTCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_PINCFG(base, index) (FLEXIO_RD_SHIFTCTL_PINCFG(base, index))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_SHIFTCTL_PINCFG(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_PINCFG_MASK, FLEXIO_SHIFTCTL_PINCFG(value)))
#define FLEXIO_BWR_SHIFTCTL_PINCFG(base, index, value) (FLEXIO_WR_SHIFTCTL_PINCFG(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMPOL[23] (RW)
 *
 * Values:
 * - 0 - Shift on posedge of Shift clock
 * - 1 - Shift on negedge of Shift clock
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMPOL field. */
#define FLEXIO_RD_SHIFTCTL_TIMPOL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMPOL_MASK) >> FLEXIO_SHIFTCTL_TIMPOL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMPOL_SHIFT))

/*! @brief Set the TIMPOL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMPOL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMPOL_MASK, FLEXIO_SHIFTCTL_TIMPOL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCTL_REG(base, index), FLEXIO_SHIFTCTL_TIMPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCTL, field TIMSEL[25:24] (RW)
 *
 * Selects which Timer is used for controlling the logic/shift register and
 * generating the Shift clock.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCTL_TIMSEL field. */
#define FLEXIO_RD_SHIFTCTL_TIMSEL(base, index) ((FLEXIO_SHIFTCTL_REG(base, index) & FLEXIO_SHIFTCTL_TIMSEL_MASK) >> FLEXIO_SHIFTCTL_TIMSEL_SHIFT)
#define FLEXIO_BRD_SHIFTCTL_TIMSEL(base, index) (FLEXIO_RD_SHIFTCTL_TIMSEL(base, index))

/*! @brief Set the TIMSEL field to a new value. */
#define FLEXIO_WR_SHIFTCTL_TIMSEL(base, index, value) (FLEXIO_RMW_SHIFTCTL(base, index, FLEXIO_SHIFTCTL_TIMSEL_MASK, FLEXIO_SHIFTCTL_TIMSEL(value)))
#define FLEXIO_BWR_SHIFTCTL_TIMSEL(base, index, value) (FLEXIO_WR_SHIFTCTL_TIMSEL(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTCFG - Shifter Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTCFG - Shifter Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTCFG register
 */
/*@{*/
#define FLEXIO_RD_SHIFTCFG(base, index) (FLEXIO_SHIFTCFG_REG(base, index))
#define FLEXIO_WR_SHIFTCFG(base, index, value) (FLEXIO_SHIFTCFG_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTCFG(base, index, mask, value) (FLEXIO_WR_SHIFTCFG(base, index, (FLEXIO_RD_SHIFTCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTCFG(base, index, value) (FLEXIO_WR_SHIFTCFG(base, index, FLEXIO_RD_SHIFTCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_SHIFTCFG bitfields
 */

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTART[1:0] (RW)
 *
 * For SMOD=Transmit, this field allows automatic start bit insertion if the
 * selected timer has also enabled a start bit. For SMOD=Receive or Match Store,
 * this field allows automatic start bit checking if the selected timer has also
 * enabled a start bit.
 *
 * Values:
 * - 00 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on enable
 * - 01 - Start bit disabled for transmitter/receiver/match store, transmitter
 *     loads data on first shift
 * - 10 - Transmitter outputs start bit value 0 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 0
 * - 11 - Transmitter outputs start bit value 1 before loading data on first
 *     shift, receiver/match store sets error flag if start bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTART field. */
#define FLEXIO_RD_SHIFTCFG_SSTART(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTART_MASK) >> FLEXIO_SHIFTCFG_SSTART_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTART(base, index) (FLEXIO_RD_SHIFTCFG_SSTART(base, index))

/*! @brief Set the SSTART field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTART(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTART_MASK, FLEXIO_SHIFTCFG_SSTART(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTART(base, index, value) (FLEXIO_WR_SHIFTCFG_SSTART(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field SSTOP[5:4] (RW)
 *
 * For SMOD=Transmit, this field allows automatic stop bit insertion if the
 * selected timer has also enabled a stop bit. For SMOD=Receive or Match Store, this
 * field allows automatic stop bit checking if the selected timer has also
 * enabled a stop bit.
 *
 * Values:
 * - 00 - Stop bit disabled for transmitter/receiver/match store
 * - 01 - Reserved for transmitter/receiver/match store
 * - 10 - Transmitter outputs stop bit value 0 on store, receiver/match store
 *     sets error flag if stop bit is not 0
 * - 11 - Transmitter outputs stop bit value 1 on store, receiver/match store
 *     sets error flag if stop bit is not 1
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_SSTOP field. */
#define FLEXIO_RD_SHIFTCFG_SSTOP(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_SSTOP_MASK) >> FLEXIO_SHIFTCFG_SSTOP_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_SSTOP(base, index) (FLEXIO_RD_SHIFTCFG_SSTOP(base, index))

/*! @brief Set the SSTOP field to a new value. */
#define FLEXIO_WR_SHIFTCFG_SSTOP(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_SSTOP_MASK, FLEXIO_SHIFTCFG_SSTOP(value)))
#define FLEXIO_BWR_SHIFTCFG_SSTOP(base, index, value) (FLEXIO_WR_SHIFTCFG_SSTOP(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_SHIFTCFG, field INSRC[8] (RW)
 *
 * Selects the input source for the shifter.
 *
 * Values:
 * - 0 - Pin
 * - 1 - Shifter N+1 Output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_SHIFTCFG_INSRC field. */
#define FLEXIO_RD_SHIFTCFG_INSRC(base, index) ((FLEXIO_SHIFTCFG_REG(base, index) & FLEXIO_SHIFTCFG_INSRC_MASK) >> FLEXIO_SHIFTCFG_INSRC_SHIFT)
#define FLEXIO_BRD_SHIFTCFG_INSRC(base, index) (BITBAND_ACCESS32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_INSRC_SHIFT))

/*! @brief Set the INSRC field to a new value. */
#define FLEXIO_WR_SHIFTCFG_INSRC(base, index, value) (FLEXIO_RMW_SHIFTCFG(base, index, FLEXIO_SHIFTCFG_INSRC_MASK, FLEXIO_SHIFTCFG_INSRC(value)))
#define FLEXIO_BWR_SHIFTCFG_INSRC(base, index, value) (BITBAND_ACCESS32(&FLEXIO_SHIFTCFG_REG(base, index), FLEXIO_SHIFTCFG_INSRC_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUF - Shifter Buffer N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUF - Shifter Buffer N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUF register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUF(base, index) (FLEXIO_SHIFTBUF_REG(base, index))
#define FLEXIO_WR_SHIFTBUF(base, index, value) (FLEXIO_SHIFTBUF_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUF(base, index, mask, value) (FLEXIO_WR_SHIFTBUF(base, index, (FLEXIO_RD_SHIFTBUF(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUF(base, index, value) (FLEXIO_WR_SHIFTBUF(base, index, FLEXIO_RD_SHIFTBUF(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBIS - Shifter Buffer N Bit Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBIS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBIS(base, index) (FLEXIO_SHIFTBUFBIS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBIS(base, index, value) (FLEXIO_SHIFTBUFBIS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBIS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, (FLEXIO_RD_SHIFTBUFBIS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBIS(base, index, value) (FLEXIO_WR_SHIFTBUFBIS(base, index, FLEXIO_RD_SHIFTBUFBIS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBYS - Shifter Buffer N Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBYS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBYS(base, index) (FLEXIO_SHIFTBUFBYS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBYS(base, index, value) (FLEXIO_SHIFTBUFBYS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBYS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, (FLEXIO_RD_SHIFTBUFBYS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBYS(base, index, value) (FLEXIO_WR_SHIFTBUFBYS(base, index, FLEXIO_RD_SHIFTBUFBYS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_SHIFTBUFBBS - Shifter Buffer N Bit Byte Swapped Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_SHIFTBUFBBS register
 */
/*@{*/
#define FLEXIO_RD_SHIFTBUFBBS(base, index) (FLEXIO_SHIFTBUFBBS_REG(base, index))
#define FLEXIO_WR_SHIFTBUFBBS(base, index, value) (FLEXIO_SHIFTBUFBBS_REG(base, index) = (value))
#define FLEXIO_RMW_SHIFTBUFBBS(base, index, mask, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, (FLEXIO_RD_SHIFTBUFBBS(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) |  (value)))
#define FLEXIO_CLR_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) & ~(value)))
#define FLEXIO_TOG_SHIFTBUFBBS(base, index, value) (FLEXIO_WR_SHIFTBUFBBS(base, index, FLEXIO_RD_SHIFTBUFBBS(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCTL - Timer Control N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCTL - Timer Control N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCTL register
 */
/*@{*/
#define FLEXIO_RD_TIMCTL(base, index) (FLEXIO_TIMCTL_REG(base, index))
#define FLEXIO_WR_TIMCTL(base, index, value) (FLEXIO_TIMCTL_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCTL(base, index, mask, value) (FLEXIO_WR_TIMCTL(base, index, (FLEXIO_RD_TIMCTL(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) |  (value)))
#define FLEXIO_CLR_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCTL(base, index, value) (FLEXIO_WR_TIMCTL(base, index, FLEXIO_RD_TIMCTL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCTL bitfields
 */

/*!
 * @name Register FLEXIO_TIMCTL, field TIMOD[1:0] (RW)
 *
 * In 8-bit counter mode, the lower 8-bits of the counter and compare register
 * are used to configure the baud rate of the timer shift clock and the upper
 * 8-bits are used to configure the shifter bit count. In 8-bit PWM mode, the lower
 * 8-bits of the counter and compare register are used to configure the high
 * period of the timer shift clock and the upper 8-bits are used to configure the low
 * period of the timer shift clock. The shifter bit count is configured using
 * another timer or external signal. In 16-bit counter mode, the full 16-bits of the
 * counter and compare register are used to configure either the baud rate of
 * the shift clock or the shifter bit count.
 *
 * Values:
 * - 00 - Timer Disabled.
 * - 01 - Dual 8-bit counters baud/bit mode.
 * - 10 - Dual 8-bit counters PWM mode.
 * - 11 - Single 16-bit counter mode.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TIMOD field. */
#define FLEXIO_RD_TIMCTL_TIMOD(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TIMOD_MASK) >> FLEXIO_TIMCTL_TIMOD_SHIFT)
#define FLEXIO_BRD_TIMCTL_TIMOD(base, index) (FLEXIO_RD_TIMCTL_TIMOD(base, index))

/*! @brief Set the TIMOD field to a new value. */
#define FLEXIO_WR_TIMCTL_TIMOD(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TIMOD_MASK, FLEXIO_TIMCTL_TIMOD(value)))
#define FLEXIO_BWR_TIMCTL_TIMOD(base, index, value) (FLEXIO_WR_TIMCTL_TIMOD(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINPOL[7] (RW)
 *
 * Values:
 * - 0 - Pin is active high
 * - 1 - Pin is active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINPOL field. */
#define FLEXIO_RD_TIMCTL_PINPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINPOL_MASK) >> FLEXIO_TIMCTL_PINPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINPOL_SHIFT))

/*! @brief Set the PINPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINPOL_MASK, FLEXIO_TIMCTL_PINPOL(value)))
#define FLEXIO_BWR_TIMCTL_PINPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_PINPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINSEL[10:8] (RW)
 *
 * Selects which pin is used by the Timer input or output.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINSEL field. */
#define FLEXIO_RD_TIMCTL_PINSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINSEL_MASK) >> FLEXIO_TIMCTL_PINSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINSEL(base, index) (FLEXIO_RD_TIMCTL_PINSEL(base, index))

/*! @brief Set the PINSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_PINSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINSEL_MASK, FLEXIO_TIMCTL_PINSEL(value)))
#define FLEXIO_BWR_TIMCTL_PINSEL(base, index, value) (FLEXIO_WR_TIMCTL_PINSEL(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field PINCFG[17:16] (RW)
 *
 * Values:
 * - 00 - Timer pin output disabled
 * - 01 - Timer pin open drain or bidirectional output enable
 * - 10 - Timer pin bidirectional output data
 * - 11 - Timer pin output
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_PINCFG field. */
#define FLEXIO_RD_TIMCTL_PINCFG(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_PINCFG_MASK) >> FLEXIO_TIMCTL_PINCFG_SHIFT)
#define FLEXIO_BRD_TIMCTL_PINCFG(base, index) (FLEXIO_RD_TIMCTL_PINCFG(base, index))

/*! @brief Set the PINCFG field to a new value. */
#define FLEXIO_WR_TIMCTL_PINCFG(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_PINCFG_MASK, FLEXIO_TIMCTL_PINCFG(value)))
#define FLEXIO_BWR_TIMCTL_PINCFG(base, index, value) (FLEXIO_WR_TIMCTL_PINCFG(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSRC[22] (RW)
 *
 * Values:
 * - 0 - External trigger selected
 * - 1 - Internal trigger selected
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSRC field. */
#define FLEXIO_RD_TIMCTL_TRGSRC(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSRC_MASK) >> FLEXIO_TIMCTL_TRGSRC_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSRC(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSRC_SHIFT))

/*! @brief Set the TRGSRC field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSRC(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSRC_MASK, FLEXIO_TIMCTL_TRGSRC(value)))
#define FLEXIO_BWR_TIMCTL_TRGSRC(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGPOL[23] (RW)
 *
 * Values:
 * - 0 - Trigger active high
 * - 1 - Trigger active low
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGPOL field. */
#define FLEXIO_RD_TIMCTL_TRGPOL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGPOL_MASK) >> FLEXIO_TIMCTL_TRGPOL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGPOL(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGPOL_SHIFT))

/*! @brief Set the TRGPOL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGPOL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGPOL_MASK, FLEXIO_TIMCTL_TRGPOL(value)))
#define FLEXIO_BWR_TIMCTL_TRGPOL(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCTL_REG(base, index), FLEXIO_TIMCTL_TRGPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCTL, field TRGSEL[27:24] (RW)
 *
 * The valid values for TRGSEL will depend on the FLEXIO_PARAM register. When
 * TRGSRC = 1, the valid values for N will depend on PIN, TIMER, SHIFTER fields in
 * the FLEXIO_PARAM register. When TRGSRC = 0, the valid values for N will depend
 * on TRIGGER field in FLEXIO_PARAM register. Refer to the chip configuration
 * section for external trigger selection. The internal trigger selection is
 * configured as follows:
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCTL_TRGSEL field. */
#define FLEXIO_RD_TIMCTL_TRGSEL(base, index) ((FLEXIO_TIMCTL_REG(base, index) & FLEXIO_TIMCTL_TRGSEL_MASK) >> FLEXIO_TIMCTL_TRGSEL_SHIFT)
#define FLEXIO_BRD_TIMCTL_TRGSEL(base, index) (FLEXIO_RD_TIMCTL_TRGSEL(base, index))

/*! @brief Set the TRGSEL field to a new value. */
#define FLEXIO_WR_TIMCTL_TRGSEL(base, index, value) (FLEXIO_RMW_TIMCTL(base, index, FLEXIO_TIMCTL_TRGSEL_MASK, FLEXIO_TIMCTL_TRGSEL(value)))
#define FLEXIO_BWR_TIMCTL_TRGSEL(base, index, value) (FLEXIO_WR_TIMCTL_TRGSEL(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCFG - Timer Configuration N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCFG - Timer Configuration N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The options to enable or disable the timer using the Timer N-1 enable or
 * disable are reserved when N is evenly divisible by 4 (eg: Timer 0).
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCFG register
 */
/*@{*/
#define FLEXIO_RD_TIMCFG(base, index) (FLEXIO_TIMCFG_REG(base, index))
#define FLEXIO_WR_TIMCFG(base, index, value) (FLEXIO_TIMCFG_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCFG(base, index, mask, value) (FLEXIO_WR_TIMCFG(base, index, (FLEXIO_RD_TIMCFG(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) |  (value)))
#define FLEXIO_CLR_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCFG(base, index, value) (FLEXIO_WR_TIMCFG(base, index, FLEXIO_RD_TIMCFG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCFG bitfields
 */

/*!
 * @name Register FLEXIO_TIMCFG, field TSTART[1] (RW)
 *
 * When start bit is enabled, configured shifters will output the contents of
 * the start bit when the timer is enabled and the timer counter will reload from
 * the compare register on the first rising edge of the shift clock.
 *
 * Values:
 * - 0 - Start bit disabled
 * - 1 - Start bit enabled
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTART field. */
#define FLEXIO_RD_TIMCFG_TSTART(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTART_MASK) >> FLEXIO_TIMCFG_TSTART_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTART(base, index) (BITBAND_ACCESS32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTART_SHIFT))

/*! @brief Set the TSTART field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTART(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTART_MASK, FLEXIO_TIMCFG_TSTART(value)))
#define FLEXIO_BWR_TIMCFG_TSTART(base, index, value) (BITBAND_ACCESS32(&FLEXIO_TIMCFG_REG(base, index), FLEXIO_TIMCFG_TSTART_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TSTOP[5:4] (RW)
 *
 * The stop bit can be added on a timer compare (between each word) or on a
 * timer disable. When stop bit is enabled, configured shifters will output the
 * contents of the stop bit when the timer is disabled. When stop bit is enabled on
 * timer disable, the timer remains disabled until the next rising edge of the
 * shift clock. If configured for both timer compare and timer disable, only one stop
 * bit is inserted on timer disable.
 *
 * Values:
 * - 00 - Stop bit disabled
 * - 01 - Stop bit is enabled on timer compare
 * - 10 - Stop bit is enabled on timer disable
 * - 11 - Stop bit is enabled on timer compare and timer disable
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TSTOP field. */
#define FLEXIO_RD_TIMCFG_TSTOP(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TSTOP_MASK) >> FLEXIO_TIMCFG_TSTOP_SHIFT)
#define FLEXIO_BRD_TIMCFG_TSTOP(base, index) (FLEXIO_RD_TIMCFG_TSTOP(base, index))

/*! @brief Set the TSTOP field to a new value. */
#define FLEXIO_WR_TIMCFG_TSTOP(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TSTOP_MASK, FLEXIO_TIMCFG_TSTOP(value)))
#define FLEXIO_BWR_TIMCFG_TSTOP(base, index, value) (FLEXIO_WR_TIMCFG_TSTOP(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMENA[10:8] (RW)
 *
 * Configures the condition that causes the Timer to be enabled and start
 * decrementing.
 *
 * Values:
 * - 000 - Timer always enabled
 * - 001 - Timer enabled on Timer N-1 enable
 * - 010 - Timer enabled on Trigger high
 * - 011 - Timer enabled on Trigger high and Pin high
 * - 100 - Timer enabled on Pin rising edge
 * - 101 - Timer enabled on Pin rising edge and Trigger high
 * - 110 - Timer enabled on Trigger rising edge
 * - 111 - Timer enabled on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMENA field. */
#define FLEXIO_RD_TIMCFG_TIMENA(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMENA_MASK) >> FLEXIO_TIMCFG_TIMENA_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMENA(base, index) (FLEXIO_RD_TIMCFG_TIMENA(base, index))

/*! @brief Set the TIMENA field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMENA(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMENA_MASK, FLEXIO_TIMCFG_TIMENA(value)))
#define FLEXIO_BWR_TIMCFG_TIMENA(base, index, value) (FLEXIO_WR_TIMCFG_TIMENA(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDIS[14:12] (RW)
 *
 * Configures the condition that causes the Timer to be disabled and stop
 * decrementing.
 *
 * Values:
 * - 000 - Timer never disabled
 * - 001 - Timer disabled on Timer N-1 disable
 * - 010 - Timer disabled on Timer compare
 * - 011 - Timer disabled on Timer compare and Trigger Low
 * - 100 - Timer disabled on Pin rising or falling edge
 * - 101 - Timer disabled on Pin rising or falling edge provided Trigger is high
 * - 110 - Timer disabled on Trigger falling edge
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDIS field. */
#define FLEXIO_RD_TIMCFG_TIMDIS(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDIS_MASK) >> FLEXIO_TIMCFG_TIMDIS_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDIS(base, index) (FLEXIO_RD_TIMCFG_TIMDIS(base, index))

/*! @brief Set the TIMDIS field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDIS(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDIS_MASK, FLEXIO_TIMCFG_TIMDIS(value)))
#define FLEXIO_BWR_TIMCFG_TIMDIS(base, index, value) (FLEXIO_WR_TIMCFG_TIMDIS(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMRST[18:16] (RW)
 *
 * Configures the condition that causes the timer counter (and optionally the
 * timer output) to be reset. In 8-bit counter mode, the timer reset will only
 * reset the lower 8-bits that configure the baud rate. In all other modes, the timer
 * reset will reset the full 16-bits of the counter.
 *
 * Values:
 * - 000 - Timer never reset
 * - 001 - Reserved
 * - 010 - Timer reset on Timer Pin equal to Timer Output
 * - 011 - Timer reset on Timer Trigger equal to Timer Output
 * - 100 - Timer reset on Timer Pin rising edge
 * - 101 - Reserved
 * - 110 - Timer reset on Trigger rising edge
 * - 111 - Timer reset on Trigger rising or falling edge
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMRST field. */
#define FLEXIO_RD_TIMCFG_TIMRST(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMRST_MASK) >> FLEXIO_TIMCFG_TIMRST_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMRST(base, index) (FLEXIO_RD_TIMCFG_TIMRST(base, index))

/*! @brief Set the TIMRST field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMRST(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMRST_MASK, FLEXIO_TIMCFG_TIMRST(value)))
#define FLEXIO_BWR_TIMCFG_TIMRST(base, index, value) (FLEXIO_WR_TIMCFG_TIMRST(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMDEC[21:20] (RW)
 *
 * Configures the source of the Timer decrement and the source of the Shift
 * clock.
 *
 * Values:
 * - 00 - Decrement counter on FlexIO clock, Shift clock equals Timer output.
 * - 01 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Timer output.
 * - 10 - Decrement counter on Pin input (both edges), Shift clock equals Pin
 *     input.
 * - 11 - Decrement counter on Trigger input (both edges), Shift clock equals
 *     Trigger input.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMDEC field. */
#define FLEXIO_RD_TIMCFG_TIMDEC(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMDEC_MASK) >> FLEXIO_TIMCFG_TIMDEC_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMDEC(base, index) (FLEXIO_RD_TIMCFG_TIMDEC(base, index))

/*! @brief Set the TIMDEC field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMDEC(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMDEC_MASK, FLEXIO_TIMCFG_TIMDEC(value)))
#define FLEXIO_BWR_TIMCFG_TIMDEC(base, index, value) (FLEXIO_WR_TIMCFG_TIMDEC(base, index, value))
/*@}*/

/*!
 * @name Register FLEXIO_TIMCFG, field TIMOUT[25:24] (RW)
 *
 * Configures the initial state of the Timer Output and whether it is affected
 * by the Timer reset.
 *
 * Values:
 * - 00 - Timer output is logic one when enabled and is not affected by timer
 *     reset
 * - 01 - Timer output is logic zero when enabled and is not affected by timer
 *     reset
 * - 10 - Timer output is logic one when enabled and on timer reset
 * - 11 - Timer output is logic zero when enabled and on timer reset
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCFG_TIMOUT field. */
#define FLEXIO_RD_TIMCFG_TIMOUT(base, index) ((FLEXIO_TIMCFG_REG(base, index) & FLEXIO_TIMCFG_TIMOUT_MASK) >> FLEXIO_TIMCFG_TIMOUT_SHIFT)
#define FLEXIO_BRD_TIMCFG_TIMOUT(base, index) (FLEXIO_RD_TIMCFG_TIMOUT(base, index))

/*! @brief Set the TIMOUT field to a new value. */
#define FLEXIO_WR_TIMCFG_TIMOUT(base, index, value) (FLEXIO_RMW_TIMCFG(base, index, FLEXIO_TIMCFG_TIMOUT_MASK, FLEXIO_TIMCFG_TIMOUT(value)))
#define FLEXIO_BWR_TIMCFG_TIMOUT(base, index, value) (FLEXIO_WR_TIMCFG_TIMOUT(base, index, value))
/*@}*/

/*******************************************************************************
 * FLEXIO_TIMCMP - Timer Compare N Register
 ******************************************************************************/

/*!
 * @brief FLEXIO_TIMCMP - Timer Compare N Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * .
 */
/*!
 * @name Constants and macros for entire FLEXIO_TIMCMP register
 */
/*@{*/
#define FLEXIO_RD_TIMCMP(base, index) (FLEXIO_TIMCMP_REG(base, index))
#define FLEXIO_WR_TIMCMP(base, index, value) (FLEXIO_TIMCMP_REG(base, index) = (value))
#define FLEXIO_RMW_TIMCMP(base, index, mask, value) (FLEXIO_WR_TIMCMP(base, index, (FLEXIO_RD_TIMCMP(base, index) & ~(mask)) | (value)))
#define FLEXIO_SET_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) |  (value)))
#define FLEXIO_CLR_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) & ~(value)))
#define FLEXIO_TOG_TIMCMP(base, index, value) (FLEXIO_WR_TIMCMP(base, index, FLEXIO_RD_TIMCMP(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FLEXIO_TIMCMP bitfields
 */

/*!
 * @name Register FLEXIO_TIMCMP, field CMP[15:0] (RW)
 *
 * The timer compare value is loaded into the timer counter when the timer is
 * first enabled, when the timer is reset and when the timer decrements down to
 * zero. In dual 8-bit counters baud/bit mode, the lower 8-bits configures the baud
 * rate divider equal to (CMP[7:0] + 1) * 2. The upper 8-bits configure the
 * number of bits in each word equal to (CMP[15:8] + 1) / 2. In dual 8-bit counters
 * PWM mode, the lower 8-bits configure the high period of the output to (CMP[7:0]
 * + 1) and the upper 8-bits configure the low period of the output to (CMP[15:8]
 * + 1). In 16-bit counter mode, the compare value can be used to generate the
 * baud rate divider (if shift clock source is timer output) to equal (CMP[15:0] +
 * 1) * 2. When the shift clock source is a pin or trigger input, the compare
 * register is used to set the number of bits in each word equal to (CMP[15:0] + 1)
 * / 2.
 */
/*@{*/
/*! @brief Read current value of the FLEXIO_TIMCMP_CMP field. */
#define FLEXIO_RD_TIMCMP_CMP(base, index) ((FLEXIO_TIMCMP_REG(base, index) & FLEXIO_TIMCMP_CMP_MASK) >> FLEXIO_TIMCMP_CMP_SHIFT)
#define FLEXIO_BRD_TIMCMP_CMP(base, index) (FLEXIO_RD_TIMCMP_CMP(base, index))

/*! @brief Set the CMP field to a new value. */
#define FLEXIO_WR_TIMCMP_CMP(base, index, value) (FLEXIO_RMW_TIMCMP(base, index, FLEXIO_TIMCMP_CMP_MASK, FLEXIO_TIMCMP_CMP(value)))
#define FLEXIO_BWR_TIMCMP_CMP(base, index, value) (FLEXIO_WR_TIMCMP_CMP(base, index, value))
/*@}*/

/*
 * MKS22F25612 FMC
 *
 * Flash Memory Controller
 *
 * Registers defined in this header file:
 * - FMC_PFAPR - Flash Access Protection Register
 * - FMC_PFB0CR - Flash Bank 0 Control Register
 * - FMC_PFB1CR - Flash Bank 1 Control Register
 * - FMC_TAGVDW0S - Cache Tag Storage
 * - FMC_TAGVDW1S - Cache Tag Storage
 * - FMC_TAGVDW2S - Cache Tag Storage
 * - FMC_TAGVDW3S - Cache Tag Storage
 * - FMC_DATA_U - Cache Data Storage (upper word)
 * - FMC_DATA_L - Cache Data Storage (lower word)
 */

#define FMC_INSTANCE_COUNT (1U) /*!< Number of instances of the FMC module. */
#define FMC_IDX (0U) /*!< Instance number for FMC. */

/*******************************************************************************
 * FMC_PFAPR - Flash Access Protection Register
 ******************************************************************************/

/*!
 * @brief FMC_PFAPR - Flash Access Protection Register (RW)
 *
 * Reset value: 0x00F8003FU
 */
/*!
 * @name Constants and macros for entire FMC_PFAPR register
 */
/*@{*/
#define FMC_RD_PFAPR(base)       (FMC_PFAPR_REG(base))
#define FMC_WR_PFAPR(base, value) (FMC_PFAPR_REG(base) = (value))
#define FMC_RMW_PFAPR(base, mask, value) (FMC_WR_PFAPR(base, (FMC_RD_PFAPR(base) & ~(mask)) | (value)))
#define FMC_SET_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) |  (value)))
#define FMC_CLR_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) & ~(value)))
#define FMC_TOG_PFAPR(base, value) (FMC_WR_PFAPR(base, FMC_RD_PFAPR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFAPR bitfields
 */

/*!
 * @name Register FMC_PFAPR, field M0AP[1:0] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0AP field. */
#define FMC_RD_PFAPR_M0AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0AP_MASK) >> FMC_PFAPR_M0AP_SHIFT)
#define FMC_BRD_PFAPR_M0AP(base) (FMC_RD_PFAPR_M0AP(base))

/*! @brief Set the M0AP field to a new value. */
#define FMC_WR_PFAPR_M0AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0AP_MASK, FMC_PFAPR_M0AP(value)))
#define FMC_BWR_PFAPR_M0AP(base, value) (FMC_WR_PFAPR_M0AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1AP[3:2] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1AP field. */
#define FMC_RD_PFAPR_M1AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1AP_MASK) >> FMC_PFAPR_M1AP_SHIFT)
#define FMC_BRD_PFAPR_M1AP(base) (FMC_RD_PFAPR_M1AP(base))

/*! @brief Set the M1AP field to a new value. */
#define FMC_WR_PFAPR_M1AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1AP_MASK, FMC_PFAPR_M1AP(value)))
#define FMC_BWR_PFAPR_M1AP(base, value) (FMC_WR_PFAPR_M1AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2AP[5:4] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2AP field. */
#define FMC_RD_PFAPR_M2AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2AP_MASK) >> FMC_PFAPR_M2AP_SHIFT)
#define FMC_BRD_PFAPR_M2AP(base) (FMC_RD_PFAPR_M2AP(base))

/*! @brief Set the M2AP field to a new value. */
#define FMC_WR_PFAPR_M2AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2AP_MASK, FMC_PFAPR_M2AP(value)))
#define FMC_BWR_PFAPR_M2AP(base, value) (FMC_WR_PFAPR_M2AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3AP[7:6] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3AP field. */
#define FMC_RD_PFAPR_M3AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3AP_MASK) >> FMC_PFAPR_M3AP_SHIFT)
#define FMC_BRD_PFAPR_M3AP(base) (FMC_RD_PFAPR_M3AP(base))

/*! @brief Set the M3AP field to a new value. */
#define FMC_WR_PFAPR_M3AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3AP_MASK, FMC_PFAPR_M3AP(value)))
#define FMC_BWR_PFAPR_M3AP(base, value) (FMC_WR_PFAPR_M3AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M4AP[9:8] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M4AP field. */
#define FMC_RD_PFAPR_M4AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M4AP_MASK) >> FMC_PFAPR_M4AP_SHIFT)
#define FMC_BRD_PFAPR_M4AP(base) (FMC_RD_PFAPR_M4AP(base))

/*! @brief Set the M4AP field to a new value. */
#define FMC_WR_PFAPR_M4AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M4AP_MASK, FMC_PFAPR_M4AP(value)))
#define FMC_BWR_PFAPR_M4AP(base, value) (FMC_WR_PFAPR_M4AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M5AP[11:10] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M5AP field. */
#define FMC_RD_PFAPR_M5AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M5AP_MASK) >> FMC_PFAPR_M5AP_SHIFT)
#define FMC_BRD_PFAPR_M5AP(base) (FMC_RD_PFAPR_M5AP(base))

/*! @brief Set the M5AP field to a new value. */
#define FMC_WR_PFAPR_M5AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M5AP_MASK, FMC_PFAPR_M5AP(value)))
#define FMC_BWR_PFAPR_M5AP(base, value) (FMC_WR_PFAPR_M5AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M6AP[13:12] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master
 * - 01 - Only read accesses may be performed by this master
 * - 10 - Only write accesses may be performed by this master
 * - 11 - Both read and write accesses may be performed by this master
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M6AP field. */
#define FMC_RD_PFAPR_M6AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M6AP_MASK) >> FMC_PFAPR_M6AP_SHIFT)
#define FMC_BRD_PFAPR_M6AP(base) (FMC_RD_PFAPR_M6AP(base))

/*! @brief Set the M6AP field to a new value. */
#define FMC_WR_PFAPR_M6AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M6AP_MASK, FMC_PFAPR_M6AP(value)))
#define FMC_BWR_PFAPR_M6AP(base, value) (FMC_WR_PFAPR_M6AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M7AP[15:14] (RW)
 *
 * This field controls whether read and write access to the flash is allowed,
 * based on the logical master number of the requesting crossbar switch master.
 *
 * Values:
 * - 00 - No access may be performed by this master.
 * - 01 - Only read accesses may be performed by this master.
 * - 10 - Only write accesses may be performed by this master.
 * - 11 - Both read and write accesses may be performed by this master.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M7AP field. */
#define FMC_RD_PFAPR_M7AP(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M7AP_MASK) >> FMC_PFAPR_M7AP_SHIFT)
#define FMC_BRD_PFAPR_M7AP(base) (FMC_RD_PFAPR_M7AP(base))

/*! @brief Set the M7AP field to a new value. */
#define FMC_WR_PFAPR_M7AP(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M7AP_MASK, FMC_PFAPR_M7AP(value)))
#define FMC_BWR_PFAPR_M7AP(base, value) (FMC_WR_PFAPR_M7AP(base, value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M0PFD[16] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M0PFD field. */
#define FMC_RD_PFAPR_M0PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M0PFD_MASK) >> FMC_PFAPR_M0PFD_SHIFT)
#define FMC_BRD_PFAPR_M0PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0PFD_SHIFT))

/*! @brief Set the M0PFD field to a new value. */
#define FMC_WR_PFAPR_M0PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M0PFD_MASK, FMC_PFAPR_M0PFD(value)))
#define FMC_BWR_PFAPR_M0PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M0PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M1PFD[17] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M1PFD field. */
#define FMC_RD_PFAPR_M1PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M1PFD_MASK) >> FMC_PFAPR_M1PFD_SHIFT)
#define FMC_BRD_PFAPR_M1PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1PFD_SHIFT))

/*! @brief Set the M1PFD field to a new value. */
#define FMC_WR_PFAPR_M1PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M1PFD_MASK, FMC_PFAPR_M1PFD(value)))
#define FMC_BWR_PFAPR_M1PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M1PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M2PFD[18] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M2PFD field. */
#define FMC_RD_PFAPR_M2PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M2PFD_MASK) >> FMC_PFAPR_M2PFD_SHIFT)
#define FMC_BRD_PFAPR_M2PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2PFD_SHIFT))

/*! @brief Set the M2PFD field to a new value. */
#define FMC_WR_PFAPR_M2PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M2PFD_MASK, FMC_PFAPR_M2PFD(value)))
#define FMC_BWR_PFAPR_M2PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M2PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M3PFD[19] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M3PFD field. */
#define FMC_RD_PFAPR_M3PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M3PFD_MASK) >> FMC_PFAPR_M3PFD_SHIFT)
#define FMC_BRD_PFAPR_M3PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3PFD_SHIFT))

/*! @brief Set the M3PFD field to a new value. */
#define FMC_WR_PFAPR_M3PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M3PFD_MASK, FMC_PFAPR_M3PFD(value)))
#define FMC_BWR_PFAPR_M3PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M3PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M4PFD[20] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M4PFD field. */
#define FMC_RD_PFAPR_M4PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M4PFD_MASK) >> FMC_PFAPR_M4PFD_SHIFT)
#define FMC_BRD_PFAPR_M4PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M4PFD_SHIFT))

/*! @brief Set the M4PFD field to a new value. */
#define FMC_WR_PFAPR_M4PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M4PFD_MASK, FMC_PFAPR_M4PFD(value)))
#define FMC_BWR_PFAPR_M4PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M4PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M5PFD[21] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M5PFD field. */
#define FMC_RD_PFAPR_M5PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M5PFD_MASK) >> FMC_PFAPR_M5PFD_SHIFT)
#define FMC_BRD_PFAPR_M5PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M5PFD_SHIFT))

/*! @brief Set the M5PFD field to a new value. */
#define FMC_WR_PFAPR_M5PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M5PFD_MASK, FMC_PFAPR_M5PFD(value)))
#define FMC_BWR_PFAPR_M5PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M5PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M6PFD[22] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M6PFD field. */
#define FMC_RD_PFAPR_M6PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M6PFD_MASK) >> FMC_PFAPR_M6PFD_SHIFT)
#define FMC_BRD_PFAPR_M6PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M6PFD_SHIFT))

/*! @brief Set the M6PFD field to a new value. */
#define FMC_WR_PFAPR_M6PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M6PFD_MASK, FMC_PFAPR_M6PFD(value)))
#define FMC_BWR_PFAPR_M6PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M6PFD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFAPR, field M7PFD[23] (RW)
 *
 * These bits control whether prefetching is enabled, based on the logical
 * number of the requesting crossbar switch master. This field is further qualified by
 * the PFBnCR[BxDPE,BxIPE] bits.
 *
 * Values:
 * - 0 - Prefetching for this master is enabled.
 * - 1 - Prefetching for this master is disabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFAPR_M7PFD field. */
#define FMC_RD_PFAPR_M7PFD(base) ((FMC_PFAPR_REG(base) & FMC_PFAPR_M7PFD_MASK) >> FMC_PFAPR_M7PFD_SHIFT)
#define FMC_BRD_PFAPR_M7PFD(base) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M7PFD_SHIFT))

/*! @brief Set the M7PFD field to a new value. */
#define FMC_WR_PFAPR_M7PFD(base, value) (FMC_RMW_PFAPR(base, FMC_PFAPR_M7PFD_MASK, FMC_PFAPR_M7PFD(value)))
#define FMC_BWR_PFAPR_M7PFD(base, value) (BITBAND_ACCESS32(&FMC_PFAPR_REG(base), FMC_PFAPR_M7PFD_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FMC_PFB0CR - Flash Bank 0 Control Register
 ******************************************************************************/

/*!
 * @brief FMC_PFB0CR - Flash Bank 0 Control Register (RW)
 *
 * Reset value: 0x3002001FU
 */
/*!
 * @name Constants and macros for entire FMC_PFB0CR register
 */
/*@{*/
#define FMC_RD_PFB0CR(base)      (FMC_PFB0CR_REG(base))
#define FMC_WR_PFB0CR(base, value) (FMC_PFB0CR_REG(base) = (value))
#define FMC_RMW_PFB0CR(base, mask, value) (FMC_WR_PFB0CR(base, (FMC_RD_PFB0CR(base) & ~(mask)) | (value)))
#define FMC_SET_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) |  (value)))
#define FMC_CLR_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) & ~(value)))
#define FMC_TOG_PFB0CR(base, value) (FMC_WR_PFB0CR(base, FMC_RD_PFB0CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB0CR bitfields
 */

/*!
 * @name Register FMC_PFB0CR, field B0SEBE[0] (RW)
 *
 * This bit controls whether the single entry page buffer is enabled in response
 * to flash read accesses. Its operation is independent from bank 1's cache. A
 * high-to-low transition of this enable forces the page buffer to be invalidated.
 *
 * Values:
 * - 0 - Single entry buffer is disabled.
 * - 1 - Single entry buffer is enabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0SEBE field. */
#define FMC_RD_PFB0CR_B0SEBE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0SEBE_MASK) >> FMC_PFB0CR_B0SEBE_SHIFT)
#define FMC_BRD_PFB0CR_B0SEBE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0SEBE_SHIFT))

/*! @brief Set the B0SEBE field to a new value. */
#define FMC_WR_PFB0CR_B0SEBE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0SEBE_MASK, FMC_PFB0CR_B0SEBE(value)))
#define FMC_BWR_PFB0CR_B0SEBE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0SEBE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0 - Do not prefetch in response to instruction fetches.
 * - 1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0IPE field. */
#define FMC_RD_PFB0CR_B0IPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0IPE_MASK) >> FMC_PFB0CR_B0IPE_SHIFT)
#define FMC_BRD_PFB0CR_B0IPE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0IPE_SHIFT))

/*! @brief Set the B0IPE field to a new value. */
#define FMC_WR_PFB0CR_B0IPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0IPE_MASK, FMC_PFB0CR_B0IPE(value)))
#define FMC_BWR_PFB0CR_B0IPE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0IPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0 - Do not prefetch in response to data references.
 * - 1 - Enable prefetches in response to data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0DPE field. */
#define FMC_RD_PFB0CR_B0DPE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0DPE_MASK) >> FMC_PFB0CR_B0DPE_SHIFT)
#define FMC_BRD_PFB0CR_B0DPE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DPE_SHIFT))

/*! @brief Set the B0DPE field to a new value. */
#define FMC_WR_PFB0CR_B0DPE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0DPE_MASK, FMC_PFB0CR_B0DPE(value)))
#define FMC_BWR_PFB0CR_B0DPE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0ICE[3] (RW)
 *
 * This bit controls whether instruction fetches are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache instruction fetches.
 * - 1 - Cache instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0ICE field. */
#define FMC_RD_PFB0CR_B0ICE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0ICE_MASK) >> FMC_PFB0CR_B0ICE_SHIFT)
#define FMC_BRD_PFB0CR_B0ICE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0ICE_SHIFT))

/*! @brief Set the B0ICE field to a new value. */
#define FMC_WR_PFB0CR_B0ICE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0ICE_MASK, FMC_PFB0CR_B0ICE(value)))
#define FMC_BWR_PFB0CR_B0ICE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0ICE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0DCE[4] (RW)
 *
 * This bit controls whether data references are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache data references.
 * - 1 - Cache data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0DCE field. */
#define FMC_RD_PFB0CR_B0DCE(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0DCE_MASK) >> FMC_PFB0CR_B0DCE_SHIFT)
#define FMC_BRD_PFB0CR_B0DCE(base) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DCE_SHIFT))

/*! @brief Set the B0DCE field to a new value. */
#define FMC_WR_PFB0CR_B0DCE(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_B0DCE_MASK, FMC_PFB0CR_B0DCE(value)))
#define FMC_BWR_PFB0CR_B0DCE(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_B0DCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CRC[7:5] (RW)
 *
 * This 3-bit field defines the replacement algorithm for accesses that are
 * cached.
 *
 * Values:
 * - 000 - LRU replacement algorithm per set across all four ways
 * - 001 - Reserved
 * - 010 - Independent LRU with ways [0-1] for ifetches, [2-3] for data
 * - 011 - Independent LRU with ways [0-2] for ifetches, [3] for data
 * - 1xx - Reserved
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_CRC field. */
#define FMC_RD_PFB0CR_CRC(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_CRC_MASK) >> FMC_PFB0CR_CRC_SHIFT)
#define FMC_BRD_PFB0CR_CRC(base) (FMC_RD_PFB0CR_CRC(base))

/*! @brief Set the CRC field to a new value. */
#define FMC_WR_PFB0CR_CRC(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CRC_MASK, FMC_PFB0CR_CRC(value)))
#define FMC_BWR_PFB0CR_CRC(base, value) (FMC_WR_PFB0CR_CRC(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0MW[18:17] (RO)
 *
 * This read-only field defines the width of the bank 0 memory.
 *
 * Values:
 * - 00 - 32 bits
 * - 01 - 64 bits
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0MW field. */
#define FMC_RD_PFB0CR_B0MW(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0MW_MASK) >> FMC_PFB0CR_B0MW_SHIFT)
#define FMC_BRD_PFB0CR_B0MW(base) (FMC_RD_PFB0CR_B0MW(base))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field S_B_INV[19] (WORZ)
 *
 * This bit determines if the FMC's prefetch speculation buffer and the single
 * entry page buffer are to be invalidated (cleared). When this bit is written,
 * the speculation buffer and single entry buffer are immediately cleared. This bit
 * always reads as zero.
 *
 * Values:
 * - 0 - Speculation buffer and single entry buffer are not affected.
 * - 1 - Invalidate (clear) speculation buffer and single entry buffer.
 */
/*@{*/
/*! @brief Set the S_B_INV field to a new value. */
#define FMC_WR_PFB0CR_S_B_INV(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_S_B_INV_MASK, FMC_PFB0CR_S_B_INV(value)))
#define FMC_BWR_PFB0CR_S_B_INV(base, value) (BITBAND_ACCESS32(&FMC_PFB0CR_REG(base), FMC_PFB0CR_S_B_INV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CINV_WAY[23:20] (WORZ)
 *
 * These bits determine if the given cache way is to be invalidated (cleared).
 * When a bit within this field is written, the corresponding cache way is
 * immediately invalidated: the way's tag, data, and valid contents are cleared. This
 * field always reads as zero. Cache invalidation takes precedence over locking.
 * The cache is invalidated by system reset. System software is required to
 * maintain memory coherency when any segment of the flash memory is programmed or
 * erased. Accordingly, cache invalidations must occur after a programming or erase
 * event is completed and before the new memory image is accessed. The bit setting
 * definitions are for each bit in the field.
 *
 * Values:
 * - 0 - No cache way invalidation for the corresponding cache
 * - 1 - Invalidate cache way for the corresponding cache: clear the tag, data,
 *     and vld bits of ways selected
 */
/*@{*/
/*! @brief Set the CINV_WAY field to a new value. */
#define FMC_WR_PFB0CR_CINV_WAY(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CINV_WAY_MASK, FMC_PFB0CR_CINV_WAY(value)))
#define FMC_BWR_PFB0CR_CINV_WAY(base, value) (FMC_WR_PFB0CR_CINV_WAY(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field CLCK_WAY[27:24] (RW)
 *
 * These bits determine if the given cache way is locked such that its contents
 * will not be displaced by future misses. The bit setting definitions are for
 * each bit in the field.
 *
 * Values:
 * - 0 - Cache way is unlocked and may be displaced
 * - 1 - Cache way is locked and its contents are not displaced
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_CLCK_WAY field. */
#define FMC_RD_PFB0CR_CLCK_WAY(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_CLCK_WAY_MASK) >> FMC_PFB0CR_CLCK_WAY_SHIFT)
#define FMC_BRD_PFB0CR_CLCK_WAY(base) (FMC_RD_PFB0CR_CLCK_WAY(base))

/*! @brief Set the CLCK_WAY field to a new value. */
#define FMC_WR_PFB0CR_CLCK_WAY(base, value) (FMC_RMW_PFB0CR(base, FMC_PFB0CR_CLCK_WAY_MASK, FMC_PFB0CR_CLCK_WAY(value)))
#define FMC_BWR_PFB0CR_CLCK_WAY(base, value) (FMC_WR_PFB0CR_CLCK_WAY(base, value))
/*@}*/

/*!
 * @name Register FMC_PFB0CR, field B0RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * bank 0 flash memory. The relationship between the read access time of the
 * flash array (expressed in system clock cycles) and RWSC is defined as: Access
 * time of flash array [system clocks] = RWSC + 1 The FMC automatically calculates
 * this value based on the ratio of the system clock speed to the flash clock
 * speed. For example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB0CR_B0RWSC field. */
#define FMC_RD_PFB0CR_B0RWSC(base) ((FMC_PFB0CR_REG(base) & FMC_PFB0CR_B0RWSC_MASK) >> FMC_PFB0CR_B0RWSC_SHIFT)
#define FMC_BRD_PFB0CR_B0RWSC(base) (FMC_RD_PFB0CR_B0RWSC(base))
/*@}*/

/*******************************************************************************
 * FMC_PFB1CR - Flash Bank 1 Control Register
 ******************************************************************************/

/*!
 * @brief FMC_PFB1CR - Flash Bank 1 Control Register (RW)
 *
 * Reset value: 0x3002001FU
 *
 * This register has a format similar to that for PFB0CR, except it controls the
 * operation of flash bank 1, and the "global" cache control fields are empty.
 */
/*!
 * @name Constants and macros for entire FMC_PFB1CR register
 */
/*@{*/
#define FMC_RD_PFB1CR(base)      (FMC_PFB1CR_REG(base))
#define FMC_WR_PFB1CR(base, value) (FMC_PFB1CR_REG(base) = (value))
#define FMC_RMW_PFB1CR(base, mask, value) (FMC_WR_PFB1CR(base, (FMC_RD_PFB1CR(base) & ~(mask)) | (value)))
#define FMC_SET_PFB1CR(base, value) (FMC_WR_PFB1CR(base, FMC_RD_PFB1CR(base) |  (value)))
#define FMC_CLR_PFB1CR(base, value) (FMC_WR_PFB1CR(base, FMC_RD_PFB1CR(base) & ~(value)))
#define FMC_TOG_PFB1CR(base, value) (FMC_WR_PFB1CR(base, FMC_RD_PFB1CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_PFB1CR bitfields
 */

/*!
 * @name Register FMC_PFB1CR, field B1SEBE[0] (RW)
 *
 * This bit controls whether the single entry buffer is enabled in response to
 * flash read accesses. Its operation is independent from bank 0's cache. A
 * high-to-low transition of this enable forces the page buffer to be invalidated.
 *
 * Values:
 * - 0 - Single entry buffer is disabled.
 * - 1 - Single entry buffer is enabled.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1SEBE field. */
#define FMC_RD_PFB1CR_B1SEBE(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1SEBE_MASK) >> FMC_PFB1CR_B1SEBE_SHIFT)
#define FMC_BRD_PFB1CR_B1SEBE(base) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1SEBE_SHIFT))

/*! @brief Set the B1SEBE field to a new value. */
#define FMC_WR_PFB1CR_B1SEBE(base, value) (FMC_RMW_PFB1CR(base, FMC_PFB1CR_B1SEBE_MASK, FMC_PFB1CR_B1SEBE(value)))
#define FMC_BWR_PFB1CR_B1SEBE(base, value) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1SEBE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1IPE[1] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to instruction fetches.
 *
 * Values:
 * - 0 - Do not prefetch in response to instruction fetches.
 * - 1 - Enable prefetches in response to instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1IPE field. */
#define FMC_RD_PFB1CR_B1IPE(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1IPE_MASK) >> FMC_PFB1CR_B1IPE_SHIFT)
#define FMC_BRD_PFB1CR_B1IPE(base) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1IPE_SHIFT))

/*! @brief Set the B1IPE field to a new value. */
#define FMC_WR_PFB1CR_B1IPE(base, value) (FMC_RMW_PFB1CR(base, FMC_PFB1CR_B1IPE_MASK, FMC_PFB1CR_B1IPE(value)))
#define FMC_BWR_PFB1CR_B1IPE(base, value) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1IPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1DPE[2] (RW)
 *
 * This bit controls whether prefetches (or speculative accesses) are initiated
 * in response to data references.
 *
 * Values:
 * - 0 - Do not prefetch in response to data references.
 * - 1 - Enable prefetches in response to data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1DPE field. */
#define FMC_RD_PFB1CR_B1DPE(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1DPE_MASK) >> FMC_PFB1CR_B1DPE_SHIFT)
#define FMC_BRD_PFB1CR_B1DPE(base) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1DPE_SHIFT))

/*! @brief Set the B1DPE field to a new value. */
#define FMC_WR_PFB1CR_B1DPE(base, value) (FMC_RMW_PFB1CR(base, FMC_PFB1CR_B1DPE_MASK, FMC_PFB1CR_B1DPE(value)))
#define FMC_BWR_PFB1CR_B1DPE(base, value) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1DPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1ICE[3] (RW)
 *
 * This bit controls whether instruction fetches are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache instruction fetches.
 * - 1 - Cache instruction fetches.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1ICE field. */
#define FMC_RD_PFB1CR_B1ICE(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1ICE_MASK) >> FMC_PFB1CR_B1ICE_SHIFT)
#define FMC_BRD_PFB1CR_B1ICE(base) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1ICE_SHIFT))

/*! @brief Set the B1ICE field to a new value. */
#define FMC_WR_PFB1CR_B1ICE(base, value) (FMC_RMW_PFB1CR(base, FMC_PFB1CR_B1ICE_MASK, FMC_PFB1CR_B1ICE(value)))
#define FMC_BWR_PFB1CR_B1ICE(base, value) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1ICE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1DCE[4] (RW)
 *
 * This bit controls whether data references are loaded into the cache.
 *
 * Values:
 * - 0 - Do not cache data references.
 * - 1 - Cache data references.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1DCE field. */
#define FMC_RD_PFB1CR_B1DCE(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1DCE_MASK) >> FMC_PFB1CR_B1DCE_SHIFT)
#define FMC_BRD_PFB1CR_B1DCE(base) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1DCE_SHIFT))

/*! @brief Set the B1DCE field to a new value. */
#define FMC_WR_PFB1CR_B1DCE(base, value) (FMC_RMW_PFB1CR(base, FMC_PFB1CR_B1DCE_MASK, FMC_PFB1CR_B1DCE(value)))
#define FMC_BWR_PFB1CR_B1DCE(base, value) (BITBAND_ACCESS32(&FMC_PFB1CR_REG(base), FMC_PFB1CR_B1DCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1MW[18:17] (RO)
 *
 * This read-only field defines the width of the bank 1 memory.
 *
 * Values:
 * - 00 - 32 bits
 * - 01 - 64 bits
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1MW field. */
#define FMC_RD_PFB1CR_B1MW(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1MW_MASK) >> FMC_PFB1CR_B1MW_SHIFT)
#define FMC_BRD_PFB1CR_B1MW(base) (FMC_RD_PFB1CR_B1MW(base))
/*@}*/

/*!
 * @name Register FMC_PFB1CR, field B1RWSC[31:28] (RO)
 *
 * This read-only field defines the number of wait states required to access the
 * bank 1 flash memory. The relationship between the read access time of the
 * flash array (expressed in system clock cycles) and RWSC is defined as: Access
 * time of flash array [system clocks] = RWSC + 1 The FMC automatically calculates
 * this value based on the ratio of the system clock speed to the flash clock
 * speed. For example, when this ratio is 4:1, the field's value is 3h.
 */
/*@{*/
/*! @brief Read current value of the FMC_PFB1CR_B1RWSC field. */
#define FMC_RD_PFB1CR_B1RWSC(base) ((FMC_PFB1CR_REG(base) & FMC_PFB1CR_B1RWSC_MASK) >> FMC_PFB1CR_B1RWSC_SHIFT)
#define FMC_BRD_PFB1CR_B1RWSC(base) (FMC_RD_PFB1CR_B1RWSC(base))
/*@}*/

/*******************************************************************************
 * FMC_TAGVDW0S - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief FMC_TAGVDW0S - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 8 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-7. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_TAGVDW0S register
 */
/*@{*/
#define FMC_RD_TAGVDW0S(base, index) (FMC_TAGVDW0S_REG(base, index))
#define FMC_WR_TAGVDW0S(base, index, value) (FMC_TAGVDW0S_REG(base, index) = (value))
#define FMC_RMW_TAGVDW0S(base, index, mask, value) (FMC_WR_TAGVDW0S(base, index, (FMC_RD_TAGVDW0S(base, index) & ~(mask)) | (value)))
#define FMC_SET_TAGVDW0S(base, index, value) (FMC_WR_TAGVDW0S(base, index, FMC_RD_TAGVDW0S(base, index) |  (value)))
#define FMC_CLR_TAGVDW0S(base, index, value) (FMC_WR_TAGVDW0S(base, index, FMC_RD_TAGVDW0S(base, index) & ~(value)))
#define FMC_TOG_TAGVDW0S(base, index, value) (FMC_WR_TAGVDW0S(base, index, FMC_RD_TAGVDW0S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW0S bitfields
 */

/*!
 * @name Register FMC_TAGVDW0S, field valid[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW0S_valid field. */
#define FMC_RD_TAGVDW0S_valid(base, index) ((FMC_TAGVDW0S_REG(base, index) & FMC_TAGVDW0S_valid_MASK) >> FMC_TAGVDW0S_valid_SHIFT)
#define FMC_BRD_TAGVDW0S_valid(base, index) (BITBAND_ACCESS32(&FMC_TAGVDW0S_REG(base, index), FMC_TAGVDW0S_valid_SHIFT))

/*! @brief Set the valid field to a new value. */
#define FMC_WR_TAGVDW0S_valid(base, index, value) (FMC_RMW_TAGVDW0S(base, index, FMC_TAGVDW0S_valid_MASK, FMC_TAGVDW0S_valid(value)))
#define FMC_BWR_TAGVDW0S_valid(base, index, value) (BITBAND_ACCESS32(&FMC_TAGVDW0S_REG(base, index), FMC_TAGVDW0S_valid_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_TAGVDW0S, field tag[18:5] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW0S_tag field. */
#define FMC_RD_TAGVDW0S_tag(base, index) ((FMC_TAGVDW0S_REG(base, index) & FMC_TAGVDW0S_tag_MASK) >> FMC_TAGVDW0S_tag_SHIFT)
#define FMC_BRD_TAGVDW0S_tag(base, index) (FMC_RD_TAGVDW0S_tag(base, index))

/*! @brief Set the tag field to a new value. */
#define FMC_WR_TAGVDW0S_tag(base, index, value) (FMC_RMW_TAGVDW0S(base, index, FMC_TAGVDW0S_tag_MASK, FMC_TAGVDW0S_tag(value)))
#define FMC_BWR_TAGVDW0S_tag(base, index, value) (FMC_WR_TAGVDW0S_tag(base, index, value))
/*@}*/

/*******************************************************************************
 * FMC_TAGVDW1S - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief FMC_TAGVDW1S - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 8 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-7. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_TAGVDW1S register
 */
/*@{*/
#define FMC_RD_TAGVDW1S(base, index) (FMC_TAGVDW1S_REG(base, index))
#define FMC_WR_TAGVDW1S(base, index, value) (FMC_TAGVDW1S_REG(base, index) = (value))
#define FMC_RMW_TAGVDW1S(base, index, mask, value) (FMC_WR_TAGVDW1S(base, index, (FMC_RD_TAGVDW1S(base, index) & ~(mask)) | (value)))
#define FMC_SET_TAGVDW1S(base, index, value) (FMC_WR_TAGVDW1S(base, index, FMC_RD_TAGVDW1S(base, index) |  (value)))
#define FMC_CLR_TAGVDW1S(base, index, value) (FMC_WR_TAGVDW1S(base, index, FMC_RD_TAGVDW1S(base, index) & ~(value)))
#define FMC_TOG_TAGVDW1S(base, index, value) (FMC_WR_TAGVDW1S(base, index, FMC_RD_TAGVDW1S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW1S bitfields
 */

/*!
 * @name Register FMC_TAGVDW1S, field valid[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW1S_valid field. */
#define FMC_RD_TAGVDW1S_valid(base, index) ((FMC_TAGVDW1S_REG(base, index) & FMC_TAGVDW1S_valid_MASK) >> FMC_TAGVDW1S_valid_SHIFT)
#define FMC_BRD_TAGVDW1S_valid(base, index) (BITBAND_ACCESS32(&FMC_TAGVDW1S_REG(base, index), FMC_TAGVDW1S_valid_SHIFT))

/*! @brief Set the valid field to a new value. */
#define FMC_WR_TAGVDW1S_valid(base, index, value) (FMC_RMW_TAGVDW1S(base, index, FMC_TAGVDW1S_valid_MASK, FMC_TAGVDW1S_valid(value)))
#define FMC_BWR_TAGVDW1S_valid(base, index, value) (BITBAND_ACCESS32(&FMC_TAGVDW1S_REG(base, index), FMC_TAGVDW1S_valid_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_TAGVDW1S, field tag[18:5] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW1S_tag field. */
#define FMC_RD_TAGVDW1S_tag(base, index) ((FMC_TAGVDW1S_REG(base, index) & FMC_TAGVDW1S_tag_MASK) >> FMC_TAGVDW1S_tag_SHIFT)
#define FMC_BRD_TAGVDW1S_tag(base, index) (FMC_RD_TAGVDW1S_tag(base, index))

/*! @brief Set the tag field to a new value. */
#define FMC_WR_TAGVDW1S_tag(base, index, value) (FMC_RMW_TAGVDW1S(base, index, FMC_TAGVDW1S_tag_MASK, FMC_TAGVDW1S_tag(value)))
#define FMC_BWR_TAGVDW1S_tag(base, index, value) (FMC_WR_TAGVDW1S_tag(base, index, value))
/*@}*/

/*******************************************************************************
 * FMC_TAGVDW2S - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief FMC_TAGVDW2S - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 8 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-7. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_TAGVDW2S register
 */
/*@{*/
#define FMC_RD_TAGVDW2S(base, index) (FMC_TAGVDW2S_REG(base, index))
#define FMC_WR_TAGVDW2S(base, index, value) (FMC_TAGVDW2S_REG(base, index) = (value))
#define FMC_RMW_TAGVDW2S(base, index, mask, value) (FMC_WR_TAGVDW2S(base, index, (FMC_RD_TAGVDW2S(base, index) & ~(mask)) | (value)))
#define FMC_SET_TAGVDW2S(base, index, value) (FMC_WR_TAGVDW2S(base, index, FMC_RD_TAGVDW2S(base, index) |  (value)))
#define FMC_CLR_TAGVDW2S(base, index, value) (FMC_WR_TAGVDW2S(base, index, FMC_RD_TAGVDW2S(base, index) & ~(value)))
#define FMC_TOG_TAGVDW2S(base, index, value) (FMC_WR_TAGVDW2S(base, index, FMC_RD_TAGVDW2S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW2S bitfields
 */

/*!
 * @name Register FMC_TAGVDW2S, field valid[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW2S_valid field. */
#define FMC_RD_TAGVDW2S_valid(base, index) ((FMC_TAGVDW2S_REG(base, index) & FMC_TAGVDW2S_valid_MASK) >> FMC_TAGVDW2S_valid_SHIFT)
#define FMC_BRD_TAGVDW2S_valid(base, index) (BITBAND_ACCESS32(&FMC_TAGVDW2S_REG(base, index), FMC_TAGVDW2S_valid_SHIFT))

/*! @brief Set the valid field to a new value. */
#define FMC_WR_TAGVDW2S_valid(base, index, value) (FMC_RMW_TAGVDW2S(base, index, FMC_TAGVDW2S_valid_MASK, FMC_TAGVDW2S_valid(value)))
#define FMC_BWR_TAGVDW2S_valid(base, index, value) (BITBAND_ACCESS32(&FMC_TAGVDW2S_REG(base, index), FMC_TAGVDW2S_valid_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_TAGVDW2S, field tag[18:5] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW2S_tag field. */
#define FMC_RD_TAGVDW2S_tag(base, index) ((FMC_TAGVDW2S_REG(base, index) & FMC_TAGVDW2S_tag_MASK) >> FMC_TAGVDW2S_tag_SHIFT)
#define FMC_BRD_TAGVDW2S_tag(base, index) (FMC_RD_TAGVDW2S_tag(base, index))

/*! @brief Set the tag field to a new value. */
#define FMC_WR_TAGVDW2S_tag(base, index, value) (FMC_RMW_TAGVDW2S(base, index, FMC_TAGVDW2S_tag_MASK, FMC_TAGVDW2S_tag(value)))
#define FMC_BWR_TAGVDW2S_tag(base, index, value) (FMC_WR_TAGVDW2S_tag(base, index, value))
/*@}*/

/*******************************************************************************
 * FMC_TAGVDW3S - Cache Tag Storage
 ******************************************************************************/

/*!
 * @brief FMC_TAGVDW3S - Cache Tag Storage (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache is a 4-way, set-associative cache with 8 sets. The ways are
 * numbered 0-3 and the sets are numbered 0-7. In TAGVDWxSy, x denotes the way, and y
 * denotes the set. This section represents tag/vld information for all sets in the
 * indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_TAGVDW3S register
 */
/*@{*/
#define FMC_RD_TAGVDW3S(base, index) (FMC_TAGVDW3S_REG(base, index))
#define FMC_WR_TAGVDW3S(base, index, value) (FMC_TAGVDW3S_REG(base, index) = (value))
#define FMC_RMW_TAGVDW3S(base, index, mask, value) (FMC_WR_TAGVDW3S(base, index, (FMC_RD_TAGVDW3S(base, index) & ~(mask)) | (value)))
#define FMC_SET_TAGVDW3S(base, index, value) (FMC_WR_TAGVDW3S(base, index, FMC_RD_TAGVDW3S(base, index) |  (value)))
#define FMC_CLR_TAGVDW3S(base, index, value) (FMC_WR_TAGVDW3S(base, index, FMC_RD_TAGVDW3S(base, index) & ~(value)))
#define FMC_TOG_TAGVDW3S(base, index, value) (FMC_WR_TAGVDW3S(base, index, FMC_RD_TAGVDW3S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FMC_TAGVDW3S bitfields
 */

/*!
 * @name Register FMC_TAGVDW3S, field valid[0] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW3S_valid field. */
#define FMC_RD_TAGVDW3S_valid(base, index) ((FMC_TAGVDW3S_REG(base, index) & FMC_TAGVDW3S_valid_MASK) >> FMC_TAGVDW3S_valid_SHIFT)
#define FMC_BRD_TAGVDW3S_valid(base, index) (BITBAND_ACCESS32(&FMC_TAGVDW3S_REG(base, index), FMC_TAGVDW3S_valid_SHIFT))

/*! @brief Set the valid field to a new value. */
#define FMC_WR_TAGVDW3S_valid(base, index, value) (FMC_RMW_TAGVDW3S(base, index, FMC_TAGVDW3S_valid_MASK, FMC_TAGVDW3S_valid(value)))
#define FMC_BWR_TAGVDW3S_valid(base, index, value) (BITBAND_ACCESS32(&FMC_TAGVDW3S_REG(base, index), FMC_TAGVDW3S_valid_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FMC_TAGVDW3S, field tag[18:5] (RW)
 */
/*@{*/
/*! @brief Read current value of the FMC_TAGVDW3S_tag field. */
#define FMC_RD_TAGVDW3S_tag(base, index) ((FMC_TAGVDW3S_REG(base, index) & FMC_TAGVDW3S_tag_MASK) >> FMC_TAGVDW3S_tag_SHIFT)
#define FMC_BRD_TAGVDW3S_tag(base, index) (FMC_RD_TAGVDW3S_tag(base, index))

/*! @brief Set the tag field to a new value. */
#define FMC_WR_TAGVDW3S_tag(base, index, value) (FMC_RMW_TAGVDW3S(base, index, FMC_TAGVDW3S_tag_MASK, FMC_TAGVDW3S_tag(value)))
#define FMC_BWR_TAGVDW3S_tag(base, index, value) (FMC_WR_TAGVDW3S_tag(base, index, value))
/*@}*/

/*******************************************************************************
 * FMC_DATA_U - Cache Data Storage (upper word)
 ******************************************************************************/

/*!
 * @brief FMC_DATA_U - Cache Data Storage (upper word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 8 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-7. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the upper word (bits
 * [63:32]) of all sets in the indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_DATA_U register
 */
/*@{*/
#define FMC_RD_DATA_U(base, index, index2) (FMC_DATA_U_REG(base, index, index2))
#define FMC_WR_DATA_U(base, index, index2, value) (FMC_DATA_U_REG(base, index, index2) = (value))
#define FMC_RMW_DATA_U(base, index, index2, mask, value) (FMC_WR_DATA_U(base, index, index2, (FMC_RD_DATA_U(base, index, index2) & ~(mask)) | (value)))
#define FMC_SET_DATA_U(base, index, index2, value) (FMC_WR_DATA_U(base, index, index2, FMC_RD_DATA_U(base, index, index2) |  (value)))
#define FMC_CLR_DATA_U(base, index, index2, value) (FMC_WR_DATA_U(base, index, index2, FMC_RD_DATA_U(base, index, index2) & ~(value)))
#define FMC_TOG_DATA_U(base, index, index2, value) (FMC_WR_DATA_U(base, index, index2, FMC_RD_DATA_U(base, index, index2) ^  (value)))
/*@}*/

/*******************************************************************************
 * FMC_DATA_L - Cache Data Storage (lower word)
 ******************************************************************************/

/*!
 * @brief FMC_DATA_L - Cache Data Storage (lower word) (RW)
 *
 * Reset value: 0x00000000U
 *
 * The cache of 64-bit entries is a 4-way, set-associative cache with 8 sets.
 * The ways are numbered 0-3 and the sets are numbered 0-7. In DATAWxSyU and
 * DATAWxSyL, x denotes the way, y denotes the set, and U and L represent upper and
 * lower word, respectively. This section represents data for the lower word (bits
 * [31:0]) of all sets in the indicated way.
 */
/*!
 * @name Constants and macros for entire FMC_DATA_L register
 */
/*@{*/
#define FMC_RD_DATA_L(base, index, index2) (FMC_DATA_L_REG(base, index, index2))
#define FMC_WR_DATA_L(base, index, index2, value) (FMC_DATA_L_REG(base, index, index2) = (value))
#define FMC_RMW_DATA_L(base, index, index2, mask, value) (FMC_WR_DATA_L(base, index, index2, (FMC_RD_DATA_L(base, index, index2) & ~(mask)) | (value)))
#define FMC_SET_DATA_L(base, index, index2, value) (FMC_WR_DATA_L(base, index, index2, FMC_RD_DATA_L(base, index, index2) |  (value)))
#define FMC_CLR_DATA_L(base, index, index2, value) (FMC_WR_DATA_L(base, index, index2, FMC_RD_DATA_L(base, index, index2) & ~(value)))
#define FMC_TOG_DATA_L(base, index, index2, value) (FMC_WR_DATA_L(base, index, index2, FMC_RD_DATA_L(base, index, index2) ^  (value)))
/*@}*/

/*
 * MKS22F25612 FTFA
 *
 * Flash Memory Interface
 *
 * Registers defined in this header file:
 * - FTFA_FSTAT - Flash Status Register
 * - FTFA_FCNFG - Flash Configuration Register
 * - FTFA_FSEC - Flash Security Register
 * - FTFA_FOPT - Flash Option Register
 * - FTFA_FCCOB3 - Flash Common Command Object Registers
 * - FTFA_FCCOB2 - Flash Common Command Object Registers
 * - FTFA_FCCOB1 - Flash Common Command Object Registers
 * - FTFA_FCCOB0 - Flash Common Command Object Registers
 * - FTFA_FCCOB7 - Flash Common Command Object Registers
 * - FTFA_FCCOB6 - Flash Common Command Object Registers
 * - FTFA_FCCOB5 - Flash Common Command Object Registers
 * - FTFA_FCCOB4 - Flash Common Command Object Registers
 * - FTFA_FCCOBB - Flash Common Command Object Registers
 * - FTFA_FCCOBA - Flash Common Command Object Registers
 * - FTFA_FCCOB9 - Flash Common Command Object Registers
 * - FTFA_FCCOB8 - Flash Common Command Object Registers
 * - FTFA_FPROT3 - Program Flash Protection Registers
 * - FTFA_FPROT2 - Program Flash Protection Registers
 * - FTFA_FPROT1 - Program Flash Protection Registers
 * - FTFA_FPROT0 - Program Flash Protection Registers
 * - FTFA_XACCH3 - Execute-only Access Registers
 * - FTFA_XACCH2 - Execute-only Access Registers
 * - FTFA_XACCH1 - Execute-only Access Registers
 * - FTFA_XACCH0 - Execute-only Access Registers
 * - FTFA_XACCL3 - Execute-only Access Registers
 * - FTFA_XACCL2 - Execute-only Access Registers
 * - FTFA_XACCL1 - Execute-only Access Registers
 * - FTFA_XACCL0 - Execute-only Access Registers
 * - FTFA_SACCH3 - Supervisor-only Access Registers
 * - FTFA_SACCH2 - Supervisor-only Access Registers
 * - FTFA_SACCH1 - Supervisor-only Access Registers
 * - FTFA_SACCH0 - Supervisor-only Access Registers
 * - FTFA_SACCL3 - Supervisor-only Access Registers
 * - FTFA_SACCL2 - Supervisor-only Access Registers
 * - FTFA_SACCL1 - Supervisor-only Access Registers
 * - FTFA_SACCL0 - Supervisor-only Access Registers
 * - FTFA_FACSS - Flash Access Segment Size Register
 * - FTFA_FACSN - Flash Access Segment Number Register
 */

#define FTFA_INSTANCE_COUNT (1U) /*!< Number of instances of the FTFA module. */
#define FTFA_IDX (0U) /*!< Instance number for FTFA. */

/*******************************************************************************
 * FTFA_FSTAT - Flash Status Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSTAT - Flash Status Register (RW)
 *
 * Reset value: 0x00U
 *
 * The FSTAT register reports the operational status of the flash memory module.
 * The CCIF, RDCOLERR, ACCERR, and FPVIOL bits are readable and writable. The
 * MGSTAT0 bit is read only. The unassigned bits read 0 and are not writable. When
 * set, the Access Error (ACCERR) and Flash Protection Violation (FPVIOL) bits in
 * this register prevent the launch of any more commands until the flag is
 * cleared (by writing a one to it).
 */
/*!
 * @name Constants and macros for entire FTFA_FSTAT register
 */
/*@{*/
#define FTFA_RD_FSTAT(base)      (FTFA_FSTAT_REG(base))
#define FTFA_WR_FSTAT(base, value) (FTFA_FSTAT_REG(base) = (value))
#define FTFA_RMW_FSTAT(base, mask, value) (FTFA_WR_FSTAT(base, (FTFA_RD_FSTAT(base) & ~(mask)) | (value)))
#define FTFA_SET_FSTAT(base, value) (FTFA_WR_FSTAT(base, FTFA_RD_FSTAT(base) |  (value)))
#define FTFA_CLR_FSTAT(base, value) (FTFA_WR_FSTAT(base, FTFA_RD_FSTAT(base) & ~(value)))
#define FTFA_TOG_FSTAT(base, value) (FTFA_WR_FSTAT(base, FTFA_RD_FSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSTAT bitfields
 */

/*!
 * @name Register FTFA_FSTAT, field MGSTAT0[0] (RO)
 *
 * The MGSTAT0 status flag is set if an error is detected during execution of a
 * flash command or during the flash reset sequence. As a status flag, this field
 * cannot (and need not) be cleared by the user like the other error flags in
 * this register. The value of the MGSTAT0 bit for "command-N" is valid only at the
 * end of the "command-N" execution when CCIF=1 and before the next command has
 * been launched. At some point during the execution of "command-N+1," the
 * previous result is discarded and any previous error is cleared.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_MGSTAT0 field. */
#define FTFA_RD_FSTAT_MGSTAT0(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_MGSTAT0_MASK) >> FTFA_FSTAT_MGSTAT0_SHIFT)
#define FTFA_BRD_FSTAT_MGSTAT0(base) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_MGSTAT0_SHIFT))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field FPVIOL[4] (W1C)
 *
 * Indicates an attempt was made to program or erase an address in a protected
 * area of program flash memory during a command write sequence . While FPVIOL is
 * set, the CCIF flag cannot be cleared to launch a command. The FPVIOL bit is
 * cleared by writing a 1 to FPVIOL while CCIF is set. Writing a 0 to the FPVIOL
 * bit has no effect.
 *
 * Values:
 * - 0 - No protection violation detected
 * - 1 - Protection violation detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_FPVIOL field. */
#define FTFA_RD_FSTAT_FPVIOL(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_FPVIOL_MASK) >> FTFA_FSTAT_FPVIOL_SHIFT)
#define FTFA_BRD_FSTAT_FPVIOL(base) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT))

/*! @brief Set the FPVIOL field to a new value. */
#define FTFA_WR_FSTAT_FPVIOL(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_FPVIOL(value)))
#define FTFA_BWR_FSTAT_FPVIOL(base, value) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_FPVIOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field ACCERR[5] (W1C)
 *
 * Indicates an illegal access has occurred to a flash memory resource caused by
 * a violation of the command write sequence or issuing an illegal flash
 * command. While ACCERR is set, the CCIF flag cannot be cleared to launch a command.
 * The ACCERR bit is cleared by writing a 1 to ACCERR while CCIF is set. Writing a
 * 0 to the ACCERR bit has no effect.
 *
 * Values:
 * - 0 - No access error detected
 * - 1 - Access error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_ACCERR field. */
#define FTFA_RD_FSTAT_ACCERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_ACCERR_MASK) >> FTFA_FSTAT_ACCERR_SHIFT)
#define FTFA_BRD_FSTAT_ACCERR(base) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT))

/*! @brief Set the ACCERR field to a new value. */
#define FTFA_WR_FSTAT_ACCERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_ACCERR(value)))
#define FTFA_BWR_FSTAT_ACCERR(base, value) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_ACCERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field RDCOLERR[6] (W1C)
 *
 * Indicates that the MCU attempted a read from a flash memory resource that was
 * being manipulated by a flash command (CCIF=0). Any simultaneous access is
 * detected as a collision error by the block arbitration logic. The read data in
 * this case cannot be guaranteed. The RDCOLERR bit is cleared by writing a 1 to
 * it. Writing a 0 to RDCOLERR has no effect.
 *
 * Values:
 * - 0 - No collision error detected
 * - 1 - Collision error detected
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_RDCOLERR field. */
#define FTFA_RD_FSTAT_RDCOLERR(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_RDCOLERR_MASK) >> FTFA_FSTAT_RDCOLERR_SHIFT)
#define FTFA_BRD_FSTAT_RDCOLERR(base) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT))

/*! @brief Set the RDCOLERR field to a new value. */
#define FTFA_WR_FSTAT_RDCOLERR(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_RDCOLERR_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_CCIF_MASK), FTFA_FSTAT_RDCOLERR(value)))
#define FTFA_BWR_FSTAT_RDCOLERR(base, value) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_RDCOLERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFA_FSTAT, field CCIF[7] (W1C)
 *
 * Indicates that a flash command has completed. The CCIF flag is cleared by
 * writing a 1 to CCIF to launch a command, and CCIF stays low until command
 * completion or command violation. CCIF is reset to 0 but is set to 1 by the memory
 * controller at the end of the reset initialization sequence. Depending on how
 * quickly the read occurs after reset release, the user may or may not see the 0
 * hardware reset value.
 *
 * Values:
 * - 0 - Flash command in progress
 * - 1 - Flash command has completed
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSTAT_CCIF field. */
#define FTFA_RD_FSTAT_CCIF(base) ((FTFA_FSTAT_REG(base) & FTFA_FSTAT_CCIF_MASK) >> FTFA_FSTAT_CCIF_SHIFT)
#define FTFA_BRD_FSTAT_CCIF(base) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT))

/*! @brief Set the CCIF field to a new value. */
#define FTFA_WR_FSTAT_CCIF(base, value) (FTFA_RMW_FSTAT(base, (FTFA_FSTAT_CCIF_MASK | FTFA_FSTAT_FPVIOL_MASK | FTFA_FSTAT_ACCERR_MASK | FTFA_FSTAT_RDCOLERR_MASK), FTFA_FSTAT_CCIF(value)))
#define FTFA_BWR_FSTAT_CCIF(base, value) (BITBAND_ACCESS8(&FTFA_FSTAT_REG(base), FTFA_FSTAT_CCIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFA_FCNFG - Flash Configuration Register
 ******************************************************************************/

/*!
 * @brief FTFA_FCNFG - Flash Configuration Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides information on the current functional state of the
 * flash memory module. The erase control bits (ERSAREQ and ERSSUSP) have write
 * restrictions. The unassigned bits read as noted and are not writable.
 */
/*!
 * @name Constants and macros for entire FTFA_FCNFG register
 */
/*@{*/
#define FTFA_RD_FCNFG(base)      (FTFA_FCNFG_REG(base))
#define FTFA_WR_FCNFG(base, value) (FTFA_FCNFG_REG(base) = (value))
#define FTFA_RMW_FCNFG(base, mask, value) (FTFA_WR_FCNFG(base, (FTFA_RD_FCNFG(base) & ~(mask)) | (value)))
#define FTFA_SET_FCNFG(base, value) (FTFA_WR_FCNFG(base, FTFA_RD_FCNFG(base) |  (value)))
#define FTFA_CLR_FCNFG(base, value) (FTFA_WR_FCNFG(base, FTFA_RD_FCNFG(base) & ~(value)))
#define FTFA_TOG_FCNFG(base, value) (FTFA_WR_FCNFG(base, FTFA_RD_FCNFG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual FTFA_FCNFG bitfields
 */

/*!
 * @name Register FTFA_FCNFG, field ERSSUSP[4] (RW)
 *
 * Allows the user to suspend (interrupt) the Erase Flash Sector command while
 * it is executing.
 *
 * Values:
 * - 0 - No suspend requested
 * - 1 - Suspend the current Erase Flash Sector command execution.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSSUSP field. */
#define FTFA_RD_FCNFG_ERSSUSP(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSSUSP_MASK) >> FTFA_FCNFG_ERSSUSP_SHIFT)
#define FTFA_BRD_FCNFG_ERSSUSP(base) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT))

/*! @brief Set the ERSSUSP field to a new value. */
#define FTFA_WR_FCNFG_ERSSUSP(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_ERSSUSP_MASK, FTFA_FCNFG_ERSSUSP(value)))
#define FTFA_BWR_FCNFG_ERSSUSP(base, value) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSSUSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field ERSAREQ[5] (RO)
 *
 * Issues a request to the memory controller to execute the Erase All Blocks
 * command and release security. ERSAREQ is not directly writable but is under
 * indirect user control. Refer to the device's Chip Configuration details on how to
 * request this command. ERSAREQ sets when an erase all request is triggered
 * external to the flash memory module and CCIF is set (no command is currently being
 * executed). ERSAREQ is cleared by the flash memory module when the operation
 * completes.
 *
 * Values:
 * - 0 - No request or request complete
 * - 1 - Request to: run the Erase All Blocks command, verify the erased state,
 *     program the security byte in the Flash Configuration Field to the unsecure
 *     state, and release MCU security by setting the FSEC[SEC] field to the
 *     unsecure state.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_ERSAREQ field. */
#define FTFA_RD_FCNFG_ERSAREQ(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_ERSAREQ_MASK) >> FTFA_FCNFG_ERSAREQ_SHIFT)
#define FTFA_BRD_FCNFG_ERSAREQ(base) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_ERSAREQ_SHIFT))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field RDCOLLIE[6] (RW)
 *
 * Controls interrupt generation when a flash memory read collision error occurs.
 *
 * Values:
 * - 0 - Read collision error interrupt disabled
 * - 1 - Read collision error interrupt enabled. An interrupt request is
 *     generated whenever a flash memory read collision error is detected (see the
 *     description of FSTAT[RDCOLERR]).
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_RDCOLLIE field. */
#define FTFA_RD_FCNFG_RDCOLLIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_RDCOLLIE_MASK) >> FTFA_FCNFG_RDCOLLIE_SHIFT)
#define FTFA_BRD_FCNFG_RDCOLLIE(base) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT))

/*! @brief Set the RDCOLLIE field to a new value. */
#define FTFA_WR_FCNFG_RDCOLLIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_RDCOLLIE_MASK, FTFA_FCNFG_RDCOLLIE(value)))
#define FTFA_BWR_FCNFG_RDCOLLIE(base, value) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_RDCOLLIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register FTFA_FCNFG, field CCIE[7] (RW)
 *
 * Controls interrupt generation when a flash command completes.
 *
 * Values:
 * - 0 - Command complete interrupt disabled
 * - 1 - Command complete interrupt enabled. An interrupt request is generated
 *     whenever the FSTAT[CCIF] flag is set.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FCNFG_CCIE field. */
#define FTFA_RD_FCNFG_CCIE(base) ((FTFA_FCNFG_REG(base) & FTFA_FCNFG_CCIE_MASK) >> FTFA_FCNFG_CCIE_SHIFT)
#define FTFA_BRD_FCNFG_CCIE(base) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT))

/*! @brief Set the CCIE field to a new value. */
#define FTFA_WR_FCNFG_CCIE(base, value) (FTFA_RMW_FCNFG(base, FTFA_FCNFG_CCIE_MASK, FTFA_FCNFG_CCIE(value)))
#define FTFA_BWR_FCNFG_CCIE(base, value) (BITBAND_ACCESS8(&FTFA_FCNFG_REG(base), FTFA_FCNFG_CCIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * FTFA_FSEC - Flash Security Register
 ******************************************************************************/

/*!
 * @brief FTFA_FSEC - Flash Security Register (RO)
 *
 * Reset value: 0x00U
 *
 * This read-only register holds all bits associated with the security of the
 * MCU and flash memory module. During the reset sequence, the register is loaded
 * with the contents of the flash security byte in the Flash Configuration Field
 * located in program flash memory. The flash basis for the values is signified by
 * X in the reset value.
 */
/*!
 * @name Constants and macros for entire FTFA_FSEC register
 */
/*@{*/
#define FTFA_RD_FSEC(base)       (FTFA_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual FTFA_FSEC bitfields
 */

/*!
 * @name Register FTFA_FSEC, field SEC[1:0] (RO)
 *
 * Defines the security state of the MCU. In the secure state, the MCU limits
 * access to flash memory module resources. The limitations are defined per device
 * and are detailed in the Chip Configuration details. If the flash memory module
 * is unsecured using backdoor key access, SEC is forced to 10b.
 *
 * Values:
 * - 00 - MCU security status is secure.
 * - 01 - MCU security status is secure.
 * - 10 - MCU security status is unsecure. (The standard shipping condition of
 *     the flash memory module is unsecure.)
 * - 11 - MCU security status is secure.
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_SEC field. */
#define FTFA_RD_FSEC_SEC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_SEC_MASK) >> FTFA_FSEC_SEC_SHIFT)
#define FTFA_BRD_FSEC_SEC(base) (FTFA_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field FSLACC[3:2] (RO)
 *
 * Enables or disables access to the flash memory contents during returned part
 * failure analysis at Freescale. When SEC is secure and FSLACC is denied, access
 * to the program flash contents is denied and any failure analysis performed by
 * Freescale factory test must begin with a full erase to unsecure the part.
 * When access is granted (SEC is unsecure, or SEC is secure and FSLACC is granted),
 * Freescale factory testing has visibility of the current flash contents. The
 * state of the FSLACC bits is only relevant when SEC is set to secure. When SEC
 * is set to unsecure, the FSLACC setting does not matter.
 *
 * Values:
 * - 00 - Freescale factory access granted
 * - 01 - Freescale factory access denied
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_FSLACC field. */
#define FTFA_RD_FSEC_FSLACC(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_FSLACC_MASK) >> FTFA_FSEC_FSLACC_SHIFT)
#define FTFA_BRD_FSEC_FSLACC(base) (FTFA_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field MEEN[5:4] (RO)
 *
 * Enables and disables mass erase capability of the flash memory module. The
 * state of this field is relevant only when SEC is set to secure. When SEC is set
 * to unsecure, the MEEN setting does not matter.
 *
 * Values:
 * - 00 - Mass erase is enabled
 * - 01 - Mass erase is enabled
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_MEEN field. */
#define FTFA_RD_FSEC_MEEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_MEEN_MASK) >> FTFA_FSEC_MEEN_SHIFT)
#define FTFA_BRD_FSEC_MEEN(base) (FTFA_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register FTFA_FSEC, field KEYEN[7:6] (RO)
 *
 * Enables or disables backdoor key access to the flash memory module.
 *
 * Values:
 * - 00 - Backdoor key access disabled
 * - 01 - Backdoor key access disabled (preferred KEYEN state to disable
 *     backdoor key access)
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the FTFA_FSEC_KEYEN field. */
#define FTFA_RD_FSEC_KEYEN(base) ((FTFA_FSEC_REG(base) & FTFA_FSEC_KEYEN_MASK) >> FTFA_FSEC_KEYEN_SHIFT)
#define FTFA_BRD_FSEC_KEYEN(base) (FTFA_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * FTFA_FOPT - Flash Option Register
 ******************************************************************************/

/*!
 * @brief FTFA_FOPT - Flash Option Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash option register allows the MCU to customize its operations by
 * examining the state of these read-only bits, which are loaded from NVM at reset.
 * The function of the bits is defined in the device's Chip Configuration details.
 * All bits in the register are read-only . During the reset sequence, the
 * register is loaded from the flash nonvolatile option byte in the Flash Configuration
 * Field located in program flash memory. The flash basis for the values is
 * signified by X in the reset value. However, the register is written to 0xFF if the
 * contents of the flash nonvolatile option byte are 0x00.
 */
/*!
 * @name Constants and macros for entire FTFA_FOPT register
 */
/*@{*/
#define FTFA_RD_FOPT(base)       (FTFA_FOPT_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB3 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB3 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB3 register
 */
/*@{*/
#define FTFA_RD_FCCOB3(base)     (FTFA_FCCOB3_REG(base))
#define FTFA_WR_FCCOB3(base, value) (FTFA_FCCOB3_REG(base) = (value))
#define FTFA_RMW_FCCOB3(base, mask, value) (FTFA_WR_FCCOB3(base, (FTFA_RD_FCCOB3(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB3(base, value) (FTFA_WR_FCCOB3(base, FTFA_RD_FCCOB3(base) |  (value)))
#define FTFA_CLR_FCCOB3(base, value) (FTFA_WR_FCCOB3(base, FTFA_RD_FCCOB3(base) & ~(value)))
#define FTFA_TOG_FCCOB3(base, value) (FTFA_WR_FCCOB3(base, FTFA_RD_FCCOB3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB2 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB2 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB2 register
 */
/*@{*/
#define FTFA_RD_FCCOB2(base)     (FTFA_FCCOB2_REG(base))
#define FTFA_WR_FCCOB2(base, value) (FTFA_FCCOB2_REG(base) = (value))
#define FTFA_RMW_FCCOB2(base, mask, value) (FTFA_WR_FCCOB2(base, (FTFA_RD_FCCOB2(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB2(base, value) (FTFA_WR_FCCOB2(base, FTFA_RD_FCCOB2(base) |  (value)))
#define FTFA_CLR_FCCOB2(base, value) (FTFA_WR_FCCOB2(base, FTFA_RD_FCCOB2(base) & ~(value)))
#define FTFA_TOG_FCCOB2(base, value) (FTFA_WR_FCCOB2(base, FTFA_RD_FCCOB2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB1 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB1 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB1 register
 */
/*@{*/
#define FTFA_RD_FCCOB1(base)     (FTFA_FCCOB1_REG(base))
#define FTFA_WR_FCCOB1(base, value) (FTFA_FCCOB1_REG(base) = (value))
#define FTFA_RMW_FCCOB1(base, mask, value) (FTFA_WR_FCCOB1(base, (FTFA_RD_FCCOB1(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB1(base, value) (FTFA_WR_FCCOB1(base, FTFA_RD_FCCOB1(base) |  (value)))
#define FTFA_CLR_FCCOB1(base, value) (FTFA_WR_FCCOB1(base, FTFA_RD_FCCOB1(base) & ~(value)))
#define FTFA_TOG_FCCOB1(base, value) (FTFA_WR_FCCOB1(base, FTFA_RD_FCCOB1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB0 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB0 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB0 register
 */
/*@{*/
#define FTFA_RD_FCCOB0(base)     (FTFA_FCCOB0_REG(base))
#define FTFA_WR_FCCOB0(base, value) (FTFA_FCCOB0_REG(base) = (value))
#define FTFA_RMW_FCCOB0(base, mask, value) (FTFA_WR_FCCOB0(base, (FTFA_RD_FCCOB0(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB0(base, value) (FTFA_WR_FCCOB0(base, FTFA_RD_FCCOB0(base) |  (value)))
#define FTFA_CLR_FCCOB0(base, value) (FTFA_WR_FCCOB0(base, FTFA_RD_FCCOB0(base) & ~(value)))
#define FTFA_TOG_FCCOB0(base, value) (FTFA_WR_FCCOB0(base, FTFA_RD_FCCOB0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB7 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB7 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB7 register
 */
/*@{*/
#define FTFA_RD_FCCOB7(base)     (FTFA_FCCOB7_REG(base))
#define FTFA_WR_FCCOB7(base, value) (FTFA_FCCOB7_REG(base) = (value))
#define FTFA_RMW_FCCOB7(base, mask, value) (FTFA_WR_FCCOB7(base, (FTFA_RD_FCCOB7(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB7(base, value) (FTFA_WR_FCCOB7(base, FTFA_RD_FCCOB7(base) |  (value)))
#define FTFA_CLR_FCCOB7(base, value) (FTFA_WR_FCCOB7(base, FTFA_RD_FCCOB7(base) & ~(value)))
#define FTFA_TOG_FCCOB7(base, value) (FTFA_WR_FCCOB7(base, FTFA_RD_FCCOB7(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB6 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB6 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB6 register
 */
/*@{*/
#define FTFA_RD_FCCOB6(base)     (FTFA_FCCOB6_REG(base))
#define FTFA_WR_FCCOB6(base, value) (FTFA_FCCOB6_REG(base) = (value))
#define FTFA_RMW_FCCOB6(base, mask, value) (FTFA_WR_FCCOB6(base, (FTFA_RD_FCCOB6(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB6(base, value) (FTFA_WR_FCCOB6(base, FTFA_RD_FCCOB6(base) |  (value)))
#define FTFA_CLR_FCCOB6(base, value) (FTFA_WR_FCCOB6(base, FTFA_RD_FCCOB6(base) & ~(value)))
#define FTFA_TOG_FCCOB6(base, value) (FTFA_WR_FCCOB6(base, FTFA_RD_FCCOB6(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB5 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB5 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB5 register
 */
/*@{*/
#define FTFA_RD_FCCOB5(base)     (FTFA_FCCOB5_REG(base))
#define FTFA_WR_FCCOB5(base, value) (FTFA_FCCOB5_REG(base) = (value))
#define FTFA_RMW_FCCOB5(base, mask, value) (FTFA_WR_FCCOB5(base, (FTFA_RD_FCCOB5(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB5(base, value) (FTFA_WR_FCCOB5(base, FTFA_RD_FCCOB5(base) |  (value)))
#define FTFA_CLR_FCCOB5(base, value) (FTFA_WR_FCCOB5(base, FTFA_RD_FCCOB5(base) & ~(value)))
#define FTFA_TOG_FCCOB5(base, value) (FTFA_WR_FCCOB5(base, FTFA_RD_FCCOB5(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB4 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB4 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB4 register
 */
/*@{*/
#define FTFA_RD_FCCOB4(base)     (FTFA_FCCOB4_REG(base))
#define FTFA_WR_FCCOB4(base, value) (FTFA_FCCOB4_REG(base) = (value))
#define FTFA_RMW_FCCOB4(base, mask, value) (FTFA_WR_FCCOB4(base, (FTFA_RD_FCCOB4(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB4(base, value) (FTFA_WR_FCCOB4(base, FTFA_RD_FCCOB4(base) |  (value)))
#define FTFA_CLR_FCCOB4(base, value) (FTFA_WR_FCCOB4(base, FTFA_RD_FCCOB4(base) & ~(value)))
#define FTFA_TOG_FCCOB4(base, value) (FTFA_WR_FCCOB4(base, FTFA_RD_FCCOB4(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBB - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBB - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBB register
 */
/*@{*/
#define FTFA_RD_FCCOBB(base)     (FTFA_FCCOBB_REG(base))
#define FTFA_WR_FCCOBB(base, value) (FTFA_FCCOBB_REG(base) = (value))
#define FTFA_RMW_FCCOBB(base, mask, value) (FTFA_WR_FCCOBB(base, (FTFA_RD_FCCOBB(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBB(base, value) (FTFA_WR_FCCOBB(base, FTFA_RD_FCCOBB(base) |  (value)))
#define FTFA_CLR_FCCOBB(base, value) (FTFA_WR_FCCOBB(base, FTFA_RD_FCCOBB(base) & ~(value)))
#define FTFA_TOG_FCCOBB(base, value) (FTFA_WR_FCCOBB(base, FTFA_RD_FCCOBB(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOBA - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOBA - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOBA register
 */
/*@{*/
#define FTFA_RD_FCCOBA(base)     (FTFA_FCCOBA_REG(base))
#define FTFA_WR_FCCOBA(base, value) (FTFA_FCCOBA_REG(base) = (value))
#define FTFA_RMW_FCCOBA(base, mask, value) (FTFA_WR_FCCOBA(base, (FTFA_RD_FCCOBA(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOBA(base, value) (FTFA_WR_FCCOBA(base, FTFA_RD_FCCOBA(base) |  (value)))
#define FTFA_CLR_FCCOBA(base, value) (FTFA_WR_FCCOBA(base, FTFA_RD_FCCOBA(base) & ~(value)))
#define FTFA_TOG_FCCOBA(base, value) (FTFA_WR_FCCOBA(base, FTFA_RD_FCCOBA(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB9 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB9 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB9 register
 */
/*@{*/
#define FTFA_RD_FCCOB9(base)     (FTFA_FCCOB9_REG(base))
#define FTFA_WR_FCCOB9(base, value) (FTFA_FCCOB9_REG(base) = (value))
#define FTFA_RMW_FCCOB9(base, mask, value) (FTFA_WR_FCCOB9(base, (FTFA_RD_FCCOB9(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB9(base, value) (FTFA_WR_FCCOB9(base, FTFA_RD_FCCOB9(base) |  (value)))
#define FTFA_CLR_FCCOB9(base, value) (FTFA_WR_FCCOB9(base, FTFA_RD_FCCOB9(base) & ~(value)))
#define FTFA_TOG_FCCOB9(base, value) (FTFA_WR_FCCOB9(base, FTFA_RD_FCCOB9(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FCCOB8 - Flash Common Command Object Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FCCOB8 - Flash Common Command Object Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FCCOB register group provides 12 bytes for command codes and parameters.
 * The individual bytes within the set append a 0-B hex identifier to the FCCOB
 * register name: FCCOB0, FCCOB1, ..., FCCOBB.
 */
/*!
 * @name Constants and macros for entire FTFA_FCCOB8 register
 */
/*@{*/
#define FTFA_RD_FCCOB8(base)     (FTFA_FCCOB8_REG(base))
#define FTFA_WR_FCCOB8(base, value) (FTFA_FCCOB8_REG(base) = (value))
#define FTFA_RMW_FCCOB8(base, mask, value) (FTFA_WR_FCCOB8(base, (FTFA_RD_FCCOB8(base) & ~(mask)) | (value)))
#define FTFA_SET_FCCOB8(base, value) (FTFA_WR_FCCOB8(base, FTFA_RD_FCCOB8(base) |  (value)))
#define FTFA_CLR_FCCOB8(base, value) (FTFA_WR_FCCOB8(base, FTFA_RD_FCCOB8(base) & ~(value)))
#define FTFA_TOG_FCCOB8(base, value) (FTFA_WR_FCCOB8(base, FTFA_RD_FCCOB8(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT3 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT3 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT3 register
 */
/*@{*/
#define FTFA_RD_FPROT3(base)     (FTFA_FPROT3_REG(base))
#define FTFA_WR_FPROT3(base, value) (FTFA_FPROT3_REG(base) = (value))
#define FTFA_RMW_FPROT3(base, mask, value) (FTFA_WR_FPROT3(base, (FTFA_RD_FPROT3(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT3(base, value) (FTFA_WR_FPROT3(base, FTFA_RD_FPROT3(base) |  (value)))
#define FTFA_CLR_FPROT3(base, value) (FTFA_WR_FPROT3(base, FTFA_RD_FPROT3(base) & ~(value)))
#define FTFA_TOG_FPROT3(base, value) (FTFA_WR_FPROT3(base, FTFA_RD_FPROT3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT2 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT2 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT2 register
 */
/*@{*/
#define FTFA_RD_FPROT2(base)     (FTFA_FPROT2_REG(base))
#define FTFA_WR_FPROT2(base, value) (FTFA_FPROT2_REG(base) = (value))
#define FTFA_RMW_FPROT2(base, mask, value) (FTFA_WR_FPROT2(base, (FTFA_RD_FPROT2(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT2(base, value) (FTFA_WR_FPROT2(base, FTFA_RD_FPROT2(base) |  (value)))
#define FTFA_CLR_FPROT2(base, value) (FTFA_WR_FPROT2(base, FTFA_RD_FPROT2(base) & ~(value)))
#define FTFA_TOG_FPROT2(base, value) (FTFA_WR_FPROT2(base, FTFA_RD_FPROT2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT1 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT1 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT1 register
 */
/*@{*/
#define FTFA_RD_FPROT1(base)     (FTFA_FPROT1_REG(base))
#define FTFA_WR_FPROT1(base, value) (FTFA_FPROT1_REG(base) = (value))
#define FTFA_RMW_FPROT1(base, mask, value) (FTFA_WR_FPROT1(base, (FTFA_RD_FPROT1(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT1(base, value) (FTFA_WR_FPROT1(base, FTFA_RD_FPROT1(base) |  (value)))
#define FTFA_CLR_FPROT1(base, value) (FTFA_WR_FPROT1(base, FTFA_RD_FPROT1(base) & ~(value)))
#define FTFA_TOG_FPROT1(base, value) (FTFA_WR_FPROT1(base, FTFA_RD_FPROT1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_FPROT0 - Program Flash Protection Registers
 ******************************************************************************/

/*!
 * @brief FTFA_FPROT0 - Program Flash Protection Registers (RW)
 *
 * Reset value: 0x00U
 *
 * The FPROT registers define which program flash regions are protected from
 * program and erase operations. Protected flash regions cannot have their content
 * changed; that is, these regions cannot be programmed and cannot be erased by
 * any flash command. Unprotected regions can be changed by program and erase
 * operations. The four FPROT registers allow up to 32 protectable regions. Each bit
 * protects a 1/32 region of the program flash memory except for memory
 * configurations with less than 64 KB of program flash where each assigned bit protects 2
 * KB . For configurations with 48 KB of program flash memory or less, FPROT0 is
 * not used. For configurations with 32 KB of program flash memory or less,
 * FPROT1 is not used. For configurations with 16 KB of program flash memory, FPROT2
 * is not used. The bitfields are defined in each register as follows: Program
 * flash protection register Program flash protection bits FPROT0 PROT[31:24] FPROT1
 * PROT[23:16] FPROT2 PROT[15:8] FPROT3 PROT[7:0] During the reset sequence, the
 * FPROT registers are loaded with the contents of the program flash protection
 * bytes in the Flash Configuration Field as indicated in the following table.
 * Program flash protection register Flash Configuration Field offset address
 * FPROT0 0x000B FPROT1 0x000A FPROT2 0x0009 FPROT3 0x0008 To change the program flash
 * protection that is loaded during the reset sequence, unprotect the sector of
 * program flash memory that contains the Flash Configuration Field. Then,
 * reprogram the program flash protection byte.
 */
/*!
 * @name Constants and macros for entire FTFA_FPROT0 register
 */
/*@{*/
#define FTFA_RD_FPROT0(base)     (FTFA_FPROT0_REG(base))
#define FTFA_WR_FPROT0(base, value) (FTFA_FPROT0_REG(base) = (value))
#define FTFA_RMW_FPROT0(base, mask, value) (FTFA_WR_FPROT0(base, (FTFA_RD_FPROT0(base) & ~(mask)) | (value)))
#define FTFA_SET_FPROT0(base, value) (FTFA_WR_FPROT0(base, FTFA_RD_FPROT0(base) |  (value)))
#define FTFA_CLR_FPROT0(base, value) (FTFA_WR_FPROT0(base, FTFA_RD_FPROT0(base) & ~(value)))
#define FTFA_TOG_FPROT0(base, value) (FTFA_WR_FPROT0(base, FTFA_RD_FPROT0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH3 register
 */
/*@{*/
#define FTFA_RD_XACCH3(base)     (FTFA_XACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH2 register
 */
/*@{*/
#define FTFA_RD_XACCH2(base)     (FTFA_XACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH1 register
 */
/*@{*/
#define FTFA_RD_XACCH1(base)     (FTFA_XACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCH0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCH0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCH0 register
 */
/*@{*/
#define FTFA_RD_XACCH0(base)     (FTFA_XACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL3 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL3 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL3 register
 */
/*@{*/
#define FTFA_RD_XACCL3(base)     (FTFA_XACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL2 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL2 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL2 register
 */
/*@{*/
#define FTFA_RD_XACCL2(base)     (FTFA_XACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL1 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL1 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL1 register
 */
/*@{*/
#define FTFA_RD_XACCL1(base)     (FTFA_XACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_XACCL0 - Execute-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_XACCL0 - Execute-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The XACC registers define which program flash segments are restricted to data
 * read or execute only or both data and instruction fetches. The eight XACC
 * registers allow up to 64 restricted segments of equal memory size. Execute-only
 * access register Program flash execute-only access bits XACCH0 XA[63:56] XACCH1
 * XA[55:48] XACCH2 XA[47:40] XACCH3 XA[39:32] XACCL0 XA[31:24] XACCL1 XA[23:16]
 * XACCL2 XA[15:8] XACCL3 XA[7:0] During the reset sequence, the XACC registers
 * are loaded with the logical AND of Program Flash IFR addresses A and B as
 * indicated in the following table. Execute-only access register Program Flash IFR
 * address A Program Flash IFR address B XACCH0 0xA3 0xAB XACCH1 0xA2 0xAA XACCH2
 * 0xA1 0xA9 XACCH3 0xA0 0xA8 XACCL0 0xA7 0xAF XACCL1 0xA6 0xAE XACCL2 0xA5 0xAD
 * XACCL3 0xA4 0xAC Use the Program Once command to program the execute-only
 * access control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_XACCL0 register
 */
/*@{*/
#define FTFA_RD_XACCL0(base)     (FTFA_XACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH3 register
 */
/*@{*/
#define FTFA_RD_SACCH3(base)     (FTFA_SACCH3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH2 register
 */
/*@{*/
#define FTFA_RD_SACCH2(base)     (FTFA_SACCH2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH1 register
 */
/*@{*/
#define FTFA_RD_SACCH1(base)     (FTFA_SACCH1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCH0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCH0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCH0 register
 */
/*@{*/
#define FTFA_RD_SACCH0(base)     (FTFA_SACCH0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL3 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL3 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL3 register
 */
/*@{*/
#define FTFA_RD_SACCL3(base)     (FTFA_SACCL3_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL2 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL2 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL2 register
 */
/*@{*/
#define FTFA_RD_SACCL2(base)     (FTFA_SACCL2_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL1 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL1 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL1 register
 */
/*@{*/
#define FTFA_RD_SACCL1(base)     (FTFA_SACCL1_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_SACCL0 - Supervisor-only Access Registers
 ******************************************************************************/

/*!
 * @brief FTFA_SACCL0 - Supervisor-only Access Registers (RO)
 *
 * Reset value: 0x00U
 *
 * The SACC registers define which program flash segments are restricted to
 * supervisor only or user and supervisor access. The eight SACC registers allow up
 * to 64 restricted segments of equal memory size. Supervisor-only access register
 * Program flash supervisor-only access bits SACCH0 SA[63:56] SACCH1 SA[55:48]
 * SACCH2 SA[47:40] SACCH3 SA[39:32] SACCL0 SA[31:24] SACCL1 SA[23:16] SACCL2
 * SA[15:8] SACCL3 SA[7:0] During the reset sequence, the SACC registers are loaded
 * with the logical AND of Program Flash IFR addresses A and B as indicated in the
 * following table. Supervisor-only access register Program Flash IFR address A
 * Program Flash IFR address B SACCH0 0xB3 0xBB SACCH1 0xB2 0xBA SACCH2 0xB1 0xB9
 * SACCH3 0xB0 0xB8 SACCL0 0xB7 0xBF SACCL1 0xB6 0xBE SACCL2 0xB5 0xBD SACCL3
 * 0xB4 0xBC Use the Program Once command to program the supervisor-only access
 * control fields that are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_SACCL0 register
 */
/*@{*/
#define FTFA_RD_SACCL0(base)     (FTFA_SACCL0_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSS - Flash Access Segment Size Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSS - Flash Access Segment Size Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment size register determines which bits in the address
 * are used to index into the SACC and XACC bitmaps to get the appropriate
 * permission flags. All bits in the register are read-only. The contents of this
 * register are loaded during the reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSS register
 */
/*@{*/
#define FTFA_RD_FACSS(base)      (FTFA_FACSS_REG(base))
/*@}*/

/*******************************************************************************
 * FTFA_FACSN - Flash Access Segment Number Register
 ******************************************************************************/

/*!
 * @brief FTFA_FACSN - Flash Access Segment Number Register (RO)
 *
 * Reset value: 0x00U
 *
 * The flash access segment number register provides the number of program flash
 * segments that are available for XACC and SACC permissions. All bits in the
 * register are read-only. The contents of this register are loaded during the
 * reset sequence.
 */
/*!
 * @name Constants and macros for entire FTFA_FACSN register
 */
/*@{*/
#define FTFA_RD_FACSN(base)      (FTFA_FACSN_REG(base))
/*@}*/

/*
 * MKS22F25612 GPIO
 *
 * General Purpose Input/Output
 *
 * Registers defined in this header file:
 * - GPIO_PDOR - Port Data Output Register
 * - GPIO_PSOR - Port Set Output Register
 * - GPIO_PCOR - Port Clear Output Register
 * - GPIO_PTOR - Port Toggle Output Register
 * - GPIO_PDIR - Port Data Input Register
 * - GPIO_PDDR - Port Data Direction Register
 */

#define GPIO_INSTANCE_COUNT (5U) /*!< Number of instances of the GPIO module. */
#define GPIOA_IDX (0U) /*!< Instance number for GPIOA. */
#define GPIOB_IDX (1U) /*!< Instance number for GPIOB. */
#define GPIOC_IDX (2U) /*!< Instance number for GPIOC. */
#define GPIOD_IDX (3U) /*!< Instance number for GPIOD. */
#define GPIOE_IDX (4U) /*!< Instance number for GPIOE. */

/*******************************************************************************
 * GPIO_PDOR - Port Data Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDOR - Port Data Output Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the logic levels that are driven on each
 * general-purpose output pins. Do not modify pin configuration registers associated with
 * pins not available in your selected package. All unbonded pins not available in
 * your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDOR register
 */
/*@{*/
#define GPIO_RD_PDOR(base)       (GPIO_PDOR_REG(base))
#define GPIO_WR_PDOR(base, value) (GPIO_PDOR_REG(base) = (value))
#define GPIO_RMW_PDOR(base, mask, value) (GPIO_WR_PDOR(base, (GPIO_RD_PDOR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) |  (value)))
#define GPIO_CLR_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) & ~(value)))
#define GPIO_TOG_PDOR(base, value) (GPIO_WR_PDOR(base, GPIO_RD_PDOR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PSOR - Port Set Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PSOR - Port Set Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to set the fields of the PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PSOR register
 */
/*@{*/
#define GPIO_RD_PSOR(base)       (GPIO_PSOR_REG(base))
#define GPIO_WR_PSOR(base, value) (GPIO_PSOR_REG(base) = (value))
#define GPIO_RMW_PSOR(base, mask, value) (GPIO_WR_PSOR(base, (GPIO_RD_PSOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PCOR - Port Clear Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PCOR - Port Clear Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * This register configures whether to clear the fields of PDOR.
 */
/*!
 * @name Constants and macros for entire GPIO_PCOR register
 */
/*@{*/
#define GPIO_RD_PCOR(base)       (GPIO_PCOR_REG(base))
#define GPIO_WR_PCOR(base, value) (GPIO_PCOR_REG(base) = (value))
#define GPIO_RMW_PCOR(base, mask, value) (GPIO_WR_PCOR(base, (GPIO_RD_PCOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PTOR - Port Toggle Output Register
 ******************************************************************************/

/*!
 * @brief GPIO_PTOR - Port Toggle Output Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire GPIO_PTOR register
 */
/*@{*/
#define GPIO_RD_PTOR(base)       (GPIO_PTOR_REG(base))
#define GPIO_WR_PTOR(base, value) (GPIO_PTOR_REG(base) = (value))
#define GPIO_RMW_PTOR(base, mask, value) (GPIO_WR_PTOR(base, (GPIO_RD_PTOR(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * GPIO_PDIR - Port Data Input Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDIR - Port Data Input Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Do not modify pin configuration registers associated with pins not available
 * in your selected package. All unbonded pins not available in your package will
 * default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire GPIO_PDIR register
 */
/*@{*/
#define GPIO_RD_PDIR(base)       (GPIO_PDIR_REG(base))
/*@}*/

/*******************************************************************************
 * GPIO_PDDR - Port Data Direction Register
 ******************************************************************************/

/*!
 * @brief GPIO_PDDR - Port Data Direction Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PDDR configures the individual port pins for input or output.
 */
/*!
 * @name Constants and macros for entire GPIO_PDDR register
 */
/*@{*/
#define GPIO_RD_PDDR(base)       (GPIO_PDDR_REG(base))
#define GPIO_WR_PDDR(base, value) (GPIO_PDDR_REG(base) = (value))
#define GPIO_RMW_PDDR(base, mask, value) (GPIO_WR_PDDR(base, (GPIO_RD_PDDR(base) & ~(mask)) | (value)))
#define GPIO_SET_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) |  (value)))
#define GPIO_CLR_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) & ~(value)))
#define GPIO_TOG_PDDR(base, value) (GPIO_WR_PDDR(base, GPIO_RD_PDDR(base) ^  (value)))
/*@}*/

/*
 * MKS22F25612 I2S
 *
 * Inter-IC Sound / Synchronous Audio Interface
 *
 * Registers defined in this header file:
 * - I2S_TCSR - SAI Transmit Control Register
 * - I2S_TCR1 - SAI Transmit Configuration 1 Register
 * - I2S_TCR2 - SAI Transmit Configuration 2 Register
 * - I2S_TCR3 - SAI Transmit Configuration 3 Register
 * - I2S_TCR4 - SAI Transmit Configuration 4 Register
 * - I2S_TCR5 - SAI Transmit Configuration 5 Register
 * - I2S_TDR - SAI Transmit Data Register
 * - I2S_TFR - SAI Transmit FIFO Register
 * - I2S_TMR - SAI Transmit Mask Register
 * - I2S_RCSR - SAI Receive Control Register
 * - I2S_RCR1 - SAI Receive Configuration 1 Register
 * - I2S_RCR2 - SAI Receive Configuration 2 Register
 * - I2S_RCR3 - SAI Receive Configuration 3 Register
 * - I2S_RCR4 - SAI Receive Configuration 4 Register
 * - I2S_RCR5 - SAI Receive Configuration 5 Register
 * - I2S_RDR - SAI Receive Data Register
 * - I2S_RFR - SAI Receive FIFO Register
 * - I2S_RMR - SAI Receive Mask Register
 * - I2S_MCR - SAI MCLK Control Register
 * - I2S_MDR - SAI MCLK Divide Register
 */

#define I2S_INSTANCE_COUNT (2U) /*!< Number of instances of the I2S module. */
#define I2S0_IDX (0U) /*!< Instance number for I2S0. */
#define I2S1_IDX (1U) /*!< Instance number for I2S1. */

/*******************************************************************************
 * I2S_TCSR - SAI Transmit Control Register
 ******************************************************************************/

/*!
 * @brief I2S_TCSR - SAI Transmit Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCSR register
 */
/*@{*/
#define I2S_RD_TCSR(base)        (I2S_TCSR_REG(base))
#define I2S_WR_TCSR(base, value) (I2S_TCSR_REG(base) = (value))
#define I2S_RMW_TCSR(base, mask, value) (I2S_WR_TCSR(base, (I2S_RD_TCSR(base) & ~(mask)) | (value)))
#define I2S_SET_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) |  (value)))
#define I2S_CLR_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) & ~(value)))
#define I2S_TOG_TCSR(base, value) (I2S_WR_TCSR(base, I2S_RD_TCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCSR bitfields
 */

/*!
 * @name Register I2S_TCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRDE field. */
#define I2S_RD_TCSR_FRDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRDE_MASK) >> I2S_TCSR_FRDE_SHIFT)
#define I2S_BRD_TCSR_FRDE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRDE_SHIFT))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_TCSR_FRDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRDE(value)))
#define I2S_BWR_TCSR_FRDE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWDE field. */
#define I2S_RD_TCSR_FWDE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWDE_MASK) >> I2S_TCSR_FWDE_SHIFT)
#define I2S_BRD_TCSR_FWDE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWDE_SHIFT))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_TCSR_FWDE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWDE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWDE(value)))
#define I2S_BWR_TCSR_FWDE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRIE field. */
#define I2S_RD_TCSR_FRIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRIE_MASK) >> I2S_TCSR_FRIE_SHIFT)
#define I2S_BRD_TCSR_FRIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRIE_SHIFT))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_TCSR_FRIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FRIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FRIE(value)))
#define I2S_BWR_TCSR_FRIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWIE field. */
#define I2S_RD_TCSR_FWIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWIE_MASK) >> I2S_TCSR_FWIE_SHIFT)
#define I2S_BRD_TCSR_FWIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWIE_SHIFT))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_TCSR_FWIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FWIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FWIE(value)))
#define I2S_BWR_TCSR_FWIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEIE field. */
#define I2S_RD_TCSR_FEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEIE_MASK) >> I2S_TCSR_FEIE_SHIFT)
#define I2S_BRD_TCSR_FEIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_TCSR_FEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEIE(value)))
#define I2S_BWR_TCSR_FEIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEIE field. */
#define I2S_RD_TCSR_SEIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEIE_MASK) >> I2S_TCSR_SEIE_SHIFT)
#define I2S_BRD_TCSR_SEIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEIE_SHIFT))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_TCSR_SEIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEIE(value)))
#define I2S_BWR_TCSR_SEIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSIE field. */
#define I2S_RD_TCSR_WSIE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSIE_MASK) >> I2S_TCSR_WSIE_SHIFT)
#define I2S_BRD_TCSR_WSIE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSIE_SHIFT))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_TCSR_WSIE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSIE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_WSIE(value)))
#define I2S_BWR_TCSR_WSIE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled transmit channel FIFO is
 * less than or equal to the transmit FIFO watermark.
 *
 * Values:
 * - 0 - Transmit FIFO watermark has not been reached.
 * - 1 - Transmit FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FRF field. */
#define I2S_RD_TCSR_FRF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FRF_MASK) >> I2S_TCSR_FRF_SHIFT)
#define I2S_BRD_TCSR_FRF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FRF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled transmit FIFO is empty.
 *
 * Values:
 * - 0 - No enabled transmit FIFO is empty.
 * - 1 - Enabled transmit FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FWF field. */
#define I2S_RD_TCSR_FWF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FWF_MASK) >> I2S_TCSR_FWF_SHIFT)
#define I2S_BRD_TCSR_FWF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FWF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled transmit FIFO has underrun. Write a logic 1 to this
 * field to clear this flag.
 *
 * Values:
 * - 0 - Transmit underrun not detected.
 * - 1 - Transmit underrun detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_FEF field. */
#define I2S_RD_TCSR_FEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_FEF_MASK) >> I2S_TCSR_FEF_SHIFT)
#define I2S_BRD_TCSR_FEF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_TCSR_FEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FEF(value)))
#define I2S_BWR_TCSR_FEF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SEF field. */
#define I2S_RD_TCSR_SEF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SEF_MASK) >> I2S_TCSR_SEF_SHIFT)
#define I2S_BRD_TCSR_SEF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEF_SHIFT))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_TCSR_SEF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SEF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SEF(value)))
#define I2S_BWR_TCSR_SEF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_WSF field. */
#define I2S_RD_TCSR_WSF(base) ((I2S_TCSR_REG(base) & I2S_TCSR_WSF_MASK) >> I2S_TCSR_WSF_SHIFT)
#define I2S_BRD_TCSR_WSF(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSF_SHIFT))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_TCSR_WSF(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_WSF_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK), I2S_TCSR_WSF(value)))
#define I2S_BWR_TCSR_WSF(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_WSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field SR[24] (RW)
 *
 * When set, resets the internal transmitter logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_SR field. */
#define I2S_RD_TCSR_SR(base) ((I2S_TCSR_REG(base) & I2S_TCSR_SR_MASK) >> I2S_TCSR_SR_SHIFT)
#define I2S_BRD_TCSR_SR(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SR_SHIFT))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_TCSR_SR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_SR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_SR(value)))
#define I2S_BWR_TCSR_SR(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_SR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the transmitter is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_TCSR_FR(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_FR_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_FR(value)))
#define I2S_BWR_TCSR_FR(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_FR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field BCE[28] (RW)
 *
 * Enables the transmit bit clock, separately from the TE. This field is
 * automatically set whenever TE is set. When software clears this field, the transmit
 * bit clock remains enabled, and this bit remains set, until the end of the
 * current frame.
 *
 * Values:
 * - 0 - Transmit bit clock is disabled.
 * - 1 - Transmit bit clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_BCE field. */
#define I2S_RD_TCSR_BCE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_BCE_MASK) >> I2S_TCSR_BCE_SHIFT)
#define I2S_BRD_TCSR_BCE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_BCE_SHIFT))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_TCSR_BCE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_BCE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_BCE(value)))
#define I2S_BWR_TCSR_BCE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_BCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field DBGE[29] (RW)
 *
 * Enables/disables transmitter operation in Debug mode. The transmit bit clock
 * is not affected by debug mode.
 *
 * Values:
 * - 0 - Transmitter is disabled in Debug mode, after completing the current
 *     frame.
 * - 1 - Transmitter is enabled in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_DBGE field. */
#define I2S_RD_TCSR_DBGE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_DBGE_MASK) >> I2S_TCSR_DBGE_SHIFT)
#define I2S_BRD_TCSR_DBGE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_TCSR_DBGE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_DBGE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_DBGE(value)))
#define I2S_BWR_TCSR_DBGE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field STOPE[30] (RW)
 *
 * Configures transmitter operation in Stop mode. This field is ignored and the
 * transmitter is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Transmitter disabled in Stop mode.
 * - 1 - Transmitter enabled in Stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_STOPE field. */
#define I2S_RD_TCSR_STOPE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_STOPE_MASK) >> I2S_TCSR_STOPE_SHIFT)
#define I2S_BRD_TCSR_STOPE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_STOPE_SHIFT))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_TCSR_STOPE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_STOPE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_STOPE(value)))
#define I2S_BWR_TCSR_STOPE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_STOPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCSR, field TE[31] (RW)
 *
 * Enables/disables the transmitter. When software clears this field, the
 * transmitter remains enabled, and this bit remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Transmitter is disabled.
 * - 1 - Transmitter is enabled, or transmitter has been disabled and has not
 *     yet reached end of frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCSR_TE field. */
#define I2S_RD_TCSR_TE(base) ((I2S_TCSR_REG(base) & I2S_TCSR_TE_MASK) >> I2S_TCSR_TE_SHIFT)
#define I2S_BRD_TCSR_TE(base) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define I2S_WR_TCSR_TE(base, value) (I2S_RMW_TCSR(base, (I2S_TCSR_TE_MASK | I2S_TCSR_FEF_MASK | I2S_TCSR_SEF_MASK | I2S_TCSR_WSF_MASK), I2S_TCSR_TE(value)))
#define I2S_BWR_TCSR_TE(base, value) (BITBAND_ACCESS32(&I2S_TCSR_REG(base), I2S_TCSR_TE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_TCR1 - SAI Transmit Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR1 - SAI Transmit Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCR1 register
 */
/*@{*/
#define I2S_RD_TCR1(base)        (I2S_TCR1_REG(base))
#define I2S_WR_TCR1(base, value) (I2S_TCR1_REG(base) = (value))
#define I2S_RMW_TCR1(base, mask, value) (I2S_WR_TCR1(base, (I2S_RD_TCR1(base) & ~(mask)) | (value)))
#define I2S_SET_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) |  (value)))
#define I2S_CLR_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) & ~(value)))
#define I2S_TOG_TCR1(base, value) (I2S_WR_TCR1(base, I2S_RD_TCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR1 bitfields
 */

/*!
 * @name Register I2S_TCR1, field TFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled transmit channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR1_TFW field. */
#define I2S_RD_TCR1_TFW(base) ((I2S_TCR1_REG(base) & I2S_TCR1_TFW_MASK) >> I2S_TCR1_TFW_SHIFT)
#define I2S_BRD_TCR1_TFW(base) (I2S_RD_TCR1_TFW(base))

/*! @brief Set the TFW field to a new value. */
#define I2S_WR_TCR1_TFW(base, value) (I2S_RMW_TCR1(base, I2S_TCR1_TFW_MASK, I2S_TCR1_TFW(value)))
#define I2S_BWR_TCR1_TFW(base, value) (I2S_WR_TCR1_TFW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR2 - SAI Transmit Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR2 - SAI Transmit Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR2 register
 */
/*@{*/
#define I2S_RD_TCR2(base)        (I2S_TCR2_REG(base))
#define I2S_WR_TCR2(base, value) (I2S_TCR2_REG(base) = (value))
#define I2S_RMW_TCR2(base, mask, value) (I2S_WR_TCR2(base, (I2S_RD_TCR2(base) & ~(mask)) | (value)))
#define I2S_SET_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) |  (value)))
#define I2S_CLR_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) & ~(value)))
#define I2S_TOG_TCR2(base, value) (I2S_WR_TCR2(base, I2S_RD_TCR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR2 bitfields
 */

/*!
 * @name Register I2S_TCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_DIV field. */
#define I2S_RD_TCR2_DIV(base) ((I2S_TCR2_REG(base) & I2S_TCR2_DIV_MASK) >> I2S_TCR2_DIV_SHIFT)
#define I2S_BRD_TCR2_DIV(base) (I2S_RD_TCR2_DIV(base))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_TCR2_DIV(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_DIV_MASK, I2S_TCR2_DIV(value)))
#define I2S_BWR_TCR2_DIV(base, value) (I2S_WR_TCR2_DIV(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCD field. */
#define I2S_RD_TCR2_BCD(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCD_MASK) >> I2S_TCR2_BCD_SHIFT)
#define I2S_BRD_TCR2_BCD(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCD_SHIFT))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_TCR2_BCD(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCD_MASK, I2S_TCR2_BCD(value)))
#define I2S_BWR_TCR2_BCD(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCP field. */
#define I2S_RD_TCR2_BCP(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCP_MASK) >> I2S_TCR2_BCP_SHIFT)
#define I2S_BRD_TCR2_BCP(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCP_SHIFT))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_TCR2_BCP(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCP_MASK, I2S_TCR2_BCP(value)))
#define I2S_BWR_TCR2_BCP(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip-specific information for the meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_MSEL field. */
#define I2S_RD_TCR2_MSEL(base) ((I2S_TCR2_REG(base) & I2S_TCR2_MSEL_MASK) >> I2S_TCR2_MSEL_SHIFT)
#define I2S_BRD_TCR2_MSEL(base) (I2S_RD_TCR2_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_TCR2_MSEL(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_MSEL_MASK, I2S_TCR2_MSEL(value)))
#define I2S_BWR_TCR2_MSEL(base, value) (I2S_WR_TCR2_MSEL(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the
 * transmitter is delayed by the pad output delay (the transmitter is clocked by the pad
 * input as if the clock was externally generated). This has the effect of
 * decreasing the data input setup time, but increasing the data output valid time. The
 * slave mode timing from the datasheet should be used for the transmitter when
 * this bit is set. In synchronous mode, this bit allows the transmitter to use
 * the slave mode timing from the datasheet, while the receiver uses the master
 * mode timing. This field has no effect when configured for an externally generated
 * bit clock .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCI field. */
#define I2S_RD_TCR2_BCI(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCI_MASK) >> I2S_TCR2_BCI_SHIFT)
#define I2S_BRD_TCR2_BCI(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCI_SHIFT))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_TCR2_BCI(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCI_MASK, I2S_TCR2_BCI(value)))
#define I2S_BWR_TCR2_BCI(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the transmitter. When the transmitter
 * is configured in asynchronous mode and this bit is set, the transmitter is
 * clocked by the receiver bit clock (SAI_RX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the transmitter continues to use the
 * transmit frame sync (SAI_TX_SYNC). When the transmitter is configured in
 * synchronous mode, the transmitter BCS field and receiver BCS field must be set to
 * the same value. When both are set, the transmitter and receiver are both
 * clocked by the transmitter bit clock (SAI_TX_BCLK) but use the receiver frame sync
 * (SAI_RX_SYNC).
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_BCS field. */
#define I2S_RD_TCR2_BCS(base) ((I2S_TCR2_REG(base) & I2S_TCR2_BCS_MASK) >> I2S_TCR2_BCS_SHIFT)
#define I2S_BRD_TCR2_BCS(base) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCS_SHIFT))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_TCR2_BCS(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_BCS_MASK, I2S_TCR2_BCS(value)))
#define I2S_BWR_TCR2_BCS(base, value) (BITBAND_ACCESS32(&I2S_TCR2_REG(base), I2S_TCR2_BCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the receiver must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with receiver.
 * - 10 - Synchronous with another SAI transmitter.
 * - 11 - Synchronous with another SAI receiver.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR2_SYNC field. */
#define I2S_RD_TCR2_SYNC(base) ((I2S_TCR2_REG(base) & I2S_TCR2_SYNC_MASK) >> I2S_TCR2_SYNC_SHIFT)
#define I2S_BRD_TCR2_SYNC(base) (I2S_RD_TCR2_SYNC(base))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_TCR2_SYNC(base, value) (I2S_RMW_TCR2(base, I2S_TCR2_SYNC_MASK, I2S_TCR2_SYNC(value)))
#define I2S_BWR_TCR2_SYNC(base, value) (I2S_WR_TCR2_SYNC(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TCR3 - SAI Transmit Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR3 - SAI Transmit Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TCR3 register
 */
/*@{*/
#define I2S_RD_TCR3(base)        (I2S_TCR3_REG(base))
#define I2S_WR_TCR3(base, value) (I2S_TCR3_REG(base) = (value))
#define I2S_RMW_TCR3(base, mask, value) (I2S_WR_TCR3(base, (I2S_RD_TCR3(base) & ~(mask)) | (value)))
#define I2S_SET_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) |  (value)))
#define I2S_CLR_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) & ~(value)))
#define I2S_TOG_TCR3(base, value) (I2S_WR_TCR3(base, I2S_RD_TCR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR3 bitfields
 */

/*!
 * @name Register I2S_TCR3, field WDFL[3:0] (RW)
 *
 * Configures which word sets the start of word flag. The value written must be
 * one less than the word number. For example, writing 0 configures the first
 * word in the frame. When configured to a value greater than TCR4[FRSZ], then the
 * start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_WDFL field. */
#define I2S_RD_TCR3_WDFL(base) ((I2S_TCR3_REG(base) & I2S_TCR3_WDFL_MASK) >> I2S_TCR3_WDFL_SHIFT)
#define I2S_BRD_TCR3_WDFL(base) (I2S_RD_TCR3_WDFL(base))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_TCR3_WDFL(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_WDFL_MASK, I2S_TCR3_WDFL(value)))
#define I2S_BWR_TCR3_WDFL(base, value) (I2S_WR_TCR3_WDFL(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR3, field TCE[16] (RW)
 *
 * Enables the corresponding data channel for transmit operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for transmit operation.
 *
 * Values:
 * - 0 - Transmit data channel N is disabled.
 * - 1 - Transmit data channel N is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR3_TCE field. */
#define I2S_RD_TCR3_TCE(base) ((I2S_TCR3_REG(base) & I2S_TCR3_TCE_MASK) >> I2S_TCR3_TCE_SHIFT)
#define I2S_BRD_TCR3_TCE(base) (BITBAND_ACCESS32(&I2S_TCR3_REG(base), I2S_TCR3_TCE_SHIFT))

/*! @brief Set the TCE field to a new value. */
#define I2S_WR_TCR3_TCE(base, value) (I2S_RMW_TCR3(base, I2S_TCR3_TCE_MASK, I2S_TCR3_TCE(value)))
#define I2S_BWR_TCR3_TCE(base, value) (BITBAND_ACCESS32(&I2S_TCR3_REG(base), I2S_TCR3_TCE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_TCR4 - SAI Transmit Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR4 - SAI Transmit Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR4 register
 */
/*@{*/
#define I2S_RD_TCR4(base)        (I2S_TCR4_REG(base))
#define I2S_WR_TCR4(base, value) (I2S_TCR4_REG(base) = (value))
#define I2S_RMW_TCR4(base, mask, value) (I2S_WR_TCR4(base, (I2S_RD_TCR4(base) & ~(mask)) | (value)))
#define I2S_SET_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) |  (value)))
#define I2S_CLR_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) & ~(value)))
#define I2S_TOG_TCR4(base, value) (I2S_WR_TCR4(base, I2S_RD_TCR4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR4 bitfields
 */

/*!
 * @name Register I2S_TCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is generated externally in Slave mode.
 * - 1 - Frame sync is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSD field. */
#define I2S_RD_TCR4_FSD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSD_MASK) >> I2S_TCR4_FSD_SHIFT)
#define I2S_BRD_TCR4_FSD(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSD_SHIFT))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_TCR4_FSD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSD_MASK, I2S_TCR4_FSD(value)))
#define I2S_BWR_TCR4_FSD(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSP field. */
#define I2S_RD_TCR4_FSP(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSP_MASK) >> I2S_TCR4_FSP_SHIFT)
#define I2S_BRD_TCR4_FSP(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSP_SHIFT))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_TCR4_FSP(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSP_MASK, I2S_TCR4_FSP(value)))
#define I2S_BWR_TCR4_FSP(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0 - Internal frame sync is generated continuously.
 * - 1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_ONDEM field. */
#define I2S_RD_TCR4_ONDEM(base) ((I2S_TCR4_REG(base) & I2S_TCR4_ONDEM_MASK) >> I2S_TCR4_ONDEM_SHIFT)
#define I2S_BRD_TCR4_ONDEM(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_ONDEM_SHIFT))

/*! @brief Set the ONDEM field to a new value. */
#define I2S_WR_TCR4_ONDEM(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_ONDEM_MASK, I2S_TCR4_ONDEM(value)))
#define I2S_BWR_TCR4_ONDEM(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_ONDEM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FSE field. */
#define I2S_RD_TCR4_FSE(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FSE_MASK) >> I2S_TCR4_FSE_SHIFT)
#define I2S_BRD_TCR4_FSE(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSE_SHIFT))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_TCR4_FSE(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FSE_MASK, I2S_TCR4_FSE(value)))
#define I2S_BWR_TCR4_FSE(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is transmitted first.
 *
 * Values:
 * - 0 - LSB is transmitted first.
 * - 1 - MSB is transmitted first.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_MF field. */
#define I2S_RD_TCR4_MF(base) ((I2S_TCR4_REG(base) & I2S_TCR4_MF_MASK) >> I2S_TCR4_MF_SHIFT)
#define I2S_BRD_TCR4_MF(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_MF_SHIFT))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_TCR4_MF(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_MF_MASK, I2S_TCR4_MF(value)))
#define I2S_BWR_TCR4_MF(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_MF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_SYWD field. */
#define I2S_RD_TCR4_SYWD(base) ((I2S_TCR4_REG(base) & I2S_TCR4_SYWD_MASK) >> I2S_TCR4_SYWD_SHIFT)
#define I2S_BRD_TCR4_SYWD(base) (I2S_RD_TCR4_SYWD(base))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_TCR4_SYWD(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_SYWD_MASK, I2S_TCR4_SYWD(value)))
#define I2S_BWR_TCR4_SYWD(base, value) (I2S_WR_TCR4_SYWD(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FRSZ[19:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 16 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FRSZ field. */
#define I2S_RD_TCR4_FRSZ(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FRSZ_MASK) >> I2S_TCR4_FRSZ_SHIFT)
#define I2S_BRD_TCR4_FRSZ(base) (I2S_RD_TCR4_FRSZ(base))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_TCR4_FRSZ(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FRSZ_MASK, I2S_TCR4_FRSZ(value)))
#define I2S_BWR_TCR4_FRSZ(base, value) (I2S_WR_TCR4_FRSZ(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are loaded from the FIFO. The first word in each frame always starts with
 * a new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO write pointer will
 * only increment when the full 32-bit FIFO word has been written by software.
 *
 * Values:
 * - 00 - FIFO packing is disabled
 * - 01 - Reserved
 * - 10 - 8-bit FIFO packing is enabled
 * - 11 - 16-bit FIFO packing is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FPACK field. */
#define I2S_RD_TCR4_FPACK(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FPACK_MASK) >> I2S_TCR4_FPACK_SHIFT)
#define I2S_BRD_TCR4_FPACK(base) (I2S_RD_TCR4_FPACK(base))

/*! @brief Set the FPACK field to a new value. */
#define I2S_WR_TCR4_FPACK(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FPACK_MASK, I2S_TCR4_FPACK(value)))
#define I2S_BWR_TCR4_FPACK(base, value) (I2S_WR_TCR4_FPACK(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue transmitting after a FIFO error has
 * been detected.
 *
 * Values:
 * - 0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 1 - On FIFO error, the SAI will continue from the same word that caused the
 *     FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR4_FCONT field. */
#define I2S_RD_TCR4_FCONT(base) ((I2S_TCR4_REG(base) & I2S_TCR4_FCONT_MASK) >> I2S_TCR4_FCONT_SHIFT)
#define I2S_BRD_TCR4_FCONT(base) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FCONT_SHIFT))

/*! @brief Set the FCONT field to a new value. */
#define I2S_WR_TCR4_FCONT(base, value) (I2S_RMW_TCR4(base, I2S_TCR4_FCONT_MASK, I2S_TCR4_FCONT(value)))
#define I2S_BWR_TCR4_FCONT(base, value) (BITBAND_ACCESS32(&I2S_TCR4_REG(base), I2S_TCR4_FCONT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_TCR5 - SAI Transmit Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_TCR5 - SAI Transmit Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when TCSR[TE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_TCR5 register
 */
/*@{*/
#define I2S_RD_TCR5(base)        (I2S_TCR5_REG(base))
#define I2S_WR_TCR5(base, value) (I2S_TCR5_REG(base) = (value))
#define I2S_RMW_TCR5(base, mask, value) (I2S_WR_TCR5(base, (I2S_RD_TCR5(base) & ~(mask)) | (value)))
#define I2S_SET_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) |  (value)))
#define I2S_CLR_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) & ~(value)))
#define I2S_TOG_TCR5(base, value) (I2S_WR_TCR5(base, I2S_RD_TCR5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TCR5 bitfields
 */

/*!
 * @name Register I2S_TCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit transmitted for each word in the
 * frame. If configured for MSB First, the index of the next bit transmitted is
 * one less than the current bit transmitted. If configured for LSB First, the
 * index of the next bit transmitted is one more than the current bit transmitted.
 * The value written must be greater than or equal to the word width when
 * configured for MSB First. The value written must be less than or equal to 31-word width
 * when configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_FBT field. */
#define I2S_RD_TCR5_FBT(base) ((I2S_TCR5_REG(base) & I2S_TCR5_FBT_MASK) >> I2S_TCR5_FBT_SHIFT)
#define I2S_BRD_TCR5_FBT(base) (I2S_RD_TCR5_FBT(base))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_TCR5_FBT(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_FBT_MASK, I2S_TCR5_FBT(value)))
#define I2S_BWR_TCR5_FBT(base, value) (I2S_WR_TCR5_FBT(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_W0W field. */
#define I2S_RD_TCR5_W0W(base) ((I2S_TCR5_REG(base) & I2S_TCR5_W0W_MASK) >> I2S_TCR5_W0W_SHIFT)
#define I2S_BRD_TCR5_W0W(base) (I2S_RD_TCR5_W0W(base))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_TCR5_W0W(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_W0W_MASK, I2S_TCR5_W0W(value)))
#define I2S_BWR_TCR5_W0W(base, value) (I2S_WR_TCR5_W0W(base, value))
/*@}*/

/*!
 * @name Register I2S_TCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_TCR5_WNW field. */
#define I2S_RD_TCR5_WNW(base) ((I2S_TCR5_REG(base) & I2S_TCR5_WNW_MASK) >> I2S_TCR5_WNW_SHIFT)
#define I2S_BRD_TCR5_WNW(base) (I2S_RD_TCR5_WNW(base))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_TCR5_WNW(base, value) (I2S_RMW_TCR5(base, I2S_TCR5_WNW_MASK, I2S_TCR5_WNW(value)))
#define I2S_BWR_TCR5_WNW(base, value) (I2S_WR_TCR5_WNW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_TDR - SAI Transmit Data Register
 ******************************************************************************/

/*!
 * @brief I2S_TDR - SAI Transmit Data Register (WORZ)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_TDR register
 */
/*@{*/
#define I2S_RD_TDR(base, index)  (I2S_TDR_REG(base, index))
#define I2S_WR_TDR(base, index, value) (I2S_TDR_REG(base, index) = (value))
#define I2S_RMW_TDR(base, index, mask, value) (I2S_WR_TDR(base, index, (I2S_RD_TDR(base, index) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * I2S_TFR - SAI Transmit FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_TFR - SAI Transmit FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_TFR register
 */
/*@{*/
#define I2S_RD_TFR(base, index)  (I2S_TFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_TFR bitfields
 */

/*!
 * @name Register I2S_TFR, field RFP[3:0] (RO)
 *
 * FIFO read pointer for transmit data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_RFP field. */
#define I2S_RD_TFR_RFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_RFP_MASK) >> I2S_TFR_RFP_SHIFT)
#define I2S_BRD_TFR_RFP(base, index) (I2S_RD_TFR_RFP(base, index))
/*@}*/

/*!
 * @name Register I2S_TFR, field WFP[19:16] (RO)
 *
 * FIFO write pointer for transmit data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_TFR_WFP field. */
#define I2S_RD_TFR_WFP(base, index) ((I2S_TFR_REG(base, index) & I2S_TFR_WFP_MASK) >> I2S_TFR_WFP_SHIFT)
#define I2S_BRD_TFR_WFP(base, index) (I2S_RD_TFR_WFP(base, index))
/*@}*/

/*******************************************************************************
 * I2S_TMR - SAI Transmit Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_TMR - SAI Transmit Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When TCSR[TE] is first set At
 * the end of each frame. This allows the masked words in each frame to change
 * from frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_TMR register
 */
/*@{*/
#define I2S_RD_TMR(base)         (I2S_TMR_REG(base))
#define I2S_WR_TMR(base, value)  (I2S_TMR_REG(base) = (value))
#define I2S_RMW_TMR(base, mask, value) (I2S_WR_TMR(base, (I2S_RD_TMR(base) & ~(mask)) | (value)))
#define I2S_SET_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) |  (value)))
#define I2S_CLR_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) & ~(value)))
#define I2S_TOG_TMR(base, value) (I2S_WR_TMR(base, I2S_RD_TMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_TMR bitfields
 */

/*!
 * @name Register I2S_TMR, field TWM[15:0] (RW)
 *
 * Configures whether the transmit word is masked (transmit data pin tristated
 * and transmit data not read from FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked. The transmit data pins are tri-stated when masked.
 */
/*@{*/
/*! @brief Read current value of the I2S_TMR_TWM field. */
#define I2S_RD_TMR_TWM(base) ((I2S_TMR_REG(base) & I2S_TMR_TWM_MASK) >> I2S_TMR_TWM_SHIFT)
#define I2S_BRD_TMR_TWM(base) (I2S_RD_TMR_TWM(base))

/*! @brief Set the TWM field to a new value. */
#define I2S_WR_TMR_TWM(base, value) (I2S_RMW_TMR(base, I2S_TMR_TWM_MASK, I2S_TMR_TWM(value)))
#define I2S_BWR_TMR_TWM(base, value) (I2S_WR_TMR_TWM(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCSR - SAI Receive Control Register
 ******************************************************************************/

/*!
 * @brief I2S_RCSR - SAI Receive Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCSR register
 */
/*@{*/
#define I2S_RD_RCSR(base)        (I2S_RCSR_REG(base))
#define I2S_WR_RCSR(base, value) (I2S_RCSR_REG(base) = (value))
#define I2S_RMW_RCSR(base, mask, value) (I2S_WR_RCSR(base, (I2S_RD_RCSR(base) & ~(mask)) | (value)))
#define I2S_SET_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) |  (value)))
#define I2S_CLR_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) & ~(value)))
#define I2S_TOG_RCSR(base, value) (I2S_WR_RCSR(base, I2S_RD_RCSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCSR bitfields
 */

/*!
 * @name Register I2S_RCSR, field FRDE[0] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRDE field. */
#define I2S_RD_RCSR_FRDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRDE_MASK) >> I2S_RCSR_FRDE_SHIFT)
#define I2S_BRD_RCSR_FRDE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRDE_SHIFT))

/*! @brief Set the FRDE field to a new value. */
#define I2S_WR_RCSR_FRDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRDE(value)))
#define I2S_BWR_RCSR_FRDE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWDE[1] (RW)
 *
 * Enables/disables DMA requests.
 *
 * Values:
 * - 0 - Disables the DMA request.
 * - 1 - Enables the DMA request.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWDE field. */
#define I2S_RD_RCSR_FWDE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWDE_MASK) >> I2S_RCSR_FWDE_SHIFT)
#define I2S_BRD_RCSR_FWDE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWDE_SHIFT))

/*! @brief Set the FWDE field to a new value. */
#define I2S_WR_RCSR_FWDE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWDE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWDE(value)))
#define I2S_BWR_RCSR_FWDE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRIE[8] (RW)
 *
 * Enables/disables FIFO request interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRIE field. */
#define I2S_RD_RCSR_FRIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRIE_MASK) >> I2S_RCSR_FRIE_SHIFT)
#define I2S_BRD_RCSR_FRIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRIE_SHIFT))

/*! @brief Set the FRIE field to a new value. */
#define I2S_WR_RCSR_FRIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FRIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FRIE(value)))
#define I2S_BWR_RCSR_FRIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWIE[9] (RW)
 *
 * Enables/disables FIFO warning interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWIE field. */
#define I2S_RD_RCSR_FWIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWIE_MASK) >> I2S_RCSR_FWIE_SHIFT)
#define I2S_BRD_RCSR_FWIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWIE_SHIFT))

/*! @brief Set the FWIE field to a new value. */
#define I2S_WR_RCSR_FWIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FWIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FWIE(value)))
#define I2S_BWR_RCSR_FWIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEIE[10] (RW)
 *
 * Enables/disables FIFO error interrupts.
 *
 * Values:
 * - 0 - Disables the interrupt.
 * - 1 - Enables the interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEIE field. */
#define I2S_RD_RCSR_FEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEIE_MASK) >> I2S_RCSR_FEIE_SHIFT)
#define I2S_BRD_RCSR_FEIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define I2S_WR_RCSR_FEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEIE(value)))
#define I2S_BWR_RCSR_FEIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEIE[11] (RW)
 *
 * Enables/disables sync error interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEIE field. */
#define I2S_RD_RCSR_SEIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEIE_MASK) >> I2S_RCSR_SEIE_SHIFT)
#define I2S_BRD_RCSR_SEIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEIE_SHIFT))

/*! @brief Set the SEIE field to a new value. */
#define I2S_WR_RCSR_SEIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEIE(value)))
#define I2S_BWR_RCSR_SEIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSIE[12] (RW)
 *
 * Enables/disables word start interrupts.
 *
 * Values:
 * - 0 - Disables interrupt.
 * - 1 - Enables interrupt.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSIE field. */
#define I2S_RD_RCSR_WSIE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSIE_MASK) >> I2S_RCSR_WSIE_SHIFT)
#define I2S_BRD_RCSR_WSIE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSIE_SHIFT))

/*! @brief Set the WSIE field to a new value. */
#define I2S_WR_RCSR_WSIE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSIE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_WSIE(value)))
#define I2S_BWR_RCSR_WSIE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FRF[16] (RO)
 *
 * Indicates that the number of words in an enabled receive channel FIFO is
 * greater than the receive FIFO watermark.
 *
 * Values:
 * - 0 - Receive FIFO watermark not reached.
 * - 1 - Receive FIFO watermark has been reached.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FRF field. */
#define I2S_RD_RCSR_FRF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FRF_MASK) >> I2S_RCSR_FRF_SHIFT)
#define I2S_BRD_RCSR_FRF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FRF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FWF[17] (RO)
 *
 * Indicates that an enabled receive FIFO is full.
 *
 * Values:
 * - 0 - No enabled receive FIFO is full.
 * - 1 - Enabled receive FIFO is full.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FWF field. */
#define I2S_RD_RCSR_FWF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FWF_MASK) >> I2S_RCSR_FWF_SHIFT)
#define I2S_BRD_RCSR_FWF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FWF_SHIFT))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FEF[18] (W1C)
 *
 * Indicates that an enabled receive FIFO has overflowed. Write a logic 1 to
 * this field to clear this flag.
 *
 * Values:
 * - 0 - Receive overflow not detected.
 * - 1 - Receive overflow detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_FEF field. */
#define I2S_RD_RCSR_FEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_FEF_MASK) >> I2S_RCSR_FEF_SHIFT)
#define I2S_BRD_RCSR_FEF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define I2S_WR_RCSR_FEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FEF(value)))
#define I2S_BWR_RCSR_FEF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SEF[19] (W1C)
 *
 * Indicates that an error in the externally-generated frame sync has been
 * detected. Write a logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Sync error not detected.
 * - 1 - Frame sync error detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SEF field. */
#define I2S_RD_RCSR_SEF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SEF_MASK) >> I2S_RCSR_SEF_SHIFT)
#define I2S_BRD_RCSR_SEF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEF_SHIFT))

/*! @brief Set the SEF field to a new value. */
#define I2S_WR_RCSR_SEF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SEF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SEF(value)))
#define I2S_BWR_RCSR_SEF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field WSF[20] (W1C)
 *
 * Indicates that the start of the configured word has been detected. Write a
 * logic 1 to this field to clear this flag.
 *
 * Values:
 * - 0 - Start of word not detected.
 * - 1 - Start of word detected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_WSF field. */
#define I2S_RD_RCSR_WSF(base) ((I2S_RCSR_REG(base) & I2S_RCSR_WSF_MASK) >> I2S_RCSR_WSF_SHIFT)
#define I2S_BRD_RCSR_WSF(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSF_SHIFT))

/*! @brief Set the WSF field to a new value. */
#define I2S_WR_RCSR_WSF(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_WSF_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK), I2S_RCSR_WSF(value)))
#define I2S_BWR_RCSR_WSF(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_WSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field SR[24] (RW)
 *
 * Resets the internal receiver logic including the FIFO pointers.
 * Software-visible registers are not affected, except for the status registers.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Software reset.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_SR field. */
#define I2S_RD_RCSR_SR(base) ((I2S_RCSR_REG(base) & I2S_RCSR_SR_MASK) >> I2S_RCSR_SR_SHIFT)
#define I2S_BRD_RCSR_SR(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SR_SHIFT))

/*! @brief Set the SR field to a new value. */
#define I2S_WR_RCSR_SR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_SR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_SR(value)))
#define I2S_BWR_RCSR_SR(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_SR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field FR[25] (WORZ)
 *
 * Resets the FIFO pointers. Reading this field will always return zero. FIFO
 * pointers should only be reset when the receiver is disabled or the FIFO error
 * flag is set.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - FIFO reset.
 */
/*@{*/
/*! @brief Set the FR field to a new value. */
#define I2S_WR_RCSR_FR(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_FR_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_FR(value)))
#define I2S_BWR_RCSR_FR(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_FR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field BCE[28] (RW)
 *
 * Enables the receive bit clock, separately from RE. This field is
 * automatically set whenever RE is set. When software clears this field, the receive bit
 * clock remains enabled, and this field remains set, until the end of the current
 * frame.
 *
 * Values:
 * - 0 - Receive bit clock is disabled.
 * - 1 - Receive bit clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_BCE field. */
#define I2S_RD_RCSR_BCE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_BCE_MASK) >> I2S_RCSR_BCE_SHIFT)
#define I2S_BRD_RCSR_BCE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_BCE_SHIFT))

/*! @brief Set the BCE field to a new value. */
#define I2S_WR_RCSR_BCE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_BCE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_BCE(value)))
#define I2S_BWR_RCSR_BCE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_BCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field DBGE[29] (RW)
 *
 * Enables/disables receiver operation in Debug mode. The receive bit clock is
 * not affected by Debug mode.
 *
 * Values:
 * - 0 - Receiver is disabled in Debug mode, after completing the current frame.
 * - 1 - Receiver is enabled in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_DBGE field. */
#define I2S_RD_RCSR_DBGE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_DBGE_MASK) >> I2S_RCSR_DBGE_SHIFT)
#define I2S_BRD_RCSR_DBGE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_DBGE_SHIFT))

/*! @brief Set the DBGE field to a new value. */
#define I2S_WR_RCSR_DBGE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_DBGE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_DBGE(value)))
#define I2S_BWR_RCSR_DBGE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_DBGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field STOPE[30] (RW)
 *
 * Configures receiver operation in Stop mode. This bit is ignored and the
 * receiver is disabled in all low-leakage stop modes.
 *
 * Values:
 * - 0 - Receiver disabled in Stop mode.
 * - 1 - Receiver enabled in Stop mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_STOPE field. */
#define I2S_RD_RCSR_STOPE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_STOPE_MASK) >> I2S_RCSR_STOPE_SHIFT)
#define I2S_BRD_RCSR_STOPE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_STOPE_SHIFT))

/*! @brief Set the STOPE field to a new value. */
#define I2S_WR_RCSR_STOPE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_STOPE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_STOPE(value)))
#define I2S_BWR_RCSR_STOPE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_STOPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCSR, field RE[31] (RW)
 *
 * Enables/disables the receiver. When software clears this field, the receiver
 * remains enabled, and this bit remains set, until the end of the current frame.
 *
 * Values:
 * - 0 - Receiver is disabled.
 * - 1 - Receiver is enabled, or receiver has been disabled and has not yet
 *     reached end of frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCSR_RE field. */
#define I2S_RD_RCSR_RE(base) ((I2S_RCSR_REG(base) & I2S_RCSR_RE_MASK) >> I2S_RCSR_RE_SHIFT)
#define I2S_BRD_RCSR_RE(base) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define I2S_WR_RCSR_RE(base, value) (I2S_RMW_RCSR(base, (I2S_RCSR_RE_MASK | I2S_RCSR_FEF_MASK | I2S_RCSR_SEF_MASK | I2S_RCSR_WSF_MASK), I2S_RCSR_RE(value)))
#define I2S_BWR_RCSR_RE(base, value) (BITBAND_ACCESS32(&I2S_RCSR_REG(base), I2S_RCSR_RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_RCR1 - SAI Receive Configuration 1 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR1 - SAI Receive Configuration 1 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCR1 register
 */
/*@{*/
#define I2S_RD_RCR1(base)        (I2S_RCR1_REG(base))
#define I2S_WR_RCR1(base, value) (I2S_RCR1_REG(base) = (value))
#define I2S_RMW_RCR1(base, mask, value) (I2S_WR_RCR1(base, (I2S_RD_RCR1(base) & ~(mask)) | (value)))
#define I2S_SET_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) |  (value)))
#define I2S_CLR_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) & ~(value)))
#define I2S_TOG_RCR1(base, value) (I2S_WR_RCR1(base, I2S_RD_RCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR1 bitfields
 */

/*!
 * @name Register I2S_RCR1, field RFW[2:0] (RW)
 *
 * Configures the watermark level for all enabled receiver channels.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR1_RFW field. */
#define I2S_RD_RCR1_RFW(base) ((I2S_RCR1_REG(base) & I2S_RCR1_RFW_MASK) >> I2S_RCR1_RFW_SHIFT)
#define I2S_BRD_RCR1_RFW(base) (I2S_RD_RCR1_RFW(base))

/*! @brief Set the RFW field to a new value. */
#define I2S_WR_RCR1_RFW(base, value) (I2S_RMW_RCR1(base, I2S_RCR1_RFW_MASK, I2S_RCR1_RFW(value)))
#define I2S_BWR_RCR1_RFW(base, value) (I2S_WR_RCR1_RFW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR2 - SAI Receive Configuration 2 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR2 - SAI Receive Configuration 2 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR2 register
 */
/*@{*/
#define I2S_RD_RCR2(base)        (I2S_RCR2_REG(base))
#define I2S_WR_RCR2(base, value) (I2S_RCR2_REG(base) = (value))
#define I2S_RMW_RCR2(base, mask, value) (I2S_WR_RCR2(base, (I2S_RD_RCR2(base) & ~(mask)) | (value)))
#define I2S_SET_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) |  (value)))
#define I2S_CLR_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) & ~(value)))
#define I2S_TOG_RCR2(base, value) (I2S_WR_RCR2(base, I2S_RD_RCR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR2 bitfields
 */

/*!
 * @name Register I2S_RCR2, field DIV[7:0] (RW)
 *
 * Divides down the audio master clock to generate the bit clock when configured
 * for an internal bit clock. The division value is (DIV + 1) * 2.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_DIV field. */
#define I2S_RD_RCR2_DIV(base) ((I2S_RCR2_REG(base) & I2S_RCR2_DIV_MASK) >> I2S_RCR2_DIV_SHIFT)
#define I2S_BRD_RCR2_DIV(base) (I2S_RD_RCR2_DIV(base))

/*! @brief Set the DIV field to a new value. */
#define I2S_WR_RCR2_DIV(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_DIV_MASK, I2S_RCR2_DIV(value)))
#define I2S_BWR_RCR2_DIV(base, value) (I2S_WR_RCR2_DIV(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCD[24] (RW)
 *
 * Configures the direction of the bit clock.
 *
 * Values:
 * - 0 - Bit clock is generated externally in Slave mode.
 * - 1 - Bit clock is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCD field. */
#define I2S_RD_RCR2_BCD(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCD_MASK) >> I2S_RCR2_BCD_SHIFT)
#define I2S_BRD_RCR2_BCD(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCD_SHIFT))

/*! @brief Set the BCD field to a new value. */
#define I2S_WR_RCR2_BCD(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCD_MASK, I2S_RCR2_BCD(value)))
#define I2S_BWR_RCR2_BCD(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCP[25] (RW)
 *
 * Configures the polarity of the bit clock.
 *
 * Values:
 * - 0 - Bit Clock is active high with drive outputs on rising edge and sample
 *     inputs on falling edge.
 * - 1 - Bit Clock is active low with drive outputs on falling edge and sample
 *     inputs on rising edge.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCP field. */
#define I2S_RD_RCR2_BCP(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCP_MASK) >> I2S_RCR2_BCP_SHIFT)
#define I2S_BRD_RCR2_BCP(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCP_SHIFT))

/*! @brief Set the BCP field to a new value. */
#define I2S_WR_RCR2_BCP(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCP_MASK, I2S_RCR2_BCP(value)))
#define I2S_BWR_RCR2_BCP(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field MSEL[27:26] (RW)
 *
 * Selects the audio Master Clock option used to generate an internally
 * generated bit clock. This field has no effect when configured for an externally
 * generated bit clock. Depending on the device, some Master Clock options might not be
 * available. See the chip-specific information for the availability and
 * chip-specific meaning of each option.
 *
 * Values:
 * - 00 - Bus Clock selected.
 * - 01 - Master Clock (MCLK) 1 option selected.
 * - 10 - Master Clock (MCLK) 2 option selected.
 * - 11 - Master Clock (MCLK) 3 option selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_MSEL field. */
#define I2S_RD_RCR2_MSEL(base) ((I2S_RCR2_REG(base) & I2S_RCR2_MSEL_MASK) >> I2S_RCR2_MSEL_SHIFT)
#define I2S_BRD_RCR2_MSEL(base) (I2S_RD_RCR2_MSEL(base))

/*! @brief Set the MSEL field to a new value. */
#define I2S_WR_RCR2_MSEL(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_MSEL_MASK, I2S_RCR2_MSEL(value)))
#define I2S_BWR_RCR2_MSEL(base, value) (I2S_WR_RCR2_MSEL(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCI[28] (RW)
 *
 * When this field is set and using an internally generated bit clock in either
 * synchronous or asynchronous mode, the bit clock actually used by the receiver
 * is delayed by the pad output delay (the receiver is clocked by the pad input
 * as if the clock was externally generated). This has the effect of decreasing
 * the data input setup time, but increasing the data output valid time. The slave
 * mode timing from the datasheet should be used for the receiver when this bit
 * is set. In synchronous mode, this bit allows the receiver to use the slave mode
 * timing from the datasheet, while the transmitter uses the master mode timing.
 * This field has no effect when configured for an externally generated bit
 * clock .
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Internal logic is clocked as if bit clock was externally generated.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCI field. */
#define I2S_RD_RCR2_BCI(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCI_MASK) >> I2S_RCR2_BCI_SHIFT)
#define I2S_BRD_RCR2_BCI(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCI_SHIFT))

/*! @brief Set the BCI field to a new value. */
#define I2S_WR_RCR2_BCI(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCI_MASK, I2S_RCR2_BCI(value)))
#define I2S_BWR_RCR2_BCI(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field BCS[29] (RW)
 *
 * This field swaps the bit clock used by the receiver. When the receiver is
 * configured in asynchronous mode and this bit is set, the receiver is clocked by
 * the transmitter bit clock (SAI_TX_BCLK). This allows the transmitter and
 * receiver to share the same bit clock, but the receiver continues to use the receiver
 * frame sync (SAI_RX_SYNC). When the receiver is configured in synchronous
 * mode, the transmitter BCS field and receiver BCS field must be set to the same
 * value. When both are set, the transmitter and receiver are both clocked by the
 * receiver bit clock (SAI_RX_BCLK) but use the transmitter frame sync
 * (SAI_TX_SYNC).
 *
 * Values:
 * - 0 - Use the normal bit clock source.
 * - 1 - Swap the bit clock source.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_BCS field. */
#define I2S_RD_RCR2_BCS(base) ((I2S_RCR2_REG(base) & I2S_RCR2_BCS_MASK) >> I2S_RCR2_BCS_SHIFT)
#define I2S_BRD_RCR2_BCS(base) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCS_SHIFT))

/*! @brief Set the BCS field to a new value. */
#define I2S_WR_RCR2_BCS(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_BCS_MASK, I2S_RCR2_BCS(value)))
#define I2S_BWR_RCR2_BCS(base, value) (BITBAND_ACCESS32(&I2S_RCR2_REG(base), I2S_RCR2_BCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR2, field SYNC[31:30] (RW)
 *
 * Configures between asynchronous and synchronous modes of operation. When
 * configured for a synchronous mode of operation, the transmitter must be configured
 * for asynchronous operation.
 *
 * Values:
 * - 00 - Asynchronous mode.
 * - 01 - Synchronous with transmitter.
 * - 10 - Synchronous with another SAI receiver.
 * - 11 - Synchronous with another SAI transmitter.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR2_SYNC field. */
#define I2S_RD_RCR2_SYNC(base) ((I2S_RCR2_REG(base) & I2S_RCR2_SYNC_MASK) >> I2S_RCR2_SYNC_SHIFT)
#define I2S_BRD_RCR2_SYNC(base) (I2S_RD_RCR2_SYNC(base))

/*! @brief Set the SYNC field to a new value. */
#define I2S_WR_RCR2_SYNC(base, value) (I2S_RMW_RCR2(base, I2S_RCR2_SYNC_MASK, I2S_RCR2_SYNC(value)))
#define I2S_BWR_RCR2_SYNC(base, value) (I2S_WR_RCR2_SYNC(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RCR3 - SAI Receive Configuration 3 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR3 - SAI Receive Configuration 3 Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire I2S_RCR3 register
 */
/*@{*/
#define I2S_RD_RCR3(base)        (I2S_RCR3_REG(base))
#define I2S_WR_RCR3(base, value) (I2S_RCR3_REG(base) = (value))
#define I2S_RMW_RCR3(base, mask, value) (I2S_WR_RCR3(base, (I2S_RD_RCR3(base) & ~(mask)) | (value)))
#define I2S_SET_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) |  (value)))
#define I2S_CLR_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) & ~(value)))
#define I2S_TOG_RCR3(base, value) (I2S_WR_RCR3(base, I2S_RD_RCR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR3 bitfields
 */

/*!
 * @name Register I2S_RCR3, field WDFL[3:0] (RW)
 *
 * Configures which word the start of word flag is set. The value written should
 * be one less than the word number (for example, write zero to configure for
 * the first word in the frame). When configured to a value greater than the Frame
 * Size field, then the start of word flag is never set.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_WDFL field. */
#define I2S_RD_RCR3_WDFL(base) ((I2S_RCR3_REG(base) & I2S_RCR3_WDFL_MASK) >> I2S_RCR3_WDFL_SHIFT)
#define I2S_BRD_RCR3_WDFL(base) (I2S_RD_RCR3_WDFL(base))

/*! @brief Set the WDFL field to a new value. */
#define I2S_WR_RCR3_WDFL(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_WDFL_MASK, I2S_RCR3_WDFL(value)))
#define I2S_BWR_RCR3_WDFL(base, value) (I2S_WR_RCR3_WDFL(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR3, field RCE[16] (RW)
 *
 * Enables the corresponding data channel for receive operation. A channel must
 * be enabled before its FIFO is accessed. Changing this field will take effect
 * immediately for generating the FIFO request and warning flags, but at the end
 * of each frame for receive operation.
 *
 * Values:
 * - 0 - Receive data channel N is disabled.
 * - 1 - Receive data channel N is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR3_RCE field. */
#define I2S_RD_RCR3_RCE(base) ((I2S_RCR3_REG(base) & I2S_RCR3_RCE_MASK) >> I2S_RCR3_RCE_SHIFT)
#define I2S_BRD_RCR3_RCE(base) (BITBAND_ACCESS32(&I2S_RCR3_REG(base), I2S_RCR3_RCE_SHIFT))

/*! @brief Set the RCE field to a new value. */
#define I2S_WR_RCR3_RCE(base, value) (I2S_RMW_RCR3(base, I2S_RCR3_RCE_MASK, I2S_RCR3_RCE(value)))
#define I2S_BWR_RCR3_RCE(base, value) (BITBAND_ACCESS32(&I2S_RCR3_REG(base), I2S_RCR3_RCE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_RCR4 - SAI Receive Configuration 4 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR4 - SAI Receive Configuration 4 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR4 register
 */
/*@{*/
#define I2S_RD_RCR4(base)        (I2S_RCR4_REG(base))
#define I2S_WR_RCR4(base, value) (I2S_RCR4_REG(base) = (value))
#define I2S_RMW_RCR4(base, mask, value) (I2S_WR_RCR4(base, (I2S_RD_RCR4(base) & ~(mask)) | (value)))
#define I2S_SET_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) |  (value)))
#define I2S_CLR_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) & ~(value)))
#define I2S_TOG_RCR4(base, value) (I2S_WR_RCR4(base, I2S_RD_RCR4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR4 bitfields
 */

/*!
 * @name Register I2S_RCR4, field FSD[0] (RW)
 *
 * Configures the direction of the frame sync.
 *
 * Values:
 * - 0 - Frame Sync is generated externally in Slave mode.
 * - 1 - Frame Sync is generated internally in Master mode.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSD field. */
#define I2S_RD_RCR4_FSD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSD_MASK) >> I2S_RCR4_FSD_SHIFT)
#define I2S_BRD_RCR4_FSD(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSD_SHIFT))

/*! @brief Set the FSD field to a new value. */
#define I2S_WR_RCR4_FSD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSD_MASK, I2S_RCR4_FSD(value)))
#define I2S_BWR_RCR4_FSD(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSP[1] (RW)
 *
 * Configures the polarity of the frame sync.
 *
 * Values:
 * - 0 - Frame sync is active high.
 * - 1 - Frame sync is active low.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSP field. */
#define I2S_RD_RCR4_FSP(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSP_MASK) >> I2S_RCR4_FSP_SHIFT)
#define I2S_BRD_RCR4_FSP(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSP_SHIFT))

/*! @brief Set the FSP field to a new value. */
#define I2S_WR_RCR4_FSP(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSP_MASK, I2S_RCR4_FSP(value)))
#define I2S_BWR_RCR4_FSP(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field ONDEM[2] (RW)
 *
 * When set, and the frame sync is generated internally, a frame sync is only
 * generated when the FIFO warning flag is clear.
 *
 * Values:
 * - 0 - Internal frame sync is generated continuously.
 * - 1 - Internal frame sync is generated when the FIFO warning flag is clear.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_ONDEM field. */
#define I2S_RD_RCR4_ONDEM(base) ((I2S_RCR4_REG(base) & I2S_RCR4_ONDEM_MASK) >> I2S_RCR4_ONDEM_SHIFT)
#define I2S_BRD_RCR4_ONDEM(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_ONDEM_SHIFT))

/*! @brief Set the ONDEM field to a new value. */
#define I2S_WR_RCR4_ONDEM(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_ONDEM_MASK, I2S_RCR4_ONDEM(value)))
#define I2S_BWR_RCR4_ONDEM(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_ONDEM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FSE[3] (RW)
 *
 * Values:
 * - 0 - Frame sync asserts with the first bit of the frame.
 * - 1 - Frame sync asserts one bit before the first bit of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FSE field. */
#define I2S_RD_RCR4_FSE(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FSE_MASK) >> I2S_RCR4_FSE_SHIFT)
#define I2S_BRD_RCR4_FSE(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSE_SHIFT))

/*! @brief Set the FSE field to a new value. */
#define I2S_WR_RCR4_FSE(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FSE_MASK, I2S_RCR4_FSE(value)))
#define I2S_BWR_RCR4_FSE(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field MF[4] (RW)
 *
 * Configures whether the LSB or the MSB is received first.
 *
 * Values:
 * - 0 - LSB is received first.
 * - 1 - MSB is received first.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_MF field. */
#define I2S_RD_RCR4_MF(base) ((I2S_RCR4_REG(base) & I2S_RCR4_MF_MASK) >> I2S_RCR4_MF_SHIFT)
#define I2S_BRD_RCR4_MF(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_MF_SHIFT))

/*! @brief Set the MF field to a new value. */
#define I2S_WR_RCR4_MF(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_MF_MASK, I2S_RCR4_MF(value)))
#define I2S_BWR_RCR4_MF(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_MF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field SYWD[12:8] (RW)
 *
 * Configures the length of the frame sync in number of bit clocks. The value
 * written must be one less than the number of bit clocks. For example, write 0 for
 * the frame sync to assert for one bit clock only. The sync width cannot be
 * configured longer than the first word of the frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_SYWD field. */
#define I2S_RD_RCR4_SYWD(base) ((I2S_RCR4_REG(base) & I2S_RCR4_SYWD_MASK) >> I2S_RCR4_SYWD_SHIFT)
#define I2S_BRD_RCR4_SYWD(base) (I2S_RD_RCR4_SYWD(base))

/*! @brief Set the SYWD field to a new value. */
#define I2S_WR_RCR4_SYWD(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_SYWD_MASK, I2S_RCR4_SYWD(value)))
#define I2S_BWR_RCR4_SYWD(base, value) (I2S_WR_RCR4_SYWD(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FRSZ[19:16] (RW)
 *
 * Configures the number of words in each frame. The value written must be one
 * less than the number of words in the frame. For example, write 0 for one word
 * per frame. The maximum supported frame size is 16 words.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FRSZ field. */
#define I2S_RD_RCR4_FRSZ(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FRSZ_MASK) >> I2S_RCR4_FRSZ_SHIFT)
#define I2S_BRD_RCR4_FRSZ(base) (I2S_RD_RCR4_FRSZ(base))

/*! @brief Set the FRSZ field to a new value. */
#define I2S_WR_RCR4_FRSZ(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FRSZ_MASK, I2S_RCR4_FRSZ(value)))
#define I2S_BWR_RCR4_FRSZ(base, value) (I2S_WR_RCR4_FRSZ(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FPACK[25:24] (RW)
 *
 * Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO word. If
 * the word size is greater than 8-bit or 16-bit then only the first 8-bit or
 * 16-bits are stored to the FIFO. The first word in each frame always starts with a
 * new 32-bit FIFO word and the first bit shifted must be configured within the
 * first packed word. When FIFO packing is enabled, the FIFO read pointer will
 * only increment when the full 32-bit FIFO word has been read by software.
 *
 * Values:
 * - 00 - FIFO packing is disabled
 * - 01 - Reserved.
 * - 10 - 8-bit FIFO packing is enabled
 * - 11 - 16-bit FIFO packing is enabled
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FPACK field. */
#define I2S_RD_RCR4_FPACK(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FPACK_MASK) >> I2S_RCR4_FPACK_SHIFT)
#define I2S_BRD_RCR4_FPACK(base) (I2S_RD_RCR4_FPACK(base))

/*! @brief Set the FPACK field to a new value. */
#define I2S_WR_RCR4_FPACK(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FPACK_MASK, I2S_RCR4_FPACK(value)))
#define I2S_BWR_RCR4_FPACK(base, value) (I2S_WR_RCR4_FPACK(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR4, field FCONT[28] (RW)
 *
 * Configures when the SAI will continue receiving after a FIFO error has been
 * detected.
 *
 * Values:
 * - 0 - On FIFO error, the SAI will continue from the start of the next frame
 *     after the FIFO error flag has been cleared.
 * - 1 - On FIFO error, the SAI will continue from the same word that caused the
 *     FIFO error to set after the FIFO warning flag has been cleared.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR4_FCONT field. */
#define I2S_RD_RCR4_FCONT(base) ((I2S_RCR4_REG(base) & I2S_RCR4_FCONT_MASK) >> I2S_RCR4_FCONT_SHIFT)
#define I2S_BRD_RCR4_FCONT(base) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FCONT_SHIFT))

/*! @brief Set the FCONT field to a new value. */
#define I2S_WR_RCR4_FCONT(base, value) (I2S_RMW_RCR4(base, I2S_RCR4_FCONT_MASK, I2S_RCR4_FCONT(value)))
#define I2S_BWR_RCR4_FCONT(base, value) (BITBAND_ACCESS32(&I2S_RCR4_REG(base), I2S_RCR4_FCONT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * I2S_RCR5 - SAI Receive Configuration 5 Register
 ******************************************************************************/

/*!
 * @brief I2S_RCR5 - SAI Receive Configuration 5 Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register must not be altered when RCSR[RE] is set.
 */
/*!
 * @name Constants and macros for entire I2S_RCR5 register
 */
/*@{*/
#define I2S_RD_RCR5(base)        (I2S_RCR5_REG(base))
#define I2S_WR_RCR5(base, value) (I2S_RCR5_REG(base) = (value))
#define I2S_RMW_RCR5(base, mask, value) (I2S_WR_RCR5(base, (I2S_RD_RCR5(base) & ~(mask)) | (value)))
#define I2S_SET_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) |  (value)))
#define I2S_CLR_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) & ~(value)))
#define I2S_TOG_RCR5(base, value) (I2S_WR_RCR5(base, I2S_RD_RCR5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RCR5 bitfields
 */

/*!
 * @name Register I2S_RCR5, field FBT[12:8] (RW)
 *
 * Configures the bit index for the first bit received for each word in the
 * frame. If configured for MSB First, the index of the next bit received is one less
 * than the current bit received. If configured for LSB First, the index of the
 * next bit received is one more than the current bit received. The value written
 * must be greater than or equal to the word width when configured for MSB
 * First. The value written must be less than or equal to 31-word width when
 * configured for LSB First.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_FBT field. */
#define I2S_RD_RCR5_FBT(base) ((I2S_RCR5_REG(base) & I2S_RCR5_FBT_MASK) >> I2S_RCR5_FBT_SHIFT)
#define I2S_BRD_RCR5_FBT(base) (I2S_RD_RCR5_FBT(base))

/*! @brief Set the FBT field to a new value. */
#define I2S_WR_RCR5_FBT(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_FBT_MASK, I2S_RCR5_FBT(value)))
#define I2S_BWR_RCR5_FBT(base, value) (I2S_WR_RCR5_FBT(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR5, field W0W[20:16] (RW)
 *
 * Configures the number of bits in the first word in each frame. The value
 * written must be one less than the number of bits in the first word. Word width of
 * less than 8 bits is not supported if there is only one word per frame.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_W0W field. */
#define I2S_RD_RCR5_W0W(base) ((I2S_RCR5_REG(base) & I2S_RCR5_W0W_MASK) >> I2S_RCR5_W0W_SHIFT)
#define I2S_BRD_RCR5_W0W(base) (I2S_RD_RCR5_W0W(base))

/*! @brief Set the W0W field to a new value. */
#define I2S_WR_RCR5_W0W(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_W0W_MASK, I2S_RCR5_W0W(value)))
#define I2S_BWR_RCR5_W0W(base, value) (I2S_WR_RCR5_W0W(base, value))
/*@}*/

/*!
 * @name Register I2S_RCR5, field WNW[28:24] (RW)
 *
 * Configures the number of bits in each word, for each word except the first in
 * the frame. The value written must be one less than the number of bits per
 * word. Word width of less than 8 bits is not supported.
 */
/*@{*/
/*! @brief Read current value of the I2S_RCR5_WNW field. */
#define I2S_RD_RCR5_WNW(base) ((I2S_RCR5_REG(base) & I2S_RCR5_WNW_MASK) >> I2S_RCR5_WNW_SHIFT)
#define I2S_BRD_RCR5_WNW(base) (I2S_RD_RCR5_WNW(base))

/*! @brief Set the WNW field to a new value. */
#define I2S_WR_RCR5_WNW(base, value) (I2S_RMW_RCR5(base, I2S_RCR5_WNW_MASK, I2S_RCR5_WNW(value)))
#define I2S_BWR_RCR5_WNW(base, value) (I2S_WR_RCR5_WNW(base, value))
/*@}*/

/*******************************************************************************
 * I2S_RDR - SAI Receive Data Register
 ******************************************************************************/

/*!
 * @brief I2S_RDR - SAI Receive Data Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Reading this register introduces one additional peripheral clock wait state
 * on each read.
 */
/*!
 * @name Constants and macros for entire I2S_RDR register
 */
/*@{*/
#define I2S_RD_RDR(base, index)  (I2S_RDR_REG(base, index))
/*@}*/

/*******************************************************************************
 * I2S_RFR - SAI Receive FIFO Register
 ******************************************************************************/

/*!
 * @brief I2S_RFR - SAI Receive FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * The MSB of the read and write pointers is used to distinguish between FIFO
 * full and empty conditions. If the read and write pointers are identical, then
 * the FIFO is empty. If the read and write pointers are identical except for the
 * MSB, then the FIFO is full.
 */
/*!
 * @name Constants and macros for entire I2S_RFR register
 */
/*@{*/
#define I2S_RD_RFR(base, index)  (I2S_RFR_REG(base, index))
/*@}*/

/*
 * Constants & macros for individual I2S_RFR bitfields
 */

/*!
 * @name Register I2S_RFR, field RFP[3:0] (RO)
 *
 * FIFO read pointer for receive data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_RFP field. */
#define I2S_RD_RFR_RFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_RFP_MASK) >> I2S_RFR_RFP_SHIFT)
#define I2S_BRD_RFR_RFP(base, index) (I2S_RD_RFR_RFP(base, index))
/*@}*/

/*!
 * @name Register I2S_RFR, field WFP[19:16] (RO)
 *
 * FIFO write pointer for receive data channel.
 */
/*@{*/
/*! @brief Read current value of the I2S_RFR_WFP field. */
#define I2S_RD_RFR_WFP(base, index) ((I2S_RFR_REG(base, index) & I2S_RFR_WFP_MASK) >> I2S_RFR_WFP_SHIFT)
#define I2S_BRD_RFR_WFP(base, index) (I2S_RD_RFR_WFP(base, index))
/*@}*/

/*******************************************************************************
 * I2S_RMR - SAI Receive Mask Register
 ******************************************************************************/

/*!
 * @brief I2S_RMR - SAI Receive Mask Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is double-buffered and updates: When RCSR[RE] is first set At
 * the end of each frame This allows the masked words in each frame to change from
 * frame to frame.
 */
/*!
 * @name Constants and macros for entire I2S_RMR register
 */
/*@{*/
#define I2S_RD_RMR(base)         (I2S_RMR_REG(base))
#define I2S_WR_RMR(base, value)  (I2S_RMR_REG(base) = (value))
#define I2S_RMW_RMR(base, mask, value) (I2S_WR_RMR(base, (I2S_RD_RMR(base) & ~(mask)) | (value)))
#define I2S_SET_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) |  (value)))
#define I2S_CLR_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) & ~(value)))
#define I2S_TOG_RMR(base, value) (I2S_WR_RMR(base, I2S_RD_RMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_RMR bitfields
 */

/*!
 * @name Register I2S_RMR, field RWM[15:0] (RW)
 *
 * Configures whether the receive word is masked (received data ignored and not
 * written to receive FIFO) for the corresponding word in the frame.
 *
 * Values:
 * - 0 - Word N is enabled.
 * - 1 - Word N is masked.
 */
/*@{*/
/*! @brief Read current value of the I2S_RMR_RWM field. */
#define I2S_RD_RMR_RWM(base) ((I2S_RMR_REG(base) & I2S_RMR_RWM_MASK) >> I2S_RMR_RWM_SHIFT)
#define I2S_BRD_RMR_RWM(base) (I2S_RD_RMR_RWM(base))

/*! @brief Set the RWM field to a new value. */
#define I2S_WR_RMR_RWM(base, value) (I2S_RMW_RMR(base, I2S_RMR_RWM_MASK, I2S_RMR_RWM(value)))
#define I2S_BWR_RMR_RWM(base, value) (I2S_WR_RMR_RWM(base, value))
/*@}*/

/*******************************************************************************
 * I2S_MCR - SAI MCLK Control Register
 ******************************************************************************/

/*!
 * @brief I2S_MCR - SAI MCLK Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Control Register (MCR) controls the clock source and direction of
 * the audio master clock.
 */
/*!
 * @name Constants and macros for entire I2S_MCR register
 */
/*@{*/
#define I2S_RD_MCR(base)         (I2S_MCR_REG(base))
#define I2S_WR_MCR(base, value)  (I2S_MCR_REG(base) = (value))
#define I2S_RMW_MCR(base, mask, value) (I2S_WR_MCR(base, (I2S_RD_MCR(base) & ~(mask)) | (value)))
#define I2S_SET_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) |  (value)))
#define I2S_CLR_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) & ~(value)))
#define I2S_TOG_MCR(base, value) (I2S_WR_MCR(base, I2S_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_MCR bitfields
 */

/*!
 * @name Register I2S_MCR, field MICS[25:24] (RW)
 *
 * Selects the clock input to the MCLK divider. This field cannot be changed
 * while the MCLK divider is enabled. See the chip-specific information for the
 * connections to these inputs.
 *
 * Values:
 * - 00 - MCLK divider input clock 0 is selected.
 * - 01 - MCLK divider input clock 1 is selected.
 * - 10 - MCLK divider input clock 2 is selected.
 * - 11 - MCLK divider input clock 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_MICS field. */
#define I2S_RD_MCR_MICS(base) ((I2S_MCR_REG(base) & I2S_MCR_MICS_MASK) >> I2S_MCR_MICS_SHIFT)
#define I2S_BRD_MCR_MICS(base) (I2S_RD_MCR_MICS(base))

/*! @brief Set the MICS field to a new value. */
#define I2S_WR_MCR_MICS(base, value) (I2S_RMW_MCR(base, I2S_MCR_MICS_MASK, I2S_MCR_MICS(value)))
#define I2S_BWR_MCR_MICS(base, value) (I2S_WR_MCR_MICS(base, value))
/*@}*/

/*!
 * @name Register I2S_MCR, field MOE[30] (RW)
 *
 * Enables the MCLK divider and configures the MCLK signal pin as an output.
 * When software clears this field, it remains set until the MCLK divider is fully
 * disabled.
 *
 * Values:
 * - 0 - MCLK signal pin is configured as an input that bypasses the MCLK
 *     divider.
 * - 1 - MCLK signal pin is configured as an output from the MCLK divider and
 *     the MCLK divider is enabled.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_MOE field. */
#define I2S_RD_MCR_MOE(base) ((I2S_MCR_REG(base) & I2S_MCR_MOE_MASK) >> I2S_MCR_MOE_SHIFT)
#define I2S_BRD_MCR_MOE(base) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_MOE_SHIFT))

/*! @brief Set the MOE field to a new value. */
#define I2S_WR_MCR_MOE(base, value) (I2S_RMW_MCR(base, I2S_MCR_MOE_MASK, I2S_MCR_MOE(value)))
#define I2S_BWR_MCR_MOE(base, value) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_MOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register I2S_MCR, field DUF[31] (RO)
 *
 * Provides the status of on-the-fly updates to the MCLK divider ratio.
 *
 * Values:
 * - 0 - MCLK divider ratio is not being updated currently.
 * - 1 - MCLK divider ratio is updating on-the-fly. Further updates to the MCLK
 *     divider ratio are blocked while this flag remains set.
 */
/*@{*/
/*! @brief Read current value of the I2S_MCR_DUF field. */
#define I2S_RD_MCR_DUF(base) ((I2S_MCR_REG(base) & I2S_MCR_DUF_MASK) >> I2S_MCR_DUF_SHIFT)
#define I2S_BRD_MCR_DUF(base) (BITBAND_ACCESS32(&I2S_MCR_REG(base), I2S_MCR_DUF_SHIFT))
/*@}*/

/*******************************************************************************
 * I2S_MDR - SAI MCLK Divide Register
 ******************************************************************************/

/*!
 * @brief I2S_MDR - SAI MCLK Divide Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCLK Divide Register (MDR) configures the MCLK divide ratio. Although the
 * MDR can be changed when the MCLK divider clock is enabled, additional writes
 * to the MDR are blocked while MCR[DUF] is set. Writes to the MDR when the MCLK
 * divided clock is disabled do not set MCR[DUF].
 */
/*!
 * @name Constants and macros for entire I2S_MDR register
 */
/*@{*/
#define I2S_RD_MDR(base)         (I2S_MDR_REG(base))
#define I2S_WR_MDR(base, value)  (I2S_MDR_REG(base) = (value))
#define I2S_RMW_MDR(base, mask, value) (I2S_WR_MDR(base, (I2S_RD_MDR(base) & ~(mask)) | (value)))
#define I2S_SET_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) |  (value)))
#define I2S_CLR_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) & ~(value)))
#define I2S_TOG_MDR(base, value) (I2S_WR_MDR(base, I2S_RD_MDR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual I2S_MDR bitfields
 */

/*!
 * @name Register I2S_MDR, field DIVIDE[11:0] (RW)
 *
 * Sets the MCLK divide ratio such that: MCLK output = MCLK input * ( (FRACT +
 * 1) / (DIVIDE + 1) ). FRACT must be set equal or less than the value in the
 * DIVIDE field. When using fractional divide values, the MCLK duty cycle will not
 * always be 50/50. See .
 */
/*@{*/
/*! @brief Read current value of the I2S_MDR_DIVIDE field. */
#define I2S_RD_MDR_DIVIDE(base) ((I2S_MDR_REG(base) & I2S_MDR_DIVIDE_MASK) >> I2S_MDR_DIVIDE_SHIFT)
#define I2S_BRD_MDR_DIVIDE(base) (I2S_RD_MDR_DIVIDE(base))

/*! @brief Set the DIVIDE field to a new value. */
#define I2S_WR_MDR_DIVIDE(base, value) (I2S_RMW_MDR(base, I2S_MDR_DIVIDE_MASK, I2S_MDR_DIVIDE(value)))
#define I2S_BWR_MDR_DIVIDE(base, value) (I2S_WR_MDR_DIVIDE(base, value))
/*@}*/

/*!
 * @name Register I2S_MDR, field FRACT[19:12] (RW)
 *
 * Sets the MCLK divide ratio such that: MCLK output = MCLK input * ( (FRACT +
 * 1) / (DIVIDE + 1) ). FRACT must be set equal or less than the value in the
 * DIVIDE field. When using fractional divide values, the MCLK duty cycle will not
 * always be 50/50. See .
 */
/*@{*/
/*! @brief Read current value of the I2S_MDR_FRACT field. */
#define I2S_RD_MDR_FRACT(base) ((I2S_MDR_REG(base) & I2S_MDR_FRACT_MASK) >> I2S_MDR_FRACT_SHIFT)
#define I2S_BRD_MDR_FRACT(base) (I2S_RD_MDR_FRACT(base))

/*! @brief Set the FRACT field to a new value. */
#define I2S_WR_MDR_FRACT(base, value) (I2S_RMW_MDR(base, I2S_MDR_FRACT_MASK, I2S_MDR_FRACT(value)))
#define I2S_BWR_MDR_FRACT(base, value) (I2S_WR_MDR_FRACT(base, value))
/*@}*/

/*
 * MKS22F25612 LLWU
 *
 * Low leakage wakeup unit
 *
 * Registers defined in this header file:
 * - LLWU_PE1 - LLWU Pin Enable 1 register
 * - LLWU_PE2 - LLWU Pin Enable 2 register
 * - LLWU_PE3 - LLWU Pin Enable 3 register
 * - LLWU_PE4 - LLWU Pin Enable 4 register
 * - LLWU_PE5 - LLWU Pin Enable 5 register
 * - LLWU_PE6 - LLWU Pin Enable 6 register
 * - LLWU_PE7 - LLWU Pin Enable 7 register
 * - LLWU_PE8 - LLWU Pin Enable 8 register
 * - LLWU_ME - LLWU Module Enable register
 * - LLWU_PF1 - LLWU Pin Flag 1 register
 * - LLWU_PF2 - LLWU Pin Flag 2 register
 * - LLWU_PF3 - LLWU Pin Flag 3 register
 * - LLWU_PF4 - LLWU Pin Flag 4 register
 * - LLWU_MF5 - LLWU Module Flag 5 register
 * - LLWU_FILT1 - LLWU Pin Filter 1 register
 * - LLWU_FILT2 - LLWU Pin Filter 2 register
 */

#define LLWU_INSTANCE_COUNT (1U) /*!< Number of instances of the LLWU module. */
#define LLWU_IDX (0U) /*!< Instance number for LLWU. */

/*******************************************************************************
 * LLWU_PE1 - LLWU Pin Enable 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE1 - LLWU Pin Enable 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE1 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P3-LLWU_P0. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE1 register
 */
/*@{*/
#define LLWU_RD_PE1(base)        (LLWU_PE1_REG(base))
#define LLWU_WR_PE1(base, value) (LLWU_PE1_REG(base) = (value))
#define LLWU_RMW_PE1(base, mask, value) (LLWU_WR_PE1(base, (LLWU_RD_PE1(base) & ~(mask)) | (value)))
#define LLWU_SET_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) |  (value)))
#define LLWU_CLR_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) & ~(value)))
#define LLWU_TOG_PE1(base, value) (LLWU_WR_PE1(base, LLWU_RD_PE1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE1 bitfields
 */

/*!
 * @name Register LLWU_PE1, field WUPE0[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE0 field. */
#define LLWU_RD_PE1_WUPE0(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE0_MASK) >> LLWU_PE1_WUPE0_SHIFT)
#define LLWU_BRD_PE1_WUPE0(base) (LLWU_RD_PE1_WUPE0(base))

/*! @brief Set the WUPE0 field to a new value. */
#define LLWU_WR_PE1_WUPE0(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE0_MASK, LLWU_PE1_WUPE0(value)))
#define LLWU_BWR_PE1_WUPE0(base, value) (LLWU_WR_PE1_WUPE0(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE1[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE1 field. */
#define LLWU_RD_PE1_WUPE1(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE1_MASK) >> LLWU_PE1_WUPE1_SHIFT)
#define LLWU_BRD_PE1_WUPE1(base) (LLWU_RD_PE1_WUPE1(base))

/*! @brief Set the WUPE1 field to a new value. */
#define LLWU_WR_PE1_WUPE1(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE1_MASK, LLWU_PE1_WUPE1(value)))
#define LLWU_BWR_PE1_WUPE1(base, value) (LLWU_WR_PE1_WUPE1(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE2[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE2 field. */
#define LLWU_RD_PE1_WUPE2(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE2_MASK) >> LLWU_PE1_WUPE2_SHIFT)
#define LLWU_BRD_PE1_WUPE2(base) (LLWU_RD_PE1_WUPE2(base))

/*! @brief Set the WUPE2 field to a new value. */
#define LLWU_WR_PE1_WUPE2(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE2_MASK, LLWU_PE1_WUPE2(value)))
#define LLWU_BWR_PE1_WUPE2(base, value) (LLWU_WR_PE1_WUPE2(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE1, field WUPE3[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE1_WUPE3 field. */
#define LLWU_RD_PE1_WUPE3(base) ((LLWU_PE1_REG(base) & LLWU_PE1_WUPE3_MASK) >> LLWU_PE1_WUPE3_SHIFT)
#define LLWU_BRD_PE1_WUPE3(base) (LLWU_RD_PE1_WUPE3(base))

/*! @brief Set the WUPE3 field to a new value. */
#define LLWU_WR_PE1_WUPE3(base, value) (LLWU_RMW_PE1(base, LLWU_PE1_WUPE3_MASK, LLWU_PE1_WUPE3(value)))
#define LLWU_BWR_PE1_WUPE3(base, value) (LLWU_WR_PE1_WUPE3(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE2 - LLWU Pin Enable 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE2 - LLWU Pin Enable 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE2 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P7-LLWU_P4. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE2 register
 */
/*@{*/
#define LLWU_RD_PE2(base)        (LLWU_PE2_REG(base))
#define LLWU_WR_PE2(base, value) (LLWU_PE2_REG(base) = (value))
#define LLWU_RMW_PE2(base, mask, value) (LLWU_WR_PE2(base, (LLWU_RD_PE2(base) & ~(mask)) | (value)))
#define LLWU_SET_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) |  (value)))
#define LLWU_CLR_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) & ~(value)))
#define LLWU_TOG_PE2(base, value) (LLWU_WR_PE2(base, LLWU_RD_PE2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE2 bitfields
 */

/*!
 * @name Register LLWU_PE2, field WUPE4[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE4 field. */
#define LLWU_RD_PE2_WUPE4(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE4_MASK) >> LLWU_PE2_WUPE4_SHIFT)
#define LLWU_BRD_PE2_WUPE4(base) (LLWU_RD_PE2_WUPE4(base))

/*! @brief Set the WUPE4 field to a new value. */
#define LLWU_WR_PE2_WUPE4(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE4_MASK, LLWU_PE2_WUPE4(value)))
#define LLWU_BWR_PE2_WUPE4(base, value) (LLWU_WR_PE2_WUPE4(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE5[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE5 field. */
#define LLWU_RD_PE2_WUPE5(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE5_MASK) >> LLWU_PE2_WUPE5_SHIFT)
#define LLWU_BRD_PE2_WUPE5(base) (LLWU_RD_PE2_WUPE5(base))

/*! @brief Set the WUPE5 field to a new value. */
#define LLWU_WR_PE2_WUPE5(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE5_MASK, LLWU_PE2_WUPE5(value)))
#define LLWU_BWR_PE2_WUPE5(base, value) (LLWU_WR_PE2_WUPE5(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE6[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE6 field. */
#define LLWU_RD_PE2_WUPE6(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE6_MASK) >> LLWU_PE2_WUPE6_SHIFT)
#define LLWU_BRD_PE2_WUPE6(base) (LLWU_RD_PE2_WUPE6(base))

/*! @brief Set the WUPE6 field to a new value. */
#define LLWU_WR_PE2_WUPE6(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE6_MASK, LLWU_PE2_WUPE6(value)))
#define LLWU_BWR_PE2_WUPE6(base, value) (LLWU_WR_PE2_WUPE6(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE2, field WUPE7[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE2_WUPE7 field. */
#define LLWU_RD_PE2_WUPE7(base) ((LLWU_PE2_REG(base) & LLWU_PE2_WUPE7_MASK) >> LLWU_PE2_WUPE7_SHIFT)
#define LLWU_BRD_PE2_WUPE7(base) (LLWU_RD_PE2_WUPE7(base))

/*! @brief Set the WUPE7 field to a new value. */
#define LLWU_WR_PE2_WUPE7(base, value) (LLWU_RMW_PE2(base, LLWU_PE2_WUPE7_MASK, LLWU_PE2_WUPE7(value)))
#define LLWU_BWR_PE2_WUPE7(base, value) (LLWU_WR_PE2_WUPE7(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE3 - LLWU Pin Enable 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE3 - LLWU Pin Enable 3 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE3 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P11-LLWU_P8. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module
 * (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE3 register
 */
/*@{*/
#define LLWU_RD_PE3(base)        (LLWU_PE3_REG(base))
#define LLWU_WR_PE3(base, value) (LLWU_PE3_REG(base) = (value))
#define LLWU_RMW_PE3(base, mask, value) (LLWU_WR_PE3(base, (LLWU_RD_PE3(base) & ~(mask)) | (value)))
#define LLWU_SET_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) |  (value)))
#define LLWU_CLR_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) & ~(value)))
#define LLWU_TOG_PE3(base, value) (LLWU_WR_PE3(base, LLWU_RD_PE3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE3 bitfields
 */

/*!
 * @name Register LLWU_PE3, field WUPE8[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE8 field. */
#define LLWU_RD_PE3_WUPE8(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE8_MASK) >> LLWU_PE3_WUPE8_SHIFT)
#define LLWU_BRD_PE3_WUPE8(base) (LLWU_RD_PE3_WUPE8(base))

/*! @brief Set the WUPE8 field to a new value. */
#define LLWU_WR_PE3_WUPE8(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE8_MASK, LLWU_PE3_WUPE8(value)))
#define LLWU_BWR_PE3_WUPE8(base, value) (LLWU_WR_PE3_WUPE8(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE9[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE9 field. */
#define LLWU_RD_PE3_WUPE9(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE9_MASK) >> LLWU_PE3_WUPE9_SHIFT)
#define LLWU_BRD_PE3_WUPE9(base) (LLWU_RD_PE3_WUPE9(base))

/*! @brief Set the WUPE9 field to a new value. */
#define LLWU_WR_PE3_WUPE9(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE9_MASK, LLWU_PE3_WUPE9(value)))
#define LLWU_BWR_PE3_WUPE9(base, value) (LLWU_WR_PE3_WUPE9(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE10[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE10 field. */
#define LLWU_RD_PE3_WUPE10(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE10_MASK) >> LLWU_PE3_WUPE10_SHIFT)
#define LLWU_BRD_PE3_WUPE10(base) (LLWU_RD_PE3_WUPE10(base))

/*! @brief Set the WUPE10 field to a new value. */
#define LLWU_WR_PE3_WUPE10(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE10_MASK, LLWU_PE3_WUPE10(value)))
#define LLWU_BWR_PE3_WUPE10(base, value) (LLWU_WR_PE3_WUPE10(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE3, field WUPE11[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE3_WUPE11 field. */
#define LLWU_RD_PE3_WUPE11(base) ((LLWU_PE3_REG(base) & LLWU_PE3_WUPE11_MASK) >> LLWU_PE3_WUPE11_SHIFT)
#define LLWU_BRD_PE3_WUPE11(base) (LLWU_RD_PE3_WUPE11(base))

/*! @brief Set the WUPE11 field to a new value. */
#define LLWU_WR_PE3_WUPE11(base, value) (LLWU_RMW_PE3(base, LLWU_PE3_WUPE11_MASK, LLWU_PE3_WUPE11(value)))
#define LLWU_BWR_PE3_WUPE11(base, value) (LLWU_WR_PE3_WUPE11(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE4 - LLWU Pin Enable 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE4 - LLWU Pin Enable 4 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE4 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P15-LLWU_P12. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE4 register
 */
/*@{*/
#define LLWU_RD_PE4(base)        (LLWU_PE4_REG(base))
#define LLWU_WR_PE4(base, value) (LLWU_PE4_REG(base) = (value))
#define LLWU_RMW_PE4(base, mask, value) (LLWU_WR_PE4(base, (LLWU_RD_PE4(base) & ~(mask)) | (value)))
#define LLWU_SET_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) |  (value)))
#define LLWU_CLR_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) & ~(value)))
#define LLWU_TOG_PE4(base, value) (LLWU_WR_PE4(base, LLWU_RD_PE4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE4 bitfields
 */

/*!
 * @name Register LLWU_PE4, field WUPE12[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE12 field. */
#define LLWU_RD_PE4_WUPE12(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE12_MASK) >> LLWU_PE4_WUPE12_SHIFT)
#define LLWU_BRD_PE4_WUPE12(base) (LLWU_RD_PE4_WUPE12(base))

/*! @brief Set the WUPE12 field to a new value. */
#define LLWU_WR_PE4_WUPE12(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE12_MASK, LLWU_PE4_WUPE12(value)))
#define LLWU_BWR_PE4_WUPE12(base, value) (LLWU_WR_PE4_WUPE12(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE13[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE13 field. */
#define LLWU_RD_PE4_WUPE13(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE13_MASK) >> LLWU_PE4_WUPE13_SHIFT)
#define LLWU_BRD_PE4_WUPE13(base) (LLWU_RD_PE4_WUPE13(base))

/*! @brief Set the WUPE13 field to a new value. */
#define LLWU_WR_PE4_WUPE13(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE13_MASK, LLWU_PE4_WUPE13(value)))
#define LLWU_BWR_PE4_WUPE13(base, value) (LLWU_WR_PE4_WUPE13(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE14[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE14 field. */
#define LLWU_RD_PE4_WUPE14(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE14_MASK) >> LLWU_PE4_WUPE14_SHIFT)
#define LLWU_BRD_PE4_WUPE14(base) (LLWU_RD_PE4_WUPE14(base))

/*! @brief Set the WUPE14 field to a new value. */
#define LLWU_WR_PE4_WUPE14(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE14_MASK, LLWU_PE4_WUPE14(value)))
#define LLWU_BWR_PE4_WUPE14(base, value) (LLWU_WR_PE4_WUPE14(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE4, field WUPE15[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE4_WUPE15 field. */
#define LLWU_RD_PE4_WUPE15(base) ((LLWU_PE4_REG(base) & LLWU_PE4_WUPE15_MASK) >> LLWU_PE4_WUPE15_SHIFT)
#define LLWU_BRD_PE4_WUPE15(base) (LLWU_RD_PE4_WUPE15(base))

/*! @brief Set the WUPE15 field to a new value. */
#define LLWU_WR_PE4_WUPE15(base, value) (LLWU_RMW_PE4(base, LLWU_PE4_WUPE15_MASK, LLWU_PE4_WUPE15(value)))
#define LLWU_BWR_PE4_WUPE15(base, value) (LLWU_WR_PE4_WUPE15(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE5 - LLWU Pin Enable 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE5 - LLWU Pin Enable 5 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE5 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P19-LLWU_P16. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE5 register
 */
/*@{*/
#define LLWU_RD_PE5(base)        (LLWU_PE5_REG(base))
#define LLWU_WR_PE5(base, value) (LLWU_PE5_REG(base) = (value))
#define LLWU_RMW_PE5(base, mask, value) (LLWU_WR_PE5(base, (LLWU_RD_PE5(base) & ~(mask)) | (value)))
#define LLWU_SET_PE5(base, value) (LLWU_WR_PE5(base, LLWU_RD_PE5(base) |  (value)))
#define LLWU_CLR_PE5(base, value) (LLWU_WR_PE5(base, LLWU_RD_PE5(base) & ~(value)))
#define LLWU_TOG_PE5(base, value) (LLWU_WR_PE5(base, LLWU_RD_PE5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE5 bitfields
 */

/*!
 * @name Register LLWU_PE5, field WUPE16[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE16 field. */
#define LLWU_RD_PE5_WUPE16(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE16_MASK) >> LLWU_PE5_WUPE16_SHIFT)
#define LLWU_BRD_PE5_WUPE16(base) (LLWU_RD_PE5_WUPE16(base))

/*! @brief Set the WUPE16 field to a new value. */
#define LLWU_WR_PE5_WUPE16(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE16_MASK, LLWU_PE5_WUPE16(value)))
#define LLWU_BWR_PE5_WUPE16(base, value) (LLWU_WR_PE5_WUPE16(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE17[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE17 field. */
#define LLWU_RD_PE5_WUPE17(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE17_MASK) >> LLWU_PE5_WUPE17_SHIFT)
#define LLWU_BRD_PE5_WUPE17(base) (LLWU_RD_PE5_WUPE17(base))

/*! @brief Set the WUPE17 field to a new value. */
#define LLWU_WR_PE5_WUPE17(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE17_MASK, LLWU_PE5_WUPE17(value)))
#define LLWU_BWR_PE5_WUPE17(base, value) (LLWU_WR_PE5_WUPE17(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE18[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE18 field. */
#define LLWU_RD_PE5_WUPE18(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE18_MASK) >> LLWU_PE5_WUPE18_SHIFT)
#define LLWU_BRD_PE5_WUPE18(base) (LLWU_RD_PE5_WUPE18(base))

/*! @brief Set the WUPE18 field to a new value. */
#define LLWU_WR_PE5_WUPE18(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE18_MASK, LLWU_PE5_WUPE18(value)))
#define LLWU_BWR_PE5_WUPE18(base, value) (LLWU_WR_PE5_WUPE18(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE5, field WUPE19[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE5_WUPE19 field. */
#define LLWU_RD_PE5_WUPE19(base) ((LLWU_PE5_REG(base) & LLWU_PE5_WUPE19_MASK) >> LLWU_PE5_WUPE19_SHIFT)
#define LLWU_BRD_PE5_WUPE19(base) (LLWU_RD_PE5_WUPE19(base))

/*! @brief Set the WUPE19 field to a new value. */
#define LLWU_WR_PE5_WUPE19(base, value) (LLWU_RMW_PE5(base, LLWU_PE5_WUPE19_MASK, LLWU_PE5_WUPE19(value)))
#define LLWU_BWR_PE5_WUPE19(base, value) (LLWU_WR_PE5_WUPE19(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE6 - LLWU Pin Enable 6 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE6 - LLWU Pin Enable 6 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE6 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P23-LLWU_P20. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE6 register
 */
/*@{*/
#define LLWU_RD_PE6(base)        (LLWU_PE6_REG(base))
#define LLWU_WR_PE6(base, value) (LLWU_PE6_REG(base) = (value))
#define LLWU_RMW_PE6(base, mask, value) (LLWU_WR_PE6(base, (LLWU_RD_PE6(base) & ~(mask)) | (value)))
#define LLWU_SET_PE6(base, value) (LLWU_WR_PE6(base, LLWU_RD_PE6(base) |  (value)))
#define LLWU_CLR_PE6(base, value) (LLWU_WR_PE6(base, LLWU_RD_PE6(base) & ~(value)))
#define LLWU_TOG_PE6(base, value) (LLWU_WR_PE6(base, LLWU_RD_PE6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE6 bitfields
 */

/*!
 * @name Register LLWU_PE6, field WUPE20[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE20 field. */
#define LLWU_RD_PE6_WUPE20(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE20_MASK) >> LLWU_PE6_WUPE20_SHIFT)
#define LLWU_BRD_PE6_WUPE20(base) (LLWU_RD_PE6_WUPE20(base))

/*! @brief Set the WUPE20 field to a new value. */
#define LLWU_WR_PE6_WUPE20(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE20_MASK, LLWU_PE6_WUPE20(value)))
#define LLWU_BWR_PE6_WUPE20(base, value) (LLWU_WR_PE6_WUPE20(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE21[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE21 field. */
#define LLWU_RD_PE6_WUPE21(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE21_MASK) >> LLWU_PE6_WUPE21_SHIFT)
#define LLWU_BRD_PE6_WUPE21(base) (LLWU_RD_PE6_WUPE21(base))

/*! @brief Set the WUPE21 field to a new value. */
#define LLWU_WR_PE6_WUPE21(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE21_MASK, LLWU_PE6_WUPE21(value)))
#define LLWU_BWR_PE6_WUPE21(base, value) (LLWU_WR_PE6_WUPE21(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE22[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE22 field. */
#define LLWU_RD_PE6_WUPE22(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE22_MASK) >> LLWU_PE6_WUPE22_SHIFT)
#define LLWU_BRD_PE6_WUPE22(base) (LLWU_RD_PE6_WUPE22(base))

/*! @brief Set the WUPE22 field to a new value. */
#define LLWU_WR_PE6_WUPE22(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE22_MASK, LLWU_PE6_WUPE22(value)))
#define LLWU_BWR_PE6_WUPE22(base, value) (LLWU_WR_PE6_WUPE22(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE6, field WUPE23[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE6_WUPE23 field. */
#define LLWU_RD_PE6_WUPE23(base) ((LLWU_PE6_REG(base) & LLWU_PE6_WUPE23_MASK) >> LLWU_PE6_WUPE23_SHIFT)
#define LLWU_BRD_PE6_WUPE23(base) (LLWU_RD_PE6_WUPE23(base))

/*! @brief Set the WUPE23 field to a new value. */
#define LLWU_WR_PE6_WUPE23(base, value) (LLWU_RMW_PE6(base, LLWU_PE6_WUPE23_MASK, LLWU_PE6_WUPE23(value)))
#define LLWU_BWR_PE6_WUPE23(base, value) (LLWU_WR_PE6_WUPE23(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE7 - LLWU Pin Enable 7 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE7 - LLWU Pin Enable 7 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE7 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P27-LLWU_P24. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE7 register
 */
/*@{*/
#define LLWU_RD_PE7(base)        (LLWU_PE7_REG(base))
#define LLWU_WR_PE7(base, value) (LLWU_PE7_REG(base) = (value))
#define LLWU_RMW_PE7(base, mask, value) (LLWU_WR_PE7(base, (LLWU_RD_PE7(base) & ~(mask)) | (value)))
#define LLWU_SET_PE7(base, value) (LLWU_WR_PE7(base, LLWU_RD_PE7(base) |  (value)))
#define LLWU_CLR_PE7(base, value) (LLWU_WR_PE7(base, LLWU_RD_PE7(base) & ~(value)))
#define LLWU_TOG_PE7(base, value) (LLWU_WR_PE7(base, LLWU_RD_PE7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE7 bitfields
 */

/*!
 * @name Register LLWU_PE7, field WUPE24[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE24 field. */
#define LLWU_RD_PE7_WUPE24(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE24_MASK) >> LLWU_PE7_WUPE24_SHIFT)
#define LLWU_BRD_PE7_WUPE24(base) (LLWU_RD_PE7_WUPE24(base))

/*! @brief Set the WUPE24 field to a new value. */
#define LLWU_WR_PE7_WUPE24(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE24_MASK, LLWU_PE7_WUPE24(value)))
#define LLWU_BWR_PE7_WUPE24(base, value) (LLWU_WR_PE7_WUPE24(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE25[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE25 field. */
#define LLWU_RD_PE7_WUPE25(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE25_MASK) >> LLWU_PE7_WUPE25_SHIFT)
#define LLWU_BRD_PE7_WUPE25(base) (LLWU_RD_PE7_WUPE25(base))

/*! @brief Set the WUPE25 field to a new value. */
#define LLWU_WR_PE7_WUPE25(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE25_MASK, LLWU_PE7_WUPE25(value)))
#define LLWU_BWR_PE7_WUPE25(base, value) (LLWU_WR_PE7_WUPE25(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE26[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE26 field. */
#define LLWU_RD_PE7_WUPE26(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE26_MASK) >> LLWU_PE7_WUPE26_SHIFT)
#define LLWU_BRD_PE7_WUPE26(base) (LLWU_RD_PE7_WUPE26(base))

/*! @brief Set the WUPE26 field to a new value. */
#define LLWU_WR_PE7_WUPE26(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE26_MASK, LLWU_PE7_WUPE26(value)))
#define LLWU_BWR_PE7_WUPE26(base, value) (LLWU_WR_PE7_WUPE26(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE7, field WUPE27[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE7_WUPE27 field. */
#define LLWU_RD_PE7_WUPE27(base) ((LLWU_PE7_REG(base) & LLWU_PE7_WUPE27_MASK) >> LLWU_PE7_WUPE27_SHIFT)
#define LLWU_BRD_PE7_WUPE27(base) (LLWU_RD_PE7_WUPE27(base))

/*! @brief Set the WUPE27 field to a new value. */
#define LLWU_WR_PE7_WUPE27(base, value) (LLWU_RMW_PE7(base, LLWU_PE7_WUPE27_MASK, LLWU_PE7_WUPE27(value)))
#define LLWU_BWR_PE7_WUPE27(base, value) (LLWU_WR_PE7_WUPE27(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_PE8 - LLWU Pin Enable 8 register
 ******************************************************************************/

/*!
 * @brief LLWU_PE8 - LLWU Pin Enable 8 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_PE8 contains the field to enable and select the edge detect type for the
 * external wakeup input pins LLWU_P31-LLWU_P28. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PE8 register
 */
/*@{*/
#define LLWU_RD_PE8(base)        (LLWU_PE8_REG(base))
#define LLWU_WR_PE8(base, value) (LLWU_PE8_REG(base) = (value))
#define LLWU_RMW_PE8(base, mask, value) (LLWU_WR_PE8(base, (LLWU_RD_PE8(base) & ~(mask)) | (value)))
#define LLWU_SET_PE8(base, value) (LLWU_WR_PE8(base, LLWU_RD_PE8(base) |  (value)))
#define LLWU_CLR_PE8(base, value) (LLWU_WR_PE8(base, LLWU_RD_PE8(base) & ~(value)))
#define LLWU_TOG_PE8(base, value) (LLWU_WR_PE8(base, LLWU_RD_PE8(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PE8 bitfields
 */

/*!
 * @name Register LLWU_PE8, field WUPE28[1:0] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE28 field. */
#define LLWU_RD_PE8_WUPE28(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE28_MASK) >> LLWU_PE8_WUPE28_SHIFT)
#define LLWU_BRD_PE8_WUPE28(base) (LLWU_RD_PE8_WUPE28(base))

/*! @brief Set the WUPE28 field to a new value. */
#define LLWU_WR_PE8_WUPE28(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE28_MASK, LLWU_PE8_WUPE28(value)))
#define LLWU_BWR_PE8_WUPE28(base, value) (LLWU_WR_PE8_WUPE28(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE29[3:2] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE29 field. */
#define LLWU_RD_PE8_WUPE29(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE29_MASK) >> LLWU_PE8_WUPE29_SHIFT)
#define LLWU_BRD_PE8_WUPE29(base) (LLWU_RD_PE8_WUPE29(base))

/*! @brief Set the WUPE29 field to a new value. */
#define LLWU_WR_PE8_WUPE29(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE29_MASK, LLWU_PE8_WUPE29(value)))
#define LLWU_BWR_PE8_WUPE29(base, value) (LLWU_WR_PE8_WUPE29(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE30[5:4] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE30 field. */
#define LLWU_RD_PE8_WUPE30(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE30_MASK) >> LLWU_PE8_WUPE30_SHIFT)
#define LLWU_BRD_PE8_WUPE30(base) (LLWU_RD_PE8_WUPE30(base))

/*! @brief Set the WUPE30 field to a new value. */
#define LLWU_WR_PE8_WUPE30(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE30_MASK, LLWU_PE8_WUPE30(value)))
#define LLWU_BWR_PE8_WUPE30(base, value) (LLWU_WR_PE8_WUPE30(base, value))
/*@}*/

/*!
 * @name Register LLWU_PE8, field WUPE31[7:6] (RW)
 *
 * Enables and configures the edge detection for the wakeup pin.
 *
 * Values:
 * - 00 - External input pin disabled as wakeup input
 * - 01 - External input pin enabled with rising edge detection
 * - 10 - External input pin enabled with falling edge detection
 * - 11 - External input pin enabled with any change detection
 */
/*@{*/
/*! @brief Read current value of the LLWU_PE8_WUPE31 field. */
#define LLWU_RD_PE8_WUPE31(base) ((LLWU_PE8_REG(base) & LLWU_PE8_WUPE31_MASK) >> LLWU_PE8_WUPE31_SHIFT)
#define LLWU_BRD_PE8_WUPE31(base) (LLWU_RD_PE8_WUPE31(base))

/*! @brief Set the WUPE31 field to a new value. */
#define LLWU_WR_PE8_WUPE31(base, value) (LLWU_RMW_PE8(base, LLWU_PE8_WUPE31_MASK, LLWU_PE8_WUPE31(value)))
#define LLWU_BWR_PE8_WUPE31(base, value) (LLWU_WR_PE8_WUPE31(base, value))
/*@}*/

/*******************************************************************************
 * LLWU_ME - LLWU Module Enable register
 ******************************************************************************/

/*!
 * @brief LLWU_ME - LLWU Module Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_ME contains the bits to enable the internal module flag as a wakeup
 * input source for inputs MWUF7-MWUF0. This register is reset on Chip Reset not VLLS
 * and by reset types that trigger Chip Reset not VLLS. It is unaffected by
 * reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control Module (RCM). The
 * RCM implements many of the reset functions for the chip. See the chip's reset
 * chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_ME register
 */
/*@{*/
#define LLWU_RD_ME(base)         (LLWU_ME_REG(base))
#define LLWU_WR_ME(base, value)  (LLWU_ME_REG(base) = (value))
#define LLWU_RMW_ME(base, mask, value) (LLWU_WR_ME(base, (LLWU_RD_ME(base) & ~(mask)) | (value)))
#define LLWU_SET_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) |  (value)))
#define LLWU_CLR_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) & ~(value)))
#define LLWU_TOG_ME(base, value) (LLWU_WR_ME(base, LLWU_RD_ME(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_ME bitfields
 */

/*!
 * @name Register LLWU_ME, field WUME0[0] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME0 field. */
#define LLWU_RD_ME_WUME0(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME0_MASK) >> LLWU_ME_WUME0_SHIFT)
#define LLWU_BRD_ME_WUME0(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT))

/*! @brief Set the WUME0 field to a new value. */
#define LLWU_WR_ME_WUME0(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME0_MASK, LLWU_ME_WUME0(value)))
#define LLWU_BWR_ME_WUME0(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME1[1] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME1 field. */
#define LLWU_RD_ME_WUME1(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME1_MASK) >> LLWU_ME_WUME1_SHIFT)
#define LLWU_BRD_ME_WUME1(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT))

/*! @brief Set the WUME1 field to a new value. */
#define LLWU_WR_ME_WUME1(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME1_MASK, LLWU_ME_WUME1(value)))
#define LLWU_BWR_ME_WUME1(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME2[2] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME2 field. */
#define LLWU_RD_ME_WUME2(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME2_MASK) >> LLWU_ME_WUME2_SHIFT)
#define LLWU_BRD_ME_WUME2(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT))

/*! @brief Set the WUME2 field to a new value. */
#define LLWU_WR_ME_WUME2(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME2_MASK, LLWU_ME_WUME2(value)))
#define LLWU_BWR_ME_WUME2(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME3[3] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME3 field. */
#define LLWU_RD_ME_WUME3(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME3_MASK) >> LLWU_ME_WUME3_SHIFT)
#define LLWU_BRD_ME_WUME3(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT))

/*! @brief Set the WUME3 field to a new value. */
#define LLWU_WR_ME_WUME3(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME3_MASK, LLWU_ME_WUME3(value)))
#define LLWU_BWR_ME_WUME3(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME4[4] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME4 field. */
#define LLWU_RD_ME_WUME4(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME4_MASK) >> LLWU_ME_WUME4_SHIFT)
#define LLWU_BRD_ME_WUME4(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT))

/*! @brief Set the WUME4 field to a new value. */
#define LLWU_WR_ME_WUME4(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME4_MASK, LLWU_ME_WUME4(value)))
#define LLWU_BWR_ME_WUME4(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME5[5] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME5 field. */
#define LLWU_RD_ME_WUME5(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME5_MASK) >> LLWU_ME_WUME5_SHIFT)
#define LLWU_BRD_ME_WUME5(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT))

/*! @brief Set the WUME5 field to a new value. */
#define LLWU_WR_ME_WUME5(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME5_MASK, LLWU_ME_WUME5(value)))
#define LLWU_BWR_ME_WUME5(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME6[6] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME6 field. */
#define LLWU_RD_ME_WUME6(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME6_MASK) >> LLWU_ME_WUME6_SHIFT)
#define LLWU_BRD_ME_WUME6(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT))

/*! @brief Set the WUME6 field to a new value. */
#define LLWU_WR_ME_WUME6(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME6_MASK, LLWU_ME_WUME6(value)))
#define LLWU_BWR_ME_WUME6(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_ME, field WUME7[7] (RW)
 *
 * Enables an internal module as a wakeup source input.
 *
 * Values:
 * - 0 - Internal module flag not used as wakeup source
 * - 1 - Internal module flag used as wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_ME_WUME7 field. */
#define LLWU_RD_ME_WUME7(base) ((LLWU_ME_REG(base) & LLWU_ME_WUME7_MASK) >> LLWU_ME_WUME7_SHIFT)
#define LLWU_BRD_ME_WUME7(base) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT))

/*! @brief Set the WUME7 field to a new value. */
#define LLWU_WR_ME_WUME7(base, value) (LLWU_RMW_ME(base, LLWU_ME_WUME7_MASK, LLWU_ME_WUME7(value)))
#define LLWU_BWR_ME_WUME7(base, value) (BITBAND_ACCESS8(&LLWU_ME_REG(base), LLWU_ME_WUME7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_PF1 - LLWU Pin Flag 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF1 - LLWU Pin Flag 1 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF1 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF1 register
 */
/*@{*/
#define LLWU_RD_PF1(base)        (LLWU_PF1_REG(base))
#define LLWU_WR_PF1(base, value) (LLWU_PF1_REG(base) = (value))
#define LLWU_RMW_PF1(base, mask, value) (LLWU_WR_PF1(base, (LLWU_RD_PF1(base) & ~(mask)) | (value)))
#define LLWU_SET_PF1(base, value) (LLWU_WR_PF1(base, LLWU_RD_PF1(base) |  (value)))
#define LLWU_CLR_PF1(base, value) (LLWU_WR_PF1(base, LLWU_RD_PF1(base) & ~(value)))
#define LLWU_TOG_PF1(base, value) (LLWU_WR_PF1(base, LLWU_RD_PF1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF1 bitfields
 */

/*!
 * @name Register LLWU_PF1, field WUF0[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF0.
 *
 * Values:
 * - 0 - LLWU_P0 input was not a wakeup source
 * - 1 - LLWU_P0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF0 field. */
#define LLWU_RD_PF1_WUF0(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF0_MASK) >> LLWU_PF1_WUF0_SHIFT)
#define LLWU_BRD_PF1_WUF0(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF0_SHIFT))

/*! @brief Set the WUF0 field to a new value. */
#define LLWU_WR_PF1_WUF0(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF0(value)))
#define LLWU_BWR_PF1_WUF0(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF1[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF1.
 *
 * Values:
 * - 0 - LLWU_P1 input was not a wakeup source
 * - 1 - LLWU_P1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF1 field. */
#define LLWU_RD_PF1_WUF1(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF1_MASK) >> LLWU_PF1_WUF1_SHIFT)
#define LLWU_BRD_PF1_WUF1(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF1_SHIFT))

/*! @brief Set the WUF1 field to a new value. */
#define LLWU_WR_PF1_WUF1(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF1(value)))
#define LLWU_BWR_PF1_WUF1(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF2[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF2.
 *
 * Values:
 * - 0 - LLWU_P2 input was not a wakeup source
 * - 1 - LLWU_P2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF2 field. */
#define LLWU_RD_PF1_WUF2(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF2_MASK) >> LLWU_PF1_WUF2_SHIFT)
#define LLWU_BRD_PF1_WUF2(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF2_SHIFT))

/*! @brief Set the WUF2 field to a new value. */
#define LLWU_WR_PF1_WUF2(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF2(value)))
#define LLWU_BWR_PF1_WUF2(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF3[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF3.
 *
 * Values:
 * - 0 - LLWU_P3 input was not a wakeup source
 * - 1 - LLWU_P3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF3 field. */
#define LLWU_RD_PF1_WUF3(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF3_MASK) >> LLWU_PF1_WUF3_SHIFT)
#define LLWU_BRD_PF1_WUF3(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF3_SHIFT))

/*! @brief Set the WUF3 field to a new value. */
#define LLWU_WR_PF1_WUF3(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF3(value)))
#define LLWU_BWR_PF1_WUF3(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF4[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF4.
 *
 * Values:
 * - 0 - LLWU_P4 input was not a wakeup source
 * - 1 - LLWU_P4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF4 field. */
#define LLWU_RD_PF1_WUF4(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF4_MASK) >> LLWU_PF1_WUF4_SHIFT)
#define LLWU_BRD_PF1_WUF4(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF4_SHIFT))

/*! @brief Set the WUF4 field to a new value. */
#define LLWU_WR_PF1_WUF4(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF4(value)))
#define LLWU_BWR_PF1_WUF4(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF5[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF5.
 *
 * Values:
 * - 0 - LLWU_P5 input was not a wakeup source
 * - 1 - LLWU_P5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF5 field. */
#define LLWU_RD_PF1_WUF5(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF5_MASK) >> LLWU_PF1_WUF5_SHIFT)
#define LLWU_BRD_PF1_WUF5(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF5_SHIFT))

/*! @brief Set the WUF5 field to a new value. */
#define LLWU_WR_PF1_WUF5(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF5(value)))
#define LLWU_BWR_PF1_WUF5(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF6[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF6.
 *
 * Values:
 * - 0 - LLWU_P6 input was not a wakeup source
 * - 1 - LLWU_P6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF6 field. */
#define LLWU_RD_PF1_WUF6(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF6_MASK) >> LLWU_PF1_WUF6_SHIFT)
#define LLWU_BRD_PF1_WUF6(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF6_SHIFT))

/*! @brief Set the WUF6 field to a new value. */
#define LLWU_WR_PF1_WUF6(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF6_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF7_MASK), LLWU_PF1_WUF6(value)))
#define LLWU_BWR_PF1_WUF6(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF1, field WUF7[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF7.
 *
 * Values:
 * - 0 - LLWU_P7 input was not a wakeup source
 * - 1 - LLWU_P7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF1_WUF7 field. */
#define LLWU_RD_PF1_WUF7(base) ((LLWU_PF1_REG(base) & LLWU_PF1_WUF7_MASK) >> LLWU_PF1_WUF7_SHIFT)
#define LLWU_BRD_PF1_WUF7(base) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF7_SHIFT))

/*! @brief Set the WUF7 field to a new value. */
#define LLWU_WR_PF1_WUF7(base, value) (LLWU_RMW_PF1(base, (LLWU_PF1_WUF7_MASK | LLWU_PF1_WUF0_MASK | LLWU_PF1_WUF1_MASK | LLWU_PF1_WUF2_MASK | LLWU_PF1_WUF3_MASK | LLWU_PF1_WUF4_MASK | LLWU_PF1_WUF5_MASK | LLWU_PF1_WUF6_MASK), LLWU_PF1_WUF7(value)))
#define LLWU_BWR_PF1_WUF7(base, value) (BITBAND_ACCESS8(&LLWU_PF1_REG(base), LLWU_PF1_WUF7_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_PF2 - LLWU Pin Flag 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF2 - LLWU Pin Flag 2 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF2 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF2 register
 */
/*@{*/
#define LLWU_RD_PF2(base)        (LLWU_PF2_REG(base))
#define LLWU_WR_PF2(base, value) (LLWU_PF2_REG(base) = (value))
#define LLWU_RMW_PF2(base, mask, value) (LLWU_WR_PF2(base, (LLWU_RD_PF2(base) & ~(mask)) | (value)))
#define LLWU_SET_PF2(base, value) (LLWU_WR_PF2(base, LLWU_RD_PF2(base) |  (value)))
#define LLWU_CLR_PF2(base, value) (LLWU_WR_PF2(base, LLWU_RD_PF2(base) & ~(value)))
#define LLWU_TOG_PF2(base, value) (LLWU_WR_PF2(base, LLWU_RD_PF2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF2 bitfields
 */

/*!
 * @name Register LLWU_PF2, field WUF8[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF8.
 *
 * Values:
 * - 0 - LLWU_P8 input was not a wakeup source
 * - 1 - LLWU_P8 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF8 field. */
#define LLWU_RD_PF2_WUF8(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF8_MASK) >> LLWU_PF2_WUF8_SHIFT)
#define LLWU_BRD_PF2_WUF8(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF8_SHIFT))

/*! @brief Set the WUF8 field to a new value. */
#define LLWU_WR_PF2_WUF8(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF8(value)))
#define LLWU_BWR_PF2_WUF8(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF9[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF9.
 *
 * Values:
 * - 0 - LLWU_P9 input was not a wakeup source
 * - 1 - LLWU_P9 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF9 field. */
#define LLWU_RD_PF2_WUF9(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF9_MASK) >> LLWU_PF2_WUF9_SHIFT)
#define LLWU_BRD_PF2_WUF9(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF9_SHIFT))

/*! @brief Set the WUF9 field to a new value. */
#define LLWU_WR_PF2_WUF9(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF9(value)))
#define LLWU_BWR_PF2_WUF9(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF10[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF10.
 *
 * Values:
 * - 0 - LLWU_P10 input was not a wakeup source
 * - 1 - LLWU_P10 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF10 field. */
#define LLWU_RD_PF2_WUF10(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF10_MASK) >> LLWU_PF2_WUF10_SHIFT)
#define LLWU_BRD_PF2_WUF10(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF10_SHIFT))

/*! @brief Set the WUF10 field to a new value. */
#define LLWU_WR_PF2_WUF10(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF10(value)))
#define LLWU_BWR_PF2_WUF10(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF11[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF11.
 *
 * Values:
 * - 0 - LLWU_P11 input was not a wakeup source
 * - 1 - LLWU_P11 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF11 field. */
#define LLWU_RD_PF2_WUF11(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF11_MASK) >> LLWU_PF2_WUF11_SHIFT)
#define LLWU_BRD_PF2_WUF11(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF11_SHIFT))

/*! @brief Set the WUF11 field to a new value. */
#define LLWU_WR_PF2_WUF11(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF11(value)))
#define LLWU_BWR_PF2_WUF11(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF11_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF12[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF12.
 *
 * Values:
 * - 0 - LLWU_P12 input was not a wakeup source
 * - 1 - LLWU_P12 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF12 field. */
#define LLWU_RD_PF2_WUF12(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF12_MASK) >> LLWU_PF2_WUF12_SHIFT)
#define LLWU_BRD_PF2_WUF12(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF12_SHIFT))

/*! @brief Set the WUF12 field to a new value. */
#define LLWU_WR_PF2_WUF12(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF12(value)))
#define LLWU_BWR_PF2_WUF12(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF12_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF13[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF13.
 *
 * Values:
 * - 0 - LLWU_P13 input was not a wakeup source
 * - 1 - LLWU_P13 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF13 field. */
#define LLWU_RD_PF2_WUF13(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF13_MASK) >> LLWU_PF2_WUF13_SHIFT)
#define LLWU_BRD_PF2_WUF13(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF13_SHIFT))

/*! @brief Set the WUF13 field to a new value. */
#define LLWU_WR_PF2_WUF13(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF13(value)))
#define LLWU_BWR_PF2_WUF13(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF14[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF14.
 *
 * Values:
 * - 0 - LLWU_P14 input was not a wakeup source
 * - 1 - LLWU_P14 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF14 field. */
#define LLWU_RD_PF2_WUF14(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF14_MASK) >> LLWU_PF2_WUF14_SHIFT)
#define LLWU_BRD_PF2_WUF14(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF14_SHIFT))

/*! @brief Set the WUF14 field to a new value. */
#define LLWU_WR_PF2_WUF14(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF14_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF15_MASK), LLWU_PF2_WUF14(value)))
#define LLWU_BWR_PF2_WUF14(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF14_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF2, field WUF15[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF15.
 *
 * Values:
 * - 0 - LLWU_P15 input was not a wakeup source
 * - 1 - LLWU_P15 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF2_WUF15 field. */
#define LLWU_RD_PF2_WUF15(base) ((LLWU_PF2_REG(base) & LLWU_PF2_WUF15_MASK) >> LLWU_PF2_WUF15_SHIFT)
#define LLWU_BRD_PF2_WUF15(base) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF15_SHIFT))

/*! @brief Set the WUF15 field to a new value. */
#define LLWU_WR_PF2_WUF15(base, value) (LLWU_RMW_PF2(base, (LLWU_PF2_WUF15_MASK | LLWU_PF2_WUF8_MASK | LLWU_PF2_WUF9_MASK | LLWU_PF2_WUF10_MASK | LLWU_PF2_WUF11_MASK | LLWU_PF2_WUF12_MASK | LLWU_PF2_WUF13_MASK | LLWU_PF2_WUF14_MASK), LLWU_PF2_WUF15(value)))
#define LLWU_BWR_PF2_WUF15(base, value) (BITBAND_ACCESS8(&LLWU_PF2_REG(base), LLWU_PF2_WUF15_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_PF3 - LLWU Pin Flag 3 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF3 - LLWU Pin Flag 3 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF3 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF3 register
 */
/*@{*/
#define LLWU_RD_PF3(base)        (LLWU_PF3_REG(base))
#define LLWU_WR_PF3(base, value) (LLWU_PF3_REG(base) = (value))
#define LLWU_RMW_PF3(base, mask, value) (LLWU_WR_PF3(base, (LLWU_RD_PF3(base) & ~(mask)) | (value)))
#define LLWU_SET_PF3(base, value) (LLWU_WR_PF3(base, LLWU_RD_PF3(base) |  (value)))
#define LLWU_CLR_PF3(base, value) (LLWU_WR_PF3(base, LLWU_RD_PF3(base) & ~(value)))
#define LLWU_TOG_PF3(base, value) (LLWU_WR_PF3(base, LLWU_RD_PF3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF3 bitfields
 */

/*!
 * @name Register LLWU_PF3, field WUF16[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF16.
 *
 * Values:
 * - 0 - LLWU_P16 input was not a wakeup source
 * - 1 - LLWU_P16 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF16 field. */
#define LLWU_RD_PF3_WUF16(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF16_MASK) >> LLWU_PF3_WUF16_SHIFT)
#define LLWU_BRD_PF3_WUF16(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF16_SHIFT))

/*! @brief Set the WUF16 field to a new value. */
#define LLWU_WR_PF3_WUF16(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF16(value)))
#define LLWU_BWR_PF3_WUF16(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF16_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF17[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF17.
 *
 * Values:
 * - 0 - LLWU_P17 input was not a wakeup source
 * - 1 - LLWU_P17 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF17 field. */
#define LLWU_RD_PF3_WUF17(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF17_MASK) >> LLWU_PF3_WUF17_SHIFT)
#define LLWU_BRD_PF3_WUF17(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF17_SHIFT))

/*! @brief Set the WUF17 field to a new value. */
#define LLWU_WR_PF3_WUF17(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF17(value)))
#define LLWU_BWR_PF3_WUF17(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF17_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF18[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF18.
 *
 * Values:
 * - 0 - LLWU_P18 input was not a wakeup source
 * - 1 - LLWU_P18 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF18 field. */
#define LLWU_RD_PF3_WUF18(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF18_MASK) >> LLWU_PF3_WUF18_SHIFT)
#define LLWU_BRD_PF3_WUF18(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF18_SHIFT))

/*! @brief Set the WUF18 field to a new value. */
#define LLWU_WR_PF3_WUF18(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF18(value)))
#define LLWU_BWR_PF3_WUF18(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF18_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF19[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF19.
 *
 * Values:
 * - 0 - LLWU_P19 input was not a wakeup source
 * - 1 - LLWU_P19 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF19 field. */
#define LLWU_RD_PF3_WUF19(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF19_MASK) >> LLWU_PF3_WUF19_SHIFT)
#define LLWU_BRD_PF3_WUF19(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF19_SHIFT))

/*! @brief Set the WUF19 field to a new value. */
#define LLWU_WR_PF3_WUF19(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF19(value)))
#define LLWU_BWR_PF3_WUF19(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF19_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF20[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF20.
 *
 * Values:
 * - 0 - LLWU_P20 input was not a wakeup source
 * - 1 - LLWU_P20 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF20 field. */
#define LLWU_RD_PF3_WUF20(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF20_MASK) >> LLWU_PF3_WUF20_SHIFT)
#define LLWU_BRD_PF3_WUF20(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF20_SHIFT))

/*! @brief Set the WUF20 field to a new value. */
#define LLWU_WR_PF3_WUF20(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF20(value)))
#define LLWU_BWR_PF3_WUF20(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF20_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF21[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF21.
 *
 * Values:
 * - 0 - LLWU_P21 input was not a wakeup source
 * - 1 - LLWU_P21 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF21 field. */
#define LLWU_RD_PF3_WUF21(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF21_MASK) >> LLWU_PF3_WUF21_SHIFT)
#define LLWU_BRD_PF3_WUF21(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF21_SHIFT))

/*! @brief Set the WUF21 field to a new value. */
#define LLWU_WR_PF3_WUF21(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF21(value)))
#define LLWU_BWR_PF3_WUF21(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF21_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF22[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF22.
 *
 * Values:
 * - 0 - LLWU_P22 input was not a wakeup source
 * - 1 - LLWU_P22 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF22 field. */
#define LLWU_RD_PF3_WUF22(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF22_MASK) >> LLWU_PF3_WUF22_SHIFT)
#define LLWU_BRD_PF3_WUF22(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF22_SHIFT))

/*! @brief Set the WUF22 field to a new value. */
#define LLWU_WR_PF3_WUF22(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF22_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF23_MASK), LLWU_PF3_WUF22(value)))
#define LLWU_BWR_PF3_WUF22(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF22_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF3, field WUF23[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF23.
 *
 * Values:
 * - 0 - LLWU_P23 input was not a wakeup source
 * - 1 - LLWU_P23 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF3_WUF23 field. */
#define LLWU_RD_PF3_WUF23(base) ((LLWU_PF3_REG(base) & LLWU_PF3_WUF23_MASK) >> LLWU_PF3_WUF23_SHIFT)
#define LLWU_BRD_PF3_WUF23(base) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF23_SHIFT))

/*! @brief Set the WUF23 field to a new value. */
#define LLWU_WR_PF3_WUF23(base, value) (LLWU_RMW_PF3(base, (LLWU_PF3_WUF23_MASK | LLWU_PF3_WUF16_MASK | LLWU_PF3_WUF17_MASK | LLWU_PF3_WUF18_MASK | LLWU_PF3_WUF19_MASK | LLWU_PF3_WUF20_MASK | LLWU_PF3_WUF21_MASK | LLWU_PF3_WUF22_MASK), LLWU_PF3_WUF23(value)))
#define LLWU_BWR_PF3_WUF23(base, value) (BITBAND_ACCESS8(&LLWU_PF3_REG(base), LLWU_PF3_WUF23_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_PF4 - LLWU Pin Flag 4 register
 ******************************************************************************/

/*!
 * @brief LLWU_PF4 - LLWU Pin Flag 4 register (W1C)
 *
 * Reset value: 0x00U
 *
 * LLWU_PF4 contains the wakeup flags indicating which wakeup source caused the
 * MCU to exit LLS or VLLS mode. For LLS, this is the source causing the CPU
 * interrupt flow. For VLLS, this is the source causing the MCU reset flow. The
 * external wakeup flags are read-only and clearing a flag is accomplished by a write
 * of a 1 to the corresponding WUFx bit. The wakeup flag (WUFx), if set, will
 * remain set if the associated WUPEx bit is cleared. This register is reset on Chip
 * Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See the
 * chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_PF4 register
 */
/*@{*/
#define LLWU_RD_PF4(base)        (LLWU_PF4_REG(base))
#define LLWU_WR_PF4(base, value) (LLWU_PF4_REG(base) = (value))
#define LLWU_RMW_PF4(base, mask, value) (LLWU_WR_PF4(base, (LLWU_RD_PF4(base) & ~(mask)) | (value)))
#define LLWU_SET_PF4(base, value) (LLWU_WR_PF4(base, LLWU_RD_PF4(base) |  (value)))
#define LLWU_CLR_PF4(base, value) (LLWU_WR_PF4(base, LLWU_RD_PF4(base) & ~(value)))
#define LLWU_TOG_PF4(base, value) (LLWU_WR_PF4(base, LLWU_RD_PF4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_PF4 bitfields
 */

/*!
 * @name Register LLWU_PF4, field WUF24[0] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF24.
 *
 * Values:
 * - 0 - LLWU_P24 input was not a wakeup source
 * - 1 - LLWU_P24 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF24 field. */
#define LLWU_RD_PF4_WUF24(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF24_MASK) >> LLWU_PF4_WUF24_SHIFT)
#define LLWU_BRD_PF4_WUF24(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF24_SHIFT))

/*! @brief Set the WUF24 field to a new value. */
#define LLWU_WR_PF4_WUF24(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF24(value)))
#define LLWU_BWR_PF4_WUF24(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF24_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF25[1] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF25.
 *
 * Values:
 * - 0 - LLWU_P25 input was not a wakeup source
 * - 1 - LLWU_P25 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF25 field. */
#define LLWU_RD_PF4_WUF25(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF25_MASK) >> LLWU_PF4_WUF25_SHIFT)
#define LLWU_BRD_PF4_WUF25(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF25_SHIFT))

/*! @brief Set the WUF25 field to a new value. */
#define LLWU_WR_PF4_WUF25(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF25(value)))
#define LLWU_BWR_PF4_WUF25(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF25_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF26[2] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF26.
 *
 * Values:
 * - 0 - LLWU_P26 input was not a wakeup source
 * - 1 - LLWU_P26 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF26 field. */
#define LLWU_RD_PF4_WUF26(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF26_MASK) >> LLWU_PF4_WUF26_SHIFT)
#define LLWU_BRD_PF4_WUF26(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF26_SHIFT))

/*! @brief Set the WUF26 field to a new value. */
#define LLWU_WR_PF4_WUF26(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF26(value)))
#define LLWU_BWR_PF4_WUF26(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF26_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF27[3] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF27.
 *
 * Values:
 * - 0 - LLWU_P27 input was not a wakeup source
 * - 1 - LLWU_P27 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF27 field. */
#define LLWU_RD_PF4_WUF27(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF27_MASK) >> LLWU_PF4_WUF27_SHIFT)
#define LLWU_BRD_PF4_WUF27(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF27_SHIFT))

/*! @brief Set the WUF27 field to a new value. */
#define LLWU_WR_PF4_WUF27(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF27(value)))
#define LLWU_BWR_PF4_WUF27(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF27_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF28[4] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF28.
 *
 * Values:
 * - 0 - LLWU_P28 input was not a wakeup source
 * - 1 - LLWU_P28 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF28 field. */
#define LLWU_RD_PF4_WUF28(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF28_MASK) >> LLWU_PF4_WUF28_SHIFT)
#define LLWU_BRD_PF4_WUF28(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF28_SHIFT))

/*! @brief Set the WUF28 field to a new value. */
#define LLWU_WR_PF4_WUF28(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF28(value)))
#define LLWU_BWR_PF4_WUF28(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF28_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF29[5] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF29.
 *
 * Values:
 * - 0 - LLWU_P29 input was not a wakeup source
 * - 1 - LLWU_P29 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF29 field. */
#define LLWU_RD_PF4_WUF29(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF29_MASK) >> LLWU_PF4_WUF29_SHIFT)
#define LLWU_BRD_PF4_WUF29(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF29_SHIFT))

/*! @brief Set the WUF29 field to a new value. */
#define LLWU_WR_PF4_WUF29(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF29(value)))
#define LLWU_BWR_PF4_WUF29(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF29_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF30[6] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF30.
 *
 * Values:
 * - 0 - LLWU_P30 input was not a wakeup source
 * - 1 - LLWU_P30 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF30 field. */
#define LLWU_RD_PF4_WUF30(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF30_MASK) >> LLWU_PF4_WUF30_SHIFT)
#define LLWU_BRD_PF4_WUF30(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF30_SHIFT))

/*! @brief Set the WUF30 field to a new value. */
#define LLWU_WR_PF4_WUF30(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF30_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF31_MASK), LLWU_PF4_WUF30(value)))
#define LLWU_BWR_PF4_WUF30(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF30_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LLWU_PF4, field WUF31[7] (W1C)
 *
 * Indicates that an enabled external wakeup pin was a source of exiting a
 * low-leakage power mode. To clear the flag write a one to WUF31.
 *
 * Values:
 * - 0 - LLWU_P31 input was not a wakeup source
 * - 1 - LLWU_P31 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_PF4_WUF31 field. */
#define LLWU_RD_PF4_WUF31(base) ((LLWU_PF4_REG(base) & LLWU_PF4_WUF31_MASK) >> LLWU_PF4_WUF31_SHIFT)
#define LLWU_BRD_PF4_WUF31(base) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF31_SHIFT))

/*! @brief Set the WUF31 field to a new value. */
#define LLWU_WR_PF4_WUF31(base, value) (LLWU_RMW_PF4(base, (LLWU_PF4_WUF31_MASK | LLWU_PF4_WUF24_MASK | LLWU_PF4_WUF25_MASK | LLWU_PF4_WUF26_MASK | LLWU_PF4_WUF27_MASK | LLWU_PF4_WUF28_MASK | LLWU_PF4_WUF29_MASK | LLWU_PF4_WUF30_MASK), LLWU_PF4_WUF31(value)))
#define LLWU_BWR_PF4_WUF31(base, value) (BITBAND_ACCESS8(&LLWU_PF4_REG(base), LLWU_PF4_WUF31_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_MF5 - LLWU Module Flag 5 register
 ******************************************************************************/

/*!
 * @brief LLWU_MF5 - LLWU Module Flag 5 register (RO)
 *
 * Reset value: 0x00U
 *
 * LLWU_MF5 contains the wakeup flags indicating which internal wakeup source
 * caused the MCU to exit LLS or VLLS mode. For LLS, this is the source causing the
 * CPU interrupt flow. For VLLS, this is the source causing the MCU reset flow.
 * For internal peripherals that are capable of running in a low-leakage power
 * mode, such as a real time clock module or CMP module, the flag from the
 * associated peripheral is accessible as the MWUFx bit. The flag will need to be cleared
 * in the peripheral instead of writing a 1 to the MWUFx bit. This register is
 * reset on Chip Reset not VLLS and by reset types that trigger Chip Reset not
 * VLLS. It is unaffected by reset types that do not trigger Chip Reset not VLLS.
 * See the IntroductionInformation found here describes the registers of the Reset
 * Control Module (RCM). The RCM implements many of the reset functions for the
 * chip. See the chip's reset chapter for more information. details for more
 * information.
 */
/*!
 * @name Constants and macros for entire LLWU_MF5 register
 */
/*@{*/
#define LLWU_RD_MF5(base)        (LLWU_MF5_REG(base))
/*@}*/

/*
 * Constants & macros for individual LLWU_MF5 bitfields
 */

/*!
 * @name Register LLWU_MF5, field MWUF0[0] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 0 input was not a wakeup source
 * - 1 - Module 0 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF0 field. */
#define LLWU_RD_MF5_MWUF0(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF0_MASK) >> LLWU_MF5_MWUF0_SHIFT)
#define LLWU_BRD_MF5_MWUF0(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF0_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF1[1] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 1 input was not a wakeup source
 * - 1 - Module 1 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF1 field. */
#define LLWU_RD_MF5_MWUF1(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF1_MASK) >> LLWU_MF5_MWUF1_SHIFT)
#define LLWU_BRD_MF5_MWUF1(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF1_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF2[2] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 2 input was not a wakeup source
 * - 1 - Module 2 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF2 field. */
#define LLWU_RD_MF5_MWUF2(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF2_MASK) >> LLWU_MF5_MWUF2_SHIFT)
#define LLWU_BRD_MF5_MWUF2(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF2_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF3[3] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 3 input was not a wakeup source
 * - 1 - Module 3 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF3 field. */
#define LLWU_RD_MF5_MWUF3(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF3_MASK) >> LLWU_MF5_MWUF3_SHIFT)
#define LLWU_BRD_MF5_MWUF3(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF3_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF4[4] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 4 input was not a wakeup source
 * - 1 - Module 4 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF4 field. */
#define LLWU_RD_MF5_MWUF4(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF4_MASK) >> LLWU_MF5_MWUF4_SHIFT)
#define LLWU_BRD_MF5_MWUF4(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF4_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF5[5] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 5 input was not a wakeup source
 * - 1 - Module 5 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF5 field. */
#define LLWU_RD_MF5_MWUF5(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF5_MASK) >> LLWU_MF5_MWUF5_SHIFT)
#define LLWU_BRD_MF5_MWUF5(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF5_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF6[6] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 6 input was not a wakeup source
 * - 1 - Module 6 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF6 field. */
#define LLWU_RD_MF5_MWUF6(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF6_MASK) >> LLWU_MF5_MWUF6_SHIFT)
#define LLWU_BRD_MF5_MWUF6(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF6_SHIFT))
/*@}*/

/*!
 * @name Register LLWU_MF5, field MWUF7[7] (RO)
 *
 * Indicates that an enabled internal peripheral was a source of exiting a
 * low-leakage power mode. To clear the flag, follow the internal peripheral flag
 * clearing mechanism.
 *
 * Values:
 * - 0 - Module 7 input was not a wakeup source
 * - 1 - Module 7 input was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_MF5_MWUF7 field. */
#define LLWU_RD_MF5_MWUF7(base) ((LLWU_MF5_REG(base) & LLWU_MF5_MWUF7_MASK) >> LLWU_MF5_MWUF7_SHIFT)
#define LLWU_BRD_MF5_MWUF7(base) (BITBAND_ACCESS8(&LLWU_MF5_REG(base), LLWU_MF5_MWUF7_SHIFT))
/*@}*/

/*******************************************************************************
 * LLWU_FILT1 - LLWU Pin Filter 1 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT1 - LLWU Pin Filter 1 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT1 is a control and status register that is used to enable/disable
 * the digital filter 1 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT1 register
 */
/*@{*/
#define LLWU_RD_FILT1(base)      (LLWU_FILT1_REG(base))
#define LLWU_WR_FILT1(base, value) (LLWU_FILT1_REG(base) = (value))
#define LLWU_RMW_FILT1(base, mask, value) (LLWU_WR_FILT1(base, (LLWU_RD_FILT1(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) |  (value)))
#define LLWU_CLR_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) & ~(value)))
#define LLWU_TOG_FILT1(base, value) (LLWU_WR_FILT1(base, LLWU_RD_FILT1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT1 bitfields
 */

/*!
 * @name Register LLWU_FILT1, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 00000 - Select LLWU_P0 for filter
 * - 11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTSEL field. */
#define LLWU_RD_FILT1_FILTSEL(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTSEL_MASK) >> LLWU_FILT1_FILTSEL_SHIFT)
#define LLWU_BRD_FILT1_FILTSEL(base) (LLWU_RD_FILT1_FILTSEL(base))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT1_FILTSEL(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTSEL_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTSEL(value)))
#define LLWU_BWR_FILT1_FILTSEL(base, value) (LLWU_WR_FILT1_FILTSEL(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTE field. */
#define LLWU_RD_FILT1_FILTE(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTE_MASK) >> LLWU_FILT1_FILTE_SHIFT)
#define LLWU_BRD_FILT1_FILTE(base) (LLWU_RD_FILT1_FILTE(base))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT1_FILTE(base, value) (LLWU_RMW_FILT1(base, (LLWU_FILT1_FILTE_MASK | LLWU_FILT1_FILTF_MASK), LLWU_FILT1_FILTE(value)))
#define LLWU_BWR_FILT1_FILTE(base, value) (LLWU_WR_FILT1_FILTE(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT1, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 1 was not a wakeup source
 * - 1 - Pin Filter 1 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT1_FILTF field. */
#define LLWU_RD_FILT1_FILTF(base) ((LLWU_FILT1_REG(base) & LLWU_FILT1_FILTF_MASK) >> LLWU_FILT1_FILTF_SHIFT)
#define LLWU_BRD_FILT1_FILTF(base) (BITBAND_ACCESS8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT1_FILTF(base, value) (LLWU_RMW_FILT1(base, LLWU_FILT1_FILTF_MASK, LLWU_FILT1_FILTF(value)))
#define LLWU_BWR_FILT1_FILTF(base, value) (BITBAND_ACCESS8(&LLWU_FILT1_REG(base), LLWU_FILT1_FILTF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LLWU_FILT2 - LLWU Pin Filter 2 register
 ******************************************************************************/

/*!
 * @brief LLWU_FILT2 - LLWU Pin Filter 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * LLWU_FILT2 is a control and status register that is used to enable/disable
 * the digital filter 2 features for an external pin. This register is reset on
 * Chip Reset not VLLS and by reset types that trigger Chip Reset not VLLS. It is
 * unaffected by reset types that do not trigger Chip Reset not VLLS. See the
 * IntroductionInformation found here describes the registers of the Reset Control
 * Module (RCM). The RCM implements many of the reset functions for the chip. See
 * the chip's reset chapter for more information. details for more information.
 */
/*!
 * @name Constants and macros for entire LLWU_FILT2 register
 */
/*@{*/
#define LLWU_RD_FILT2(base)      (LLWU_FILT2_REG(base))
#define LLWU_WR_FILT2(base, value) (LLWU_FILT2_REG(base) = (value))
#define LLWU_RMW_FILT2(base, mask, value) (LLWU_WR_FILT2(base, (LLWU_RD_FILT2(base) & ~(mask)) | (value)))
#define LLWU_SET_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) |  (value)))
#define LLWU_CLR_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) & ~(value)))
#define LLWU_TOG_FILT2(base, value) (LLWU_WR_FILT2(base, LLWU_RD_FILT2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LLWU_FILT2 bitfields
 */

/*!
 * @name Register LLWU_FILT2, field FILTSEL[4:0] (RW)
 *
 * Selects 1 of the wakeup pins to be muxed into the filter.
 *
 * Values:
 * - 00000 - Select LLWU_P0 for filter
 * - 11111 - Select LLWU_P31 for filter
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTSEL field. */
#define LLWU_RD_FILT2_FILTSEL(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTSEL_MASK) >> LLWU_FILT2_FILTSEL_SHIFT)
#define LLWU_BRD_FILT2_FILTSEL(base) (LLWU_RD_FILT2_FILTSEL(base))

/*! @brief Set the FILTSEL field to a new value. */
#define LLWU_WR_FILT2_FILTSEL(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTSEL_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTSEL(value)))
#define LLWU_BWR_FILT2_FILTSEL(base, value) (LLWU_WR_FILT2_FILTSEL(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTE[6:5] (RW)
 *
 * Controls the digital filter options for the external pin detect.
 *
 * Values:
 * - 00 - Filter disabled
 * - 01 - Filter posedge detect enabled
 * - 10 - Filter negedge detect enabled
 * - 11 - Filter any edge detect enabled
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTE field. */
#define LLWU_RD_FILT2_FILTE(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTE_MASK) >> LLWU_FILT2_FILTE_SHIFT)
#define LLWU_BRD_FILT2_FILTE(base) (LLWU_RD_FILT2_FILTE(base))

/*! @brief Set the FILTE field to a new value. */
#define LLWU_WR_FILT2_FILTE(base, value) (LLWU_RMW_FILT2(base, (LLWU_FILT2_FILTE_MASK | LLWU_FILT2_FILTF_MASK), LLWU_FILT2_FILTE(value)))
#define LLWU_BWR_FILT2_FILTE(base, value) (LLWU_WR_FILT2_FILTE(base, value))
/*@}*/

/*!
 * @name Register LLWU_FILT2, field FILTF[7] (W1C)
 *
 * Indicates that the filtered external wakeup pin, selected by FILTSEL, was a
 * source of exiting a low-leakage power mode. To clear the flag write a one to
 * FILTF.
 *
 * Values:
 * - 0 - Pin Filter 2 was not a wakeup source
 * - 1 - Pin Filter 2 was a wakeup source
 */
/*@{*/
/*! @brief Read current value of the LLWU_FILT2_FILTF field. */
#define LLWU_RD_FILT2_FILTF(base) ((LLWU_FILT2_REG(base) & LLWU_FILT2_FILTF_MASK) >> LLWU_FILT2_FILTF_SHIFT)
#define LLWU_BRD_FILT2_FILTF(base) (BITBAND_ACCESS8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT))

/*! @brief Set the FILTF field to a new value. */
#define LLWU_WR_FILT2_FILTF(base, value) (LLWU_RMW_FILT2(base, LLWU_FILT2_FILTF_MASK, LLWU_FILT2_FILTF(value)))
#define LLWU_BWR_FILT2_FILTF(base, value) (BITBAND_ACCESS8(&LLWU_FILT2_REG(base), LLWU_FILT2_FILTF_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 LPI2C
 *
 * The LPI2C Memory Map/Register Definition can be found here.
 *
 * Registers defined in this header file:
 * - LPI2C_VERID - Version ID Register
 * - LPI2C_PARAM - Parameter Register
 * - LPI2C_MCR - Master Control Register
 * - LPI2C_MSR - Master Status Register
 * - LPI2C_MIER - Master Interrupt Enable Register
 * - LPI2C_MDER - Master DMA Enable Register
 * - LPI2C_MCFGR0 - Master Configuration Register 0
 * - LPI2C_MCFGR1 - Master Configuration Register 1
 * - LPI2C_MCFGR2 - Master Configuration Register 2
 * - LPI2C_MCFGR3 - Master Configuration Register 3
 * - LPI2C_MDMR - Master Data Match Register
 * - LPI2C_MCCR0 - Master Clock Configuration Register 0
 * - LPI2C_MCCR1 - Master Clock Configuration Register 1
 * - LPI2C_MFCR - Master FIFO Control Register
 * - LPI2C_MFSR - Master FIFO Status Register
 * - LPI2C_MTDR - Master Transmit Data Register
 * - LPI2C_MRDR - Master Receive Data Register
 * - LPI2C_SCR - Slave Control Register
 * - LPI2C_SSR - Slave Status Register
 * - LPI2C_SIER - Slave Interrupt Enable Register
 * - LPI2C_SDER - Slave DMA Enable Register
 * - LPI2C_SCFGR1 - Slave Configuration Register 1
 * - LPI2C_SCFGR2 - Slave Configuration Register 2
 * - LPI2C_SAMR - Slave Address Match Register
 * - LPI2C_SASR - Slave Address Status Register
 * - LPI2C_STAR - Slave Transmit ACK Register
 * - LPI2C_STDR - Slave Transmit Data Register
 * - LPI2C_SRDR - Slave Receive Data Register
 */

#define LPI2C_INSTANCE_COUNT (2U) /*!< Number of instances of the LPI2C module. */
#define LPI2C0_IDX (0U) /*!< Instance number for LPI2C0. */
#define LPI2C1_IDX (1U) /*!< Instance number for LPI2C1. */

/*******************************************************************************
 * LPI2C_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief LPI2C_VERID - Version ID Register (RO)
 *
 * Reset value: 0x01000003U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_VERID register
 */
/*@{*/
#define LPI2C_RD_VERID(base)     (LPI2C_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_VERID bitfields
 */

/*!
 * @name Register LPI2C_VERID, field FEATURE[15:0] (RO)
 *
 * This read only field returns the feature set number.
 *
 * Values:
 * - 10 - Master only with standard feature set.
 * - 11 - Master and slave with standard feature set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_FEATURE field. */
#define LPI2C_RD_VERID_FEATURE(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_FEATURE_MASK) >> LPI2C_VERID_FEATURE_SHIFT)
#define LPI2C_BRD_VERID_FEATURE(base) (LPI2C_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MINOR field. */
#define LPI2C_RD_VERID_MINOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MINOR_MASK) >> LPI2C_VERID_MINOR_SHIFT)
#define LPI2C_BRD_VERID_MINOR(base) (LPI2C_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register LPI2C_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the specification.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_VERID_MAJOR field. */
#define LPI2C_RD_VERID_MAJOR(base) ((LPI2C_VERID_REG(base) & LPI2C_VERID_MAJOR_MASK) >> LPI2C_VERID_MAJOR_SHIFT)
#define LPI2C_BRD_VERID_MAJOR(base) (LPI2C_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * LPI2C_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief LPI2C_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00000202U
 *
 * .
 */
/*!
 * @name Constants and macros for entire LPI2C_PARAM register
 */
/*@{*/
#define LPI2C_RD_PARAM(base)     (LPI2C_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_PARAM bitfields
 */

/*!
 * @name Register LPI2C_PARAM, field MTXFIFO[3:0] (RO)
 *
 * The number of words in the master transmit FIFO is 2^MTXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MTXFIFO field. */
#define LPI2C_RD_PARAM_MTXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MTXFIFO_MASK) >> LPI2C_PARAM_MTXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MTXFIFO(base) (LPI2C_RD_PARAM_MTXFIFO(base))
/*@}*/

/*!
 * @name Register LPI2C_PARAM, field MRXFIFO[11:8] (RO)
 *
 * The number of words in the master receive FIFO is 2^MRXFIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_PARAM_MRXFIFO field. */
#define LPI2C_RD_PARAM_MRXFIFO(base) ((LPI2C_PARAM_REG(base) & LPI2C_PARAM_MRXFIFO_MASK) >> LPI2C_PARAM_MRXFIFO_SHIFT)
#define LPI2C_BRD_PARAM_MRXFIFO(base) (LPI2C_RD_PARAM_MRXFIFO(base))
/*@}*/

/*******************************************************************************
 * LPI2C_MCR - Master Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MCR - Master Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCR register
 */
/*@{*/
#define LPI2C_RD_MCR(base)       (LPI2C_MCR_REG(base))
#define LPI2C_WR_MCR(base, value) (LPI2C_MCR_REG(base) = (value))
#define LPI2C_RMW_MCR(base, mask, value) (LPI2C_WR_MCR(base, (LPI2C_RD_MCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) |  (value)))
#define LPI2C_CLR_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) & ~(value)))
#define LPI2C_TOG_MCR(base, value) (LPI2C_WR_MCR(base, LPI2C_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCR bitfields
 */

/*!
 * @name Register LPI2C_MCR, field MEN[0] (RW)
 *
 * Values:
 * - 0 - Master logic is disabled.
 * - 1 - Master logic is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_MEN field. */
#define LPI2C_RD_MCR_MEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_MEN_MASK) >> LPI2C_MCR_MEN_SHIFT)
#define LPI2C_BRD_MCR_MEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_MEN_SHIFT))

/*! @brief Set the MEN field to a new value. */
#define LPI2C_WR_MCR_MEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_MEN_MASK, LPI2C_MCR_MEN(value)))
#define LPI2C_BWR_MCR_MEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_MEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RST[1] (RW)
 *
 * Reset all internal master logic and registers, except the Master Control
 * Register. Remains set until cleared by software.
 *
 * Values:
 * - 0 - Master logic is not reset.
 * - 1 - Master logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_RST field. */
#define LPI2C_RD_MCR_RST(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_RST_MASK) >> LPI2C_MCR_RST_SHIFT)
#define LPI2C_BRD_MCR_RST(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_MCR_RST(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RST_MASK, LPI2C_MCR_RST(value)))
#define LPI2C_BWR_MCR_RST(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DOZEN[2] (RW)
 *
 * Enables or disables Doze mode for the master.
 *
 * Values:
 * - 0 - Master is enabled in Doze mode.
 * - 1 - Master is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DOZEN field. */
#define LPI2C_RD_MCR_DOZEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DOZEN_MASK) >> LPI2C_MCR_DOZEN_SHIFT)
#define LPI2C_BRD_MCR_DOZEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DOZEN_SHIFT))

/*! @brief Set the DOZEN field to a new value. */
#define LPI2C_WR_MCR_DOZEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DOZEN_MASK, LPI2C_MCR_DOZEN(value)))
#define LPI2C_BWR_MCR_DOZEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DOZEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field DBGEN[3] (RW)
 *
 * Values:
 * - 0 - Master is disabled in debug mode.
 * - 1 - Master is enabled in debug mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCR_DBGEN field. */
#define LPI2C_RD_MCR_DBGEN(base) ((LPI2C_MCR_REG(base) & LPI2C_MCR_DBGEN_MASK) >> LPI2C_MCR_DBGEN_SHIFT)
#define LPI2C_BRD_MCR_DBGEN(base) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DBGEN_SHIFT))

/*! @brief Set the DBGEN field to a new value. */
#define LPI2C_WR_MCR_DBGEN(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_DBGEN_MASK, LPI2C_MCR_DBGEN(value)))
#define LPI2C_BWR_MCR_DBGEN(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_DBGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Transmit FIFO is reset.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_MCR_RTF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RTF_MASK, LPI2C_MCR_RTF(value)))
#define LPI2C_BWR_MCR_RTF(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Receive FIFO is reset.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_MCR_RRF(base, value) (LPI2C_RMW_MCR(base, LPI2C_MCR_RRF_MASK, LPI2C_MCR_RRF(value)))
#define LPI2C_BWR_MCR_RRF(base, value) (BITBAND_ACCESS32(&LPI2C_MCR_REG(base), LPI2C_MCR_RRF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MSR - Master Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MSR - Master Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire LPI2C_MSR register
 */
/*@{*/
#define LPI2C_RD_MSR(base)       (LPI2C_MSR_REG(base))
#define LPI2C_WR_MSR(base, value) (LPI2C_MSR_REG(base) = (value))
#define LPI2C_RMW_MSR(base, mask, value) (LPI2C_WR_MSR(base, (LPI2C_RD_MSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) |  (value)))
#define LPI2C_CLR_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) & ~(value)))
#define LPI2C_TOG_MSR(base, value) (LPI2C_WR_MSR(base, LPI2C_RD_MSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MSR bitfields
 */

/*!
 * @name Register LPI2C_MSR, field TDF[0] (RO)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER.
 *
 * Values:
 * - 0 - Transmit data not requested.
 * - 1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_TDF field. */
#define LPI2C_RD_MSR_TDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_TDF_MASK) >> LPI2C_MSR_TDF_SHIFT)
#define LPI2C_BRD_MSR_TDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_TDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field RDF[1] (RO)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER.
 *
 * Values:
 * - 0 - Receive Data is not ready.
 * - 1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_RDF field. */
#define LPI2C_RD_MSR_RDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_RDF_MASK) >> LPI2C_MSR_RDF_SHIFT)
#define LPI2C_BRD_MSR_RDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_RDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field EPF[8] (W1C)
 *
 * This flag will set when the LPI2C master generates either a repeated START or
 * a STOP condition. It does not set when the master first generates a START
 * condition.
 *
 * Values:
 * - 0 - Master has not generated a STOP or Repeated START condition.
 * - 1 - Master has generated a STOP or Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_EPF field. */
#define LPI2C_RD_MSR_EPF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_EPF_MASK) >> LPI2C_MSR_EPF_SHIFT)
#define LPI2C_BRD_MSR_EPF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_EPF_SHIFT))

/*! @brief Set the EPF field to a new value. */
#define LPI2C_WR_MSR_EPF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_EPF(value)))
#define LPI2C_BWR_MSR_EPF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_EPF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C master generates a STOP condition.
 *
 * Values:
 * - 0 - Master has not generated a STOP condition.
 * - 1 - Master has generated a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_SDF field. */
#define LPI2C_RD_MSR_SDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_SDF_MASK) >> LPI2C_MSR_SDF_SHIFT)
#define LPI2C_BRD_MSR_SDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_SDF_SHIFT))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_MSR_SDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_SDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_SDF(value)))
#define LPI2C_BWR_MSR_SDF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_SDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field NDF[10] (W1C)
 *
 * This flag will set if the LPI2C master detects a NACK when transmitting an
 * address or data. If a NACK is expected for a given address (as configured by the
 * command word) then the flag will set if a NACK is not generated. When set,
 * the master will transmit a STOP condition and will not initiate a new START
 * condition until this flag has been cleared.
 *
 * Values:
 * - 0 - Unexpected NACK not detected.
 * - 1 - Unexpected NACK was detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_NDF field. */
#define LPI2C_RD_MSR_NDF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_NDF_MASK) >> LPI2C_MSR_NDF_SHIFT)
#define LPI2C_BRD_MSR_NDF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_NDF_SHIFT))

/*! @brief Set the NDF field to a new value. */
#define LPI2C_WR_MSR_NDF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_NDF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_NDF(value)))
#define LPI2C_BWR_MSR_NDF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_NDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field ALF[11] (W1C)
 *
 * This flag will set if the LPI2C master transmits a logic one and detects a
 * logic zero on the I2C bus, or if it detects a START or STOP condition while it
 * is transmitting data. When this flag sets, the LPI2C master will release the
 * bus (go idle) and will not initiate a new START condition until this flag has
 * been cleared.
 *
 * Values:
 * - 0 - Master has not lost arbitration.
 * - 1 - Master has lost arbitration.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_ALF field. */
#define LPI2C_RD_MSR_ALF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_ALF_MASK) >> LPI2C_MSR_ALF_SHIFT)
#define LPI2C_BRD_MSR_ALF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_ALF_SHIFT))

/*! @brief Set the ALF field to a new value. */
#define LPI2C_WR_MSR_ALF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_ALF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_ALF(value)))
#define LPI2C_BWR_MSR_ALF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_ALF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field FEF[12] (W1C)
 *
 * Detects an attempt to send or receive data without first generating a
 * (repeated) START condition. This can occur if the transmit FIFO underflows when the
 * AUTOSTOP bit is set. When this flag is set, the LPI2C master will send a STOP
 * condition (if busy) and will not initiate a new START condition until this flag
 * has been cleared.
 *
 * Values:
 * - 0 - No error.
 * - 1 - Master sending or receiving data without START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_FEF field. */
#define LPI2C_RD_MSR_FEF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_FEF_MASK) >> LPI2C_MSR_FEF_SHIFT)
#define LPI2C_BRD_MSR_FEF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_MSR_FEF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_FEF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_PLTF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_FEF(value)))
#define LPI2C_BWR_MSR_FEF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field PLTF[13] (W1C)
 *
 * Will set when the SCL and/or SDA input is low for more than PINLOW cycles,
 * even when the LPI2C master is idle. Software is responsible for resolving the
 * pin low condition. This flag cannot be cleared for as long as the pin low
 * timeout continues and must be cleared before the LPI2C can initiate a START
 * condition.
 *
 * Values:
 * - 0 - Pin low timeout has not occurred or is disabled.
 * - 1 - Pin low timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_PLTF field. */
#define LPI2C_RD_MSR_PLTF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_PLTF_MASK) >> LPI2C_MSR_PLTF_SHIFT)
#define LPI2C_BRD_MSR_PLTF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_PLTF_SHIFT))

/*! @brief Set the PLTF field to a new value. */
#define LPI2C_WR_MSR_PLTF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_PLTF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_DMF_MASK), LPI2C_MSR_PLTF(value)))
#define LPI2C_BWR_MSR_PLTF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_PLTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field DMF[14] (W1C)
 *
 * Indicates that the received data has matched the MATCH0 and/or MATCH1 fields
 * as configured by MATCFG. Received data that is discarded due to CMD field does
 * not cause this flag to set.
 *
 * Values:
 * - 0 - Have not received matching data.
 * - 1 - Have received matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_DMF field. */
#define LPI2C_RD_MSR_DMF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_DMF_MASK) >> LPI2C_MSR_DMF_SHIFT)
#define LPI2C_BRD_MSR_DMF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_DMF_SHIFT))

/*! @brief Set the DMF field to a new value. */
#define LPI2C_WR_MSR_DMF(base, value) (LPI2C_RMW_MSR(base, (LPI2C_MSR_DMF_MASK | LPI2C_MSR_EPF_MASK | LPI2C_MSR_SDF_MASK | LPI2C_MSR_NDF_MASK | LPI2C_MSR_ALF_MASK | LPI2C_MSR_FEF_MASK | LPI2C_MSR_PLTF_MASK), LPI2C_MSR_DMF(value)))
#define LPI2C_BWR_MSR_DMF(base, value) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_DMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field MBF[24] (RO)
 *
 * Values:
 * - 0 - I2C Master is idle.
 * - 1 - I2C Master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_MBF field. */
#define LPI2C_RD_MSR_MBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_MBF_MASK) >> LPI2C_MSR_MBF_SHIFT)
#define LPI2C_BRD_MSR_MBF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_MBF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_MSR, field BBF[25] (RO)
 *
 * Values:
 * - 0 - I2C Bus is idle.
 * - 1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MSR_BBF field. */
#define LPI2C_RD_MSR_BBF(base) ((LPI2C_MSR_REG(base) & LPI2C_MSR_BBF_MASK) >> LPI2C_MSR_BBF_SHIFT)
#define LPI2C_BRD_MSR_BBF(base) (BITBAND_ACCESS32(&LPI2C_MSR_REG(base), LPI2C_MSR_BBF_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_MIER - Master Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MIER - Master Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MIER register
 */
/*@{*/
#define LPI2C_RD_MIER(base)      (LPI2C_MIER_REG(base))
#define LPI2C_WR_MIER(base, value) (LPI2C_MIER_REG(base) = (value))
#define LPI2C_RMW_MIER(base, mask, value) (LPI2C_WR_MIER(base, (LPI2C_RD_MIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) |  (value)))
#define LPI2C_CLR_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) & ~(value)))
#define LPI2C_TOG_MIER(base, value) (LPI2C_WR_MIER(base, LPI2C_RD_MIER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MIER bitfields
 */

/*!
 * @name Register LPI2C_MIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_TDIE field. */
#define LPI2C_RD_MIER_TDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_TDIE_MASK) >> LPI2C_MIER_TDIE_SHIFT)
#define LPI2C_BRD_MIER_TDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_TDIE_SHIFT))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_MIER_TDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_TDIE_MASK, LPI2C_MIER_TDIE(value)))
#define LPI2C_BWR_MIER_TDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_TDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_RDIE field. */
#define LPI2C_RD_MIER_RDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_RDIE_MASK) >> LPI2C_MIER_RDIE_SHIFT)
#define LPI2C_BRD_MIER_RDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_RDIE_SHIFT))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_MIER_RDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_RDIE_MASK, LPI2C_MIER_RDIE(value)))
#define LPI2C_BWR_MIER_RDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_RDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field EPIE[8] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_EPIE field. */
#define LPI2C_RD_MIER_EPIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_EPIE_MASK) >> LPI2C_MIER_EPIE_SHIFT)
#define LPI2C_BRD_MIER_EPIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_EPIE_SHIFT))

/*! @brief Set the EPIE field to a new value. */
#define LPI2C_WR_MIER_EPIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_EPIE_MASK, LPI2C_MIER_EPIE(value)))
#define LPI2C_BWR_MIER_EPIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_EPIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_SDIE field. */
#define LPI2C_RD_MIER_SDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_SDIE_MASK) >> LPI2C_MIER_SDIE_SHIFT)
#define LPI2C_BRD_MIER_SDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_SDIE_SHIFT))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_MIER_SDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_SDIE_MASK, LPI2C_MIER_SDIE(value)))
#define LPI2C_BWR_MIER_SDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_SDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field NDIE[10] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_NDIE field. */
#define LPI2C_RD_MIER_NDIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_NDIE_MASK) >> LPI2C_MIER_NDIE_SHIFT)
#define LPI2C_BRD_MIER_NDIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_NDIE_SHIFT))

/*! @brief Set the NDIE field to a new value. */
#define LPI2C_WR_MIER_NDIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_NDIE_MASK, LPI2C_MIER_NDIE(value)))
#define LPI2C_BWR_MIER_NDIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_NDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field ALIE[11] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_ALIE field. */
#define LPI2C_RD_MIER_ALIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_ALIE_MASK) >> LPI2C_MIER_ALIE_SHIFT)
#define LPI2C_BRD_MIER_ALIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_ALIE_SHIFT))

/*! @brief Set the ALIE field to a new value. */
#define LPI2C_WR_MIER_ALIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_ALIE_MASK, LPI2C_MIER_ALIE(value)))
#define LPI2C_BWR_MIER_ALIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_ALIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field FEIE[12] (RW)
 *
 * Values:
 * - 0 - Interrupt enabled.
 * - 1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_FEIE field. */
#define LPI2C_RD_MIER_FEIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_FEIE_MASK) >> LPI2C_MIER_FEIE_SHIFT)
#define LPI2C_BRD_MIER_FEIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_MIER_FEIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_FEIE_MASK, LPI2C_MIER_FEIE(value)))
#define LPI2C_BWR_MIER_FEIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field PLTIE[13] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_PLTIE field. */
#define LPI2C_RD_MIER_PLTIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_PLTIE_MASK) >> LPI2C_MIER_PLTIE_SHIFT)
#define LPI2C_BRD_MIER_PLTIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_PLTIE_SHIFT))

/*! @brief Set the PLTIE field to a new value. */
#define LPI2C_WR_MIER_PLTIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_PLTIE_MASK, LPI2C_MIER_PLTIE(value)))
#define LPI2C_BWR_MIER_PLTIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_PLTIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MIER, field DMIE[14] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MIER_DMIE field. */
#define LPI2C_RD_MIER_DMIE(base) ((LPI2C_MIER_REG(base) & LPI2C_MIER_DMIE_MASK) >> LPI2C_MIER_DMIE_SHIFT)
#define LPI2C_BRD_MIER_DMIE(base) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_DMIE_SHIFT))

/*! @brief Set the DMIE field to a new value. */
#define LPI2C_WR_MIER_DMIE(base, value) (LPI2C_RMW_MIER(base, LPI2C_MIER_DMIE_MASK, LPI2C_MIER_DMIE(value)))
#define LPI2C_BWR_MIER_DMIE(base, value) (BITBAND_ACCESS32(&LPI2C_MIER_REG(base), LPI2C_MIER_DMIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MDER - Master DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDER - Master DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDER register
 */
/*@{*/
#define LPI2C_RD_MDER(base)      (LPI2C_MDER_REG(base))
#define LPI2C_WR_MDER(base, value) (LPI2C_MDER_REG(base) = (value))
#define LPI2C_RMW_MDER(base, mask, value) (LPI2C_WR_MDER(base, (LPI2C_RD_MDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) |  (value)))
#define LPI2C_CLR_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) & ~(value)))
#define LPI2C_TOG_MDER(base, value) (LPI2C_WR_MDER(base, LPI2C_RD_MDER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDER bitfields
 */

/*!
 * @name Register LPI2C_MDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_TDDE field. */
#define LPI2C_RD_MDER_TDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_TDDE_MASK) >> LPI2C_MDER_TDDE_SHIFT)
#define LPI2C_BRD_MDER_TDDE(base) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_TDDE_SHIFT))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_MDER_TDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_TDDE_MASK, LPI2C_MDER_TDDE(value)))
#define LPI2C_BWR_MDER_TDDE(base, value) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_TDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDER_RDDE field. */
#define LPI2C_RD_MDER_RDDE(base) ((LPI2C_MDER_REG(base) & LPI2C_MDER_RDDE_MASK) >> LPI2C_MDER_RDDE_SHIFT)
#define LPI2C_BRD_MDER_RDDE(base) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_RDDE_SHIFT))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_MDER_RDDE(base, value) (LPI2C_RMW_MDER(base, LPI2C_MDER_RDDE_MASK, LPI2C_MDER_RDDE(value)))
#define LPI2C_BWR_MDER_RDDE(base, value) (BITBAND_ACCESS32(&LPI2C_MDER_REG(base), LPI2C_MDER_RDDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR0 - Master Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR0 - Master Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR0 register
 */
/*@{*/
#define LPI2C_RD_MCFGR0(base)    (LPI2C_MCFGR0_REG(base))
#define LPI2C_WR_MCFGR0(base, value) (LPI2C_MCFGR0_REG(base) = (value))
#define LPI2C_RMW_MCFGR0(base, mask, value) (LPI2C_WR_MCFGR0(base, (LPI2C_RD_MCFGR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) |  (value)))
#define LPI2C_CLR_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) & ~(value)))
#define LPI2C_TOG_MCFGR0(base, value) (LPI2C_WR_MCFGR0(base, LPI2C_RD_MCFGR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR0 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR0, field HREN[0] (RW)
 *
 * When enabled, the LPI2C master will only initiate a START condition if the
 * host request input is asserted and the bus is idle. A repeated START is not
 * affected by the host request.
 *
 * Values:
 * - 0 - Host request input is disabled.
 * - 1 - Host request input is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HREN field. */
#define LPI2C_RD_MCFGR0_HREN(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HREN_MASK) >> LPI2C_MCFGR0_HREN_SHIFT)
#define LPI2C_BRD_MCFGR0_HREN(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HREN_SHIFT))

/*! @brief Set the HREN field to a new value. */
#define LPI2C_WR_MCFGR0_HREN(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HREN_MASK, LPI2C_MCFGR0_HREN(value)))
#define LPI2C_BWR_MCFGR0_HREN(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRPOL[1] (RW)
 *
 * Configures the polarity of the host request input pin.
 *
 * Values:
 * - 0 - Active low.
 * - 1 - Active high.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRPOL field. */
#define LPI2C_RD_MCFGR0_HRPOL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRPOL_MASK) >> LPI2C_MCFGR0_HRPOL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRPOL(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRPOL_SHIFT))

/*! @brief Set the HRPOL field to a new value. */
#define LPI2C_WR_MCFGR0_HRPOL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRPOL_MASK, LPI2C_MCFGR0_HRPOL(value)))
#define LPI2C_BWR_MCFGR0_HRPOL(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field HRSEL[2] (RW)
 *
 * Selects the source of the host request input.
 *
 * Values:
 * - 0 - Host request input is pin LPI2C_HREQ.
 * - 1 - Host request input is input trigger.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_HRSEL field. */
#define LPI2C_RD_MCFGR0_HRSEL(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_HRSEL_MASK) >> LPI2C_MCFGR0_HRSEL_SHIFT)
#define LPI2C_BRD_MCFGR0_HRSEL(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRSEL_SHIFT))

/*! @brief Set the HRSEL field to a new value. */
#define LPI2C_WR_MCFGR0_HRSEL(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_HRSEL_MASK, LPI2C_MCFGR0_HRSEL(value)))
#define LPI2C_BWR_MCFGR0_HRSEL(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_HRSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field CIRFIFO[8] (RW)
 *
 * When enabled, the transmit FIFO read pointer is saved to a temporary
 * register. The transmit FIFO will be emptied as normal, but once the LPI2C master is
 * idle and the transmit FIFO is empty, then the read pointer value will be
 * restored from the temporary register. This will cause the contents of the transmit
 * FIFO to be cycled through repeatedly. If AUTOSTOP is set, a STOP condition will
 * be sent whenever the transmit FIFO is empty and the read pointer is restored.
 *
 * Values:
 * - 0 - Circular FIFO is disabled.
 * - 1 - Circular FIFO is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_CIRFIFO field. */
#define LPI2C_RD_MCFGR0_CIRFIFO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_CIRFIFO_MASK) >> LPI2C_MCFGR0_CIRFIFO_SHIFT)
#define LPI2C_BRD_MCFGR0_CIRFIFO(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_CIRFIFO_SHIFT))

/*! @brief Set the CIRFIFO field to a new value. */
#define LPI2C_WR_MCFGR0_CIRFIFO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_CIRFIFO_MASK, LPI2C_MCFGR0_CIRFIFO(value)))
#define LPI2C_BWR_MCFGR0_CIRFIFO(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_CIRFIFO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR0, field RDMO[9] (RW)
 *
 * When enabled, all received data that does not cause DMF to set is discarded.
 * Once DMF is set, the RDMO configuration is ignored. When disabling RDMO, clear
 * RDMO before clearing DMF to ensure no receive data is lost.
 *
 * Values:
 * - 0 - Received data is stored in the receive FIFO as normal.
 * - 1 - Received data is discarded unless the RMF is set.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR0_RDMO field. */
#define LPI2C_RD_MCFGR0_RDMO(base) ((LPI2C_MCFGR0_REG(base) & LPI2C_MCFGR0_RDMO_MASK) >> LPI2C_MCFGR0_RDMO_SHIFT)
#define LPI2C_BRD_MCFGR0_RDMO(base) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_RDMO_SHIFT))

/*! @brief Set the RDMO field to a new value. */
#define LPI2C_WR_MCFGR0_RDMO(base, value) (LPI2C_RMW_MCFGR0(base, LPI2C_MCFGR0_RDMO_MASK, LPI2C_MCFGR0_RDMO(value)))
#define LPI2C_BWR_MCFGR0_RDMO(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR0_REG(base), LPI2C_MCFGR0_RDMO_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR1 - Master Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR1 - Master Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR1 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR1 register
 */
/*@{*/
#define LPI2C_RD_MCFGR1(base)    (LPI2C_MCFGR1_REG(base))
#define LPI2C_WR_MCFGR1(base, value) (LPI2C_MCFGR1_REG(base) = (value))
#define LPI2C_RMW_MCFGR1(base, mask, value) (LPI2C_WR_MCFGR1(base, (LPI2C_RD_MCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) |  (value)))
#define LPI2C_CLR_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) & ~(value)))
#define LPI2C_TOG_MCFGR1(base, value) (LPI2C_WR_MCFGR1(base, LPI2C_RD_MCFGR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR1, field PRESCALE[2:0] (RW)
 *
 * Configures the clock prescaler used for all LPI2C master logic, except the
 * digital glitch filters.
 *
 * Values:
 * - 000 - Divide by 1.
 * - 001 - Divide by 2.
 * - 010 - Divide by 4.
 * - 011 - Divide by 8.
 * - 100 - Divide by 16.
 * - 101 - Divide by 32.
 * - 110 - Divide by 64.
 * - 111 - Divide by 128.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PRESCALE field. */
#define LPI2C_RD_MCFGR1_PRESCALE(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PRESCALE_MASK) >> LPI2C_MCFGR1_PRESCALE_SHIFT)
#define LPI2C_BRD_MCFGR1_PRESCALE(base) (LPI2C_RD_MCFGR1_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPI2C_WR_MCFGR1_PRESCALE(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PRESCALE_MASK, LPI2C_MCFGR1_PRESCALE(value)))
#define LPI2C_BWR_MCFGR1_PRESCALE(base, value) (LPI2C_WR_MCFGR1_PRESCALE(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field AUTOSTOP[8] (RW)
 *
 * When enabled, a STOP condition is generated whenever the LPI2C master is busy
 * and the transmit FIFO is empty. The STOP condition can also be generated
 * using a transmit FIFO command.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - STOP condition is automatically generated whenever the transmit FIFO is
 *     empty and LPI2C master is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_AUTOSTOP field. */
#define LPI2C_RD_MCFGR1_AUTOSTOP(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_AUTOSTOP_MASK) >> LPI2C_MCFGR1_AUTOSTOP_SHIFT)
#define LPI2C_BRD_MCFGR1_AUTOSTOP(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_AUTOSTOP_SHIFT))

/*! @brief Set the AUTOSTOP field to a new value. */
#define LPI2C_WR_MCFGR1_AUTOSTOP(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_AUTOSTOP_MASK, LPI2C_MCFGR1_AUTOSTOP(value)))
#define LPI2C_BWR_MCFGR1_AUTOSTOP(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_AUTOSTOP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field IGNACK[9] (RW)
 *
 * When set, the received NACK field is ignored and assumed to be ACK. This bit
 * is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0 - LPI2C Master will receive ACK and NACK normally.
 * - 1 - LPI2C Master will treat a received NACK as if it was an ACK.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_IGNACK field. */
#define LPI2C_RD_MCFGR1_IGNACK(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_IGNACK_MASK) >> LPI2C_MCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_MCFGR1_IGNACK(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_IGNACK_SHIFT))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_MCFGR1_IGNACK(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_IGNACK_MASK, LPI2C_MCFGR1_IGNACK(value)))
#define LPI2C_BWR_MCFGR1_IGNACK(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_IGNACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field TIMECFG[10] (RW)
 *
 * Values:
 * - 0 - Pin Low Timeout Flag will set if SCL is low for longer than the
 *     configured timeout.
 * - 1 - Pin Low Timeout Flag will set if either SCL or SDA is low for longer
 *     than the configured timeout.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_TIMECFG field. */
#define LPI2C_RD_MCFGR1_TIMECFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_TIMECFG_MASK) >> LPI2C_MCFGR1_TIMECFG_SHIFT)
#define LPI2C_BRD_MCFGR1_TIMECFG(base) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_TIMECFG_SHIFT))

/*! @brief Set the TIMECFG field to a new value. */
#define LPI2C_WR_MCFGR1_TIMECFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_TIMECFG_MASK, LPI2C_MCFGR1_TIMECFG(value)))
#define LPI2C_BWR_MCFGR1_TIMECFG(base, value) (BITBAND_ACCESS32(&LPI2C_MCFGR1_REG(base), LPI2C_MCFGR1_TIMECFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field MATCFG[18:16] (RW)
 *
 * Configures the condition that will cause the DMF to set.
 *
 * Values:
 * - 000 - Match disabled.
 * - 001 - Reserved.
 * - 010 - Match enabled (1st data word equals MATCH0 OR MATCH1).
 * - 011 - Match enabled (any data word equals MATCH0 OR MATCH1).
 * - 100 - Match enabled (1st data word equals MATCH0 AND 2nd data word equals
 *     MATCH1).
 * - 101 - Match enabled (any data word equals MATCH0 AND next data word equals
 *     MATCH1).
 * - 110 - Match enabled (1st data word AND MATCH1 equals MATCH0 AND MATCH1).
 * - 111 - Match enabled (any data word AND MATCH1 equals MATCH0 AND MATCH1).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_MATCFG field. */
#define LPI2C_RD_MCFGR1_MATCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_MATCFG_MASK) >> LPI2C_MCFGR1_MATCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_MATCFG(base) (LPI2C_RD_MCFGR1_MATCFG(base))

/*! @brief Set the MATCFG field to a new value. */
#define LPI2C_WR_MCFGR1_MATCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_MATCFG_MASK, LPI2C_MCFGR1_MATCFG(value)))
#define LPI2C_BWR_MCFGR1_MATCFG(base, value) (LPI2C_WR_MCFGR1_MATCFG(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR1, field PINCFG[26:24] (RW)
 *
 * Configures the pin mode.
 *
 * Values:
 * - 000 - LPI2C configured for 2-pin open drain mode.
 * - 001 - LPI2C configured for 2-pin output only mode (ultra-fast mode).
 * - 010 - LPI2C configured for 2-pin push-pull mode.
 * - 011 - LPI2C configured for 4-pin push-pull mode.
 * - 100 - LPI2C configured for 2-pin open drain mode with separate LPI2C slave.
 * - 101 - LPI2C configured for 2-pin output only mode (ultra-fast mode) with
 *     separate LPI2C slave.
 * - 110 - LPI2C configured for 2-pin push-pull mode with separate LPI2C slave.
 * - 111 - LPI2C configured for 4-pin push-pull mode (inverted outputs).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR1_PINCFG field. */
#define LPI2C_RD_MCFGR1_PINCFG(base) ((LPI2C_MCFGR1_REG(base) & LPI2C_MCFGR1_PINCFG_MASK) >> LPI2C_MCFGR1_PINCFG_SHIFT)
#define LPI2C_BRD_MCFGR1_PINCFG(base) (LPI2C_RD_MCFGR1_PINCFG(base))

/*! @brief Set the PINCFG field to a new value. */
#define LPI2C_WR_MCFGR1_PINCFG(base, value) (LPI2C_RMW_MCFGR1(base, LPI2C_MCFGR1_PINCFG_MASK, LPI2C_MCFGR1_PINCFG(value)))
#define LPI2C_BWR_MCFGR1_PINCFG(base, value) (LPI2C_WR_MCFGR1_PINCFG(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR2 - Master Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR2 - Master Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR2 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR2 register
 */
/*@{*/
#define LPI2C_RD_MCFGR2(base)    (LPI2C_MCFGR2_REG(base))
#define LPI2C_WR_MCFGR2(base, value) (LPI2C_MCFGR2_REG(base) = (value))
#define LPI2C_RMW_MCFGR2(base, mask, value) (LPI2C_WR_MCFGR2(base, (LPI2C_RD_MCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) |  (value)))
#define LPI2C_CLR_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) & ~(value)))
#define LPI2C_TOG_MCFGR2(base, value) (LPI2C_WR_MCFGR2(base, LPI2C_RD_MCFGR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR2, field BUSIDLE[11:0] (RW)
 *
 * Configures the bus idle timeout period in clock cycles. If both SCL and SDA
 * are high for longer than BUSIDLE cycles, then the I2C bus is assumed to be idle
 * and the master can generate a START condition. When set to zero, this feature
 * is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_BUSIDLE field. */
#define LPI2C_RD_MCFGR2_BUSIDLE(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_BUSIDLE_MASK) >> LPI2C_MCFGR2_BUSIDLE_SHIFT)
#define LPI2C_BRD_MCFGR2_BUSIDLE(base) (LPI2C_RD_MCFGR2_BUSIDLE(base))

/*! @brief Set the BUSIDLE field to a new value. */
#define LPI2C_WR_MCFGR2_BUSIDLE(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_BUSIDLE_MASK, LPI2C_MCFGR2_BUSIDLE(value)))
#define LPI2C_BWR_MCFGR2_BUSIDLE(base, value) (LPI2C_WR_MCFGR2_BUSIDLE(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C master digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSCL field. */
#define LPI2C_RD_MCFGR2_FILTSCL(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSCL_MASK) >> LPI2C_MCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSCL(base) (LPI2C_RD_MCFGR2_FILTSCL(base))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSCL(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSCL_MASK, LPI2C_MCFGR2_FILTSCL(value)))
#define LPI2C_BWR_MCFGR2_FILTSCL(base, value) (LPI2C_WR_MCFGR2_FILTSCL(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C master digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA cycles and must be configured less than the minimum
 * SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration and is automatically bypassed in High Speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR2_FILTSDA field. */
#define LPI2C_RD_MCFGR2_FILTSDA(base) ((LPI2C_MCFGR2_REG(base) & LPI2C_MCFGR2_FILTSDA_MASK) >> LPI2C_MCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_MCFGR2_FILTSDA(base) (LPI2C_RD_MCFGR2_FILTSDA(base))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_MCFGR2_FILTSDA(base, value) (LPI2C_RMW_MCFGR2(base, LPI2C_MCFGR2_FILTSDA_MASK, LPI2C_MCFGR2_FILTSDA(value)))
#define LPI2C_BWR_MCFGR2_FILTSDA(base, value) (LPI2C_WR_MCFGR2_FILTSDA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCFGR3 - Master Configuration Register 3
 ******************************************************************************/

/*!
 * @brief LPI2C_MCFGR3 - Master Configuration Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCFGR3 should only be written when the I2C Master is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCFGR3 register
 */
/*@{*/
#define LPI2C_RD_MCFGR3(base)    (LPI2C_MCFGR3_REG(base))
#define LPI2C_WR_MCFGR3(base, value) (LPI2C_MCFGR3_REG(base) = (value))
#define LPI2C_RMW_MCFGR3(base, mask, value) (LPI2C_WR_MCFGR3(base, (LPI2C_RD_MCFGR3(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) |  (value)))
#define LPI2C_CLR_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) & ~(value)))
#define LPI2C_TOG_MCFGR3(base, value) (LPI2C_WR_MCFGR3(base, LPI2C_RD_MCFGR3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCFGR3 bitfields
 */

/*!
 * @name Register LPI2C_MCFGR3, field PINLOW[19:8] (RW)
 *
 * Configures the pin low timeout flag in clock cycles. If SCL and/or SDA is low
 * for longer than (PINLOW * 256) cycles then PLTF is set. When set to zero,
 * this feature is disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCFGR3_PINLOW field. */
#define LPI2C_RD_MCFGR3_PINLOW(base) ((LPI2C_MCFGR3_REG(base) & LPI2C_MCFGR3_PINLOW_MASK) >> LPI2C_MCFGR3_PINLOW_SHIFT)
#define LPI2C_BRD_MCFGR3_PINLOW(base) (LPI2C_RD_MCFGR3_PINLOW(base))

/*! @brief Set the PINLOW field to a new value. */
#define LPI2C_WR_MCFGR3_PINLOW(base, value) (LPI2C_RMW_MCFGR3(base, LPI2C_MCFGR3_PINLOW_MASK, LPI2C_MCFGR3_PINLOW(value)))
#define LPI2C_BWR_MCFGR3_PINLOW(base, value) (LPI2C_WR_MCFGR3_PINLOW(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MDMR - Master Data Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MDMR - Master Data Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MDMR register
 */
/*@{*/
#define LPI2C_RD_MDMR(base)      (LPI2C_MDMR_REG(base))
#define LPI2C_WR_MDMR(base, value) (LPI2C_MDMR_REG(base) = (value))
#define LPI2C_RMW_MDMR(base, mask, value) (LPI2C_WR_MDMR(base, (LPI2C_RD_MDMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) |  (value)))
#define LPI2C_CLR_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) & ~(value)))
#define LPI2C_TOG_MDMR(base, value) (LPI2C_WR_MDMR(base, LPI2C_RD_MDMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MDMR bitfields
 */

/*!
 * @name Register LPI2C_MDMR, field MATCH0[7:0] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH0 field. */
#define LPI2C_RD_MDMR_MATCH0(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH0_MASK) >> LPI2C_MDMR_MATCH0_SHIFT)
#define LPI2C_BRD_MDMR_MATCH0(base) (LPI2C_RD_MDMR_MATCH0(base))

/*! @brief Set the MATCH0 field to a new value. */
#define LPI2C_WR_MDMR_MATCH0(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH0_MASK, LPI2C_MDMR_MATCH0(value)))
#define LPI2C_BWR_MDMR_MATCH0(base, value) (LPI2C_WR_MDMR_MATCH0(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MDMR, field MATCH1[23:16] (RW)
 *
 * Compared against the received data when receive data match is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MDMR_MATCH1 field. */
#define LPI2C_RD_MDMR_MATCH1(base) ((LPI2C_MDMR_REG(base) & LPI2C_MDMR_MATCH1_MASK) >> LPI2C_MDMR_MATCH1_SHIFT)
#define LPI2C_BRD_MDMR_MATCH1(base) (LPI2C_RD_MDMR_MATCH1(base))

/*! @brief Set the MATCH1 field to a new value. */
#define LPI2C_WR_MDMR_MATCH1(base, value) (LPI2C_RMW_MDMR(base, LPI2C_MDMR_MATCH1_MASK, LPI2C_MDMR_MATCH1(value)))
#define LPI2C_BWR_MDMR_MATCH1(base, value) (LPI2C_WR_MDMR_MATCH1(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR0 - Master Clock Configuration Register 0
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR0 - Master Clock Configuration Register 0 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR0 cannot be changed when the I2C master is enabled and is used for
 * standard, fast, fast-mode plus and ultra-fast transfers.
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR0 register
 */
/*@{*/
#define LPI2C_RD_MCCR0(base)     (LPI2C_MCCR0_REG(base))
#define LPI2C_WR_MCCR0(base, value) (LPI2C_MCCR0_REG(base) = (value))
#define LPI2C_RMW_MCCR0(base, mask, value) (LPI2C_WR_MCCR0(base, (LPI2C_RD_MCCR0(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) |  (value)))
#define LPI2C_CLR_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) & ~(value)))
#define LPI2C_TOG_MCCR0(base, value) (LPI2C_WR_MCCR0(base, LPI2C_RD_MCCR0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR0 bitfields
 */

/*!
 * @name Register LPI2C_MCCR0, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKLO field. */
#define LPI2C_RD_MCCR0_CLKLO(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKLO_MASK) >> LPI2C_MCCR0_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR0_CLKLO(base) (LPI2C_RD_MCCR0_CLKLO(base))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR0_CLKLO(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKLO_MASK, LPI2C_MCCR0_CLKLO(value)))
#define LPI2C_BWR_MCCR0_CLKLO(base, value) (LPI2C_WR_MCCR0_CLKLO(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_CLKHI field. */
#define LPI2C_RD_MCCR0_CLKHI(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_CLKHI_MASK) >> LPI2C_MCCR0_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR0_CLKHI(base) (LPI2C_RD_MCCR0_CLKHI(base))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR0_CLKHI(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_CLKHI_MASK, LPI2C_MCCR0_CLKHI(value)))
#define LPI2C_BWR_MCCR0_CLKHI(base, value) (LPI2C_WR_MCCR0_CLKHI(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_SETHOLD field. */
#define LPI2C_RD_MCCR0_SETHOLD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_SETHOLD_MASK) >> LPI2C_MCCR0_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR0_SETHOLD(base) (LPI2C_RD_MCCR0_SETHOLD(base))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR0_SETHOLD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_SETHOLD_MASK, LPI2C_MCCR0_SETHOLD(value)))
#define LPI2C_BWR_MCCR0_SETHOLD(base, value) (LPI2C_WR_MCCR0_SETHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR0, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR0_DATAVD field. */
#define LPI2C_RD_MCCR0_DATAVD(base) ((LPI2C_MCCR0_REG(base) & LPI2C_MCCR0_DATAVD_MASK) >> LPI2C_MCCR0_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR0_DATAVD(base) (LPI2C_RD_MCCR0_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR0_DATAVD(base, value) (LPI2C_RMW_MCCR0(base, LPI2C_MCCR0_DATAVD_MASK, LPI2C_MCCR0_DATAVD(value)))
#define LPI2C_BWR_MCCR0_DATAVD(base, value) (LPI2C_WR_MCCR0_DATAVD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MCCR1 - Master Clock Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_MCCR1 - Master Clock Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MCCR1 cannot be changed when the I2C master is enabled and is used for
 * high speed mode transfers. The separate clock configuration for high speed mode
 * allows arbitration to take place in Fast mode (with timing configured by
 * MCCR0), before switching to high speed mode (with timing configured by MCCR1).
 */
/*!
 * @name Constants and macros for entire LPI2C_MCCR1 register
 */
/*@{*/
#define LPI2C_RD_MCCR1(base)     (LPI2C_MCCR1_REG(base))
#define LPI2C_WR_MCCR1(base, value) (LPI2C_MCCR1_REG(base) = (value))
#define LPI2C_RMW_MCCR1(base, mask, value) (LPI2C_WR_MCCR1(base, (LPI2C_RD_MCCR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) |  (value)))
#define LPI2C_CLR_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) & ~(value)))
#define LPI2C_TOG_MCCR1(base, value) (LPI2C_WR_MCCR1(base, LPI2C_RD_MCCR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MCCR1 bitfields
 */

/*!
 * @name Register LPI2C_MCCR1, field CLKLO[5:0] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven low by the
 * master. This value is also used for the minimum bus free time between a STOP
 * and a START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKLO field. */
#define LPI2C_RD_MCCR1_CLKLO(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKLO_MASK) >> LPI2C_MCCR1_CLKLO_SHIFT)
#define LPI2C_BRD_MCCR1_CLKLO(base) (LPI2C_RD_MCCR1_CLKLO(base))

/*! @brief Set the CLKLO field to a new value. */
#define LPI2C_WR_MCCR1_CLKLO(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKLO_MASK, LPI2C_MCCR1_CLKLO(value)))
#define LPI2C_BWR_MCCR1_CLKLO(base, value) (LPI2C_WR_MCCR1_CLKLO(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field CLKHI[13:8] (RW)
 *
 * Minimum number of cycles (minus one) that the SCL clock is driven high by the
 * master. The SCL high time is extended by the time it takes to detect a rising
 * edge on the external SCL pin. Ignoring any additional board delay due to
 * external loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_CLKHI field. */
#define LPI2C_RD_MCCR1_CLKHI(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_CLKHI_MASK) >> LPI2C_MCCR1_CLKHI_SHIFT)
#define LPI2C_BRD_MCCR1_CLKHI(base) (LPI2C_RD_MCCR1_CLKHI(base))

/*! @brief Set the CLKHI field to a new value. */
#define LPI2C_WR_MCCR1_CLKHI(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_CLKHI_MASK, LPI2C_MCCR1_CLKHI(value)))
#define LPI2C_BWR_MCCR1_CLKHI(base, value) (LPI2C_WR_MCCR1_CLKHI(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field SETHOLD[21:16] (RW)
 *
 * Minimum number of cycles (minus one) that is used by the master as the setup
 * and hold time for a (repeated) START condition and setup time for a STOP
 * condition. The setup time is extended by the time it takes to detect a rising edge
 * on the external SCL pin. Ignoring any additional board delay due to external
 * loading, this is equal to (2 + FILTSCL) / 2^PRESCALE cycles.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_SETHOLD field. */
#define LPI2C_RD_MCCR1_SETHOLD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_SETHOLD_MASK) >> LPI2C_MCCR1_SETHOLD_SHIFT)
#define LPI2C_BRD_MCCR1_SETHOLD(base) (LPI2C_RD_MCCR1_SETHOLD(base))

/*! @brief Set the SETHOLD field to a new value. */
#define LPI2C_WR_MCCR1_SETHOLD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_SETHOLD_MASK, LPI2C_MCCR1_SETHOLD(value)))
#define LPI2C_BWR_MCCR1_SETHOLD(base, value) (LPI2C_WR_MCCR1_SETHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MCCR1, field DATAVD[29:24] (RW)
 *
 * Minimum number of cycles (minus one) that is used as the data hold time for
 * SDA. Must be configured less than the minimum SCL low period.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MCCR1_DATAVD field. */
#define LPI2C_RD_MCCR1_DATAVD(base) ((LPI2C_MCCR1_REG(base) & LPI2C_MCCR1_DATAVD_MASK) >> LPI2C_MCCR1_DATAVD_SHIFT)
#define LPI2C_BRD_MCCR1_DATAVD(base) (LPI2C_RD_MCCR1_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_MCCR1_DATAVD(base, value) (LPI2C_RMW_MCCR1(base, LPI2C_MCCR1_DATAVD_MASK, LPI2C_MCCR1_DATAVD(value)))
#define LPI2C_BWR_MCCR1_DATAVD(base, value) (LPI2C_WR_MCCR1_DATAVD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MFCR - Master FIFO Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFCR - Master FIFO Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFCR register
 */
/*@{*/
#define LPI2C_RD_MFCR(base)      (LPI2C_MFCR_REG(base))
#define LPI2C_WR_MFCR(base, value) (LPI2C_MFCR_REG(base) = (value))
#define LPI2C_RMW_MFCR(base, mask, value) (LPI2C_WR_MFCR(base, (LPI2C_RD_MFCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) |  (value)))
#define LPI2C_CLR_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) & ~(value)))
#define LPI2C_TOG_MFCR(base, value) (LPI2C_WR_MFCR(base, LPI2C_RD_MFCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFCR bitfields
 */

/*!
 * @name Register LPI2C_MFCR, field TXWATER[7:0] (RW)
 *
 * The Transmit Data Flag is set whenever the number of words in the transmit
 * FIFO is equal or less than TXWATER. Writing a value equal or greater than the
 * FIFO size will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_TXWATER field. */
#define LPI2C_RD_MFCR_TXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_TXWATER_MASK) >> LPI2C_MFCR_TXWATER_SHIFT)
#define LPI2C_BRD_MFCR_TXWATER(base) (LPI2C_RD_MFCR_TXWATER(base))

/*! @brief Set the TXWATER field to a new value. */
#define LPI2C_WR_MFCR_TXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_TXWATER_MASK, LPI2C_MFCR_TXWATER(value)))
#define LPI2C_BWR_MFCR_TXWATER(base, value) (LPI2C_WR_MFCR_TXWATER(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MFCR, field RXWATER[23:16] (RW)
 *
 * The Receive Data Flag is set whenever the number of words in the receive FIFO
 * is greater than RXWATER. Writing a value equal or greater than the FIFO size
 * will be truncated.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFCR_RXWATER field. */
#define LPI2C_RD_MFCR_RXWATER(base) ((LPI2C_MFCR_REG(base) & LPI2C_MFCR_RXWATER_MASK) >> LPI2C_MFCR_RXWATER_SHIFT)
#define LPI2C_BRD_MFCR_RXWATER(base) (LPI2C_RD_MFCR_RXWATER(base))

/*! @brief Set the RXWATER field to a new value. */
#define LPI2C_WR_MFCR_RXWATER(base, value) (LPI2C_RMW_MFCR(base, LPI2C_MFCR_RXWATER_MASK, LPI2C_MFCR_RXWATER(value)))
#define LPI2C_BWR_MFCR_RXWATER(base, value) (LPI2C_WR_MFCR_RXWATER(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MFSR - Master FIFO Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MFSR - Master FIFO Status Register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MFSR register
 */
/*@{*/
#define LPI2C_RD_MFSR(base)      (LPI2C_MFSR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MFSR bitfields
 */

/*!
 * @name Register LPI2C_MFSR, field TXCOUNT[7:0] (RO)
 *
 * Returns the number of words in the transmit FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_TXCOUNT field. */
#define LPI2C_RD_MFSR_TXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_TXCOUNT_MASK) >> LPI2C_MFSR_TXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_TXCOUNT(base) (LPI2C_RD_MFSR_TXCOUNT(base))
/*@}*/

/*!
 * @name Register LPI2C_MFSR, field RXCOUNT[23:16] (RO)
 *
 * Returns the number of words in the receive FIFO.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MFSR_RXCOUNT field. */
#define LPI2C_RD_MFSR_RXCOUNT(base) ((LPI2C_MFSR_REG(base) & LPI2C_MFSR_RXCOUNT_MASK) >> LPI2C_MFSR_RXCOUNT_SHIFT)
#define LPI2C_BRD_MFSR_RXCOUNT(base) (LPI2C_RD_MFSR_RXCOUNT(base))
/*@}*/

/*******************************************************************************
 * LPI2C_MTDR - Master Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MTDR - Master Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 *
 * An 8-bit write to the CMD field will store the data in the Command FIFO, but
 * does not increment the FIFO write pointer. An 8-bit write to the DATA field
 * will zero extend the CMD field unless the CMD field has been written separately
 * since the last FIFO write, it also increments the FIFO write pointer. A 16-bit
 * or 32-bit will write both the CMD and DATA fields and increment the FIFO.
 */
/*!
 * @name Constants and macros for entire LPI2C_MTDR register
 */
/*@{*/
#define LPI2C_RD_MTDR(base)      (LPI2C_MTDR_REG(base))
#define LPI2C_WR_MTDR(base, value) (LPI2C_MTDR_REG(base) = (value))
#define LPI2C_RMW_MTDR(base, mask, value) (LPI2C_WR_MTDR(base, (LPI2C_RD_MTDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MTDR bitfields
 */

/*!
 * @name Register LPI2C_MTDR, field DATA[7:0] (WO)
 *
 * Performing an 8-bit write to DATA will zero extend the CMD field.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_MTDR_DATA(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_DATA_MASK, LPI2C_MTDR_DATA(value)))
#define LPI2C_BWR_MTDR_DATA(base, value) (LPI2C_WR_MTDR_DATA(base, value))
/*@}*/

/*!
 * @name Register LPI2C_MTDR, field CMD[10:8] (WO)
 *
 * Values:
 * - 000 - Transmit DATA[7:0].
 * - 001 - Receive (DATA[7:0] + 1) bytes.
 * - 010 - Generate STOP condition.
 * - 011 - Receive and discard (DATA[7:0] + 1) bytes.
 * - 100 - Generate (repeated) START and transmit address in DATA[7:0].
 * - 101 - Generate (repeated) START and transmit address in DATA[7:0]. This
 *     transfer expects a NACK to be returned.
 * - 110 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode.
 * - 111 - Generate (repeated) START and transmit address in DATA[7:0] using
 *     high speed mode. This transfer expects a NACK to be returned.
 */
/*@{*/
/*! @brief Set the CMD field to a new value. */
#define LPI2C_WR_MTDR_CMD(base, value) (LPI2C_RMW_MTDR(base, LPI2C_MTDR_CMD_MASK, LPI2C_MTDR_CMD(value)))
#define LPI2C_BWR_MTDR_CMD(base, value) (LPI2C_WR_MTDR_CMD(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_MRDR - Master Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_MRDR - Master Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_MRDR register
 */
/*@{*/
#define LPI2C_RD_MRDR(base)      (LPI2C_MRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_MRDR bitfields
 */

/*!
 * @name Register LPI2C_MRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C master that has
 * not been discarded. Receive data can be discarded due to the CMD field or the
 * master can be configured to discard non-matching data.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_DATA field. */
#define LPI2C_RD_MRDR_DATA(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_DATA_MASK) >> LPI2C_MRDR_DATA_SHIFT)
#define LPI2C_BRD_MRDR_DATA(base) (LPI2C_RD_MRDR_DATA(base))
/*@}*/

/*!
 * @name Register LPI2C_MRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0 - Receive FIFO is not empty.
 * - 1 - Receive FIFO is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_MRDR_RXEMPTY field. */
#define LPI2C_RD_MRDR_RXEMPTY(base) ((LPI2C_MRDR_REG(base) & LPI2C_MRDR_RXEMPTY_MASK) >> LPI2C_MRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_MRDR_RXEMPTY(base) (BITBAND_ACCESS32(&LPI2C_MRDR_REG(base), LPI2C_MRDR_RXEMPTY_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_SCR - Slave Control Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SCR - Slave Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SCR register
 */
/*@{*/
#define LPI2C_RD_SCR(base)       (LPI2C_SCR_REG(base))
#define LPI2C_WR_SCR(base, value) (LPI2C_SCR_REG(base) = (value))
#define LPI2C_RMW_SCR(base, mask, value) (LPI2C_WR_SCR(base, (LPI2C_RD_SCR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) |  (value)))
#define LPI2C_CLR_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) & ~(value)))
#define LPI2C_TOG_SCR(base, value) (LPI2C_WR_SCR(base, LPI2C_RD_SCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCR bitfields
 */

/*!
 * @name Register LPI2C_SCR, field SEN[0] (RW)
 *
 * Values:
 * - 0 - Slave mode is disabled.
 * - 1 - Slave mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_SEN field. */
#define LPI2C_RD_SCR_SEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_SEN_MASK) >> LPI2C_SCR_SEN_SHIFT)
#define LPI2C_BRD_SCR_SEN(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_SEN_SHIFT))

/*! @brief Set the SEN field to a new value. */
#define LPI2C_WR_SCR_SEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_SEN_MASK, LPI2C_SCR_SEN(value)))
#define LPI2C_BWR_SCR_SEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_SEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RST[1] (RW)
 *
 * Values:
 * - 0 - Slave logic is not reset.
 * - 1 - Slave logic is reset.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_RST field. */
#define LPI2C_RD_SCR_RST(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_RST_MASK) >> LPI2C_SCR_RST_SHIFT)
#define LPI2C_BRD_SCR_RST(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define LPI2C_WR_SCR_RST(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RST_MASK, LPI2C_SCR_RST(value)))
#define LPI2C_BWR_SCR_RST(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTEN[4] (RW)
 *
 * Values:
 * - 0 - Disable digital filter and output delay counter for slave mode.
 * - 1 - Enable digital filter and output delay counter for slave mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTEN field. */
#define LPI2C_RD_SCR_FILTEN(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTEN_MASK) >> LPI2C_SCR_FILTEN_SHIFT)
#define LPI2C_BRD_SCR_FILTEN(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTEN_SHIFT))

/*! @brief Set the FILTEN field to a new value. */
#define LPI2C_WR_SCR_FILTEN(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTEN_MASK, LPI2C_SCR_FILTEN(value)))
#define LPI2C_BWR_SCR_FILTEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field FILTDZ[5] (RW)
 *
 * Values:
 * - 0 - Filter remains enabled in Doze mode.
 * - 1 - Filter is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCR_FILTDZ field. */
#define LPI2C_RD_SCR_FILTDZ(base) ((LPI2C_SCR_REG(base) & LPI2C_SCR_FILTDZ_MASK) >> LPI2C_SCR_FILTDZ_SHIFT)
#define LPI2C_BRD_SCR_FILTDZ(base) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTDZ_SHIFT))

/*! @brief Set the FILTDZ field to a new value. */
#define LPI2C_WR_SCR_FILTDZ(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_FILTDZ_MASK, LPI2C_SCR_FILTDZ(value)))
#define LPI2C_BWR_SCR_FILTDZ(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_FILTDZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RTF[8] (WORZ)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Transmit Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RTF field to a new value. */
#define LPI2C_WR_SCR_RTF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RTF_MASK, LPI2C_SCR_RTF(value)))
#define LPI2C_BWR_SCR_RTF(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCR, field RRF[9] (WORZ)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Receive Data Register is now empty.
 */
/*@{*/
/*! @brief Set the RRF field to a new value. */
#define LPI2C_WR_SCR_RRF(base, value) (LPI2C_RMW_SCR(base, LPI2C_SCR_RRF_MASK, LPI2C_SCR_RRF(value)))
#define LPI2C_BWR_SCR_RRF(base, value) (BITBAND_ACCESS32(&LPI2C_SCR_REG(base), LPI2C_SCR_RRF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SSR - Slave Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SSR - Slave Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SSR register
 */
/*@{*/
#define LPI2C_RD_SSR(base)       (LPI2C_SSR_REG(base))
#define LPI2C_WR_SSR(base, value) (LPI2C_SSR_REG(base) = (value))
#define LPI2C_RMW_SSR(base, mask, value) (LPI2C_WR_SSR(base, (LPI2C_RD_SSR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) |  (value)))
#define LPI2C_CLR_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) & ~(value)))
#define LPI2C_TOG_SSR(base, value) (LPI2C_WR_SSR(base, LPI2C_RD_SSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SSR bitfields
 */

/*!
 * @name Register LPI2C_SSR, field TDF[0] (RO)
 *
 * This flag is cleared by writing the transmit data register. When TXCFG is
 * clear, it is also cleared if a NACK or Repeated START or STOP condition is
 * detected.
 *
 * Values:
 * - 0 - Transmit data not requested.
 * - 1 - Transmit data is requested.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TDF field. */
#define LPI2C_RD_SSR_TDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TDF_MASK) >> LPI2C_SSR_TDF_SHIFT)
#define LPI2C_BRD_SSR_TDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_TDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RDF[1] (RO)
 *
 * This flag is cleared by reading the receive data register. When RXCFG is set,
 * this flag is not cleared when reading the receive data register and AVF is
 * set.
 *
 * Values:
 * - 0 - Receive Data is not ready.
 * - 1 - Receive data is ready.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RDF field. */
#define LPI2C_RD_SSR_RDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RDF_MASK) >> LPI2C_SSR_RDF_SHIFT)
#define LPI2C_BRD_SSR_RDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RDF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AVF[2] (RO)
 *
 * This flag is cleared by reading the address status register. When RXCFG is
 * set, this flag is also cleared by reading the receive data register.
 *
 * Values:
 * - 0 - Address Status Register is not valid.
 * - 1 - Address Status Register is valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AVF field. */
#define LPI2C_RD_SSR_AVF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AVF_MASK) >> LPI2C_SSR_AVF_SHIFT)
#define LPI2C_BRD_SSR_AVF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AVF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field TAF[3] (RO)
 *
 * This flag is cleared by writing the transmit ACK register.
 *
 * Values:
 * - 0 - Transmit ACK/NACK is not required.
 * - 1 - Transmit ACK/NACK is required.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_TAF field. */
#define LPI2C_RD_SSR_TAF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_TAF_MASK) >> LPI2C_SSR_TAF_SHIFT)
#define LPI2C_BRD_SSR_TAF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_TAF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field RSF[8] (W1C)
 *
 * This flag will set when the LPI2C slave detects a repeated START condition,
 * provided the LPI2C slave matched the last address byte. It does not set when
 * the slave first detects a START condition.
 *
 * Values:
 * - 0 - Slave has not detected a Repeated START condition.
 * - 1 - Slave has detected a Repeated START condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_RSF field. */
#define LPI2C_RD_SSR_RSF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_RSF_MASK) >> LPI2C_SSR_RSF_SHIFT)
#define LPI2C_BRD_SSR_RSF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RSF_SHIFT))

/*! @brief Set the RSF field to a new value. */
#define LPI2C_WR_SSR_RSF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_RSF(value)))
#define LPI2C_BWR_SSR_RSF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_RSF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SDF[9] (W1C)
 *
 * This flag will set when the LPI2C slave detects a STOP condition, provided
 * the LPI2C slave matched the last address byte.
 *
 * Values:
 * - 0 - Slave has not detected a STOP condition.
 * - 1 - Slave has detected a STOP condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SDF field. */
#define LPI2C_RD_SSR_SDF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SDF_MASK) >> LPI2C_SSR_SDF_SHIFT)
#define LPI2C_BRD_SSR_SDF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SDF_SHIFT))

/*! @brief Set the SDF field to a new value. */
#define LPI2C_WR_SSR_SDF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_SDF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_BEF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_SDF(value)))
#define LPI2C_BWR_SSR_SDF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BEF[10] (W1C)
 *
 * This flag will set if the LPI2C slave transmits a logic one and detects a
 * logic zero on the I2C bus. The slave will ignore the rest of the transfer until
 * the next (repeated) START condition.
 *
 * Values:
 * - 0 - Slave has not detected a bit error.
 * - 1 - Slave has detected a bit error.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BEF field. */
#define LPI2C_RD_SSR_BEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BEF_MASK) >> LPI2C_SSR_BEF_SHIFT)
#define LPI2C_BRD_SSR_BEF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BEF_SHIFT))

/*! @brief Set the BEF field to a new value. */
#define LPI2C_WR_SSR_BEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_BEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_FEF_MASK), LPI2C_SSR_BEF(value)))
#define LPI2C_BWR_SSR_BEF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field FEF[11] (W1C)
 *
 * FIFO error flag can only set when clock stretching is disabled.
 *
 * Values:
 * - 0 - FIFO underflow or overflow not detected.
 * - 1 - FIFO underflow or overflow detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_FEF field. */
#define LPI2C_RD_SSR_FEF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_FEF_MASK) >> LPI2C_SSR_FEF_SHIFT)
#define LPI2C_BRD_SSR_FEF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_FEF_SHIFT))

/*! @brief Set the FEF field to a new value. */
#define LPI2C_WR_SSR_FEF(base, value) (LPI2C_RMW_SSR(base, (LPI2C_SSR_FEF_MASK | LPI2C_SSR_RSF_MASK | LPI2C_SSR_SDF_MASK | LPI2C_SSR_BEF_MASK), LPI2C_SSR_FEF(value)))
#define LPI2C_BWR_SSR_FEF(base, value) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_FEF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM0F[12] (RO)
 *
 * Indicates that the received address has matched the ADDR0 field as configured
 * by ADDRCFG. This flag is cleared by reading the Address Status Register. This
 * flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0 - Have not received ADDR0 matching address.
 * - 1 - Have received ADDR0 matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM0F field. */
#define LPI2C_RD_SSR_AM0F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM0F_MASK) >> LPI2C_SSR_AM0F_SHIFT)
#define LPI2C_BRD_SSR_AM0F(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM0F_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field AM1F[13] (RO)
 *
 * Indicates that the received address has matched the ADDR1 field or ADDR0 to
 * ADDR1 range as configured by ADDRCFG. This flag is cleared by reading the
 * Address Status Register. This flag cannot generate an asynchronous wakeup.
 *
 * Values:
 * - 0 - Have not received ADDR1 or ADDR0/ADDR1 range matching address.
 * - 1 - Have received ADDR1 or ADDR0/ADDR1 range matching address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_AM1F field. */
#define LPI2C_RD_SSR_AM1F(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_AM1F_MASK) >> LPI2C_SSR_AM1F_SHIFT)
#define LPI2C_BRD_SSR_AM1F(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_AM1F_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field GCF[14] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0 - Slave has not detected the General Call Address or General Call Address
 *     disabled.
 * - 1 - Slave has detected the General Call Address.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_GCF field. */
#define LPI2C_RD_SSR_GCF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_GCF_MASK) >> LPI2C_SSR_GCF_SHIFT)
#define LPI2C_BRD_SSR_GCF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_GCF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SARF[15] (RO)
 *
 * This flag is cleared by reading the Address Status Register. This flag cannot
 * generate an asynchronous wakeup.
 *
 * Values:
 * - 0 - SMBus Alert Response disabled or not detected.
 * - 1 - SMBus Alert Response enabled and detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SARF field. */
#define LPI2C_RD_SSR_SARF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SARF_MASK) >> LPI2C_SSR_SARF_SHIFT)
#define LPI2C_BRD_SSR_SARF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SARF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field SBF[24] (RO)
 *
 * Values:
 * - 0 - I2C Slave is idle.
 * - 1 - I2C Slave is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_SBF field. */
#define LPI2C_RD_SSR_SBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_SBF_MASK) >> LPI2C_SSR_SBF_SHIFT)
#define LPI2C_BRD_SSR_SBF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_SBF_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SSR, field BBF[25] (RO)
 *
 * Values:
 * - 0 - I2C Bus is idle.
 * - 1 - I2C Bus is busy.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SSR_BBF field. */
#define LPI2C_RD_SSR_BBF(base) ((LPI2C_SSR_REG(base) & LPI2C_SSR_BBF_MASK) >> LPI2C_SSR_BBF_SHIFT)
#define LPI2C_BRD_SSR_BBF(base) (BITBAND_ACCESS32(&LPI2C_SSR_REG(base), LPI2C_SSR_BBF_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_SIER - Slave Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SIER - Slave Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SIER register
 */
/*@{*/
#define LPI2C_RD_SIER(base)      (LPI2C_SIER_REG(base))
#define LPI2C_WR_SIER(base, value) (LPI2C_SIER_REG(base) = (value))
#define LPI2C_RMW_SIER(base, mask, value) (LPI2C_WR_SIER(base, (LPI2C_RD_SIER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) |  (value)))
#define LPI2C_CLR_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) & ~(value)))
#define LPI2C_TOG_SIER(base, value) (LPI2C_WR_SIER(base, LPI2C_RD_SIER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SIER bitfields
 */

/*!
 * @name Register LPI2C_SIER, field TDIE[0] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TDIE field. */
#define LPI2C_RD_SIER_TDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TDIE_MASK) >> LPI2C_SIER_TDIE_SHIFT)
#define LPI2C_BRD_SIER_TDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TDIE_SHIFT))

/*! @brief Set the TDIE field to a new value. */
#define LPI2C_WR_SIER_TDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TDIE_MASK, LPI2C_SIER_TDIE(value)))
#define LPI2C_BWR_SIER_TDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RDIE[1] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RDIE field. */
#define LPI2C_RD_SIER_RDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RDIE_MASK) >> LPI2C_SIER_RDIE_SHIFT)
#define LPI2C_BRD_SIER_RDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RDIE_SHIFT))

/*! @brief Set the RDIE field to a new value. */
#define LPI2C_WR_SIER_RDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RDIE_MASK, LPI2C_SIER_RDIE(value)))
#define LPI2C_BWR_SIER_RDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AVIE[2] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AVIE field. */
#define LPI2C_RD_SIER_AVIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AVIE_MASK) >> LPI2C_SIER_AVIE_SHIFT)
#define LPI2C_BRD_SIER_AVIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AVIE_SHIFT))

/*! @brief Set the AVIE field to a new value. */
#define LPI2C_WR_SIER_AVIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AVIE_MASK, LPI2C_SIER_AVIE(value)))
#define LPI2C_BWR_SIER_AVIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AVIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field TAIE[3] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_TAIE field. */
#define LPI2C_RD_SIER_TAIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_TAIE_MASK) >> LPI2C_SIER_TAIE_SHIFT)
#define LPI2C_BRD_SIER_TAIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TAIE_SHIFT))

/*! @brief Set the TAIE field to a new value. */
#define LPI2C_WR_SIER_TAIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_TAIE_MASK, LPI2C_SIER_TAIE(value)))
#define LPI2C_BWR_SIER_TAIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_TAIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field RSIE[8] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_RSIE field. */
#define LPI2C_RD_SIER_RSIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_RSIE_MASK) >> LPI2C_SIER_RSIE_SHIFT)
#define LPI2C_BRD_SIER_RSIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RSIE_SHIFT))

/*! @brief Set the RSIE field to a new value. */
#define LPI2C_WR_SIER_RSIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_RSIE_MASK, LPI2C_SIER_RSIE(value)))
#define LPI2C_BWR_SIER_RSIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_RSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SDIE[9] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SDIE field. */
#define LPI2C_RD_SIER_SDIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SDIE_MASK) >> LPI2C_SIER_SDIE_SHIFT)
#define LPI2C_BRD_SIER_SDIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SDIE_SHIFT))

/*! @brief Set the SDIE field to a new value. */
#define LPI2C_WR_SIER_SDIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SDIE_MASK, LPI2C_SIER_SDIE(value)))
#define LPI2C_BWR_SIER_SDIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field BEIE[10] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_BEIE field. */
#define LPI2C_RD_SIER_BEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_BEIE_MASK) >> LPI2C_SIER_BEIE_SHIFT)
#define LPI2C_BRD_SIER_BEIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_BEIE_SHIFT))

/*! @brief Set the BEIE field to a new value. */
#define LPI2C_WR_SIER_BEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_BEIE_MASK, LPI2C_SIER_BEIE(value)))
#define LPI2C_BWR_SIER_BEIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_BEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field FEIE[11] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_FEIE field. */
#define LPI2C_RD_SIER_FEIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_FEIE_MASK) >> LPI2C_SIER_FEIE_SHIFT)
#define LPI2C_BRD_SIER_FEIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPI2C_WR_SIER_FEIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_FEIE_MASK, LPI2C_SIER_FEIE(value)))
#define LPI2C_BWR_SIER_FEIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM0IE[12] (RW)
 *
 * Values:
 * - 0 - Interrupt enabled.
 * - 1 - Interrupt disabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM0IE field. */
#define LPI2C_RD_SIER_AM0IE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM0IE_MASK) >> LPI2C_SIER_AM0IE_SHIFT)
#define LPI2C_BRD_SIER_AM0IE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM0IE_SHIFT))

/*! @brief Set the AM0IE field to a new value. */
#define LPI2C_WR_SIER_AM0IE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM0IE_MASK, LPI2C_SIER_AM0IE(value)))
#define LPI2C_BWR_SIER_AM0IE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM0IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field AM1F[13] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_AM1F field. */
#define LPI2C_RD_SIER_AM1F(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_AM1F_MASK) >> LPI2C_SIER_AM1F_SHIFT)
#define LPI2C_BRD_SIER_AM1F(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM1F_SHIFT))

/*! @brief Set the AM1F field to a new value. */
#define LPI2C_WR_SIER_AM1F(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_AM1F_MASK, LPI2C_SIER_AM1F(value)))
#define LPI2C_BWR_SIER_AM1F(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_AM1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field GCIE[14] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_GCIE field. */
#define LPI2C_RD_SIER_GCIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_GCIE_MASK) >> LPI2C_SIER_GCIE_SHIFT)
#define LPI2C_BRD_SIER_GCIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_GCIE_SHIFT))

/*! @brief Set the GCIE field to a new value. */
#define LPI2C_WR_SIER_GCIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_GCIE_MASK, LPI2C_SIER_GCIE(value)))
#define LPI2C_BWR_SIER_GCIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_GCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SIER, field SARIE[15] (RW)
 *
 * Values:
 * - 0 - Interrupt disabled.
 * - 1 - Interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SIER_SARIE field. */
#define LPI2C_RD_SIER_SARIE(base) ((LPI2C_SIER_REG(base) & LPI2C_SIER_SARIE_MASK) >> LPI2C_SIER_SARIE_SHIFT)
#define LPI2C_BRD_SIER_SARIE(base) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SARIE_SHIFT))

/*! @brief Set the SARIE field to a new value. */
#define LPI2C_WR_SIER_SARIE(base, value) (LPI2C_RMW_SIER(base, LPI2C_SIER_SARIE_MASK, LPI2C_SIER_SARIE(value)))
#define LPI2C_BWR_SIER_SARIE(base, value) (BITBAND_ACCESS32(&LPI2C_SIER_REG(base), LPI2C_SIER_SARIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SDER - Slave DMA Enable Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SDER - Slave DMA Enable Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SDER register
 */
/*@{*/
#define LPI2C_RD_SDER(base)      (LPI2C_SDER_REG(base))
#define LPI2C_WR_SDER(base, value) (LPI2C_SDER_REG(base) = (value))
#define LPI2C_RMW_SDER(base, mask, value) (LPI2C_WR_SDER(base, (LPI2C_RD_SDER(base) & ~(mask)) | (value)))
#define LPI2C_SET_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) |  (value)))
#define LPI2C_CLR_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) & ~(value)))
#define LPI2C_TOG_SDER(base, value) (LPI2C_WR_SDER(base, LPI2C_RD_SDER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SDER bitfields
 */

/*!
 * @name Register LPI2C_SDER, field TDDE[0] (RW)
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_TDDE field. */
#define LPI2C_RD_SDER_TDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_TDDE_MASK) >> LPI2C_SDER_TDDE_SHIFT)
#define LPI2C_BRD_SDER_TDDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_TDDE_SHIFT))

/*! @brief Set the TDDE field to a new value. */
#define LPI2C_WR_SDER_TDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_TDDE_MASK, LPI2C_SDER_TDDE(value)))
#define LPI2C_BWR_SDER_TDDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_TDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field RDDE[1] (RW)
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_RDDE field. */
#define LPI2C_RD_SDER_RDDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_RDDE_MASK) >> LPI2C_SDER_RDDE_SHIFT)
#define LPI2C_BRD_SDER_RDDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_RDDE_SHIFT))

/*! @brief Set the RDDE field to a new value. */
#define LPI2C_WR_SDER_RDDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_RDDE_MASK, LPI2C_SDER_RDDE(value)))
#define LPI2C_BWR_SDER_RDDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_RDDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SDER, field AVDE[2] (RW)
 *
 * The Address Valid DMA request is shared with the Receive Data DMA request. If
 * both are enabled, then set RXCFG to allow the DMA to read the address from
 * the Receive Data Register.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SDER_AVDE field. */
#define LPI2C_RD_SDER_AVDE(base) ((LPI2C_SDER_REG(base) & LPI2C_SDER_AVDE_MASK) >> LPI2C_SDER_AVDE_SHIFT)
#define LPI2C_BRD_SDER_AVDE(base) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_AVDE_SHIFT))

/*! @brief Set the AVDE field to a new value. */
#define LPI2C_WR_SDER_AVDE(base, value) (LPI2C_RMW_SDER(base, LPI2C_SDER_AVDE_MASK, LPI2C_SDER_AVDE(value)))
#define LPI2C_BWR_SDER_AVDE(base, value) (BITBAND_ACCESS32(&LPI2C_SDER_REG(base), LPI2C_SDER_AVDE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR1 - Slave Configuration Register 1
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR1 - Slave Configuration Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR1 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR1 register
 */
/*@{*/
#define LPI2C_RD_SCFGR1(base)    (LPI2C_SCFGR1_REG(base))
#define LPI2C_WR_SCFGR1(base, value) (LPI2C_SCFGR1_REG(base) = (value))
#define LPI2C_RMW_SCFGR1(base, mask, value) (LPI2C_WR_SCFGR1(base, (LPI2C_RD_SCFGR1(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) |  (value)))
#define LPI2C_CLR_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) & ~(value)))
#define LPI2C_TOG_SCFGR1(base, value) (LPI2C_WR_SCFGR1(base, LPI2C_RD_SCFGR1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR1 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR1, field ADRSTALL[0] (RW)
 *
 * Enables SCL clock stretching when the address valid flag is asserted. Clock
 * stretching only occurs following the 9th bit and is therefore compatible with
 * high speed mode.
 *
 * Values:
 * - 0 - Clock stretching disabled.
 * - 1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADRSTALL field. */
#define LPI2C_RD_SCFGR1_ADRSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADRSTALL_MASK) >> LPI2C_SCFGR1_ADRSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ADRSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADRSTALL_SHIFT))

/*! @brief Set the ADRSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ADRSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADRSTALL_MASK, LPI2C_SCFGR1_ADRSTALL(value)))
#define LPI2C_BWR_SCFGR1_ADRSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ADRSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXSTALL[1] (RW)
 *
 * Enables SCL clock stretching when receive data flag is set during a
 * slave-receive transfer. Clock stretching occurs following the 9th bit and is therefore
 * compatible with high speed mode.
 *
 * Values:
 * - 0 - Clock stretching disabled.
 * - 1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXSTALL field. */
#define LPI2C_RD_SCFGR1_RXSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXSTALL_MASK) >> LPI2C_SCFGR1_RXSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_RXSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXSTALL_SHIFT))

/*! @brief Set the RXSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_RXSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXSTALL_MASK, LPI2C_SCFGR1_RXSTALL(value)))
#define LPI2C_BWR_SCFGR1_RXSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXDSTALL[2] (RW)
 *
 * Enables SCL clock stretching when the transmit data flag is set during a
 * slave-transmit transfer. Clock stretching occurs following the 9th bit and is
 * therefore compatible with high speed mode.
 *
 * Values:
 * - 0 - Clock stretching disabled.
 * - 1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXDSTALL field. */
#define LPI2C_RD_SCFGR1_TXDSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXDSTALL_MASK) >> LPI2C_SCFGR1_TXDSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_TXDSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXDSTALL_SHIFT))

/*! @brief Set the TXDSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_TXDSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXDSTALL_MASK, LPI2C_SCFGR1_TXDSTALL(value)))
#define LPI2C_BWR_SCFGR1_TXDSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXDSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ACKSTALL[3] (RW)
 *
 * Enables SCL clock stretching during slave-transmit address byte(s) and
 * slave-receiver address and data byte(s) to allow software to write the Transmit ACK
 * Register before the ACK or NACK is transmitted. Clock stretching occurs when
 * transmitting the 9th bit and is therefore not compatible with high speed mode.
 * When ACKSTALL is enabled, there is no need to set either RXSTALL or ADRSTALL
 *
 * Values:
 * - 0 - Clock stretching disabled.
 * - 1 - Clock stretching enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ACKSTALL field. */
#define LPI2C_RD_SCFGR1_ACKSTALL(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ACKSTALL_MASK) >> LPI2C_SCFGR1_ACKSTALL_SHIFT)
#define LPI2C_BRD_SCFGR1_ACKSTALL(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ACKSTALL_SHIFT))

/*! @brief Set the ACKSTALL field to a new value. */
#define LPI2C_WR_SCFGR1_ACKSTALL(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ACKSTALL_MASK, LPI2C_SCFGR1_ACKSTALL(value)))
#define LPI2C_BWR_SCFGR1_ACKSTALL(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_ACKSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field GCEN[8] (RW)
 *
 * Values:
 * - 0 - General Call address is disabled.
 * - 1 - General call address is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_GCEN field. */
#define LPI2C_RD_SCFGR1_GCEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_GCEN_MASK) >> LPI2C_SCFGR1_GCEN_SHIFT)
#define LPI2C_BRD_SCFGR1_GCEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_GCEN_SHIFT))

/*! @brief Set the GCEN field to a new value. */
#define LPI2C_WR_SCFGR1_GCEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_GCEN_MASK, LPI2C_SCFGR1_GCEN(value)))
#define LPI2C_BWR_SCFGR1_GCEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_GCEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field SAEN[9] (RW)
 *
 * Values:
 * - 0 - Disables match on SMBus Alert.
 * - 1 - Enables match on SMBus Alert.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_SAEN field. */
#define LPI2C_RD_SCFGR1_SAEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_SAEN_MASK) >> LPI2C_SCFGR1_SAEN_SHIFT)
#define LPI2C_BRD_SCFGR1_SAEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_SAEN_SHIFT))

/*! @brief Set the SAEN field to a new value. */
#define LPI2C_WR_SCFGR1_SAEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_SAEN_MASK, LPI2C_SCFGR1_SAEN(value)))
#define LPI2C_BWR_SCFGR1_SAEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_SAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field TXCFG[10] (RW)
 *
 * The transmit data flag will always assert before a NACK is detected at the
 * end of a slave-transmit transfer. This can cause an extra word to be written to
 * the transmit data FIFO. When TXCFG=0, the transmit data register is
 * automatically emptied when a slave-transmit transfer is detected. This cause the
 * transmit data flag to assert whenever a slave-transmit transfer is detected and
 * negate at the end of the slave-transmit transfer. When TXCFG=1, the transmit data
 * flag will assert whenver the transit data register is empty and negate when the
 * transmit data register is full. This allows the transmit data register to be
 * filled before a slave-transmit transfer is detected, but can cause the
 * transmit data register to be written before a NACK is detected on the last byte of a
 * slave transmit transfer.
 *
 * Values:
 * - 0 - Transmit Data Flag will only assert during a slave-transmit transfer
 *     when the transmit data register is empty.
 * - 1 - Transmit Data Flag will assert whenever the transmit data register is
 *     empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_TXCFG field. */
#define LPI2C_RD_SCFGR1_TXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_TXCFG_MASK) >> LPI2C_SCFGR1_TXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_TXCFG(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXCFG_SHIFT))

/*! @brief Set the TXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_TXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_TXCFG_MASK, LPI2C_SCFGR1_TXCFG(value)))
#define LPI2C_BWR_SCFGR1_TXCFG(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_TXCFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field RXCFG[11] (RW)
 *
 * Values:
 * - 0 - Reading the receive data register will return receive data and clear
 *     the receive data flag.
 * - 1 - Reading the receive data register when the address valid flag is set
 *     will return the address status register and clear the address valid flag.
 *     Reading the receive data register when the address valid flag is clear will
 *     return receive data and clear the receive data flag.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_RXCFG field. */
#define LPI2C_RD_SCFGR1_RXCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_RXCFG_MASK) >> LPI2C_SCFGR1_RXCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_RXCFG(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXCFG_SHIFT))

/*! @brief Set the RXCFG field to a new value. */
#define LPI2C_WR_SCFGR1_RXCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_RXCFG_MASK, LPI2C_SCFGR1_RXCFG(value)))
#define LPI2C_BWR_SCFGR1_RXCFG(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_RXCFG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field IGNACK[12] (RW)
 *
 * When set, the LPI2C slave will continue transfers after a NACK is detected.
 * This bit is required to be set in Ultra-Fast Mode.
 *
 * Values:
 * - 0 - Slave will end transfer when NACK detected.
 * - 1 - Slave will not end transfer when NACK detected.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_IGNACK field. */
#define LPI2C_RD_SCFGR1_IGNACK(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_IGNACK_MASK) >> LPI2C_SCFGR1_IGNACK_SHIFT)
#define LPI2C_BRD_SCFGR1_IGNACK(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_IGNACK_SHIFT))

/*! @brief Set the IGNACK field to a new value. */
#define LPI2C_WR_SCFGR1_IGNACK(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_IGNACK_MASK, LPI2C_SCFGR1_IGNACK(value)))
#define LPI2C_BWR_SCFGR1_IGNACK(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_IGNACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field HSMEN[13] (RW)
 *
 * Enables detection of the High-speed Mode master code of slave address
 * 0000_1XX, but does not cause an address match on this code. When set and any Hs-mode
 * master code is detected, the FILTEN and ACKSTALL bits are ignored until the
 * next STOP condition is detected.
 *
 * Values:
 * - 0 - Disables detection of Hs-mode master code.
 * - 1 - Enables detection of Hs-mode master code.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_HSMEN field. */
#define LPI2C_RD_SCFGR1_HSMEN(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_HSMEN_MASK) >> LPI2C_SCFGR1_HSMEN_SHIFT)
#define LPI2C_BRD_SCFGR1_HSMEN(base) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_HSMEN_SHIFT))

/*! @brief Set the HSMEN field to a new value. */
#define LPI2C_WR_SCFGR1_HSMEN(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_HSMEN_MASK, LPI2C_SCFGR1_HSMEN(value)))
#define LPI2C_BWR_SCFGR1_HSMEN(base, value) (BITBAND_ACCESS32(&LPI2C_SCFGR1_REG(base), LPI2C_SCFGR1_HSMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR1, field ADDRCFG[18:16] (RW)
 *
 * Configures the condition that will cause an address to match.
 *
 * Values:
 * - 000 - Address match 0 (7-bit).
 * - 001 - Address match 0 (10-bit).
 * - 010 - Address match 0 (7-bit) or Address match 1 (7-bit).
 * - 011 - Address match 0 (10-bit) or Address match 1 (10-bit).
 * - 100 - Address match 0 (7-bit) or Address match 1 (10-bit).
 * - 101 - Address match 0 (10-bit) or Address match 1 (7-bit).
 * - 110 - From Address match 0 (7-bit) to Address match 1 (7-bit).
 * - 111 - From Address match 0 (10-bit) to Address match 1 (10-bit).
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR1_ADDRCFG field. */
#define LPI2C_RD_SCFGR1_ADDRCFG(base) ((LPI2C_SCFGR1_REG(base) & LPI2C_SCFGR1_ADDRCFG_MASK) >> LPI2C_SCFGR1_ADDRCFG_SHIFT)
#define LPI2C_BRD_SCFGR1_ADDRCFG(base) (LPI2C_RD_SCFGR1_ADDRCFG(base))

/*! @brief Set the ADDRCFG field to a new value. */
#define LPI2C_WR_SCFGR1_ADDRCFG(base, value) (LPI2C_RMW_SCFGR1(base, LPI2C_SCFGR1_ADDRCFG_MASK, LPI2C_SCFGR1_ADDRCFG(value)))
#define LPI2C_BWR_SCFGR1_ADDRCFG(base, value) (LPI2C_WR_SCFGR1_ADDRCFG(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SCFGR2 - Slave Configuration Register 2
 ******************************************************************************/

/*!
 * @brief LPI2C_SCFGR2 - Slave Configuration Register 2 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SCFGR2 should only be written when the I2C Slave is disabled.
 */
/*!
 * @name Constants and macros for entire LPI2C_SCFGR2 register
 */
/*@{*/
#define LPI2C_RD_SCFGR2(base)    (LPI2C_SCFGR2_REG(base))
#define LPI2C_WR_SCFGR2(base, value) (LPI2C_SCFGR2_REG(base) = (value))
#define LPI2C_RMW_SCFGR2(base, mask, value) (LPI2C_WR_SCFGR2(base, (LPI2C_RD_SCFGR2(base) & ~(mask)) | (value)))
#define LPI2C_SET_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) |  (value)))
#define LPI2C_CLR_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) & ~(value)))
#define LPI2C_TOG_SCFGR2(base, value) (LPI2C_WR_SCFGR2(base, LPI2C_RD_SCFGR2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SCFGR2 bitfields
 */

/*!
 * @name Register LPI2C_SCFGR2, field CLKHOLD[3:0] (RW)
 *
 * Configures the minimum clock hold time for the I2C slave, when clock
 * stretching is enabled. The minimum hold time is equal to CLKHOLD+3 cycles. The I2C
 * slave clock hold time is not affected by the PRESCALE configuration, and is
 * disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_CLKHOLD field. */
#define LPI2C_RD_SCFGR2_CLKHOLD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_CLKHOLD_MASK) >> LPI2C_SCFGR2_CLKHOLD_SHIFT)
#define LPI2C_BRD_SCFGR2_CLKHOLD(base) (LPI2C_RD_SCFGR2_CLKHOLD(base))

/*! @brief Set the CLKHOLD field to a new value. */
#define LPI2C_WR_SCFGR2_CLKHOLD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_CLKHOLD_MASK, LPI2C_SCFGR2_CLKHOLD(value)))
#define LPI2C_BWR_SCFGR2_CLKHOLD(base, value) (LPI2C_WR_SCFGR2_CLKHOLD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field DATAVD[13:8] (RW)
 *
 * Configures the SDA data valid delay time for the I2C slave equal to
 * FILTSCL+DATAVD+3 cycles. This data valid delay must be configured to less than the
 * minimum SCL low period. The I2C slave data valid delay time is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_DATAVD field. */
#define LPI2C_RD_SCFGR2_DATAVD(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_DATAVD_MASK) >> LPI2C_SCFGR2_DATAVD_SHIFT)
#define LPI2C_BRD_SCFGR2_DATAVD(base) (LPI2C_RD_SCFGR2_DATAVD(base))

/*! @brief Set the DATAVD field to a new value. */
#define LPI2C_WR_SCFGR2_DATAVD(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_DATAVD_MASK, LPI2C_SCFGR2_DATAVD(value)))
#define LPI2C_BWR_SCFGR2_DATAVD(base, value) (LPI2C_WR_SCFGR2_DATAVD(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSCL[19:16] (RW)
 *
 * Configures the I2C slave digital glitch filters for SCL input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSCL
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSCL+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSCL field. */
#define LPI2C_RD_SCFGR2_FILTSCL(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSCL_MASK) >> LPI2C_SCFGR2_FILTSCL_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSCL(base) (LPI2C_RD_SCFGR2_FILTSCL(base))

/*! @brief Set the FILTSCL field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSCL(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSCL_MASK, LPI2C_SCFGR2_FILTSCL(value)))
#define LPI2C_BWR_SCFGR2_FILTSCL(base, value) (LPI2C_WR_SCFGR2_FILTSCL(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SCFGR2, field FILTSDA[27:24] (RW)
 *
 * Configures the I2C slave digital glitch filters for SDA input, a
 * configuration of 0 will disable the glitch filter. Glitches equal to or less than FILTSDA
 * cycles long will be filtered out and ignored. The latency through the glitch
 * filter is equal to FILTSDA+3 cycles and must be configured less than the
 * minimum SCL low or high period. The glitch filter cycle count is not affected by the
 * PRESCALE configuration, and is disabled in high speed mode.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SCFGR2_FILTSDA field. */
#define LPI2C_RD_SCFGR2_FILTSDA(base) ((LPI2C_SCFGR2_REG(base) & LPI2C_SCFGR2_FILTSDA_MASK) >> LPI2C_SCFGR2_FILTSDA_SHIFT)
#define LPI2C_BRD_SCFGR2_FILTSDA(base) (LPI2C_RD_SCFGR2_FILTSDA(base))

/*! @brief Set the FILTSDA field to a new value. */
#define LPI2C_WR_SCFGR2_FILTSDA(base, value) (LPI2C_RMW_SCFGR2(base, LPI2C_SCFGR2_FILTSDA_MASK, LPI2C_SCFGR2_FILTSDA(value)))
#define LPI2C_BWR_SCFGR2_FILTSDA(base, value) (LPI2C_WR_SCFGR2_FILTSDA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SAMR - Slave Address Match Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SAMR - Slave Address Match Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SAMR register
 */
/*@{*/
#define LPI2C_RD_SAMR(base)      (LPI2C_SAMR_REG(base))
#define LPI2C_WR_SAMR(base, value) (LPI2C_SAMR_REG(base) = (value))
#define LPI2C_RMW_SAMR(base, mask, value) (LPI2C_WR_SAMR(base, (LPI2C_RD_SAMR(base) & ~(mask)) | (value)))
#define LPI2C_SET_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) |  (value)))
#define LPI2C_CLR_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) & ~(value)))
#define LPI2C_TOG_SAMR(base, value) (LPI2C_WR_SAMR(base, LPI2C_RD_SAMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SAMR bitfields
 */

/*!
 * @name Register LPI2C_SAMR, field ADDR0[10:1] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR0[10:9] } and the
 * second address byte is compared to ADDR0[8:1]. In 7-bit mode, the address is
 * compared to ADDR0[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR0 field. */
#define LPI2C_RD_SAMR_ADDR0(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR0_MASK) >> LPI2C_SAMR_ADDR0_SHIFT)
#define LPI2C_BRD_SAMR_ADDR0(base) (LPI2C_RD_SAMR_ADDR0(base))

/*! @brief Set the ADDR0 field to a new value. */
#define LPI2C_WR_SAMR_ADDR0(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR0_MASK, LPI2C_SAMR_ADDR0(value)))
#define LPI2C_BWR_SAMR_ADDR0(base, value) (LPI2C_WR_SAMR_ADDR0(base, value))
/*@}*/

/*!
 * @name Register LPI2C_SAMR, field ADDR1[26:17] (RW)
 *
 * Compared against the received address to detect the Slave Address. In 10-bit
 * mode, the first address byte is compared to { 11110, ADDR1[10:9] } and the
 * second address byte is compared to ADDR1[8:1]. In 7-bit mode, the address is
 * compared to ADDR1[7:1].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SAMR_ADDR1 field. */
#define LPI2C_RD_SAMR_ADDR1(base) ((LPI2C_SAMR_REG(base) & LPI2C_SAMR_ADDR1_MASK) >> LPI2C_SAMR_ADDR1_SHIFT)
#define LPI2C_BRD_SAMR_ADDR1(base) (LPI2C_RD_SAMR_ADDR1(base))

/*! @brief Set the ADDR1 field to a new value. */
#define LPI2C_WR_SAMR_ADDR1(base, value) (LPI2C_RMW_SAMR(base, LPI2C_SAMR_ADDR1_MASK, LPI2C_SAMR_ADDR1(value)))
#define LPI2C_BWR_SAMR_ADDR1(base, value) (LPI2C_WR_SAMR_ADDR1(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SASR - Slave Address Status Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SASR - Slave Address Status Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SASR register
 */
/*@{*/
#define LPI2C_RD_SASR(base)      (LPI2C_SASR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SASR bitfields
 */

/*!
 * @name Register LPI2C_SASR, field RADDR[10:0] (RO)
 *
 * RADDR updates whenever the AMF is set and the AMF is cleared by reading this
 * register. In 7-bit mode, the address byte is store in RADDR[7:0]. In 10-bit
 * mode, the first address byte is { 11110, RADDR[10:9], RADDR[0] } and the second
 * address byte is RADDR[8:1]. The R/W bit is therefore always stored in RADDR[0].
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_RADDR field. */
#define LPI2C_RD_SASR_RADDR(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_RADDR_MASK) >> LPI2C_SASR_RADDR_SHIFT)
#define LPI2C_BRD_SASR_RADDR(base) (LPI2C_RD_SASR_RADDR(base))
/*@}*/

/*!
 * @name Register LPI2C_SASR, field ANV[14] (RO)
 *
 * Values:
 * - 0 - RADDR is valid.
 * - 1 - RADDR is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SASR_ANV field. */
#define LPI2C_RD_SASR_ANV(base) ((LPI2C_SASR_REG(base) & LPI2C_SASR_ANV_MASK) >> LPI2C_SASR_ANV_SHIFT)
#define LPI2C_BRD_SASR_ANV(base) (BITBAND_ACCESS32(&LPI2C_SASR_REG(base), LPI2C_SASR_ANV_SHIFT))
/*@}*/

/*******************************************************************************
 * LPI2C_STAR - Slave Transmit ACK Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STAR - Slave Transmit ACK Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STAR register
 */
/*@{*/
#define LPI2C_RD_STAR(base)      (LPI2C_STAR_REG(base))
#define LPI2C_WR_STAR(base, value) (LPI2C_STAR_REG(base) = (value))
#define LPI2C_RMW_STAR(base, mask, value) (LPI2C_WR_STAR(base, (LPI2C_RD_STAR(base) & ~(mask)) | (value)))
#define LPI2C_SET_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) |  (value)))
#define LPI2C_CLR_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) & ~(value)))
#define LPI2C_TOG_STAR(base, value) (LPI2C_WR_STAR(base, LPI2C_RD_STAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STAR bitfields
 */

/*!
 * @name Register LPI2C_STAR, field TXNACK[0] (RW)
 *
 * When NACKSTALL is set, must be written once for each matching address byte
 * and each received word. Can also be written when LPI2C Slave is disabled or idle
 * to configure the default ACK/NACK.
 *
 * Values:
 * - 0 - Transmit ACK for received word.
 * - 1 - Transmit NACK for received word.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_STAR_TXNACK field. */
#define LPI2C_RD_STAR_TXNACK(base) ((LPI2C_STAR_REG(base) & LPI2C_STAR_TXNACK_MASK) >> LPI2C_STAR_TXNACK_SHIFT)
#define LPI2C_BRD_STAR_TXNACK(base) (BITBAND_ACCESS32(&LPI2C_STAR_REG(base), LPI2C_STAR_TXNACK_SHIFT))

/*! @brief Set the TXNACK field to a new value. */
#define LPI2C_WR_STAR_TXNACK(base, value) (LPI2C_RMW_STAR(base, LPI2C_STAR_TXNACK_MASK, LPI2C_STAR_TXNACK(value)))
#define LPI2C_BWR_STAR_TXNACK(base, value) (BITBAND_ACCESS32(&LPI2C_STAR_REG(base), LPI2C_STAR_TXNACK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPI2C_STDR - Slave Transmit Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_STDR - Slave Transmit Data Register (WO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPI2C_STDR register
 */
/*@{*/
#define LPI2C_RD_STDR(base)      (LPI2C_STDR_REG(base))
#define LPI2C_WR_STDR(base, value) (LPI2C_STDR_REG(base) = (value))
#define LPI2C_RMW_STDR(base, mask, value) (LPI2C_WR_STDR(base, (LPI2C_RD_STDR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual LPI2C_STDR bitfields
 */

/*!
 * @name Register LPI2C_STDR, field DATA[7:0] (WO)
 *
 * Writing this register will store I2C slave transmit data in the transmit
 * register.
 */
/*@{*/
/*! @brief Set the DATA field to a new value. */
#define LPI2C_WR_STDR_DATA(base, value) (LPI2C_RMW_STDR(base, LPI2C_STDR_DATA_MASK, LPI2C_STDR_DATA(value)))
#define LPI2C_BWR_STDR_DATA(base, value) (LPI2C_WR_STDR_DATA(base, value))
/*@}*/

/*******************************************************************************
 * LPI2C_SRDR - Slave Receive Data Register
 ******************************************************************************/

/*!
 * @brief LPI2C_SRDR - Slave Receive Data Register (RO)
 *
 * Reset value: 0x00004000U
 */
/*!
 * @name Constants and macros for entire LPI2C_SRDR register
 */
/*@{*/
#define LPI2C_RD_SRDR(base)      (LPI2C_SRDR_REG(base))
/*@}*/

/*
 * Constants & macros for individual LPI2C_SRDR bitfields
 */

/*!
 * @name Register LPI2C_SRDR, field DATA[7:0] (RO)
 *
 * Reading this register returns the data received by the I2C slave.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_DATA field. */
#define LPI2C_RD_SRDR_DATA(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_DATA_MASK) >> LPI2C_SRDR_DATA_SHIFT)
#define LPI2C_BRD_SRDR_DATA(base) (LPI2C_RD_SRDR_DATA(base))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field RXEMPTY[14] (RO)
 *
 * Values:
 * - 0 - The Receive Data Register is not empty.
 * - 1 - The Receive Data Register is empty.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_RXEMPTY field. */
#define LPI2C_RD_SRDR_RXEMPTY(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_RXEMPTY_MASK) >> LPI2C_SRDR_RXEMPTY_SHIFT)
#define LPI2C_BRD_SRDR_RXEMPTY(base) (BITBAND_ACCESS32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_RXEMPTY_SHIFT))
/*@}*/

/*!
 * @name Register LPI2C_SRDR, field SOF[15] (RO)
 *
 * Values:
 * - 0 - Indicates this is not the first data word since a (repeated) START or
 *     STOP condition.
 * - 1 - Indicates this is the first data word since a (repeated) START or STOP
 *     condition.
 */
/*@{*/
/*! @brief Read current value of the LPI2C_SRDR_SOF field. */
#define LPI2C_RD_SRDR_SOF(base) ((LPI2C_SRDR_REG(base) & LPI2C_SRDR_SOF_MASK) >> LPI2C_SRDR_SOF_SHIFT)
#define LPI2C_BRD_SRDR_SOF(base) (BITBAND_ACCESS32(&LPI2C_SRDR_REG(base), LPI2C_SRDR_SOF_SHIFT))
/*@}*/

/*
 * MKS22F25612 LPTMR
 *
 * Low Power Timer
 *
 * Registers defined in this header file:
 * - LPTMR_CSR - Low Power Timer Control Status Register
 * - LPTMR_PSR - Low Power Timer Prescale Register
 * - LPTMR_CMR - Low Power Timer Compare Register
 * - LPTMR_CNR - Low Power Timer Counter Register
 */

#define LPTMR_INSTANCE_COUNT (1U) /*!< Number of instances of the LPTMR module. */
#define LPTMR0_IDX (0U) /*!< Instance number for LPTMR0. */

/*******************************************************************************
 * LPTMR_CSR - Low Power Timer Control Status Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CSR - Low Power Timer Control Status Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CSR register
 */
/*@{*/
#define LPTMR_RD_CSR(base)       (LPTMR_CSR_REG(base))
#define LPTMR_WR_CSR(base, value) (LPTMR_CSR_REG(base) = (value))
#define LPTMR_RMW_CSR(base, mask, value) (LPTMR_WR_CSR(base, (LPTMR_RD_CSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) |  (value)))
#define LPTMR_CLR_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) & ~(value)))
#define LPTMR_TOG_CSR(base, value) (LPTMR_WR_CSR(base, LPTMR_RD_CSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CSR bitfields
 */

/*!
 * @name Register LPTMR_CSR, field TEN[0] (RW)
 *
 * When TEN is clear, it resets the LPTMR internal logic, including the CNR and
 * TCF. When TEN is set, the LPTMR is enabled. While writing 1 to this field,
 * CSR[5:1] must not be altered.
 *
 * Values:
 * - 0 - LPTMR is disabled and internal logic is reset.
 * - 1 - LPTMR is enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TEN field. */
#define LPTMR_RD_CSR_TEN(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TEN_MASK) >> LPTMR_CSR_TEN_SHIFT)
#define LPTMR_BRD_CSR_TEN(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT))

/*! @brief Set the TEN field to a new value. */
#define LPTMR_WR_CSR_TEN(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TEN_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TEN(value)))
#define LPTMR_BWR_CSR_TEN(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TMS[1] (RW)
 *
 * Configures the mode of the LPTMR. TMS must be altered only when the LPTMR is
 * disabled.
 *
 * Values:
 * - 0 - Time Counter mode.
 * - 1 - Pulse Counter mode.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TMS field. */
#define LPTMR_RD_CSR_TMS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TMS_MASK) >> LPTMR_CSR_TMS_SHIFT)
#define LPTMR_BRD_CSR_TMS(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT))

/*! @brief Set the TMS field to a new value. */
#define LPTMR_WR_CSR_TMS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TMS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TMS(value)))
#define LPTMR_BWR_CSR_TMS(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TFC[2] (RW)
 *
 * When clear, TFC configures the CNR to reset whenever TCF is set. When set,
 * TFC configures the CNR to reset on overflow. TFC must be altered only when the
 * LPTMR is disabled.
 *
 * Values:
 * - 0 - CNR is reset whenever TCF is set.
 * - 1 - CNR is reset on overflow.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TFC field. */
#define LPTMR_RD_CSR_TFC(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TFC_MASK) >> LPTMR_CSR_TFC_SHIFT)
#define LPTMR_BRD_CSR_TFC(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT))

/*! @brief Set the TFC field to a new value. */
#define LPTMR_WR_CSR_TFC(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TFC_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TFC(value)))
#define LPTMR_BWR_CSR_TFC(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TFC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPP[3] (RW)
 *
 * Configures the polarity of the input source in Pulse Counter mode. TPP must
 * be changed only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Pulse Counter input source is active-high, and the CNR will increment
 *     on the rising-edge.
 * - 1 - Pulse Counter input source is active-low, and the CNR will increment on
 *     the falling-edge.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPP field. */
#define LPTMR_RD_CSR_TPP(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPP_MASK) >> LPTMR_CSR_TPP_SHIFT)
#define LPTMR_BRD_CSR_TPP(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT))

/*! @brief Set the TPP field to a new value. */
#define LPTMR_WR_CSR_TPP(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPP_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPP(value)))
#define LPTMR_BWR_CSR_TPP(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TPP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TPS[5:4] (RW)
 *
 * Configures the input source to be used in Pulse Counter mode. TPS must be
 * altered only when the LPTMR is disabled. The input connections vary by device.
 * See the for information on the connections to these inputs.
 *
 * Values:
 * - 00 - Pulse counter input 0 is selected.
 * - 01 - Pulse counter input 1 is selected.
 * - 10 - Pulse counter input 2 is selected.
 * - 11 - Pulse counter input 3 is selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TPS field. */
#define LPTMR_RD_CSR_TPS(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TPS_MASK) >> LPTMR_CSR_TPS_SHIFT)
#define LPTMR_BRD_CSR_TPS(base) (LPTMR_RD_CSR_TPS(base))

/*! @brief Set the TPS field to a new value. */
#define LPTMR_WR_CSR_TPS(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TPS_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TPS(value)))
#define LPTMR_BWR_CSR_TPS(base, value) (LPTMR_WR_CSR_TPS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TIE[6] (RW)
 *
 * When TIE is set, the LPTMR Interrupt is generated whenever TCF is also set.
 *
 * Values:
 * - 0 - Timer interrupt disabled.
 * - 1 - Timer interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TIE field. */
#define LPTMR_RD_CSR_TIE(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TIE_MASK) >> LPTMR_CSR_TIE_SHIFT)
#define LPTMR_BRD_CSR_TIE(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define LPTMR_WR_CSR_TIE(base, value) (LPTMR_RMW_CSR(base, (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TCF_MASK), LPTMR_CSR_TIE(value)))
#define LPTMR_BWR_CSR_TIE(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_CSR, field TCF[7] (W1C)
 *
 * TCF is set when the LPTMR is enabled and the CNR equals the CMR and
 * increments. TCF is cleared when the LPTMR is disabled or a logic 1 is written to it.
 *
 * Values:
 * - 0 - The value of CNR is not equal to CMR and increments.
 * - 1 - The value of CNR is equal to CMR and increments.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CSR_TCF field. */
#define LPTMR_RD_CSR_TCF(base) ((LPTMR_CSR_REG(base) & LPTMR_CSR_TCF_MASK) >> LPTMR_CSR_TCF_SHIFT)
#define LPTMR_BRD_CSR_TCF(base) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define LPTMR_WR_CSR_TCF(base, value) (LPTMR_RMW_CSR(base, LPTMR_CSR_TCF_MASK, LPTMR_CSR_TCF(value)))
#define LPTMR_BWR_CSR_TCF(base, value) (BITBAND_ACCESS32(&LPTMR_CSR_REG(base), LPTMR_CSR_TCF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPTMR_PSR - Low Power Timer Prescale Register
 ******************************************************************************/

/*!
 * @brief LPTMR_PSR - Low Power Timer Prescale Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_PSR register
 */
/*@{*/
#define LPTMR_RD_PSR(base)       (LPTMR_PSR_REG(base))
#define LPTMR_WR_PSR(base, value) (LPTMR_PSR_REG(base) = (value))
#define LPTMR_RMW_PSR(base, mask, value) (LPTMR_WR_PSR(base, (LPTMR_RD_PSR(base) & ~(mask)) | (value)))
#define LPTMR_SET_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) |  (value)))
#define LPTMR_CLR_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) & ~(value)))
#define LPTMR_TOG_PSR(base, value) (LPTMR_WR_PSR(base, LPTMR_RD_PSR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_PSR bitfields
 */

/*!
 * @name Register LPTMR_PSR, field PCS[1:0] (RW)
 *
 * Selects the clock to be used by the LPTMR prescaler/glitch filter. PCS must
 * be altered only when the LPTMR is disabled. The clock connections vary by
 * device. See the chip configuration details for information on the connections to
 * these inputs.
 *
 * Values:
 * - 00 - Prescaler/glitch filter clock 0 selected.
 * - 01 - Prescaler/glitch filter clock 1 selected.
 * - 10 - Prescaler/glitch filter clock 2 selected.
 * - 11 - Prescaler/glitch filter clock 3 selected.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PCS field. */
#define LPTMR_RD_PSR_PCS(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PCS_MASK) >> LPTMR_PSR_PCS_SHIFT)
#define LPTMR_BRD_PSR_PCS(base) (LPTMR_RD_PSR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define LPTMR_WR_PSR_PCS(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PCS_MASK, LPTMR_PSR_PCS(value)))
#define LPTMR_BWR_PSR_PCS(base, value) (LPTMR_WR_PSR_PCS(base, value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PBYP[2] (RW)
 *
 * When PBYP is set, the selected prescaler clock in Time Counter mode or
 * selected input source in Pulse Counter mode directly clocks the CNR. When PBYP is
 * clear, the CNR is clocked by the output of the prescaler/glitch filter. PBYP
 * must be altered only when the LPTMR is disabled.
 *
 * Values:
 * - 0 - Prescaler/glitch filter is enabled.
 * - 1 - Prescaler/glitch filter is bypassed.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PBYP field. */
#define LPTMR_RD_PSR_PBYP(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PBYP_MASK) >> LPTMR_PSR_PBYP_SHIFT)
#define LPTMR_BRD_PSR_PBYP(base) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT))

/*! @brief Set the PBYP field to a new value. */
#define LPTMR_WR_PSR_PBYP(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PBYP_MASK, LPTMR_PSR_PBYP(value)))
#define LPTMR_BWR_PSR_PBYP(base, value) (BITBAND_ACCESS32(&LPTMR_PSR_REG(base), LPTMR_PSR_PBYP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPTMR_PSR, field PRESCALE[6:3] (RW)
 *
 * Configures the size of the Prescaler in Time Counter mode or width of the
 * glitch filter in Pulse Counter mode. PRESCALE must be altered only when the LPTMR
 * is disabled.
 *
 * Values:
 * - 0000 - Prescaler divides the prescaler clock by 2; glitch filter does not
 *     support this configuration.
 * - 0001 - Prescaler divides the prescaler clock by 4; glitch filter recognizes
 *     change on input pin after 2 rising clock edges.
 * - 0010 - Prescaler divides the prescaler clock by 8; glitch filter recognizes
 *     change on input pin after 4 rising clock edges.
 * - 0011 - Prescaler divides the prescaler clock by 16; glitch filter
 *     recognizes change on input pin after 8 rising clock edges.
 * - 0100 - Prescaler divides the prescaler clock by 32; glitch filter
 *     recognizes change on input pin after 16 rising clock edges.
 * - 0101 - Prescaler divides the prescaler clock by 64; glitch filter
 *     recognizes change on input pin after 32 rising clock edges.
 * - 0110 - Prescaler divides the prescaler clock by 128; glitch filter
 *     recognizes change on input pin after 64 rising clock edges.
 * - 0111 - Prescaler divides the prescaler clock by 256; glitch filter
 *     recognizes change on input pin after 128 rising clock edges.
 * - 1000 - Prescaler divides the prescaler clock by 512; glitch filter
 *     recognizes change on input pin after 256 rising clock edges.
 * - 1001 - Prescaler divides the prescaler clock by 1024; glitch filter
 *     recognizes change on input pin after 512 rising clock edges.
 * - 1010 - Prescaler divides the prescaler clock by 2048; glitch filter
 *     recognizes change on input pin after 1024 rising clock edges.
 * - 1011 - Prescaler divides the prescaler clock by 4096; glitch filter
 *     recognizes change on input pin after 2048 rising clock edges.
 * - 1100 - Prescaler divides the prescaler clock by 8192; glitch filter
 *     recognizes change on input pin after 4096 rising clock edges.
 * - 1101 - Prescaler divides the prescaler clock by 16,384; glitch filter
 *     recognizes change on input pin after 8192 rising clock edges.
 * - 1110 - Prescaler divides the prescaler clock by 32,768; glitch filter
 *     recognizes change on input pin after 16,384 rising clock edges.
 * - 1111 - Prescaler divides the prescaler clock by 65,536; glitch filter
 *     recognizes change on input pin after 32,768 rising clock edges.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_PSR_PRESCALE field. */
#define LPTMR_RD_PSR_PRESCALE(base) ((LPTMR_PSR_REG(base) & LPTMR_PSR_PRESCALE_MASK) >> LPTMR_PSR_PRESCALE_SHIFT)
#define LPTMR_BRD_PSR_PRESCALE(base) (LPTMR_RD_PSR_PRESCALE(base))

/*! @brief Set the PRESCALE field to a new value. */
#define LPTMR_WR_PSR_PRESCALE(base, value) (LPTMR_RMW_PSR(base, LPTMR_PSR_PRESCALE_MASK, LPTMR_PSR_PRESCALE(value)))
#define LPTMR_BWR_PSR_PRESCALE(base, value) (LPTMR_WR_PSR_PRESCALE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CMR - Low Power Timer Compare Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CMR - Low Power Timer Compare Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CMR register
 */
/*@{*/
#define LPTMR_RD_CMR(base)       (LPTMR_CMR_REG(base))
#define LPTMR_WR_CMR(base, value) (LPTMR_CMR_REG(base) = (value))
#define LPTMR_RMW_CMR(base, mask, value) (LPTMR_WR_CMR(base, (LPTMR_RD_CMR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) |  (value)))
#define LPTMR_CLR_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) & ~(value)))
#define LPTMR_TOG_CMR(base, value) (LPTMR_WR_CMR(base, LPTMR_RD_CMR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CMR bitfields
 */

/*!
 * @name Register LPTMR_CMR, field COMPARE[15:0] (RW)
 *
 * When the LPTMR is enabled and the CNR equals the value in the CMR and
 * increments, TCF is set and the hardware trigger asserts until the next time the CNR
 * increments. If the CMR is 0, the hardware trigger will remain asserted until
 * the LPTMR is disabled. If the LPTMR is enabled, the CMR must be altered only
 * when TCF is set.
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CMR_COMPARE field. */
#define LPTMR_RD_CMR_COMPARE(base) ((LPTMR_CMR_REG(base) & LPTMR_CMR_COMPARE_MASK) >> LPTMR_CMR_COMPARE_SHIFT)
#define LPTMR_BRD_CMR_COMPARE(base) (LPTMR_RD_CMR_COMPARE(base))

/*! @brief Set the COMPARE field to a new value. */
#define LPTMR_WR_CMR_COMPARE(base, value) (LPTMR_RMW_CMR(base, LPTMR_CMR_COMPARE_MASK, LPTMR_CMR_COMPARE(value)))
#define LPTMR_BWR_CMR_COMPARE(base, value) (LPTMR_WR_CMR_COMPARE(base, value))
/*@}*/

/*******************************************************************************
 * LPTMR_CNR - Low Power Timer Counter Register
 ******************************************************************************/

/*!
 * @brief LPTMR_CNR - Low Power Timer Counter Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPTMR_CNR register
 */
/*@{*/
#define LPTMR_RD_CNR(base)       (LPTMR_CNR_REG(base))
#define LPTMR_WR_CNR(base, value) (LPTMR_CNR_REG(base) = (value))
#define LPTMR_RMW_CNR(base, mask, value) (LPTMR_WR_CNR(base, (LPTMR_RD_CNR(base) & ~(mask)) | (value)))
#define LPTMR_SET_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) |  (value)))
#define LPTMR_CLR_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) & ~(value)))
#define LPTMR_TOG_CNR(base, value) (LPTMR_WR_CNR(base, LPTMR_RD_CNR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPTMR_CNR bitfields
 */

/*!
 * @name Register LPTMR_CNR, field COUNTER[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the LPTMR_CNR_COUNTER field. */
#define LPTMR_RD_CNR_COUNTER(base) ((LPTMR_CNR_REG(base) & LPTMR_CNR_COUNTER_MASK) >> LPTMR_CNR_COUNTER_SHIFT)
#define LPTMR_BRD_CNR_COUNTER(base) (LPTMR_RD_CNR_COUNTER(base))

/*! @brief Set the COUNTER field to a new value. */
#define LPTMR_WR_CNR_COUNTER(base, value) (LPTMR_RMW_CNR(base, LPTMR_CNR_COUNTER_MASK, LPTMR_CNR_COUNTER(value)))
#define LPTMR_BWR_CNR_COUNTER(base, value) (LPTMR_WR_CNR_COUNTER(base, value))
/*@}*/

/*
 * MKS22F25612 LPUART
 *
 * Universal Asynchronous Receiver/Transmitter
 *
 * Registers defined in this header file:
 * - LPUART_BAUD - LPUART Baud Rate Register
 * - LPUART_STAT - LPUART Status Register
 * - LPUART_CTRL - LPUART Control Register
 * - LPUART_DATA - LPUART Data Register
 * - LPUART_MATCH - LPUART Match Address Register
 * - LPUART_MODIR - LPUART Modem IrDA Register
 */

#define LPUART_INSTANCE_COUNT (1U) /*!< Number of instances of the LPUART module. */
#define LPUART0_IDX (0U) /*!< Instance number for LPUART0. */

/*******************************************************************************
 * LPUART_BAUD - LPUART Baud Rate Register
 ******************************************************************************/

/*!
 * @brief LPUART_BAUD - LPUART Baud Rate Register (RW)
 *
 * Reset value: 0x0F000004U
 */
/*!
 * @name Constants and macros for entire LPUART_BAUD register
 */
/*@{*/
#define LPUART_RD_BAUD(base)     (LPUART_BAUD_REG(base))
#define LPUART_WR_BAUD(base, value) (LPUART_BAUD_REG(base) = (value))
#define LPUART_RMW_BAUD(base, mask, value) (LPUART_WR_BAUD(base, (LPUART_RD_BAUD(base) & ~(mask)) | (value)))
#define LPUART_SET_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) |  (value)))
#define LPUART_CLR_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) & ~(value)))
#define LPUART_TOG_BAUD(base, value) (LPUART_WR_BAUD(base, LPUART_RD_BAUD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_BAUD bitfields
 */

/*!
 * @name Register LPUART_BAUD, field SBR[12:0] (RW)
 *
 * The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate
 * generator. When SBR is 1 - 8191, the baud rate equals "baud clock / ((OSR+1) * SBR)".
 * The 13-bit baud rate setting [SBR12:SBR0] must only be updated when the
 * transmitter and receiver are both disabled (LPUART_CTRL[RE] and LPUART_CTRL[TE] are
 * both 0).
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBR field. */
#define LPUART_RD_BAUD_SBR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBR_MASK) >> LPUART_BAUD_SBR_SHIFT)
#define LPUART_BRD_BAUD_SBR(base) (LPUART_RD_BAUD_SBR(base))

/*! @brief Set the SBR field to a new value. */
#define LPUART_WR_BAUD_SBR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBR_MASK, LPUART_BAUD_SBR(value)))
#define LPUART_BWR_BAUD_SBR(base, value) (LPUART_WR_BAUD_SBR(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field SBNS[13] (RW)
 *
 * SBNS determines whether data characters are one or two stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - One stop bit.
 * - 1 - Two stop bits.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_SBNS field. */
#define LPUART_RD_BAUD_SBNS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_SBNS_MASK) >> LPUART_BAUD_SBNS_SHIFT)
#define LPUART_BRD_BAUD_SBNS(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT))

/*! @brief Set the SBNS field to a new value. */
#define LPUART_WR_BAUD_SBNS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_SBNS_MASK, LPUART_BAUD_SBNS(value)))
#define LPUART_BWR_BAUD_SBNS(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_SBNS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RXEDGIE[14] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests. Changing CTRL[LOOP] or CTRL[RSRC] when RXEDGIE is set can cause the RXEDGIF
 * to set.
 *
 * Values:
 * - 0 - Hardware interrupts from LPUART_STAT[RXEDGIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RXEDGIE field. */
#define LPUART_RD_BAUD_RXEDGIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RXEDGIE_MASK) >> LPUART_BAUD_RXEDGIE_SHIFT)
#define LPUART_BRD_BAUD_RXEDGIE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT))

/*! @brief Set the RXEDGIE field to a new value. */
#define LPUART_WR_BAUD_RXEDGIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RXEDGIE_MASK, LPUART_BAUD_RXEDGIE(value)))
#define LPUART_BWR_BAUD_RXEDGIE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RXEDGIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field LBKDIE[15] (RW)
 *
 * LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use polling).
 * - 1 - Hardware interrupt requested when LPUART_STAT[LBKDIF] flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_LBKDIE field. */
#define LPUART_RD_BAUD_LBKDIE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_LBKDIE_MASK) >> LPUART_BAUD_LBKDIE_SHIFT)
#define LPUART_BRD_BAUD_LBKDIE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT))

/*! @brief Set the LBKDIE field to a new value. */
#define LPUART_WR_BAUD_LBKDIE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_LBKDIE_MASK, LPUART_BAUD_LBKDIE(value)))
#define LPUART_BWR_BAUD_LBKDIE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_LBKDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RESYNCDIS[16] (RW)
 *
 * When set, disables the resynchronization of the received data word when a
 * data one followed by data zero transition is detected. This bit should only be
 * changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Resynchronization during received data word is supported
 * - 1 - Resynchronization during received data word is disabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RESYNCDIS field. */
#define LPUART_RD_BAUD_RESYNCDIS(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RESYNCDIS_MASK) >> LPUART_BAUD_RESYNCDIS_SHIFT)
#define LPUART_BRD_BAUD_RESYNCDIS(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT))

/*! @brief Set the RESYNCDIS field to a new value. */
#define LPUART_WR_BAUD_RESYNCDIS(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RESYNCDIS_MASK, LPUART_BAUD_RESYNCDIS(value)))
#define LPUART_BWR_BAUD_RESYNCDIS(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RESYNCDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field BOTHEDGE[17] (RW)
 *
 * Enables sampling of the received data on both edges of the baud rate clock,
 * effectively doubling the number of times the receiver samples the input data
 * for a given oversampling ratio. This bit must be set for oversampling ratios
 * between x4 and x7 and is optional for higher oversampling ratios. This bit should
 * only be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - Receiver samples input data using the rising edge of the baud rate
 *     clock.
 * - 1 - Receiver samples input data using the rising and falling edge of the
 *     baud rate clock.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_BOTHEDGE field. */
#define LPUART_RD_BAUD_BOTHEDGE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_BOTHEDGE_MASK) >> LPUART_BAUD_BOTHEDGE_SHIFT)
#define LPUART_BRD_BAUD_BOTHEDGE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT))

/*! @brief Set the BOTHEDGE field to a new value. */
#define LPUART_WR_BAUD_BOTHEDGE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_BOTHEDGE_MASK, LPUART_BAUD_BOTHEDGE(value)))
#define LPUART_BWR_BAUD_BOTHEDGE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_BOTHEDGE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MATCFG[19:18] (RW)
 *
 * Configures the match addressing mode used.
 *
 * Values:
 * - 00 - Address Match Wakeup
 * - 01 - Idle Match Wakeup
 * - 10 - Match On and Match Off
 * - 11 - Enables RWU on Data Match and Match On/Off for transmitter CTS input
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MATCFG field. */
#define LPUART_RD_BAUD_MATCFG(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MATCFG_MASK) >> LPUART_BAUD_MATCFG_SHIFT)
#define LPUART_BRD_BAUD_MATCFG(base) (LPUART_RD_BAUD_MATCFG(base))

/*! @brief Set the MATCFG field to a new value. */
#define LPUART_WR_BAUD_MATCFG(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MATCFG_MASK, LPUART_BAUD_MATCFG(value)))
#define LPUART_BWR_BAUD_MATCFG(base, value) (LPUART_WR_BAUD_MATCFG(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field RDMAE[21] (RW)
 *
 * RDMAE configures the receiver data register full flag, LPUART_STAT[RDRF], to
 * generate a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_RDMAE field. */
#define LPUART_RD_BAUD_RDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_RDMAE_MASK) >> LPUART_BAUD_RDMAE_SHIFT)
#define LPUART_BRD_BAUD_RDMAE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT))

/*! @brief Set the RDMAE field to a new value. */
#define LPUART_WR_BAUD_RDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_RDMAE_MASK, LPUART_BAUD_RDMAE(value)))
#define LPUART_BWR_BAUD_RDMAE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_RDMAE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field TDMAE[23] (RW)
 *
 * TDMAE configures the transmit data register empty flag, LPUART_STAT[TDRE], to
 * generate a DMA request.
 *
 * Values:
 * - 0 - DMA request disabled.
 * - 1 - DMA request enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_TDMAE field. */
#define LPUART_RD_BAUD_TDMAE(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_TDMAE_MASK) >> LPUART_BAUD_TDMAE_SHIFT)
#define LPUART_BRD_BAUD_TDMAE(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT))

/*! @brief Set the TDMAE field to a new value. */
#define LPUART_WR_BAUD_TDMAE(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_TDMAE_MASK, LPUART_BAUD_TDMAE(value)))
#define LPUART_BWR_BAUD_TDMAE(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_TDMAE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field OSR[28:24] (RW)
 *
 * This field configures the oversampling ratio for the receiver between 4x
 * (00011) and 32x (11111). Writing an invalid oversampling ratio (i.e., a value not
 * between 4x and 32x) will default to an oversampling ratio of 16 (01111). This
 * field should only be changed when the transmitter and receiver are both
 * disabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_OSR field. */
#define LPUART_RD_BAUD_OSR(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_OSR_MASK) >> LPUART_BAUD_OSR_SHIFT)
#define LPUART_BRD_BAUD_OSR(base) (LPUART_RD_BAUD_OSR(base))

/*! @brief Set the OSR field to a new value. */
#define LPUART_WR_BAUD_OSR(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_OSR_MASK, LPUART_BAUD_OSR(value)))
#define LPUART_BWR_BAUD_OSR(base, value) (LPUART_WR_BAUD_OSR(base, value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field M10[29] (RW)
 *
 * The M10 bit causes a tenth bit to be part of the serial transmission. This
 * bit should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit or 9-bit data characters.
 * - 1 - Receiver and transmitter use 10-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_M10 field. */
#define LPUART_RD_BAUD_M10(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_M10_MASK) >> LPUART_BAUD_M10_SHIFT)
#define LPUART_BRD_BAUD_M10(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT))

/*! @brief Set the M10 field to a new value. */
#define LPUART_WR_BAUD_M10(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_M10_MASK, LPUART_BAUD_M10(value)))
#define LPUART_BWR_BAUD_M10(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_M10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN2[30] (RW)
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Enables automatic address matching or data matching mode for MATCH[MA2].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN2 field. */
#define LPUART_RD_BAUD_MAEN2(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN2_MASK) >> LPUART_BAUD_MAEN2_SHIFT)
#define LPUART_BRD_BAUD_MAEN2(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT))

/*! @brief Set the MAEN2 field to a new value. */
#define LPUART_WR_BAUD_MAEN2(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN2_MASK, LPUART_BAUD_MAEN2(value)))
#define LPUART_BWR_BAUD_MAEN2(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_BAUD, field MAEN1[31] (RW)
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Enables automatic address matching or data matching mode for MATCH[MA1].
 */
/*@{*/
/*! @brief Read current value of the LPUART_BAUD_MAEN1 field. */
#define LPUART_RD_BAUD_MAEN1(base) ((LPUART_BAUD_REG(base) & LPUART_BAUD_MAEN1_MASK) >> LPUART_BAUD_MAEN1_SHIFT)
#define LPUART_BRD_BAUD_MAEN1(base) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT))

/*! @brief Set the MAEN1 field to a new value. */
#define LPUART_WR_BAUD_MAEN1(base, value) (LPUART_RMW_BAUD(base, LPUART_BAUD_MAEN1_MASK, LPUART_BAUD_MAEN1(value)))
#define LPUART_BWR_BAUD_MAEN1(base, value) (BITBAND_ACCESS32(&LPUART_BAUD_REG(base), LPUART_BAUD_MAEN1_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_STAT - LPUART Status Register
 ******************************************************************************/

/*!
 * @brief LPUART_STAT - LPUART Status Register (RW)
 *
 * Reset value: 0x00C00000U
 */
/*!
 * @name Constants and macros for entire LPUART_STAT register
 */
/*@{*/
#define LPUART_RD_STAT(base)     (LPUART_STAT_REG(base))
#define LPUART_WR_STAT(base, value) (LPUART_STAT_REG(base) = (value))
#define LPUART_RMW_STAT(base, mask, value) (LPUART_WR_STAT(base, (LPUART_RD_STAT(base) & ~(mask)) | (value)))
#define LPUART_SET_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) |  (value)))
#define LPUART_CLR_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) & ~(value)))
#define LPUART_TOG_STAT(base, value) (LPUART_WR_STAT(base, LPUART_RD_STAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_STAT bitfields
 */

/*!
 * @name Register LPUART_STAT, field MA2F[14] (W1C)
 *
 * MA2F is set whenever the next character to be read from LPUART_DATA matches
 * MA2. To clear MA2F, write a logic one to the MA2F.
 *
 * Values:
 * - 0 - Received data is not equal to MA2
 * - 1 - Received data is equal to MA2
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA2F field. */
#define LPUART_RD_STAT_MA2F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA2F_MASK) >> LPUART_STAT_MA2F_SHIFT)
#define LPUART_BRD_STAT_MA2F(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT))

/*! @brief Set the MA2F field to a new value. */
#define LPUART_WR_STAT_MA2F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA2F(value)))
#define LPUART_BWR_STAT_MA2F(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MA1F[15] (W1C)
 *
 * MA1F is set whenever the next character to be read from LPUART_DATA matches
 * MA1. To clear MA1F, write a logic one to the MA1F.
 *
 * Values:
 * - 0 - Received data is not equal to MA1
 * - 1 - Received data is equal to MA1
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MA1F field. */
#define LPUART_RD_STAT_MA1F(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MA1F_MASK) >> LPUART_STAT_MA1F_SHIFT)
#define LPUART_BRD_STAT_MA1F(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT))

/*! @brief Set the MA1F field to a new value. */
#define LPUART_WR_STAT_MA1F(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MA1F_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MA1F(value)))
#define LPUART_BWR_STAT_MA1F(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MA1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field PF[16] (W1C)
 *
 * PF is set whenever the next character to be read from LPUART_DATA was
 * received when parity is enabled (PE = 1) and the parity bit in the received character
 * does not agree with the expected parity value. To clear PF, write a logic one
 * to the PF.
 *
 * Values:
 * - 0 - No parity error.
 * - 1 - Parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_PF field. */
#define LPUART_RD_STAT_PF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_PF_MASK) >> LPUART_STAT_PF_SHIFT)
#define LPUART_BRD_STAT_PF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT))

/*! @brief Set the PF field to a new value. */
#define LPUART_WR_STAT_PF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_PF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_PF(value)))
#define LPUART_BWR_STAT_PF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_PF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field FE[17] (W1C)
 *
 * FE is set whenever the next character to be read from LPUART_DATA was
 * received with logic 0 detected where a stop bit was expected. To clear FE, write
 * logic one to the FE.
 *
 * Values:
 * - 0 - No framing error detected. This does not guarantee the framing is
 *     correct.
 * - 1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_FE field. */
#define LPUART_RD_STAT_FE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_FE_MASK) >> LPUART_STAT_FE_SHIFT)
#define LPUART_BRD_STAT_FE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT))

/*! @brief Set the FE field to a new value. */
#define LPUART_WR_STAT_FE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_FE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_FE(value)))
#define LPUART_BWR_STAT_FE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_FE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field NF[18] (W1C)
 *
 * The advanced sampling technique used in the receiver takes three samples in
 * each of the received bits. If any of these samples disagrees with the rest of
 * the samples within any bit time in the frame then noise is detected for that
 * character. NF is set whenever the next character to be read from LPUART_DATA was
 * received with noise detected within the character. To clear NF, write logic
 * one to the NF.
 *
 * Values:
 * - 0 - No noise detected.
 * - 1 - Noise detected in the received character in LPUART_DATA.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_NF field. */
#define LPUART_RD_STAT_NF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_NF_MASK) >> LPUART_STAT_NF_SHIFT)
#define LPUART_BRD_STAT_NF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT))

/*! @brief Set the NF field to a new value. */
#define LPUART_WR_STAT_NF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_NF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_NF(value)))
#define LPUART_BWR_STAT_NF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_NF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field OR[19] (W1C)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the LPUART data registers is not
 * affected. If LBKDE is enabled and a LIN Break is detected, the OR field asserts
 * if LBKDIF is not cleared before the next data character is received. While
 * the OR flag is set, no additional data is stored in the data buffer even if
 * sufficient room exists. To clear OR, write logic 1 to the OR flag.
 *
 * Values:
 * - 0 - No overrun.
 * - 1 - Receive overrun (new LPUART data lost).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_OR field. */
#define LPUART_RD_STAT_OR(base) ((LPUART_STAT_REG(base) & LPUART_STAT_OR_MASK) >> LPUART_STAT_OR_SHIFT)
#define LPUART_BRD_STAT_OR(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT))

/*! @brief Set the OR field to a new value. */
#define LPUART_WR_STAT_OR(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_OR_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_OR(value)))
#define LPUART_BWR_STAT_OR(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_OR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field IDLE[20] (W1C)
 *
 * IDLE is set when the LPUART receive line becomes idle for a full character
 * time after a period of activity. When ILT is cleared, the receiver starts
 * counting idle bit times after the start bit. If the receive character is all 1s,
 * these bit times and the stop bits time count toward the full character time of
 * logic high, 10 to 13 bit times, needed for the receiver to detect an idle line.
 * When ILT is set, the receiver doesn't start counting idle bit times until
 * after the stop bits. The stop bits and any logic high bit times at the end of the
 * previous character do not count toward the full character time of logic high
 * needed for the receiver to detect an idle line. To clear IDLE, write logic 1 to
 * the IDLE flag. After IDLE has been cleared, it cannot become set again until
 * after a new character has been stored in the receive buffer or a LIN break
 * character has set the LBKDIF flag . IDLE is set only once even if the receive
 * line remains idle for an extended period.
 *
 * Values:
 * - 0 - No idle line detected.
 * - 1 - Idle line was detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_IDLE field. */
#define LPUART_RD_STAT_IDLE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_IDLE_MASK) >> LPUART_STAT_IDLE_SHIFT)
#define LPUART_BRD_STAT_IDLE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT))

/*! @brief Set the IDLE field to a new value. */
#define LPUART_WR_STAT_IDLE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_IDLE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_IDLE(value)))
#define LPUART_BWR_STAT_IDLE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_IDLE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RDRF[21] (RO)
 *
 * RDRF is set when the receive buffer (LPUART_DATA) is full. To clear RDRF,
 * read the LPUART_DATA register. A character that is in the process of being
 * received does not cause a change in RDRF until the entire character is received.
 * Even if RDRF is set, the character will continue to be received until an overrun
 * condition occurs once the entire character is received.
 *
 * Values:
 * - 0 - Receive data buffer empty.
 * - 1 - Receive data buffer full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RDRF field. */
#define LPUART_RD_STAT_RDRF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RDRF_MASK) >> LPUART_STAT_RDRF_SHIFT)
#define LPUART_BRD_STAT_RDRF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RDRF_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TC[22] (RO)
 *
 * TC is cleared when there is a transmission in progress or when a preamble or
 * break character is loaded. TC is set when the transmit buffer is empty and no
 * data, preamble, or break character is being transmitted. When TC is set, the
 * transmit data output signal becomes idle (logic 1). TC is cleared by writing to
 * LPUART_DATA to transmit new data, queuing a preamble by clearing and then
 * setting LPUART_CTRL[TE], queuing a break character by writing 1 to
 * LPUART_CTRL[SBK].
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TC field. */
#define LPUART_RD_STAT_TC(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TC_MASK) >> LPUART_STAT_TC_SHIFT)
#define LPUART_BRD_STAT_TC(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_TC_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field TDRE[23] (RO)
 *
 * TDRE will set when the transmit data register (LPUART_DATA) is empty. To
 * clear TDRE, write to the LPUART data register (LPUART_DATA). TDRE is not affected
 * by a character that is in the process of being transmitted, it is updated at
 * the start of each transmitted character.
 *
 * Values:
 * - 0 - Transmit data buffer full.
 * - 1 - Transmit data buffer empty.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_TDRE field. */
#define LPUART_RD_STAT_TDRE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_TDRE_MASK) >> LPUART_STAT_TDRE_SHIFT)
#define LPUART_BRD_STAT_TDRE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_TDRE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RAF[24] (RO)
 *
 * RAF is set when the receiver detects the beginning of a valid start bit, and
 * RAF is cleared automatically when the receiver detects an idle line.
 *
 * Values:
 * - 0 - LPUART receiver idle waiting for a start bit.
 * - 1 - LPUART receiver active (LPUART_RX input not idle).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RAF field. */
#define LPUART_RD_STAT_RAF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RAF_MASK) >> LPUART_STAT_RAF_SHIFT)
#define LPUART_BRD_STAT_RAF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RAF_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDE[25] (RW)
 *
 * LBKDE selects a longer break character detection length. While LBKDE is set,
 * receive data is not stored in the receive data buffer.
 *
 * Values:
 * - 0 - Break character is detected at length 10 bit times (if M = 0, SBNS = 0)
 *     or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1, SBNS = 1
 *     or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is detected at length of 11 bit times (if M = 0, SBNS =
 *     0) or 12 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 14 (if M = 1, SBNS =
 *     1 or M10 = 1, SNBS = 0) or 15 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDE field. */
#define LPUART_RD_STAT_LBKDE(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDE_MASK) >> LPUART_STAT_LBKDE_SHIFT)
#define LPUART_BRD_STAT_LBKDE(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT))

/*! @brief Set the LBKDE field to a new value. */
#define LPUART_WR_STAT_LBKDE(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDE_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_LBKDE(value)))
#define LPUART_BWR_STAT_LBKDE(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field BRK13[26] (RW)
 *
 * BRK13 selects a longer transmitted break character length. Detection of a
 * framing error is not affected by the state of this bit. This bit should only be
 * changed when the transmitter is disabled.
 *
 * Values:
 * - 0 - Break character is transmitted with length of 10 bit times (if M = 0,
 *     SBNS = 0) or 11 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 12 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 13 (if M10 = 1, SNBS = 1).
 * - 1 - Break character is transmitted with length of 13 bit times (if M = 0,
 *     SBNS = 0) or 14 (if M = 1, SBNS = 0 or M = 0, SBNS = 1) or 15 (if M = 1,
 *     SBNS = 1 or M10 = 1, SNBS = 0) or 16 (if M10 = 1, SNBS = 1).
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_BRK13 field. */
#define LPUART_RD_STAT_BRK13(base) ((LPUART_STAT_REG(base) & LPUART_STAT_BRK13_MASK) >> LPUART_STAT_BRK13_SHIFT)
#define LPUART_BRD_STAT_BRK13(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT))

/*! @brief Set the BRK13 field to a new value. */
#define LPUART_WR_STAT_BRK13(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_BRK13_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_BRK13(value)))
#define LPUART_BWR_STAT_BRK13(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_BRK13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RWUID[27] (RW)
 *
 * For RWU on idle character, RWUID controls whether the idle character that
 * wakes up the receiver sets the IDLE bit. For address match wakeup, RWUID controls
 * if the IDLE bit is set when the address does not match. This bit should only
 * be changed when the receiver is disabled.
 *
 * Values:
 * - 0 - During receive standby state (RWU = 1), the IDLE bit does not get set
 *     upon detection of an idle character. During address match wakeup, the IDLE
 *     bit does not get set when an address does not match.
 * - 1 - During receive standby state (RWU = 1), the IDLE bit gets set upon
 *     detection of an idle character. During address match wakeup, the IDLE bit does
 *     get set when an address does not match.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RWUID field. */
#define LPUART_RD_STAT_RWUID(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RWUID_MASK) >> LPUART_STAT_RWUID_SHIFT)
#define LPUART_BRD_STAT_RWUID(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT))

/*! @brief Set the RWUID field to a new value. */
#define LPUART_WR_STAT_RWUID(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RWUID_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RWUID(value)))
#define LPUART_BWR_STAT_RWUID(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RWUID_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the received data input. Setting
 * RXINV inverts the LPUART_RX input for all cases: data bits, start and stop bits,
 * break, and idle.
 *
 * Values:
 * - 0 - Receive data not inverted.
 * - 1 - Receive data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXINV field. */
#define LPUART_RD_STAT_RXINV(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXINV_MASK) >> LPUART_STAT_RXINV_SHIFT)
#define LPUART_BRD_STAT_RXINV(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT))

/*! @brief Set the RXINV field to a new value. */
#define LPUART_WR_STAT_RXINV(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXINV_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXINV(value)))
#define LPUART_BWR_STAT_RXINV(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field MSBF[29] (RW)
 *
 * Setting this bit reverses the order of the bits that are transmitted and
 * received on the wire. This bit does not affect the polarity of the bits, the
 * location of the parity bit or the location of the start or stop bits. This bit
 * should only be changed when the transmitter and receiver are both disabled.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit9, bit8, bit7 or bit6) is the first bit that is transmitted
 *     following the start bit depending on the setting of CTRL[M], CTRL[PE] and
 *     BAUD[M10]. Further, the first bit received after the start bit is identified
 *     as bit9, bit8, bit7 or bit6 depending on the setting of CTRL[M] and
 *     CTRL[PE].
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_MSBF field. */
#define LPUART_RD_STAT_MSBF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_MSBF_MASK) >> LPUART_STAT_MSBF_SHIFT)
#define LPUART_BRD_STAT_MSBF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT))

/*! @brief Set the MSBF field to a new value. */
#define LPUART_WR_STAT_MSBF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_MSBF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_MSBF(value)))
#define LPUART_BWR_STAT_MSBF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_MSBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field RXEDGIF[30] (W1C)
 *
 * RXEDGIF is set when an active edge, falling if RXINV = 0, rising if RXINV=1,
 * on the LPUART_RX pin occurs. RXEDGIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_RXEDGIF field. */
#define LPUART_RD_STAT_RXEDGIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_RXEDGIF_MASK) >> LPUART_STAT_RXEDGIF_SHIFT)
#define LPUART_BRD_STAT_RXEDGIF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT))

/*! @brief Set the RXEDGIF field to a new value. */
#define LPUART_WR_STAT_RXEDGIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_RXEDGIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_LBKDIF_MASK), LPUART_STAT_RXEDGIF(value)))
#define LPUART_BWR_STAT_RXEDGIF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_RXEDGIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_STAT, field LBKDIF[31] (W1C)
 *
 * LBKDIF is set when the LIN break detect circuitry is enabled and a LIN break
 * character is detected. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character has been detected.
 * - 1 - LIN break character has been detected.
 */
/*@{*/
/*! @brief Read current value of the LPUART_STAT_LBKDIF field. */
#define LPUART_RD_STAT_LBKDIF(base) ((LPUART_STAT_REG(base) & LPUART_STAT_LBKDIF_MASK) >> LPUART_STAT_LBKDIF_SHIFT)
#define LPUART_BRD_STAT_LBKDIF(base) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT))

/*! @brief Set the LBKDIF field to a new value. */
#define LPUART_WR_STAT_LBKDIF(base, value) (LPUART_RMW_STAT(base, (LPUART_STAT_LBKDIF_MASK | LPUART_STAT_MA2F_MASK | LPUART_STAT_MA1F_MASK | LPUART_STAT_PF_MASK | LPUART_STAT_FE_MASK | LPUART_STAT_NF_MASK | LPUART_STAT_OR_MASK | LPUART_STAT_IDLE_MASK | LPUART_STAT_RXEDGIF_MASK), LPUART_STAT_LBKDIF(value)))
#define LPUART_BWR_STAT_LBKDIF(base, value) (BITBAND_ACCESS32(&LPUART_STAT_REG(base), LPUART_STAT_LBKDIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_CTRL - LPUART Control Register
 ******************************************************************************/

/*!
 * @brief LPUART_CTRL - LPUART Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This read/write register controls various optional features of the LPUART
 * system. This register should only be altered when the transmitter and receiver
 * are both disabled.
 */
/*!
 * @name Constants and macros for entire LPUART_CTRL register
 */
/*@{*/
#define LPUART_RD_CTRL(base)     (LPUART_CTRL_REG(base))
#define LPUART_WR_CTRL(base, value) (LPUART_CTRL_REG(base) = (value))
#define LPUART_RMW_CTRL(base, mask, value) (LPUART_WR_CTRL(base, (LPUART_RD_CTRL(base) & ~(mask)) | (value)))
#define LPUART_SET_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) |  (value)))
#define LPUART_CLR_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) & ~(value)))
#define LPUART_TOG_CTRL(base, value) (LPUART_WR_CTRL(base, LPUART_RD_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_CTRL bitfields
 */

/*!
 * @name Register LPUART_CTRL, field PT[0] (RW)
 *
 * Provided parity is enabled (PE = 1), this bit selects even or odd parity. Odd
 * parity means the total number of 1s in the data character, including the
 * parity bit, is odd. Even parity means the total number of 1s in the data
 * character, including the parity bit, is even.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PT field. */
#define LPUART_RD_CTRL_PT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PT_MASK) >> LPUART_CTRL_PT_SHIFT)
#define LPUART_BRD_CTRL_PT(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT))

/*! @brief Set the PT field to a new value. */
#define LPUART_WR_CTRL_PT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PT_MASK, LPUART_CTRL_PT(value)))
#define LPUART_BWR_CTRL_PT(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PE[1] (RW)
 *
 * Enables hardware parity generation and checking. When parity is enabled, the
 * bit immediately before the stop bit is treated as the parity bit.
 *
 * Values:
 * - 0 - No hardware parity generation or checking.
 * - 1 - Parity enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PE field. */
#define LPUART_RD_CTRL_PE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PE_MASK) >> LPUART_CTRL_PE_SHIFT)
#define LPUART_BRD_CTRL_PE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define LPUART_WR_CTRL_PE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PE_MASK, LPUART_CTRL_PE(value)))
#define LPUART_BWR_CTRL_PE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the LPUART is programmed with ILT = 1, a
 * logic 0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILT field. */
#define LPUART_RD_CTRL_ILT(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILT_MASK) >> LPUART_CTRL_ILT_SHIFT)
#define LPUART_BRD_CTRL_ILT(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT))

/*! @brief Set the ILT field to a new value. */
#define LPUART_WR_CTRL_ILT(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILT_MASK, LPUART_CTRL_ILT(value)))
#define LPUART_BWR_CTRL_ILT(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field WAKE[3] (RW)
 *
 * Determines which condition wakes the LPUART when RWU=1: Address mark in the
 * most significant bit position of a received data character, or An idle
 * condition on the receive pin input signal.
 *
 * Values:
 * - 0 - Configures RWU for idle-line wakeup.
 * - 1 - Configures RWU with address-mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_WAKE field. */
#define LPUART_RD_CTRL_WAKE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_WAKE_MASK) >> LPUART_CTRL_WAKE_SHIFT)
#define LPUART_BRD_CTRL_WAKE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT))

/*! @brief Set the WAKE field to a new value. */
#define LPUART_WR_CTRL_WAKE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_WAKE_MASK, LPUART_CTRL_WAKE(value)))
#define LPUART_BWR_CTRL_WAKE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_WAKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field M[4] (RW)
 *
 * Values:
 * - 0 - Receiver and transmitter use 8-bit data characters.
 * - 1 - Receiver and transmitter use 9-bit data characters.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_M field. */
#define LPUART_RD_CTRL_M(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_M_MASK) >> LPUART_CTRL_M_SHIFT)
#define LPUART_BRD_CTRL_M(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT))

/*! @brief Set the M field to a new value. */
#define LPUART_WR_CTRL_M(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_M_MASK, LPUART_CTRL_M(value)))
#define LPUART_BWR_CTRL_M(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_M_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Provided LOOPS is set, RSRC is cleared, selects internal loop back mode
 *     and the LPUART does not use the LPUART_RX pin.
 * - 1 - Single-wire LPUART mode where the LPUART_TX pin is connected to the
 *     transmitter output and receiver input.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RSRC field. */
#define LPUART_RD_CTRL_RSRC(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RSRC_MASK) >> LPUART_CTRL_RSRC_SHIFT)
#define LPUART_BRD_CTRL_RSRC(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT))

/*! @brief Set the RSRC field to a new value. */
#define LPUART_WR_CTRL_RSRC(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RSRC_MASK, LPUART_CTRL_RSRC(value)))
#define LPUART_BWR_CTRL_RSRC(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field DOZEEN[6] (RW)
 *
 * Values:
 * - 0 - LPUART is enabled in Doze mode.
 * - 1 - LPUART is disabled in Doze mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_DOZEEN field. */
#define LPUART_RD_CTRL_DOZEEN(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_DOZEEN_MASK) >> LPUART_CTRL_DOZEEN_SHIFT)
#define LPUART_BRD_CTRL_DOZEEN(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT))

/*! @brief Set the DOZEEN field to a new value. */
#define LPUART_WR_CTRL_DOZEEN(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_DOZEEN_MASK, LPUART_CTRL_DOZEEN(value)))
#define LPUART_BWR_CTRL_DOZEEN(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_DOZEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the LPUART_RX pin is disconnected from the LPUART and the
 * transmitter output is internally connected to the receiver input. The
 * transmitter and the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation - LPUART_RX and LPUART_TX use separate pins.
 * - 1 - Loop mode or single-wire mode where transmitter outputs are internally
 *     connected to receiver input (see RSRC bit).
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_LOOPS field. */
#define LPUART_RD_CTRL_LOOPS(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_LOOPS_MASK) >> LPUART_CTRL_LOOPS_SHIFT)
#define LPUART_BRD_CTRL_LOOPS(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT))

/*! @brief Set the LOOPS field to a new value. */
#define LPUART_WR_CTRL_LOOPS(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_LOOPS_MASK, LPUART_CTRL_LOOPS(value)))
#define LPUART_BWR_CTRL_LOOPS(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_LOOPS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field IDLECFG[10:8] (RW)
 *
 * Configures the number of idle characters that must be received before the
 * IDLE flag is set.
 *
 * Values:
 * - 000 - 1 idle character
 * - 001 - 2 idle characters
 * - 010 - 4 idle characters
 * - 011 - 8 idle characters
 * - 100 - 16 idle characters
 * - 101 - 32 idle characters
 * - 110 - 64 idle characters
 * - 111 - 128 idle characters
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_IDLECFG field. */
#define LPUART_RD_CTRL_IDLECFG(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_IDLECFG_MASK) >> LPUART_CTRL_IDLECFG_SHIFT)
#define LPUART_BRD_CTRL_IDLECFG(base) (LPUART_RD_CTRL_IDLECFG(base))

/*! @brief Set the IDLECFG field to a new value. */
#define LPUART_WR_CTRL_IDLECFG(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_IDLECFG_MASK, LPUART_CTRL_IDLECFG(value)))
#define LPUART_BWR_CTRL_IDLECFG(base, value) (LPUART_WR_CTRL_IDLECFG(base, value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA2IE[14] (RW)
 *
 * Values:
 * - 0 - MA2F interrupt disabled
 * - 1 - MA2F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA2IE field. */
#define LPUART_RD_CTRL_MA2IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA2IE_MASK) >> LPUART_CTRL_MA2IE_SHIFT)
#define LPUART_BRD_CTRL_MA2IE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT))

/*! @brief Set the MA2IE field to a new value. */
#define LPUART_WR_CTRL_MA2IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA2IE_MASK, LPUART_CTRL_MA2IE(value)))
#define LPUART_BWR_CTRL_MA2IE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA2IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field MA1IE[15] (RW)
 *
 * Values:
 * - 0 - MA1F interrupt disabled
 * - 1 - MA1F interrupt enabled
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_MA1IE field. */
#define LPUART_RD_CTRL_MA1IE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_MA1IE_MASK) >> LPUART_CTRL_MA1IE_SHIFT)
#define LPUART_BRD_CTRL_MA1IE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT))

/*! @brief Set the MA1IE field to a new value. */
#define LPUART_WR_CTRL_MA1IE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_MA1IE_MASK, LPUART_CTRL_MA1IE(value)))
#define LPUART_BWR_CTRL_MA1IE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_MA1IE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field SBK[16] (RW)
 *
 * Writing a 1 and then a 0 to SBK queues a break character in the transmit data
 * stream. Additional break characters of 10 to 13, or 13 to 16 if
 * LPUART_STATBRK13] is set, bit times of logic 0 are queued as long as SBK is set. Depending
 * on the timing of the set and clear of SBK relative to the information
 * currently being transmitted, a second break character may be queued before software
 * clears SBK.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break character(s) to be sent.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_SBK field. */
#define LPUART_RD_CTRL_SBK(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_SBK_MASK) >> LPUART_CTRL_SBK_SHIFT)
#define LPUART_BRD_CTRL_SBK(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT))

/*! @brief Set the SBK field to a new value. */
#define LPUART_WR_CTRL_SBK(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_SBK_MASK, LPUART_CTRL_SBK(value)))
#define LPUART_BWR_CTRL_SBK(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_SBK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RWU[17] (RW)
 *
 * This field can be set to place the LPUART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * CTRL[WAKE] is clear or an address match when CTRL[WAKE] is set with STAT[RWUID] is
 * clear. RWU must be set only with CTRL[WAKE] = 0 (wakeup on idle) if the
 * channel is currently not idle. This can be determined by STAT[RAF]. If the flag is
 * set to wake up an IDLE event and the channel is already idle, it is possible
 * that the LPUART will discard data. This is because the data must be received or
 * a LIN break detected after an IDLE is detected before IDLE is allowed to be
 * reasserted.
 *
 * Values:
 * - 0 - Normal receiver operation.
 * - 1 - LPUART receiver in standby waiting for wakeup condition.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RWU field. */
#define LPUART_RD_CTRL_RWU(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RWU_MASK) >> LPUART_CTRL_RWU_SHIFT)
#define LPUART_BRD_CTRL_RWU(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT))

/*! @brief Set the RWU field to a new value. */
#define LPUART_WR_CTRL_RWU(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RWU_MASK, LPUART_CTRL_RWU(value)))
#define LPUART_BWR_CTRL_RWU(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RWU_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RE[18] (RW)
 *
 * Enables the LPUART receiver. When RE is written to 0, this register bit will
 * read as 1 until the receiver finishes receiving the current character (if any).
 *
 * Values:
 * - 0 - Receiver disabled.
 * - 1 - Receiver enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RE field. */
#define LPUART_RD_CTRL_RE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RE_MASK) >> LPUART_CTRL_RE_SHIFT)
#define LPUART_BRD_CTRL_RE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define LPUART_WR_CTRL_RE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RE_MASK, LPUART_CTRL_RE(value)))
#define LPUART_BWR_CTRL_RE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TE[19] (RW)
 *
 * Enables the LPUART transmitter. TE can also be used to queue an idle preamble
 * by clearing and then setting TE. When TE is cleared, this register bit will
 * read as 1 until the transmitter has completed the current character and the
 * LPUART_TX pin is tristated.
 *
 * Values:
 * - 0 - Transmitter disabled.
 * - 1 - Transmitter enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TE field. */
#define LPUART_RD_CTRL_TE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TE_MASK) >> LPUART_CTRL_TE_SHIFT)
#define LPUART_BRD_CTRL_TE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define LPUART_WR_CTRL_TE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TE_MASK, LPUART_CTRL_TE(value)))
#define LPUART_BWR_CTRL_TE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ILIE[20] (RW)
 *
 * ILIE enables the idle line flag, STAT[IDLE], to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from IDLE disabled; use polling.
 * - 1 - Hardware interrupt requested when IDLE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ILIE field. */
#define LPUART_RD_CTRL_ILIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ILIE_MASK) >> LPUART_CTRL_ILIE_SHIFT)
#define LPUART_BRD_CTRL_ILIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT))

/*! @brief Set the ILIE field to a new value. */
#define LPUART_WR_CTRL_ILIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ILIE_MASK, LPUART_CTRL_ILIE(value)))
#define LPUART_BWR_CTRL_ILIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ILIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field RIE[21] (RW)
 *
 * Enables STAT[RDRF] to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RDRF disabled; use polling.
 * - 1 - Hardware interrupt requested when RDRF flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_RIE field. */
#define LPUART_RD_CTRL_RIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_RIE_MASK) >> LPUART_CTRL_RIE_SHIFT)
#define LPUART_BRD_CTRL_RIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT))

/*! @brief Set the RIE field to a new value. */
#define LPUART_WR_CTRL_RIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_RIE_MASK, LPUART_CTRL_RIE(value)))
#define LPUART_BWR_CTRL_RIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_RIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TCIE[22] (RW)
 *
 * TCIE enables the transmission complete flag, TC, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from TC disabled; use polling.
 * - 1 - Hardware interrupt requested when TC flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TCIE field. */
#define LPUART_RD_CTRL_TCIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TCIE_MASK) >> LPUART_CTRL_TCIE_SHIFT)
#define LPUART_BRD_CTRL_TCIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT))

/*! @brief Set the TCIE field to a new value. */
#define LPUART_WR_CTRL_TCIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TCIE_MASK, LPUART_CTRL_TCIE(value)))
#define LPUART_BWR_CTRL_TCIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TIE[23] (RW)
 *
 * Enables STAT[TDRE] to generate interrupt requests.
 *
 * Values:
 * - 0 - Hardware interrupts from TDRE disabled; use polling.
 * - 1 - Hardware interrupt requested when TDRE flag is 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TIE field. */
#define LPUART_RD_CTRL_TIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TIE_MASK) >> LPUART_CTRL_TIE_SHIFT)
#define LPUART_BRD_CTRL_TIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define LPUART_WR_CTRL_TIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TIE_MASK, LPUART_CTRL_TIE(value)))
#define LPUART_BWR_CTRL_TIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field PEIE[24] (RW)
 *
 * This bit enables the parity error flag (PF) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - PF interrupts disabled; use polling).
 * - 1 - Hardware interrupt requested when PF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_PEIE field. */
#define LPUART_RD_CTRL_PEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_PEIE_MASK) >> LPUART_CTRL_PEIE_SHIFT)
#define LPUART_BRD_CTRL_PEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT))

/*! @brief Set the PEIE field to a new value. */
#define LPUART_WR_CTRL_PEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_PEIE_MASK, LPUART_CTRL_PEIE(value)))
#define LPUART_BWR_CTRL_PEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_PEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field FEIE[25] (RW)
 *
 * This bit enables the framing error flag (FE) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - FE interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when FE is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_FEIE field. */
#define LPUART_RD_CTRL_FEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_FEIE_MASK) >> LPUART_CTRL_FEIE_SHIFT)
#define LPUART_BRD_CTRL_FEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define LPUART_WR_CTRL_FEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_FEIE_MASK, LPUART_CTRL_FEIE(value)))
#define LPUART_BWR_CTRL_FEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field NEIE[26] (RW)
 *
 * This bit enables the noise flag (NF) to generate hardware interrupt requests.
 *
 * Values:
 * - 0 - NF interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when NF is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_NEIE field. */
#define LPUART_RD_CTRL_NEIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_NEIE_MASK) >> LPUART_CTRL_NEIE_SHIFT)
#define LPUART_BRD_CTRL_NEIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT))

/*! @brief Set the NEIE field to a new value. */
#define LPUART_WR_CTRL_NEIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_NEIE_MASK, LPUART_CTRL_NEIE(value)))
#define LPUART_BWR_CTRL_NEIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_NEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field ORIE[27] (RW)
 *
 * This bit enables the overrun flag (OR) to generate hardware interrupt
 * requests.
 *
 * Values:
 * - 0 - OR interrupts disabled; use polling.
 * - 1 - Hardware interrupt requested when OR is set.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_ORIE field. */
#define LPUART_RD_CTRL_ORIE(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_ORIE_MASK) >> LPUART_CTRL_ORIE_SHIFT)
#define LPUART_BRD_CTRL_ORIE(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT))

/*! @brief Set the ORIE field to a new value. */
#define LPUART_WR_CTRL_ORIE(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_ORIE_MASK, LPUART_CTRL_ORIE(value)))
#define LPUART_BWR_CTRL_ORIE(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_ORIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXINV[28] (RW)
 *
 * Setting this bit reverses the polarity of the transmitted data output.
 * Setting TXINV inverts the LPUART_TX output for all cases: data bits, start and stop
 * bits, break, and idle.
 *
 * Values:
 * - 0 - Transmit data not inverted.
 * - 1 - Transmit data inverted.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXINV field. */
#define LPUART_RD_CTRL_TXINV(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXINV_MASK) >> LPUART_CTRL_TXINV_SHIFT)
#define LPUART_BRD_CTRL_TXINV(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT))

/*! @brief Set the TXINV field to a new value. */
#define LPUART_WR_CTRL_TXINV(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXINV_MASK, LPUART_CTRL_TXINV(value)))
#define LPUART_BWR_CTRL_TXINV(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field TXDIR[29] (RW)
 *
 * When the LPUART is configured for single-wire half-duplex operation (LOOPS =
 * RSRC = 1), this bit determines the direction of data at the LPUART_TX pin.
 * When clearing TXDIR, the transmitter will finish receiving the current character
 * (if any) before the receiver starts receiving data from the LPUART_TX pin.
 *
 * Values:
 * - 0 - LPUART_TX pin is an input in single-wire mode.
 * - 1 - LPUART_TX pin is an output in single-wire mode.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_TXDIR field. */
#define LPUART_RD_CTRL_TXDIR(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_TXDIR_MASK) >> LPUART_CTRL_TXDIR_SHIFT)
#define LPUART_BRD_CTRL_TXDIR(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT))

/*! @brief Set the TXDIR field to a new value. */
#define LPUART_WR_CTRL_TXDIR(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_TXDIR_MASK, LPUART_CTRL_TXDIR(value)))
#define LPUART_BWR_CTRL_TXDIR(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_TXDIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R9T8[30] (RW)
 *
 * R9 is the tenth data bit received when the LPUART is configured for 10-bit
 * data formats. When reading 10-bit data, read R9 before reading LPUART_DATA T8 is
 * the ninth data bit received when the LPUART is configured for 9-bit or 10-bit
 * data formats. When writing 9-bit or 10-bit data, write T8 before writing
 * LPUART_DATA. If T8 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written each
 * time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R9T8 field. */
#define LPUART_RD_CTRL_R9T8(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R9T8_MASK) >> LPUART_CTRL_R9T8_SHIFT)
#define LPUART_BRD_CTRL_R9T8(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT))

/*! @brief Set the R9T8 field to a new value. */
#define LPUART_WR_CTRL_R9T8(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R9T8_MASK, LPUART_CTRL_R9T8(value)))
#define LPUART_BWR_CTRL_R9T8(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R9T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_CTRL, field R8T9[31] (RW)
 *
 * R8 is the ninth data bit received when the LPUART is configured for 9-bit or
 * 10-bit data formats. When reading 9-bit or 10-bit data, read R8 before reading
 * LPUART_DATA. T9 is the tenth data bit received when the LPUART is configured
 * for 10-bit data formats. When writing 10-bit data, write T9 before writing
 * LPUART_DATA. If T9 does not need to change from its previous value, such as when
 * it is used to generate address mark or parity, they it need not be written
 * each time LPUART_DATA is written.
 */
/*@{*/
/*! @brief Read current value of the LPUART_CTRL_R8T9 field. */
#define LPUART_RD_CTRL_R8T9(base) ((LPUART_CTRL_REG(base) & LPUART_CTRL_R8T9_MASK) >> LPUART_CTRL_R8T9_SHIFT)
#define LPUART_BRD_CTRL_R8T9(base) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT))

/*! @brief Set the R8T9 field to a new value. */
#define LPUART_WR_CTRL_R8T9(base, value) (LPUART_RMW_CTRL(base, LPUART_CTRL_R8T9_MASK, LPUART_CTRL_R8T9(value)))
#define LPUART_BWR_CTRL_R8T9(base, value) (BITBAND_ACCESS32(&LPUART_CTRL_REG(base), LPUART_CTRL_R8T9_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * LPUART_DATA - LPUART Data Register
 ******************************************************************************/

/*!
 * @brief LPUART_DATA - LPUART Data Register (RW)
 *
 * Reset value: 0x00001000U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data buffer and writes go to the write-only transmit
 * data buffer. Reads and writes of this register are also involved in the
 * automatic flag clearing mechanisms for some of the LPUART status flags.
 */
/*!
 * @name Constants and macros for entire LPUART_DATA register
 */
/*@{*/
#define LPUART_RD_DATA(base)     (LPUART_DATA_REG(base))
#define LPUART_WR_DATA(base, value) (LPUART_DATA_REG(base) = (value))
#define LPUART_RMW_DATA(base, mask, value) (LPUART_WR_DATA(base, (LPUART_RD_DATA(base) & ~(mask)) | (value)))
#define LPUART_SET_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) |  (value)))
#define LPUART_CLR_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) & ~(value)))
#define LPUART_TOG_DATA(base, value) (LPUART_WR_DATA(base, LPUART_RD_DATA(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_DATA bitfields
 */

/*!
 * @name Register LPUART_DATA, field R0T0[0] (RW)
 *
 * Read receive data buffer 0 or write transmit data buffer 0.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R0T0 field. */
#define LPUART_RD_DATA_R0T0(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R0T0_MASK) >> LPUART_DATA_R0T0_SHIFT)
#define LPUART_BRD_DATA_R0T0(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT))

/*! @brief Set the R0T0 field to a new value. */
#define LPUART_WR_DATA_R0T0(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R0T0_MASK, LPUART_DATA_R0T0(value)))
#define LPUART_BWR_DATA_R0T0(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R0T0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R1T1[1] (RW)
 *
 * Read receive data buffer 1 or write transmit data buffer 1.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R1T1 field. */
#define LPUART_RD_DATA_R1T1(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R1T1_MASK) >> LPUART_DATA_R1T1_SHIFT)
#define LPUART_BRD_DATA_R1T1(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT))

/*! @brief Set the R1T1 field to a new value. */
#define LPUART_WR_DATA_R1T1(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R1T1_MASK, LPUART_DATA_R1T1(value)))
#define LPUART_BWR_DATA_R1T1(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R1T1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R2T2[2] (RW)
 *
 * Read receive data buffer 2 or write transmit data buffer 2.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R2T2 field. */
#define LPUART_RD_DATA_R2T2(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R2T2_MASK) >> LPUART_DATA_R2T2_SHIFT)
#define LPUART_BRD_DATA_R2T2(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT))

/*! @brief Set the R2T2 field to a new value. */
#define LPUART_WR_DATA_R2T2(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R2T2_MASK, LPUART_DATA_R2T2(value)))
#define LPUART_BWR_DATA_R2T2(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R2T2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R3T3[3] (RW)
 *
 * Read receive data buffer 3 or write transmit data buffer 3.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R3T3 field. */
#define LPUART_RD_DATA_R3T3(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R3T3_MASK) >> LPUART_DATA_R3T3_SHIFT)
#define LPUART_BRD_DATA_R3T3(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT))

/*! @brief Set the R3T3 field to a new value. */
#define LPUART_WR_DATA_R3T3(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R3T3_MASK, LPUART_DATA_R3T3(value)))
#define LPUART_BWR_DATA_R3T3(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R3T3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R4T4[4] (RW)
 *
 * Read receive data buffer 4 or write transmit data buffer 4.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R4T4 field. */
#define LPUART_RD_DATA_R4T4(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R4T4_MASK) >> LPUART_DATA_R4T4_SHIFT)
#define LPUART_BRD_DATA_R4T4(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT))

/*! @brief Set the R4T4 field to a new value. */
#define LPUART_WR_DATA_R4T4(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R4T4_MASK, LPUART_DATA_R4T4(value)))
#define LPUART_BWR_DATA_R4T4(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R4T4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R5T5[5] (RW)
 *
 * Read receive data buffer 5 or write transmit data buffer 5.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R5T5 field. */
#define LPUART_RD_DATA_R5T5(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R5T5_MASK) >> LPUART_DATA_R5T5_SHIFT)
#define LPUART_BRD_DATA_R5T5(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT))

/*! @brief Set the R5T5 field to a new value. */
#define LPUART_WR_DATA_R5T5(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R5T5_MASK, LPUART_DATA_R5T5(value)))
#define LPUART_BWR_DATA_R5T5(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R5T5_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R6T6[6] (RW)
 *
 * Read receive data buffer 6 or write transmit data buffer 6.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R6T6 field. */
#define LPUART_RD_DATA_R6T6(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R6T6_MASK) >> LPUART_DATA_R6T6_SHIFT)
#define LPUART_BRD_DATA_R6T6(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT))

/*! @brief Set the R6T6 field to a new value. */
#define LPUART_WR_DATA_R6T6(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R6T6_MASK, LPUART_DATA_R6T6(value)))
#define LPUART_BWR_DATA_R6T6(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R6T6_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R7T7[7] (RW)
 *
 * Read receive data buffer 7 or write transmit data buffer 7.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R7T7 field. */
#define LPUART_RD_DATA_R7T7(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R7T7_MASK) >> LPUART_DATA_R7T7_SHIFT)
#define LPUART_BRD_DATA_R7T7(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT))

/*! @brief Set the R7T7 field to a new value. */
#define LPUART_WR_DATA_R7T7(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R7T7_MASK, LPUART_DATA_R7T7(value)))
#define LPUART_BWR_DATA_R7T7(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R7T7_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R8T8[8] (RW)
 *
 * Read receive data buffer 8 or write transmit data buffer 8.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R8T8 field. */
#define LPUART_RD_DATA_R8T8(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R8T8_MASK) >> LPUART_DATA_R8T8_SHIFT)
#define LPUART_BRD_DATA_R8T8(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT))

/*! @brief Set the R8T8 field to a new value. */
#define LPUART_WR_DATA_R8T8(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R8T8_MASK, LPUART_DATA_R8T8(value)))
#define LPUART_BWR_DATA_R8T8(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R8T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field R9T9[9] (RW)
 *
 * Read receive data buffer 9 or write transmit data buffer 9.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_R9T9 field. */
#define LPUART_RD_DATA_R9T9(base) ((LPUART_DATA_REG(base) & LPUART_DATA_R9T9_MASK) >> LPUART_DATA_R9T9_SHIFT)
#define LPUART_BRD_DATA_R9T9(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT))

/*! @brief Set the R9T9 field to a new value. */
#define LPUART_WR_DATA_R9T9(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_R9T9_MASK, LPUART_DATA_R9T9(value)))
#define LPUART_BWR_DATA_R9T9(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_R9T9_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field IDLINE[11] (RO)
 *
 * Indicates the receiver line was idle before receiving the character in
 * DATA[9:0]. Unlike the IDLE flag, this bit can set for the first character received
 * when the receiver is first enabled.
 *
 * Values:
 * - 0 - Receiver was not idle before receiving this character.
 * - 1 - Receiver was idle before receiving this character.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_IDLINE field. */
#define LPUART_RD_DATA_IDLINE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_IDLINE_MASK) >> LPUART_DATA_IDLINE_SHIFT)
#define LPUART_BRD_DATA_IDLINE(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_IDLINE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field RXEMPT[12] (RO)
 *
 * Asserts when there is no data in the receive buffer. This field does not take
 * into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer contains valid data.
 * - 1 - Receive buffer is empty, data returned on read is not valid.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_RXEMPT field. */
#define LPUART_RD_DATA_RXEMPT(base) ((LPUART_DATA_REG(base) & LPUART_DATA_RXEMPT_MASK) >> LPUART_DATA_RXEMPT_SHIFT)
#define LPUART_BRD_DATA_RXEMPT(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_RXEMPT_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field FRETSC[13] (RW)
 *
 * For reads, indicates the current received dataword contained in DATA[R9:R0]
 * was received with a frame error. For writes, indicates a break or idle
 * character is to be transmitted instead of the contents in DATA[T9:T0]. T9 is used to
 * indicate a break character when 0 and a idle character when 1, he contents of
 * DATA[T8:T0] should be zero.
 *
 * Values:
 * - 0 - The dataword was received without a frame error on read, transmit a
 *     normal character on write.
 * - 1 - The dataword was received with a frame error, transmit an idle or break
 *     character on transmit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_FRETSC field. */
#define LPUART_RD_DATA_FRETSC(base) ((LPUART_DATA_REG(base) & LPUART_DATA_FRETSC_MASK) >> LPUART_DATA_FRETSC_SHIFT)
#define LPUART_BRD_DATA_FRETSC(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT))

/*! @brief Set the FRETSC field to a new value. */
#define LPUART_WR_DATA_FRETSC(base, value) (LPUART_RMW_DATA(base, LPUART_DATA_FRETSC_MASK, LPUART_DATA_FRETSC(value)))
#define LPUART_BWR_DATA_FRETSC(base, value) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_FRETSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_DATA, field PARITYE[14] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_PARITYE field. */
#define LPUART_RD_DATA_PARITYE(base) ((LPUART_DATA_REG(base) & LPUART_DATA_PARITYE_MASK) >> LPUART_DATA_PARITYE_SHIFT)
#define LPUART_BRD_DATA_PARITYE(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_PARITYE_SHIFT))
/*@}*/

/*!
 * @name Register LPUART_DATA, field NOISY[15] (RO)
 *
 * The current received dataword contained in DATA[R9:R0] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the LPUART_DATA_NOISY field. */
#define LPUART_RD_DATA_NOISY(base) ((LPUART_DATA_REG(base) & LPUART_DATA_NOISY_MASK) >> LPUART_DATA_NOISY_SHIFT)
#define LPUART_BRD_DATA_NOISY(base) (BITBAND_ACCESS32(&LPUART_DATA_REG(base), LPUART_DATA_NOISY_SHIFT))
/*@}*/

/*******************************************************************************
 * LPUART_MATCH - LPUART Match Address Register
 ******************************************************************************/

/*!
 * @brief LPUART_MATCH - LPUART Match Address Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire LPUART_MATCH register
 */
/*@{*/
#define LPUART_RD_MATCH(base)    (LPUART_MATCH_REG(base))
#define LPUART_WR_MATCH(base, value) (LPUART_MATCH_REG(base) = (value))
#define LPUART_RMW_MATCH(base, mask, value) (LPUART_WR_MATCH(base, (LPUART_RD_MATCH(base) & ~(mask)) | (value)))
#define LPUART_SET_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) |  (value)))
#define LPUART_CLR_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) & ~(value)))
#define LPUART_TOG_MATCH(base, value) (LPUART_WR_MATCH(base, LPUART_RD_MATCH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MATCH bitfields
 */

/*!
 * @name Register LPUART_MATCH, field MA1[9:0] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA1 field. */
#define LPUART_RD_MATCH_MA1(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA1_MASK) >> LPUART_MATCH_MA1_SHIFT)
#define LPUART_BRD_MATCH_MA1(base) (LPUART_RD_MATCH_MA1(base))

/*! @brief Set the MA1 field to a new value. */
#define LPUART_WR_MATCH_MA1(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA1_MASK, LPUART_MATCH_MA1(value)))
#define LPUART_BWR_MATCH_MA1(base, value) (LPUART_WR_MATCH_MA1(base, value))
/*@}*/

/*!
 * @name Register LPUART_MATCH, field MA2[25:16] (RW)
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated BAUD[MAEN] bit is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. Software should only write a MA register
 * when the associated BAUD[MAEN] bit is clear.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MATCH_MA2 field. */
#define LPUART_RD_MATCH_MA2(base) ((LPUART_MATCH_REG(base) & LPUART_MATCH_MA2_MASK) >> LPUART_MATCH_MA2_SHIFT)
#define LPUART_BRD_MATCH_MA2(base) (LPUART_RD_MATCH_MA2(base))

/*! @brief Set the MA2 field to a new value. */
#define LPUART_WR_MATCH_MA2(base, value) (LPUART_RMW_MATCH(base, LPUART_MATCH_MA2_MASK, LPUART_MATCH_MA2(value)))
#define LPUART_BWR_MATCH_MA2(base, value) (LPUART_WR_MATCH_MA2(base, value))
/*@}*/

/*******************************************************************************
 * LPUART_MODIR - LPUART Modem IrDA Register
 ******************************************************************************/

/*!
 * @brief LPUART_MODIR - LPUART Modem IrDA Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The MODEM register controls options for setting the modem configuration.
 */
/*!
 * @name Constants and macros for entire LPUART_MODIR register
 */
/*@{*/
#define LPUART_RD_MODIR(base)    (LPUART_MODIR_REG(base))
#define LPUART_WR_MODIR(base, value) (LPUART_MODIR_REG(base) = (value))
#define LPUART_RMW_MODIR(base, mask, value) (LPUART_WR_MODIR(base, (LPUART_RD_MODIR(base) & ~(mask)) | (value)))
#define LPUART_SET_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) |  (value)))
#define LPUART_CLR_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) & ~(value)))
#define LPUART_TOG_MODIR(base, value) (LPUART_WR_MODIR(base, LPUART_RD_MODIR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual LPUART_MODIR bitfields
 */

/*!
 * @name Register LPUART_MODIR, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSE field. */
#define LPUART_RD_MODIR_TXCTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSE_MASK) >> LPUART_MODIR_TXCTSE_SHIFT)
#define LPUART_BRD_MODIR_TXCTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT))

/*! @brief Set the TXCTSE field to a new value. */
#define LPUART_WR_MODIR_TXCTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSE_MASK, LPUART_MODIR_TXCTSE(value)))
#define LPUART_BWR_MODIR_TXCTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer , RTS
 *     asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSE field. */
#define LPUART_RD_MODIR_TXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSE_MASK) >> LPUART_MODIR_TXRTSE_SHIFT)
#define LPUART_BRD_MODIR_TXRTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT))

/*! @brief Set the TXRTSE field to a new value. */
#define LPUART_WR_MODIR_TXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSE_MASK, LPUART_MODIR_TXRTSE(value)))
#define LPUART_BWR_MODIR_TXRTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXRTSPOL field. */
#define LPUART_RD_MODIR_TXRTSPOL(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXRTSPOL_MASK) >> LPUART_MODIR_TXRTSPOL_SHIFT)
#define LPUART_BRD_MODIR_TXRTSPOL(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT))

/*! @brief Set the TXRTSPOL field to a new value. */
#define LPUART_WR_MODIR_TXRTSPOL(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXRTSPOL_MASK, LPUART_MODIR_TXRTSPOL(value)))
#define LPUART_BWR_MODIR_TXRTSPOL(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXRTSPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the receiver data register is full or a start bit
 *     has been detected that would cause the receiver data register to become
 *     full. RTS is asserted if the receiver data register is not full and has not
 *     detected a start bit that would cause the receiver data register to become
 *     full.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_RXRTSE field. */
#define LPUART_RD_MODIR_RXRTSE(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_RXRTSE_MASK) >> LPUART_MODIR_RXRTSE_SHIFT)
#define LPUART_BRD_MODIR_RXRTSE(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT))

/*! @brief Set the RXRTSE field to a new value. */
#define LPUART_WR_MODIR_RXRTSE(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_RXRTSE_MASK, LPUART_MODIR_RXRTSE(value)))
#define LPUART_BWR_MODIR_RXRTSE(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_RXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSC[4] (RW)
 *
 * Configures if the CTS state is checked at the start of each character or only
 * when the transmitter is idle.
 *
 * Values:
 * - 0 - CTS input is sampled at the start of each character.
 * - 1 - CTS input is sampled when the transmitter is idle.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSC field. */
#define LPUART_RD_MODIR_TXCTSC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSC_MASK) >> LPUART_MODIR_TXCTSC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSC(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT))

/*! @brief Set the TXCTSC field to a new value. */
#define LPUART_WR_MODIR_TXCTSC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSC_MASK, LPUART_MODIR_TXCTSC(value)))
#define LPUART_BWR_MODIR_TXCTSC(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TXCTSSRC[5] (RW)
 *
 * Configures the source of the CTS input.
 *
 * Values:
 * - 0 - CTS input is the LPUART_CTS pin.
 * - 1 - CTS input is the inverted Receiver Match result.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TXCTSSRC field. */
#define LPUART_RD_MODIR_TXCTSSRC(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TXCTSSRC_MASK) >> LPUART_MODIR_TXCTSSRC_SHIFT)
#define LPUART_BRD_MODIR_TXCTSSRC(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT))

/*! @brief Set the TXCTSSRC field to a new value. */
#define LPUART_WR_MODIR_TXCTSSRC(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TXCTSSRC_MASK, LPUART_MODIR_TXCTSSRC(value)))
#define LPUART_BWR_MODIR_TXCTSSRC(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_TXCTSSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field TNP[17:16] (RW)
 *
 * Enables whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR narrow
 * pulse.
 *
 * Values:
 * - 00 - 1/OSR.
 * - 01 - 2/OSR.
 * - 10 - 3/OSR.
 * - 11 - 4/OSR.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_TNP field. */
#define LPUART_RD_MODIR_TNP(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_TNP_MASK) >> LPUART_MODIR_TNP_SHIFT)
#define LPUART_BRD_MODIR_TNP(base) (LPUART_RD_MODIR_TNP(base))

/*! @brief Set the TNP field to a new value. */
#define LPUART_WR_MODIR_TNP(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_TNP_MASK, LPUART_MODIR_TNP(value)))
#define LPUART_BWR_MODIR_TNP(base, value) (LPUART_WR_MODIR_TNP(base, value))
/*@}*/

/*!
 * @name Register LPUART_MODIR, field IREN[18] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0 - IR disabled.
 * - 1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the LPUART_MODIR_IREN field. */
#define LPUART_RD_MODIR_IREN(base) ((LPUART_MODIR_REG(base) & LPUART_MODIR_IREN_MASK) >> LPUART_MODIR_IREN_SHIFT)
#define LPUART_BRD_MODIR_IREN(base) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT))

/*! @brief Set the IREN field to a new value. */
#define LPUART_WR_MODIR_IREN(base, value) (LPUART_RMW_MODIR(base, LPUART_MODIR_IREN_MASK, LPUART_MODIR_IREN(value)))
#define LPUART_BWR_MODIR_IREN(base, value) (BITBAND_ACCESS32(&LPUART_MODIR_REG(base), LPUART_MODIR_IREN_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 MCG
 *
 * Multipurpose Clock Generator module
 *
 * Registers defined in this header file:
 * - MCG_C1 - MCG Control 1 Register
 * - MCG_C2 - MCG Control 2 Register
 * - MCG_C3 - MCG Control 3 Register
 * - MCG_C4 - MCG Control 4 Register
 * - MCG_C5 - MCG Control 5 Register
 * - MCG_C6 - MCG Control 6 Register
 * - MCG_S - MCG Status Register
 * - MCG_SC - MCG Status and Control Register
 * - MCG_ATCVH - MCG Auto Trim Compare Value High Register
 * - MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 * - MCG_C7 - MCG Control 7 Register
 * - MCG_C8 - MCG Control 8 Register
 */

#define MCG_INSTANCE_COUNT (1U) /*!< Number of instances of the MCG module. */
#define MCG_IDX (0U) /*!< Instance number for MCG. */

/*******************************************************************************
 * MCG_C1 - MCG Control 1 Register
 ******************************************************************************/

/*!
 * @brief MCG_C1 - MCG Control 1 Register (RW)
 *
 * Reset value: 0x04U
 */
/*!
 * @name Constants and macros for entire MCG_C1 register
 */
/*@{*/
#define MCG_RD_C1(base)          (MCG_C1_REG(base))
#define MCG_WR_C1(base, value)   (MCG_C1_REG(base) = (value))
#define MCG_RMW_C1(base, mask, value) (MCG_WR_C1(base, (MCG_RD_C1(base) & ~(mask)) | (value)))
#define MCG_SET_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) |  (value)))
#define MCG_CLR_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) & ~(value)))
#define MCG_TOG_C1(base, value)  (MCG_WR_C1(base, MCG_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C1 bitfields
 */

/*!
 * @name Register MCG_C1, field IREFSTEN[0] (RW)
 *
 * Controls whether or not the internal reference clock remains enabled when the
 * MCG enters Stop mode.
 *
 * Values:
 * - 0 - Internal reference clock is disabled in Stop mode.
 * - 1 - Internal reference clock is enabled in Stop mode if IRCLKEN is set or
 *     if MCG is in FEI, FBI, or BLPI modes before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFSTEN field. */
#define MCG_RD_C1_IREFSTEN(base) ((MCG_C1_REG(base) & MCG_C1_IREFSTEN_MASK) >> MCG_C1_IREFSTEN_SHIFT)
#define MCG_BRD_C1_IREFSTEN(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT))

/*! @brief Set the IREFSTEN field to a new value. */
#define MCG_WR_C1_IREFSTEN(base, value) (MCG_RMW_C1(base, MCG_C1_IREFSTEN_MASK, MCG_C1_IREFSTEN(value)))
#define MCG_BWR_C1_IREFSTEN(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field IRCLKEN[1] (RW)
 *
 * Enables the internal reference clock for use as MCGIRCLK.
 *
 * Values:
 * - 0 - MCGIRCLK inactive.
 * - 1 - MCGIRCLK active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IRCLKEN field. */
#define MCG_RD_C1_IRCLKEN(base) ((MCG_C1_REG(base) & MCG_C1_IRCLKEN_MASK) >> MCG_C1_IRCLKEN_SHIFT)
#define MCG_BRD_C1_IRCLKEN(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT))

/*! @brief Set the IRCLKEN field to a new value. */
#define MCG_WR_C1_IRCLKEN(base, value) (MCG_RMW_C1(base, MCG_C1_IRCLKEN_MASK, MCG_C1_IRCLKEN(value)))
#define MCG_BWR_C1_IRCLKEN(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IRCLKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field IREFS[2] (RW)
 *
 * Selects the reference clock source for the FLL.
 *
 * Values:
 * - 0 - External reference clock is selected.
 * - 1 - The slow internal reference clock is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_IREFS field. */
#define MCG_RD_C1_IREFS(base) ((MCG_C1_REG(base) & MCG_C1_IREFS_MASK) >> MCG_C1_IREFS_SHIFT)
#define MCG_BRD_C1_IREFS(base) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT))

/*! @brief Set the IREFS field to a new value. */
#define MCG_WR_C1_IREFS(base, value) (MCG_RMW_C1(base, MCG_C1_IREFS_MASK, MCG_C1_IREFS(value)))
#define MCG_BWR_C1_IREFS(base, value) (BITBAND_ACCESS8(&MCG_C1_REG(base), MCG_C1_IREFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C1, field FRDIV[5:3] (RW)
 *
 * Selects the amount to divide down the external reference clock for the FLL.
 * The resulting frequency must be in the range 31.25 kHz to 39.0625 kHz (This is
 * required when FLL/DCO is the clock source for MCGOUTCLK . In FBE mode, it is
 * not required to meet this range, but it is recommended in the cases when trying
 * to enter a FLL mode from FBE).
 *
 * Values:
 * - 000 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 1; for all other RANGE
 *     values, Divide Factor is 32.
 * - 001 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 2; for all other RANGE
 *     values, Divide Factor is 64.
 * - 010 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 4; for all other RANGE
 *     values, Divide Factor is 128.
 * - 011 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 8; for all other RANGE
 *     values, Divide Factor is 256.
 * - 100 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 16; for all other RANGE
 *     values, Divide Factor is 512.
 * - 101 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 32; for all other RANGE
 *     values, Divide Factor is 1024.
 * - 110 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 64; for all other RANGE
 *     values, Divide Factor is 1280 .
 * - 111 - If RANGE = 0 or OSCSEL=1 , Divide Factor is 128; for all other RANGE
 *     values, Divide Factor is 1536 .
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_FRDIV field. */
#define MCG_RD_C1_FRDIV(base) ((MCG_C1_REG(base) & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)
#define MCG_BRD_C1_FRDIV(base) (MCG_RD_C1_FRDIV(base))

/*! @brief Set the FRDIV field to a new value. */
#define MCG_WR_C1_FRDIV(base, value) (MCG_RMW_C1(base, MCG_C1_FRDIV_MASK, MCG_C1_FRDIV(value)))
#define MCG_BWR_C1_FRDIV(base, value) (MCG_WR_C1_FRDIV(base, value))
/*@}*/

/*!
 * @name Register MCG_C1, field CLKS[7:6] (RW)
 *
 * Selects the clock source for MCGOUTCLK .
 *
 * Values:
 * - 00 - Encoding 0 - Output of FLL or PLL is selected (depends on PLLS control
 *     bit).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the MCG_C1_CLKS field. */
#define MCG_RD_C1_CLKS(base) ((MCG_C1_REG(base) & MCG_C1_CLKS_MASK) >> MCG_C1_CLKS_SHIFT)
#define MCG_BRD_C1_CLKS(base) (MCG_RD_C1_CLKS(base))

/*! @brief Set the CLKS field to a new value. */
#define MCG_WR_C1_CLKS(base, value) (MCG_RMW_C1(base, MCG_C1_CLKS_MASK, MCG_C1_CLKS(value)))
#define MCG_BWR_C1_CLKS(base, value) (MCG_WR_C1_CLKS(base, value))
/*@}*/

/*******************************************************************************
 * MCG_C2 - MCG Control 2 Register
 ******************************************************************************/

/*!
 * @brief MCG_C2 - MCG Control 2 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C2 register
 */
/*@{*/
#define MCG_RD_C2(base)          (MCG_C2_REG(base))
#define MCG_WR_C2(base, value)   (MCG_C2_REG(base) = (value))
#define MCG_RMW_C2(base, mask, value) (MCG_WR_C2(base, (MCG_RD_C2(base) & ~(mask)) | (value)))
#define MCG_SET_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) |  (value)))
#define MCG_CLR_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) & ~(value)))
#define MCG_TOG_C2(base, value)  (MCG_WR_C2(base, MCG_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C2 bitfields
 */

/*!
 * @name Register MCG_C2, field IRCS[0] (RW)
 *
 * Selects between the fast or slow internal reference clock source.
 *
 * Values:
 * - 0 - Slow internal reference clock selected.
 * - 1 - Fast internal reference clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_IRCS field. */
#define MCG_RD_C2_IRCS(base) ((MCG_C2_REG(base) & MCG_C2_IRCS_MASK) >> MCG_C2_IRCS_SHIFT)
#define MCG_BRD_C2_IRCS(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT))

/*! @brief Set the IRCS field to a new value. */
#define MCG_WR_C2_IRCS(base, value) (MCG_RMW_C2(base, MCG_C2_IRCS_MASK, MCG_C2_IRCS(value)))
#define MCG_BWR_C2_IRCS(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_IRCS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field LP[1] (RW)
 *
 * Controls whether the FLL or PLL is disabled in BLPI and BLPE modes. In FBE or
 * PBE modes, setting this bit to 1 will transition the MCG into BLPE mode; in
 * FBI mode, setting this bit to 1 will transition the MCG into BLPI mode. In any
 * other MCG mode, LP bit has no affect.
 *
 * Values:
 * - 0 - FLL or PLL is not disabled in bypass modes.
 * - 1 - FLL or PLL is disabled in bypass modes (lower power)
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LP field. */
#define MCG_RD_C2_LP(base)   ((MCG_C2_REG(base) & MCG_C2_LP_MASK) >> MCG_C2_LP_SHIFT)
#define MCG_BRD_C2_LP(base)  (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT))

/*! @brief Set the LP field to a new value. */
#define MCG_WR_C2_LP(base, value) (MCG_RMW_C2(base, MCG_C2_LP_MASK, MCG_C2_LP(value)))
#define MCG_BWR_C2_LP(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field EREFS[2] (RW)
 *
 * Selects the source for the external reference clock. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - External reference clock requested.
 * - 1 - Oscillator requested.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_EREFS field. */
#define MCG_RD_C2_EREFS(base) ((MCG_C2_REG(base) & MCG_C2_EREFS_MASK) >> MCG_C2_EREFS_SHIFT)
#define MCG_BRD_C2_EREFS(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_EREFS_SHIFT))

/*! @brief Set the EREFS field to a new value. */
#define MCG_WR_C2_EREFS(base, value) (MCG_RMW_C2(base, MCG_C2_EREFS_MASK, MCG_C2_EREFS(value)))
#define MCG_BWR_C2_EREFS(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_EREFS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field HGO[3] (RW)
 *
 * Controls the crystal oscillator mode of operation. See the Oscillator (OSC)
 * chapter for more details.
 *
 * Values:
 * - 0 - Configure crystal oscillator for low-power operation.
 * - 1 - Configure crystal oscillator for high-gain operation.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_HGO field. */
#define MCG_RD_C2_HGO(base)  ((MCG_C2_REG(base) & MCG_C2_HGO_MASK) >> MCG_C2_HGO_SHIFT)
#define MCG_BRD_C2_HGO(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_HGO_SHIFT))

/*! @brief Set the HGO field to a new value. */
#define MCG_WR_C2_HGO(base, value) (MCG_RMW_C2(base, MCG_C2_HGO_MASK, MCG_C2_HGO(value)))
#define MCG_BWR_C2_HGO(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_HGO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field RANGE[5:4] (RW)
 *
 * Selects the frequency range for the crystal oscillator or external clock
 * source. See the Oscillator (OSC) chapter for more details and the device data
 * sheet for the frequency ranges used.
 *
 * Values:
 * - 00 - Encoding 0 - Low frequency range selected for the crystal oscillator .
 * - 01 - Encoding 1 - High frequency range selected for the crystal oscillator .
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_RANGE field. */
#define MCG_RD_C2_RANGE(base) ((MCG_C2_REG(base) & MCG_C2_RANGE_MASK) >> MCG_C2_RANGE_SHIFT)
#define MCG_BRD_C2_RANGE(base) (MCG_RD_C2_RANGE(base))

/*! @brief Set the RANGE field to a new value. */
#define MCG_WR_C2_RANGE(base, value) (MCG_RMW_C2(base, MCG_C2_RANGE_MASK, MCG_C2_RANGE(value)))
#define MCG_BWR_C2_RANGE(base, value) (MCG_WR_C2_RANGE(base, value))
/*@}*/

/*!
 * @name Register MCG_C2, field FCFTRIM[6] (RW)
 *
 * FCFTRIM controls the smallest adjustment of the fast internal reference clock
 * frequency. Setting FCFTRIM increases the period and clearing FCFTRIM
 * decreases the period by the smallest amount possible. If an FCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_FCFTRIM field. */
#define MCG_RD_C2_FCFTRIM(base) ((MCG_C2_REG(base) & MCG_C2_FCFTRIM_MASK) >> MCG_C2_FCFTRIM_SHIFT)
#define MCG_BRD_C2_FCFTRIM(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_FCFTRIM_SHIFT))

/*! @brief Set the FCFTRIM field to a new value. */
#define MCG_WR_C2_FCFTRIM(base, value) (MCG_RMW_C2(base, MCG_C2_FCFTRIM_MASK, MCG_C2_FCFTRIM(value)))
#define MCG_BWR_C2_FCFTRIM(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_FCFTRIM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C2, field LOCRE0[7] (RW)
 *
 * Determines whether an interrupt or a reset request is made following a loss
 * of OSC0 external reference clock. The LOCRE0 only has an affect when CME0 is
 * set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of OSC0 external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of OSC0 external reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C2_LOCRE0 field. */
#define MCG_RD_C2_LOCRE0(base) ((MCG_C2_REG(base) & MCG_C2_LOCRE0_MASK) >> MCG_C2_LOCRE0_SHIFT)
#define MCG_BRD_C2_LOCRE0(base) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT))

/*! @brief Set the LOCRE0 field to a new value. */
#define MCG_WR_C2_LOCRE0(base, value) (MCG_RMW_C2(base, MCG_C2_LOCRE0_MASK, MCG_C2_LOCRE0(value)))
#define MCG_BWR_C2_LOCRE0(base, value) (BITBAND_ACCESS8(&MCG_C2_REG(base), MCG_C2_LOCRE0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C3 - MCG Control 3 Register
 ******************************************************************************/

/*!
 * @brief MCG_C3 - MCG Control 3 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C3 register
 */
/*@{*/
#define MCG_RD_C3(base)          (MCG_C3_REG(base))
#define MCG_WR_C3(base, value)   (MCG_C3_REG(base) = (value))
#define MCG_RMW_C3(base, mask, value) (MCG_WR_C3(base, (MCG_RD_C3(base) & ~(mask)) | (value)))
#define MCG_SET_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) |  (value)))
#define MCG_CLR_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) & ~(value)))
#define MCG_TOG_C3(base, value)  (MCG_WR_C3(base, MCG_RD_C3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_C4 - MCG Control 4 Register
 ******************************************************************************/

/*!
 * @brief MCG_C4 - MCG Control 4 Register (RW)
 *
 * Reset value: 0x00U
 *
 * Reset values for DRST and DMX32 bits are 0.
 */
/*!
 * @name Constants and macros for entire MCG_C4 register
 */
/*@{*/
#define MCG_RD_C4(base)          (MCG_C4_REG(base))
#define MCG_WR_C4(base, value)   (MCG_C4_REG(base) = (value))
#define MCG_RMW_C4(base, mask, value) (MCG_WR_C4(base, (MCG_RD_C4(base) & ~(mask)) | (value)))
#define MCG_SET_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) |  (value)))
#define MCG_CLR_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) & ~(value)))
#define MCG_TOG_C4(base, value)  (MCG_WR_C4(base, MCG_RD_C4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C4 bitfields
 */

/*!
 * @name Register MCG_C4, field SCFTRIM[0] (RW)
 *
 * SCFTRIM A value for SCFTRIM is loaded during reset from a factory programmed
 * location . controls the smallest adjustment of the slow internal reference
 * clock frequency. Setting SCFTRIM increases the period and clearing SCFTRIM
 * decreases the period by the smallest amount possible. If an SCFTRIM value stored in
 * nonvolatile memory is to be used, it is your responsibility to copy that value
 * from the nonvolatile memory location to this bit.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_SCFTRIM field. */
#define MCG_RD_C4_SCFTRIM(base) ((MCG_C4_REG(base) & MCG_C4_SCFTRIM_MASK) >> MCG_C4_SCFTRIM_SHIFT)
#define MCG_BRD_C4_SCFTRIM(base) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT))

/*! @brief Set the SCFTRIM field to a new value. */
#define MCG_WR_C4_SCFTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_SCFTRIM_MASK, MCG_C4_SCFTRIM(value)))
#define MCG_BWR_C4_SCFTRIM(base, value) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_SCFTRIM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C4, field FCTRIM[4:1] (RW)
 *
 * FCTRIM A value for FCTRIM is loaded during reset from a factory programmed
 * location. controls the fast internal reference clock frequency by controlling
 * the fast internal reference clock period. The FCTRIM bits are binary weighted,
 * that is, bit 1 adjusts twice as much as bit 0. Increasing the binary value
 * increases the period, and decreasing the value decreases the period. If an
 * FCTRIM[3:0] value stored in nonvolatile memory is to be used, it is your
 * responsibility to copy that value from the nonvolatile memory location to this register.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_FCTRIM field. */
#define MCG_RD_C4_FCTRIM(base) ((MCG_C4_REG(base) & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT)
#define MCG_BRD_C4_FCTRIM(base) (MCG_RD_C4_FCTRIM(base))

/*! @brief Set the FCTRIM field to a new value. */
#define MCG_WR_C4_FCTRIM(base, value) (MCG_RMW_C4(base, MCG_C4_FCTRIM_MASK, MCG_C4_FCTRIM(value)))
#define MCG_BWR_C4_FCTRIM(base, value) (MCG_WR_C4_FCTRIM(base, value))
/*@}*/

/*!
 * @name Register MCG_C4, field DRST_DRS[6:5] (RW)
 *
 * The DRS bits select the frequency range for the FLL output, DCOOUT. When the
 * LP bit is set, writes to the DRS bits are ignored. The DRST read field
 * indicates the current frequency range for DCOOUT. The DRST field does not update
 * immediately after a write to the DRS field due to internal synchronization between
 * clock domains. See the DCO Frequency Range table for more details.
 *
 * Values:
 * - 00 - Encoding 0 - Low range (reset default).
 * - 01 - Encoding 1 - Mid range.
 * - 10 - Encoding 2 - Mid-high range.
 * - 11 - Encoding 3 - High range.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DRST_DRS field. */
#define MCG_RD_C4_DRST_DRS(base) ((MCG_C4_REG(base) & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT)
#define MCG_BRD_C4_DRST_DRS(base) (MCG_RD_C4_DRST_DRS(base))

/*! @brief Set the DRST_DRS field to a new value. */
#define MCG_WR_C4_DRST_DRS(base, value) (MCG_RMW_C4(base, MCG_C4_DRST_DRS_MASK, MCG_C4_DRST_DRS(value)))
#define MCG_BWR_C4_DRST_DRS(base, value) (MCG_WR_C4_DRST_DRS(base, value))
/*@}*/

/*!
 * @name Register MCG_C4, field DMX32[7] (RW)
 *
 * The DMX32 bit controls whether the DCO frequency range is narrowed to its
 * maximum frequency with a 32.768 kHz reference. The following table identifies
 * settings for the DCO frequency range. The system clocks derived from this source
 * should not exceed their specified maximums. DRST_DRS DMX32 Reference Range FLL
 * Factor DCO Range 00 0 31.25-39.0625 kHz 640 20-25 MHz 1 32.768 kHz 732 24 MHz
 * 01 0 31.25-39.0625 kHz 1280 40-50 MHz 1 32.768 kHz 1464 48 MHz 10 0
 * 31.25-39.0625 kHz 1920 60-75 MHz 1 32.768 kHz 2197 72 MHz 11 0 31.25-39.0625 kHz 2560
 * 80-100 MHz 1 32.768 kHz 2929 96 MHz
 *
 * Values:
 * - 0 - DCO has a default range of 25%.
 * - 1 - DCO is fine-tuned for maximum frequency with 32.768 kHz reference.
 */
/*@{*/
/*! @brief Read current value of the MCG_C4_DMX32 field. */
#define MCG_RD_C4_DMX32(base) ((MCG_C4_REG(base) & MCG_C4_DMX32_MASK) >> MCG_C4_DMX32_SHIFT)
#define MCG_BRD_C4_DMX32(base) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT))

/*! @brief Set the DMX32 field to a new value. */
#define MCG_WR_C4_DMX32(base, value) (MCG_RMW_C4(base, MCG_C4_DMX32_MASK, MCG_C4_DMX32(value)))
#define MCG_BWR_C4_DMX32(base, value) (BITBAND_ACCESS8(&MCG_C4_REG(base), MCG_C4_DMX32_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C5 - MCG Control 5 Register
 ******************************************************************************/

/*!
 * @brief MCG_C5 - MCG Control 5 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C5 register
 */
/*@{*/
#define MCG_RD_C5(base)          (MCG_C5_REG(base))
#define MCG_WR_C5(base, value)   (MCG_C5_REG(base) = (value))
#define MCG_RMW_C5(base, mask, value) (MCG_WR_C5(base, (MCG_RD_C5(base) & ~(mask)) | (value)))
#define MCG_SET_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) |  (value)))
#define MCG_CLR_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) & ~(value)))
#define MCG_TOG_C5(base, value)  (MCG_WR_C5(base, MCG_RD_C5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C5 bitfields
 */

/*!
 * @name Register MCG_C5, field PRDIV0[4:0] (RW)
 *
 * Selects the amount to divide down the external reference clock for the PLL.
 * The resulting frequency must be in the range of 2 MHz to 4 MHz. After the PLL
 * is enabled (by setting either PLLCLKEN 0 or PLLS), the PRDIV 0 value must not
 * be changed when LOCK0 is zero. PLL External Reference Divide Factor PRDIV 0
 * Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor PRDIV 0 Divide Factor
 * 00000 1 01000 9 10000 17 11000 25 00001 2 01001 10 10001 18 11001 Reserved
 * 00010 3 01010 11 10010 19 11010 Reserved 00011 4 01011 12 10011 20 11011 Reserved
 * 00100 5 01100 13 10100 21 11100 Reserved 00101 6 01101 14 10101 22 11101
 * Reserved 00110 7 01110 15 10110 23 11110 Reserved 00111 8 01111 16 10111 24 11111
 * Reserved
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PRDIV0 field. */
#define MCG_RD_C5_PRDIV0(base) ((MCG_C5_REG(base) & MCG_C5_PRDIV0_MASK) >> MCG_C5_PRDIV0_SHIFT)
#define MCG_BRD_C5_PRDIV0(base) (MCG_RD_C5_PRDIV0(base))

/*! @brief Set the PRDIV0 field to a new value. */
#define MCG_WR_C5_PRDIV0(base, value) (MCG_RMW_C5(base, MCG_C5_PRDIV0_MASK, MCG_C5_PRDIV0(value)))
#define MCG_BWR_C5_PRDIV0(base, value) (MCG_WR_C5_PRDIV0(base, value))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLSTEN0[5] (RW)
 *
 * Enables the PLL Clock during Normal Stop. In Low Power Stop mode, the PLL
 * clock gets disabled even if PLLSTEN 0 =1. All other power modes, PLLSTEN 0 bit
 * has no affect and does not enable the PLL Clock to run if it is written to 1.
 *
 * Values:
 * - 0 - MCGPLLCLK is disabled in any of the Stop modes.
 * - 1 - MCGPLLCLK is enabled if system is in Normal Stop mode.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLSTEN0 field. */
#define MCG_RD_C5_PLLSTEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLSTEN0_MASK) >> MCG_C5_PLLSTEN0_SHIFT)
#define MCG_BRD_C5_PLLSTEN0(base) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLSTEN0_SHIFT))

/*! @brief Set the PLLSTEN0 field to a new value. */
#define MCG_WR_C5_PLLSTEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLSTEN0_MASK, MCG_C5_PLLSTEN0(value)))
#define MCG_BWR_C5_PLLSTEN0(base, value) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLSTEN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C5, field PLLCLKEN0[6] (RW)
 *
 * Enables the PLL independent of PLLS and enables the PLL clock for use as
 * MCGPLLCLK. (PRDIV 0 needs to be programmed to the correct divider to generate a
 * PLL reference clock in the range of 2 - 4 MHz range prior to setting the
 * PLLCLKEN 0 bit). Setting PLLCLKEN 0 will enable the external oscillator if not
 * already enabled. Whenever the PLL is being enabled by means of the PLLCLKEN 0 bit,
 * and the external oscillator is being used as the reference clock, the OSCINIT 0
 * bit should be checked to make sure it is set.
 *
 * Values:
 * - 0 - MCGPLLCLK is inactive.
 * - 1 - MCGPLLCLK is active.
 */
/*@{*/
/*! @brief Read current value of the MCG_C5_PLLCLKEN0 field. */
#define MCG_RD_C5_PLLCLKEN0(base) ((MCG_C5_REG(base) & MCG_C5_PLLCLKEN0_MASK) >> MCG_C5_PLLCLKEN0_SHIFT)
#define MCG_BRD_C5_PLLCLKEN0(base) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN0_SHIFT))

/*! @brief Set the PLLCLKEN0 field to a new value. */
#define MCG_WR_C5_PLLCLKEN0(base, value) (MCG_RMW_C5(base, MCG_C5_PLLCLKEN0_MASK, MCG_C5_PLLCLKEN0(value)))
#define MCG_BWR_C5_PLLCLKEN0(base, value) (BITBAND_ACCESS8(&MCG_C5_REG(base), MCG_C5_PLLCLKEN0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_C6 - MCG Control 6 Register
 ******************************************************************************/

/*!
 * @brief MCG_C6 - MCG Control 6 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C6 register
 */
/*@{*/
#define MCG_RD_C6(base)          (MCG_C6_REG(base))
#define MCG_WR_C6(base, value)   (MCG_C6_REG(base) = (value))
#define MCG_RMW_C6(base, mask, value) (MCG_WR_C6(base, (MCG_RD_C6(base) & ~(mask)) | (value)))
#define MCG_SET_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) |  (value)))
#define MCG_CLR_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) & ~(value)))
#define MCG_TOG_C6(base, value)  (MCG_WR_C6(base, MCG_RD_C6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C6 bitfields
 */

/*!
 * @name Register MCG_C6, field VDIV0[4:0] (RW)
 *
 * Selects the amount to divide the VCO output of the PLL. The VDIV 0 bits
 * establish the multiplication factor (M) applied to the reference clock frequency.
 * After the PLL is enabled (by setting either PLLCLKEN 0 or PLLS), the VDIV 0
 * value must not be changed when LOCK 0 is zero. PLL VCO Divide Factor VDIV 0
 * Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply Factor VDIV 0 Multiply
 * Factor 00000 24 01000 32 10000 40 11000 48 00001 25 01001 33 10001 41 11001 49
 * 00010 26 01010 34 10010 42 11010 50 00011 27 01011 35 10011 43 11011 51 00100 28
 * 01100 36 10100 44 11100 52 00101 29 01101 37 10101 45 11101 53 00110 30 01110
 * 38 10110 46 11110 54 00111 31 01111 39 10111 47 11111 55
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_VDIV0 field. */
#define MCG_RD_C6_VDIV0(base) ((MCG_C6_REG(base) & MCG_C6_VDIV0_MASK) >> MCG_C6_VDIV0_SHIFT)
#define MCG_BRD_C6_VDIV0(base) (MCG_RD_C6_VDIV0(base))

/*! @brief Set the VDIV0 field to a new value. */
#define MCG_WR_C6_VDIV0(base, value) (MCG_RMW_C6(base, MCG_C6_VDIV0_MASK, MCG_C6_VDIV0(value)))
#define MCG_BWR_C6_VDIV0(base, value) (MCG_WR_C6_VDIV0(base, value))
/*@}*/

/*!
 * @name Register MCG_C6, field CME0[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the OSC0 external reference
 * mux select. The LOCRE0 bit will determine if a interrupt or a reset request is
 * generated following a loss of OSC0 indication. The CME0 bit must only be set
 * to a logic 1 when the MCG is in an operational mode that uses the external
 * clock (FEE, FBE, PEE, PBE, or BLPE) . Whenever the CME0 bit is set to a logic 1,
 * the value of the RANGE0 bits in the C2 register should not be changed. CME0
 * bit should be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur while in Stop mode. CME0 should also be set to a
 * logic 0 before entering VLPR or VLPW power modes if the MCG is in BLPE mode.
 *
 * Values:
 * - 0 - External clock monitor is disabled for OSC0.
 * - 1 - External clock monitor is enabled for OSC0.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_CME0 field. */
#define MCG_RD_C6_CME0(base) ((MCG_C6_REG(base) & MCG_C6_CME0_MASK) >> MCG_C6_CME0_SHIFT)
#define MCG_BRD_C6_CME0(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT))

/*! @brief Set the CME0 field to a new value. */
#define MCG_WR_C6_CME0(base, value) (MCG_RMW_C6(base, MCG_C6_CME0_MASK, MCG_C6_CME0(value)))
#define MCG_BWR_C6_CME0(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_CME0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C6, field PLLS[6] (RW)
 *
 * Controls whether the PLL or FLL output is selected as the MCG source when
 * CLKS[1:0]=00. If the PLLS bit is cleared and PLLCLKEN 0 is not set, the PLL is
 * disabled in all modes. If the PLLS is set, the FLL is disabled in all modes.
 *
 * Values:
 * - 0 - FLL is selected.
 * - 1 - PLL is selected (PRDIV 0 need to be programmed to the correct divider
 *     to generate a PLL reference clock in the range of 2-4 MHz prior to setting
 *     the PLLS bit).
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_PLLS field. */
#define MCG_RD_C6_PLLS(base) ((MCG_C6_REG(base) & MCG_C6_PLLS_MASK) >> MCG_C6_PLLS_SHIFT)
#define MCG_BRD_C6_PLLS(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT))

/*! @brief Set the PLLS field to a new value. */
#define MCG_WR_C6_PLLS(base, value) (MCG_RMW_C6(base, MCG_C6_PLLS_MASK, MCG_C6_PLLS(value)))
#define MCG_BWR_C6_PLLS(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_PLLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C6, field LOLIE0[7] (RW)
 *
 * Determines if an interrupt request is made following a loss of lock
 * indication. This bit only has an effect when LOLS 0 is set.
 *
 * Values:
 * - 0 - No interrupt request is generated on loss of lock.
 * - 1 - Generate an interrupt request on loss of lock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C6_LOLIE0 field. */
#define MCG_RD_C6_LOLIE0(base) ((MCG_C6_REG(base) & MCG_C6_LOLIE0_MASK) >> MCG_C6_LOLIE0_SHIFT)
#define MCG_BRD_C6_LOLIE0(base) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT))

/*! @brief Set the LOLIE0 field to a new value. */
#define MCG_WR_C6_LOLIE0(base, value) (MCG_RMW_C6(base, MCG_C6_LOLIE0_MASK, MCG_C6_LOLIE0(value)))
#define MCG_BWR_C6_LOLIE0(base, value) (BITBAND_ACCESS8(&MCG_C6_REG(base), MCG_C6_LOLIE0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_S - MCG Status Register
 ******************************************************************************/

/*!
 * @brief MCG_S - MCG Status Register (RW)
 *
 * Reset value: 0x10U
 */
/*!
 * @name Constants and macros for entire MCG_S register
 */
/*@{*/
#define MCG_RD_S(base)           (MCG_S_REG(base))
#define MCG_WR_S(base, value)    (MCG_S_REG(base) = (value))
#define MCG_RMW_S(base, mask, value) (MCG_WR_S(base, (MCG_RD_S(base) & ~(mask)) | (value)))
#define MCG_SET_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) |  (value)))
#define MCG_CLR_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) & ~(value)))
#define MCG_TOG_S(base, value)   (MCG_WR_S(base, MCG_RD_S(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_S bitfields
 */

/*!
 * @name Register MCG_S, field IRCST[0] (RO)
 *
 * The IRCST bit indicates the current source for the internal reference clock
 * select clock (IRCSCLK). The IRCST bit does not update immediately after a write
 * to the IRCS bit due to internal synchronization between clock domains. The
 * IRCST bit will only be updated if the internal reference clock is enabled,
 * either by the MCG being in a mode that uses the IRC or by setting the C1[IRCLKEN]
 * bit .
 *
 * Values:
 * - 0 - Source of internal reference clock is the slow clock (32 kHz IRC).
 * - 1 - Source of internal reference clock is the fast clock (4 MHz IRC).
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IRCST field. */
#define MCG_RD_S_IRCST(base) ((MCG_S_REG(base) & MCG_S_IRCST_MASK) >> MCG_S_IRCST_SHIFT)
#define MCG_BRD_S_IRCST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_IRCST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field OSCINIT0[1] (RO)
 *
 * This bit, which resets to 0, is set to 1 after the initialization cycles of
 * the crystal oscillator clock have completed. After being set, the bit is
 * cleared to 0 if the OSC is subsequently disabled. See the OSC module's detailed
 * description for more information.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_OSCINIT0 field. */
#define MCG_RD_S_OSCINIT0(base) ((MCG_S_REG(base) & MCG_S_OSCINIT0_MASK) >> MCG_S_OSCINIT0_SHIFT)
#define MCG_BRD_S_OSCINIT0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_OSCINIT0_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field CLKST[3:2] (RO)
 *
 * These bits indicate the current clock mode. The CLKST bits do not update
 * immediately after a write to the CLKS bits due to internal synchronization between
 * clock domains.
 *
 * Values:
 * - 00 - Encoding 0 - Output of the FLL is selected (reset default).
 * - 01 - Encoding 1 - Internal reference clock is selected.
 * - 10 - Encoding 2 - External reference clock is selected.
 * - 11 - Encoding 3 - Output of the PLL is selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_CLKST field. */
#define MCG_RD_S_CLKST(base) ((MCG_S_REG(base) & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT)
#define MCG_BRD_S_CLKST(base) (MCG_RD_S_CLKST(base))
/*@}*/

/*!
 * @name Register MCG_S, field IREFST[4] (RO)
 *
 * This bit indicates the current source for the FLL reference clock. The IREFST
 * bit does not update immediately after a write to the IREFS bit due to
 * internal synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of FLL reference clock is the external reference clock.
 * - 1 - Source of FLL reference clock is the internal reference clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_IREFST field. */
#define MCG_RD_S_IREFST(base) ((MCG_S_REG(base) & MCG_S_IREFST_MASK) >> MCG_S_IREFST_SHIFT)
#define MCG_BRD_S_IREFST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_IREFST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field PLLST[5] (RO)
 *
 * This bit indicates the clock source selected by PLLS . The PLLST bit does not
 * update immediately after a write to the PLLS bit due to internal
 * synchronization between clock domains.
 *
 * Values:
 * - 0 - Source of PLLS clock is FLL clock.
 * - 1 - Source of PLLS clock is PLL output clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_PLLST field. */
#define MCG_RD_S_PLLST(base) ((MCG_S_REG(base) & MCG_S_PLLST_MASK) >> MCG_S_PLLST_SHIFT)
#define MCG_BRD_S_PLLST(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_PLLST_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field LOCK0[6] (RO)
 *
 * This bit indicates whether the PLL has acquired lock. Lock detection is only
 * enabled when the PLL is enabled (either through clock mode selection or
 * PLLCLKEN0=1 setting). While the PLL clock is locking to the desired frequency, the
 * MCG PLL clock (MCGPLLCLK) will be gated off until the LOCK bit gets asserted.
 * If the lock status bit is set, changing the value of the PRDIV0 [4:0] bits in
 * the C5 register or the VDIV0[4:0] bits in the C6 register causes the lock
 * status bit to clear and stay cleared until the PLL has reacquired lock. Loss of PLL
 * reference clock will also cause the LOCK0 bit to clear until the PLL has
 * reacquired lock. Entry into LLS, VLPS, or regular Stop with PLLSTEN=0 also causes
 * the lock status bit to clear and stay cleared until the Stop mode is exited
 * and the PLL has reacquired lock. Any time the PLL is enabled and the LOCK0 bit
 * is cleared, the MCGPLLCLK will be gated off until the LOCK0 bit is asserted
 * again.
 *
 * Values:
 * - 0 - PLL is currently unlocked.
 * - 1 - PLL is currently locked.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOCK0 field. */
#define MCG_RD_S_LOCK0(base) ((MCG_S_REG(base) & MCG_S_LOCK0_MASK) >> MCG_S_LOCK0_SHIFT)
#define MCG_BRD_S_LOCK0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOCK0_SHIFT))
/*@}*/

/*!
 * @name Register MCG_S, field LOLS0[7] (W1C)
 *
 * This bit is a sticky bit indicating the lock status for the PLL. LOLS is set
 * if after acquiring lock, the PLL output frequency has fallen outside the lock
 * exit frequency tolerance, D unl . LOLIE determines whether an interrupt
 * request is made when LOLS is set. LOLRE determines whether a reset request is made
 * when LOLS is set. This bit is cleared by reset or by writing a logic 1 to it
 * when set. Writing a logic 0 to this bit has no effect.
 *
 * Values:
 * - 0 - PLL has not lost lock since LOLS 0 was last cleared.
 * - 1 - PLL has lost lock since LOLS 0 was last cleared.
 */
/*@{*/
/*! @brief Read current value of the MCG_S_LOLS0 field. */
#define MCG_RD_S_LOLS0(base) ((MCG_S_REG(base) & MCG_S_LOLS0_MASK) >> MCG_S_LOLS0_SHIFT)
#define MCG_BRD_S_LOLS0(base) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT))

/*! @brief Set the LOLS0 field to a new value. */
#define MCG_WR_S_LOLS0(base, value) (MCG_RMW_S(base, MCG_S_LOLS0_MASK, MCG_S_LOLS0(value)))
#define MCG_BWR_S_LOLS0(base, value) (BITBAND_ACCESS8(&MCG_S_REG(base), MCG_S_LOLS0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_SC - MCG Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCG_SC - MCG Status and Control Register (RW)
 *
 * Reset value: 0x02U
 */
/*!
 * @name Constants and macros for entire MCG_SC register
 */
/*@{*/
#define MCG_RD_SC(base)          (MCG_SC_REG(base))
#define MCG_WR_SC(base, value)   (MCG_SC_REG(base) = (value))
#define MCG_RMW_SC(base, mask, value) (MCG_WR_SC(base, (MCG_RD_SC(base) & ~(mask)) | (value)))
#define MCG_SET_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) |  (value)))
#define MCG_CLR_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) & ~(value)))
#define MCG_TOG_SC(base, value)  (MCG_WR_SC(base, MCG_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_SC bitfields
 */

/*!
 * @name Register MCG_SC, field LOCS0[0] (W1C)
 *
 * The LOCS0 indicates when a loss of OSC0 reference clock has occurred. The
 * LOCS0 bit only has an effect when CME0 is set. This bit is cleared by writing a
 * logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of OSC0 has not occurred.
 * - 1 - Loss of OSC0 has occurred.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_LOCS0 field. */
#define MCG_RD_SC_LOCS0(base) ((MCG_SC_REG(base) & MCG_SC_LOCS0_MASK) >> MCG_SC_LOCS0_SHIFT)
#define MCG_BRD_SC_LOCS0(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT))

/*! @brief Set the LOCS0 field to a new value. */
#define MCG_WR_SC_LOCS0(base, value) (MCG_RMW_SC(base, (MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_LOCS0(value)))
#define MCG_BWR_SC_LOCS0(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_LOCS0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field FCRDIV[3:1] (RW)
 *
 * Selects the amount to divide down the fast internal reference clock. The
 * resulting frequency will be in the range 31.25 kHz to 4 MHz (Note: Changing the
 * divider when the Fast IRC is enabled is not supported).
 *
 * Values:
 * - 000 - Divide Factor is 1
 * - 001 - Divide Factor is 2.
 * - 010 - Divide Factor is 4.
 * - 011 - Divide Factor is 8.
 * - 100 - Divide Factor is 16
 * - 101 - Divide Factor is 32
 * - 110 - Divide Factor is 64
 * - 111 - Divide Factor is 128.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FCRDIV field. */
#define MCG_RD_SC_FCRDIV(base) ((MCG_SC_REG(base) & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)
#define MCG_BRD_SC_FCRDIV(base) (MCG_RD_SC_FCRDIV(base))

/*! @brief Set the FCRDIV field to a new value. */
#define MCG_WR_SC_FCRDIV(base, value) (MCG_RMW_SC(base, (MCG_SC_FCRDIV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FCRDIV(value)))
#define MCG_BWR_SC_FCRDIV(base, value) (MCG_WR_SC_FCRDIV(base, value))
/*@}*/

/*!
 * @name Register MCG_SC, field FLTPRSRV[4] (RW)
 *
 * This bit will prevent the FLL filter values from resetting allowing the FLL
 * output frequency to remain the same during clock mode changes where the FLL/DCO
 * output is still valid. (Note: This requires that the FLL reference frequency
 * to remain the same as what it was prior to the new clock mode switch.
 * Otherwise FLL filter and frequency values will change.)
 *
 * Values:
 * - 0 - FLL filter and FLL frequency will reset on changes to currect clock
 *     mode.
 * - 1 - Fll filter and FLL frequency retain their previous values during new
 *     clock mode change.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_FLTPRSRV field. */
#define MCG_RD_SC_FLTPRSRV(base) ((MCG_SC_REG(base) & MCG_SC_FLTPRSRV_MASK) >> MCG_SC_FLTPRSRV_SHIFT)
#define MCG_BRD_SC_FLTPRSRV(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT))

/*! @brief Set the FLTPRSRV field to a new value. */
#define MCG_WR_SC_FLTPRSRV(base, value) (MCG_RMW_SC(base, (MCG_SC_FLTPRSRV_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_FLTPRSRV(value)))
#define MCG_BWR_SC_FLTPRSRV(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_FLTPRSRV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMF[5] (W1C)
 *
 * Fail flag for the Automatic Trim Machine (ATM). This bit asserts when the
 * Automatic Trim Machine is enabled, ATME=1, and a write to the C1, C3, C4, and SC
 * registers is detected or the MCG enters into any Stop mode. A write to ATMF
 * clears the flag.
 *
 * Values:
 * - 0 - Automatic Trim Machine completed normally.
 * - 1 - Automatic Trim Machine failed.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMF field. */
#define MCG_RD_SC_ATMF(base) ((MCG_SC_REG(base) & MCG_SC_ATMF_MASK) >> MCG_SC_ATMF_SHIFT)
#define MCG_BRD_SC_ATMF(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT))

/*! @brief Set the ATMF field to a new value. */
#define MCG_WR_SC_ATMF(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMF_MASK | MCG_SC_LOCS0_MASK), MCG_SC_ATMF(value)))
#define MCG_BWR_SC_ATMF(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATMS[6] (RW)
 *
 * Selects the IRCS clock for Auto Trim Test.
 *
 * Values:
 * - 0 - 32 kHz Internal Reference Clock selected.
 * - 1 - 4 MHz Internal Reference Clock selected.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATMS field. */
#define MCG_RD_SC_ATMS(base) ((MCG_SC_REG(base) & MCG_SC_ATMS_MASK) >> MCG_SC_ATMS_SHIFT)
#define MCG_BRD_SC_ATMS(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT))

/*! @brief Set the ATMS field to a new value. */
#define MCG_WR_SC_ATMS(base, value) (MCG_RMW_SC(base, (MCG_SC_ATMS_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATMS(value)))
#define MCG_BWR_SC_ATMS(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_SC, field ATME[7] (RW)
 *
 * Enables the Auto Trim Machine to start automatically trimming the selected
 * Internal Reference Clock. ATME deasserts after the Auto Trim Machine has
 * completed trimming all trim bits of the IRCS clock selected by the ATMS bit. Writing
 * to C1, C3, C4, and SC registers or entering Stop mode aborts the auto trim
 * operation and clears this bit.
 *
 * Values:
 * - 0 - Auto Trim Machine disabled.
 * - 1 - Auto Trim Machine enabled.
 */
/*@{*/
/*! @brief Read current value of the MCG_SC_ATME field. */
#define MCG_RD_SC_ATME(base) ((MCG_SC_REG(base) & MCG_SC_ATME_MASK) >> MCG_SC_ATME_SHIFT)
#define MCG_BRD_SC_ATME(base) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT))

/*! @brief Set the ATME field to a new value. */
#define MCG_WR_SC_ATME(base, value) (MCG_RMW_SC(base, (MCG_SC_ATME_MASK | MCG_SC_LOCS0_MASK | MCG_SC_ATMF_MASK), MCG_SC_ATME(value)))
#define MCG_BWR_SC_ATME(base, value) (BITBAND_ACCESS8(&MCG_SC_REG(base), MCG_SC_ATME_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * MCG_ATCVH - MCG Auto Trim Compare Value High Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVH - MCG Auto Trim Compare Value High Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVH register
 */
/*@{*/
#define MCG_RD_ATCVH(base)       (MCG_ATCVH_REG(base))
#define MCG_WR_ATCVH(base, value) (MCG_ATCVH_REG(base) = (value))
#define MCG_RMW_ATCVH(base, mask, value) (MCG_WR_ATCVH(base, (MCG_RD_ATCVH(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) |  (value)))
#define MCG_CLR_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) & ~(value)))
#define MCG_TOG_ATCVH(base, value) (MCG_WR_ATCVH(base, MCG_RD_ATCVH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_ATCVL - MCG Auto Trim Compare Value Low Register
 ******************************************************************************/

/*!
 * @brief MCG_ATCVL - MCG Auto Trim Compare Value Low Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_ATCVL register
 */
/*@{*/
#define MCG_RD_ATCVL(base)       (MCG_ATCVL_REG(base))
#define MCG_WR_ATCVL(base, value) (MCG_ATCVL_REG(base) = (value))
#define MCG_RMW_ATCVL(base, mask, value) (MCG_WR_ATCVL(base, (MCG_RD_ATCVL(base) & ~(mask)) | (value)))
#define MCG_SET_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) |  (value)))
#define MCG_CLR_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) & ~(value)))
#define MCG_TOG_ATCVL(base, value) (MCG_WR_ATCVL(base, MCG_RD_ATCVL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * MCG_C7 - MCG Control 7 Register
 ******************************************************************************/

/*!
 * @brief MCG_C7 - MCG Control 7 Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire MCG_C7 register
 */
/*@{*/
#define MCG_RD_C7(base)          (MCG_C7_REG(base))
#define MCG_WR_C7(base, value)   (MCG_C7_REG(base) = (value))
#define MCG_RMW_C7(base, mask, value) (MCG_WR_C7(base, (MCG_RD_C7(base) & ~(mask)) | (value)))
#define MCG_SET_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) |  (value)))
#define MCG_CLR_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) & ~(value)))
#define MCG_TOG_C7(base, value)  (MCG_WR_C7(base, MCG_RD_C7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C7 bitfields
 */

/*!
 * @name Register MCG_C7, field OSCSEL[1:0] (RW)
 *
 * Selects the MCG FLL external reference clock The OSCSEL field can't be
 * changed during MCG modes (like PBE), when external clock is serving as the clock
 * source for MCG.
 *
 * Values:
 * - 00 - Selects Oscillator (OSCCLK0).
 * - 01 - Selects 32 kHz RTC Oscillator.
 * - 10 - Selects Oscillator (OSCCLK1).
 * - 11 - RESERVED
 */
/*@{*/
/*! @brief Read current value of the MCG_C7_OSCSEL field. */
#define MCG_RD_C7_OSCSEL(base) ((MCG_C7_REG(base) & MCG_C7_OSCSEL_MASK) >> MCG_C7_OSCSEL_SHIFT)
#define MCG_BRD_C7_OSCSEL(base) (MCG_RD_C7_OSCSEL(base))

/*! @brief Set the OSCSEL field to a new value. */
#define MCG_WR_C7_OSCSEL(base, value) (MCG_RMW_C7(base, MCG_C7_OSCSEL_MASK, MCG_C7_OSCSEL(value)))
#define MCG_BWR_C7_OSCSEL(base, value) (MCG_WR_C7_OSCSEL(base, value))
/*@}*/

/*******************************************************************************
 * MCG_C8 - MCG Control 8 Register
 ******************************************************************************/

/*!
 * @brief MCG_C8 - MCG Control 8 Register (RW)
 *
 * Reset value: 0x80U
 */
/*!
 * @name Constants and macros for entire MCG_C8 register
 */
/*@{*/
#define MCG_RD_C8(base)          (MCG_C8_REG(base))
#define MCG_WR_C8(base, value)   (MCG_C8_REG(base) = (value))
#define MCG_RMW_C8(base, mask, value) (MCG_WR_C8(base, (MCG_RD_C8(base) & ~(mask)) | (value)))
#define MCG_SET_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) |  (value)))
#define MCG_CLR_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) & ~(value)))
#define MCG_TOG_C8(base, value)  (MCG_WR_C8(base, MCG_RD_C8(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCG_C8 bitfields
 */

/*!
 * @name Register MCG_C8, field LOCS1[0] (W1C)
 *
 * This bit indicates when a loss of clock has occurred. This bit is cleared by
 * writing a logic 1 to it when set.
 *
 * Values:
 * - 0 - Loss of RTC has not occur.
 * - 1 - Loss of RTC has occur
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCS1 field. */
#define MCG_RD_C8_LOCS1(base) ((MCG_C8_REG(base) & MCG_C8_LOCS1_MASK) >> MCG_C8_LOCS1_SHIFT)
#define MCG_BRD_C8_LOCS1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT))

/*! @brief Set the LOCS1 field to a new value. */
#define MCG_WR_C8_LOCS1(base, value) (MCG_RMW_C8(base, MCG_C8_LOCS1_MASK, MCG_C8_LOCS1(value)))
#define MCG_BWR_C8_LOCS1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCS1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field CME1[5] (RW)
 *
 * Enables the loss of clock monitoring circuit for the output of the RTC
 * external reference clock. The LOCRE1 bit will determine whether an interrupt or a
 * reset request is generated following a loss of RTC clock indication. The CME1
 * bit should be set to a logic 1 when the MCG is in an operational mode that uses
 * the RTC as its external reference clock or if the RTC is operational. CME1 bit
 * must be set to a logic 0 before the MCG enters any Stop mode. Otherwise, a
 * reset request may occur when in Stop mode. CME1 should also be set to a logic 0
 * before entering VLPR or VLPW power modes.
 *
 * Values:
 * - 0 - External clock monitor is disabled for RTC clock.
 * - 1 - External clock monitor is enabled for RTC clock.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_CME1 field. */
#define MCG_RD_C8_CME1(base) ((MCG_C8_REG(base) & MCG_C8_CME1_MASK) >> MCG_C8_CME1_SHIFT)
#define MCG_BRD_C8_CME1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT))

/*! @brief Set the CME1 field to a new value. */
#define MCG_WR_C8_CME1(base, value) (MCG_RMW_C8(base, (MCG_C8_CME1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_CME1(value)))
#define MCG_BWR_C8_CME1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_CME1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field LOLRE[6] (RW)
 *
 * Determines if an interrupt or a reset request is made following a PLL loss of
 * lock.
 *
 * Values:
 * - 0 - Interrupt request is generated on a PLL loss of lock indication. The
 *     PLL loss of lock interrupt enable bit must also be set to generate the
 *     interrupt request.
 * - 1 - Generate a reset request on a PLL loss of lock indication.
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOLRE field. */
#define MCG_RD_C8_LOLRE(base) ((MCG_C8_REG(base) & MCG_C8_LOLRE_MASK) >> MCG_C8_LOLRE_SHIFT)
#define MCG_BRD_C8_LOLRE(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT))

/*! @brief Set the LOLRE field to a new value. */
#define MCG_WR_C8_LOLRE(base, value) (MCG_RMW_C8(base, (MCG_C8_LOLRE_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOLRE(value)))
#define MCG_BWR_C8_LOLRE(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOLRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register MCG_C8, field LOCRE1[7] (RW)
 *
 * Determines if a interrupt or a reset request is made following a loss of RTC
 * external reference clock. The LOCRE1 only has an affect when CME1 is set.
 *
 * Values:
 * - 0 - Interrupt request is generated on a loss of RTC external reference
 *     clock.
 * - 1 - Generate a reset request on a loss of RTC external reference clock
 */
/*@{*/
/*! @brief Read current value of the MCG_C8_LOCRE1 field. */
#define MCG_RD_C8_LOCRE1(base) ((MCG_C8_REG(base) & MCG_C8_LOCRE1_MASK) >> MCG_C8_LOCRE1_SHIFT)
#define MCG_BRD_C8_LOCRE1(base) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT))

/*! @brief Set the LOCRE1 field to a new value. */
#define MCG_WR_C8_LOCRE1(base, value) (MCG_RMW_C8(base, (MCG_C8_LOCRE1_MASK | MCG_C8_LOCS1_MASK), MCG_C8_LOCRE1(value)))
#define MCG_BWR_C8_LOCRE1(base, value) (BITBAND_ACCESS8(&MCG_C8_REG(base), MCG_C8_LOCRE1_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 MCM
 *
 * Core Platform Miscellaneous Control Module
 *
 * Registers defined in this header file:
 * - MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 * - MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 * - MCM_PLACR - Crossbar Switch (AXBS) Control Register
 * - MCM_ISCR - Interrupt Status and Control Register
 * - MCM_CPO - Compute Operation Control Register
 */

#define MCM_INSTANCE_COUNT (1U) /*!< Number of instances of the MCM module. */
#define MCM_IDX (0U) /*!< Instance number for MCM. */

/*******************************************************************************
 * MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLASC - Crossbar Switch (AXBS) Slave Configuration (RO)
 *
 * Reset value: 0x000FU
 *
 * PLASC is a 16-bit read-only register identifying the presence/absence of bus
 * slave connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLASC register
 */
/*@{*/
#define MCM_RD_PLASC(base)       (MCM_PLASC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLASC bitfields
 */

/*!
 * @name Register MCM_PLASC, field ASC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus slave connection to AXBS input port n is absent
 * - 1 - A bus slave connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLASC_ASC field. */
#define MCM_RD_PLASC_ASC(base) ((MCM_PLASC_REG(base) & MCM_PLASC_ASC_MASK) >> MCM_PLASC_ASC_SHIFT)
#define MCM_BRD_PLASC_ASC(base) (MCM_RD_PLASC_ASC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration
 ******************************************************************************/

/*!
 * @brief MCM_PLAMC - Crossbar Switch (AXBS) Master Configuration (RO)
 *
 * Reset value: 0x0017U
 *
 * PLAMC is a 16-bit read-only register identifying the presence/absence of bus
 * master connections to the device's crossbar switch.
 */
/*!
 * @name Constants and macros for entire MCM_PLAMC register
 */
/*@{*/
#define MCM_RD_PLAMC(base)       (MCM_PLAMC_REG(base))
/*@}*/

/*
 * Constants & macros for individual MCM_PLAMC bitfields
 */

/*!
 * @name Register MCM_PLAMC, field AMC[7:0] (RO)
 *
 * Values:
 * - 0 - A bus master connection to AXBS input port n is absent
 * - 1 - A bus master connection to AXBS input port n is present
 */
/*@{*/
/*! @brief Read current value of the MCM_PLAMC_AMC field. */
#define MCM_RD_PLAMC_AMC(base) ((MCM_PLAMC_REG(base) & MCM_PLAMC_AMC_MASK) >> MCM_PLAMC_AMC_SHIFT)
#define MCM_BRD_PLAMC_AMC(base) (MCM_RD_PLAMC_AMC(base))
/*@}*/

/*******************************************************************************
 * MCM_PLACR - Crossbar Switch (AXBS) Control Register
 ******************************************************************************/

/*!
 * @brief MCM_PLACR - Crossbar Switch (AXBS) Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The PLACR register selects the arbitration policy for the crossbar masters.
 */
/*!
 * @name Constants and macros for entire MCM_PLACR register
 */
/*@{*/
#define MCM_RD_PLACR(base)       (MCM_PLACR_REG(base))
#define MCM_WR_PLACR(base, value) (MCM_PLACR_REG(base) = (value))
#define MCM_RMW_PLACR(base, mask, value) (MCM_WR_PLACR(base, (MCM_RD_PLACR(base) & ~(mask)) | (value)))
#define MCM_SET_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) |  (value)))
#define MCM_CLR_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) & ~(value)))
#define MCM_TOG_PLACR(base, value) (MCM_WR_PLACR(base, MCM_RD_PLACR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_PLACR bitfields
 */

/*!
 * @name Register MCM_PLACR, field ARB[9] (RW)
 *
 * Values:
 * - 0 - Fixed-priority arbitration for the crossbar masters
 * - 1 - Round-robin arbitration for the crossbar masters
 */
/*@{*/
/*! @brief Read current value of the MCM_PLACR_ARB field. */
#define MCM_RD_PLACR_ARB(base) ((MCM_PLACR_REG(base) & MCM_PLACR_ARB_MASK) >> MCM_PLACR_ARB_SHIFT)
#define MCM_BRD_PLACR_ARB(base) (MCM_RD_PLACR_ARB(base))

/*! @brief Set the ARB field to a new value. */
#define MCM_WR_PLACR_ARB(base, value) (MCM_RMW_PLACR(base, MCM_PLACR_ARB_MASK, MCM_PLACR_ARB(value)))
#define MCM_BWR_PLACR_ARB(base, value) (MCM_WR_PLACR_ARB(base, value))
/*@}*/

/*******************************************************************************
 * MCM_ISCR - Interrupt Status and Control Register
 ******************************************************************************/

/*!
 * @brief MCM_ISCR - Interrupt Status and Control Register (RW)
 *
 * Reset value: 0x00020000U
 *
 * The MCM_ISCR register includes the enable and status bits associated with the
 * core's floating-point exceptions. The individual event indicators are first
 * qualified with their exception enables and then logically summed to form an
 * interrupt request sent to the core's NVIC. Bits 15-8 are read-only indicator
 * flags based on the processor's FPSCR register. Attempted writes to these bits are
 * ignored. Once set, the flags remain asserted until software clears the
 * corresponding FPSCR bit.
 */
/*!
 * @name Constants and macros for entire MCM_ISCR register
 */
/*@{*/
#define MCM_RD_ISCR(base)        (MCM_ISCR_REG(base))
#define MCM_WR_ISCR(base, value) (MCM_ISCR_REG(base) = (value))
#define MCM_RMW_ISCR(base, mask, value) (MCM_WR_ISCR(base, (MCM_RD_ISCR(base) & ~(mask)) | (value)))
#define MCM_SET_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) |  (value)))
#define MCM_CLR_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) & ~(value)))
#define MCM_TOG_ISCR(base, value) (MCM_WR_ISCR(base, MCM_RD_ISCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_ISCR bitfields
 */

/*!
 * @name Register MCM_ISCR, field FIOC[8] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IOC] bit and signals an
 * illegal operation has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IOC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOC field. */
#define MCM_RD_ISCR_FIOC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOC_MASK) >> MCM_ISCR_FIOC_SHIFT)
#define MCM_BRD_ISCR_FIOC(base) (MCM_RD_ISCR_FIOC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZC[9] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[DZC] bit and signals a
 * divide by zero has been detected in the processor's FPU. Once set, this bit remains
 * set until software clears the FPSCR[DZC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZC field. */
#define MCM_RD_ISCR_FDZC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZC_MASK) >> MCM_ISCR_FDZC_SHIFT)
#define MCM_BRD_ISCR_FDZC(base) (MCM_RD_ISCR_FDZC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFC[10] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[OFC] bit and signals an
 * overflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[OFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFC field. */
#define MCM_RD_ISCR_FOFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFC_MASK) >> MCM_ISCR_FOFC_SHIFT)
#define MCM_BRD_ISCR_FOFC(base) (MCM_RD_ISCR_FOFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFC[11] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[UFC] bit and signals an
 * underflow has been detected in the processor's FPU. Once set, this bit remains set
 * until software clears the FPSCR[UFC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFC field. */
#define MCM_RD_ISCR_FUFC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFC_MASK) >> MCM_ISCR_FUFC_SHIFT)
#define MCM_BRD_ISCR_FUFC(base) (MCM_RD_ISCR_FUFC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXC[12] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IXC] bit and signals an
 * inexact number has been detected in the processor's FPU. Once set, this bit
 * remains set until software clears the FPSCR[IXC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXC field. */
#define MCM_RD_ISCR_FIXC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXC_MASK) >> MCM_ISCR_FIXC_SHIFT)
#define MCM_BRD_ISCR_FIXC(base) (MCM_RD_ISCR_FIXC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDC[15] (RO)
 *
 * This read-only bit is a copy of the core's FPSCR[IDC] bit and signals input
 * denormalized number has been detected in the processor's FPU. Once set, this
 * bit remains set until software clears the FPSCR[IDC] bit.
 *
 * Values:
 * - 0 - No interrupt
 * - 1 - Interrupt occurred
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDC field. */
#define MCM_RD_ISCR_FIDC(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDC_MASK) >> MCM_ISCR_FIDC_SHIFT)
#define MCM_BRD_ISCR_FIDC(base) (MCM_RD_ISCR_FIDC(base))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIOCE[24] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIOCE field. */
#define MCM_RD_ISCR_FIOCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIOCE_MASK) >> MCM_ISCR_FIOCE_SHIFT)
#define MCM_BRD_ISCR_FIOCE(base) (MCM_RD_ISCR_FIOCE(base))

/*! @brief Set the FIOCE field to a new value. */
#define MCM_WR_ISCR_FIOCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIOCE_MASK, MCM_ISCR_FIOCE(value)))
#define MCM_BWR_ISCR_FIOCE(base, value) (MCM_WR_ISCR_FIOCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FDZCE[25] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FDZCE field. */
#define MCM_RD_ISCR_FDZCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FDZCE_MASK) >> MCM_ISCR_FDZCE_SHIFT)
#define MCM_BRD_ISCR_FDZCE(base) (MCM_RD_ISCR_FDZCE(base))

/*! @brief Set the FDZCE field to a new value. */
#define MCM_WR_ISCR_FDZCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FDZCE_MASK, MCM_ISCR_FDZCE(value)))
#define MCM_BWR_ISCR_FDZCE(base, value) (MCM_WR_ISCR_FDZCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FOFCE[26] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FOFCE field. */
#define MCM_RD_ISCR_FOFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FOFCE_MASK) >> MCM_ISCR_FOFCE_SHIFT)
#define MCM_BRD_ISCR_FOFCE(base) (MCM_RD_ISCR_FOFCE(base))

/*! @brief Set the FOFCE field to a new value. */
#define MCM_WR_ISCR_FOFCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FOFCE_MASK, MCM_ISCR_FOFCE(value)))
#define MCM_BWR_ISCR_FOFCE(base, value) (MCM_WR_ISCR_FOFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FUFCE[27] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FUFCE field. */
#define MCM_RD_ISCR_FUFCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FUFCE_MASK) >> MCM_ISCR_FUFCE_SHIFT)
#define MCM_BRD_ISCR_FUFCE(base) (MCM_RD_ISCR_FUFCE(base))

/*! @brief Set the FUFCE field to a new value. */
#define MCM_WR_ISCR_FUFCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FUFCE_MASK, MCM_ISCR_FUFCE(value)))
#define MCM_BWR_ISCR_FUFCE(base, value) (MCM_WR_ISCR_FUFCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIXCE[28] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIXCE field. */
#define MCM_RD_ISCR_FIXCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIXCE_MASK) >> MCM_ISCR_FIXCE_SHIFT)
#define MCM_BRD_ISCR_FIXCE(base) (MCM_RD_ISCR_FIXCE(base))

/*! @brief Set the FIXCE field to a new value. */
#define MCM_WR_ISCR_FIXCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIXCE_MASK, MCM_ISCR_FIXCE(value)))
#define MCM_BWR_ISCR_FIXCE(base, value) (MCM_WR_ISCR_FIXCE(base, value))
/*@}*/

/*!
 * @name Register MCM_ISCR, field FIDCE[31] (RW)
 *
 * Values:
 * - 0 - Disable interrupt
 * - 1 - Enable interrupt
 */
/*@{*/
/*! @brief Read current value of the MCM_ISCR_FIDCE field. */
#define MCM_RD_ISCR_FIDCE(base) ((MCM_ISCR_REG(base) & MCM_ISCR_FIDCE_MASK) >> MCM_ISCR_FIDCE_SHIFT)
#define MCM_BRD_ISCR_FIDCE(base) (MCM_RD_ISCR_FIDCE(base))

/*! @brief Set the FIDCE field to a new value. */
#define MCM_WR_ISCR_FIDCE(base, value) (MCM_RMW_ISCR(base, MCM_ISCR_FIDCE_MASK, MCM_ISCR_FIDCE(value)))
#define MCM_BWR_ISCR_FIDCE(base, value) (MCM_WR_ISCR_FIDCE(base, value))
/*@}*/

/*******************************************************************************
 * MCM_CPO - Compute Operation Control Register
 ******************************************************************************/

/*!
 * @brief MCM_CPO - Compute Operation Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register controls the Compute Operation.
 */
/*!
 * @name Constants and macros for entire MCM_CPO register
 */
/*@{*/
#define MCM_RD_CPO(base)         (MCM_CPO_REG(base))
#define MCM_WR_CPO(base, value)  (MCM_CPO_REG(base) = (value))
#define MCM_RMW_CPO(base, mask, value) (MCM_WR_CPO(base, (MCM_RD_CPO(base) & ~(mask)) | (value)))
#define MCM_SET_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) |  (value)))
#define MCM_CLR_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) & ~(value)))
#define MCM_TOG_CPO(base, value) (MCM_WR_CPO(base, MCM_RD_CPO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual MCM_CPO bitfields
 */

/*!
 * @name Register MCM_CPO, field CPOREQ[0] (RW)
 *
 * This bit is auto-cleared by vector fetching if CPOWOI = 1.
 *
 * Values:
 * - 0 - Request is cleared.
 * - 1 - Request Compute Operation.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOREQ field. */
#define MCM_RD_CPO_CPOREQ(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOREQ_MASK) >> MCM_CPO_CPOREQ_SHIFT)
#define MCM_BRD_CPO_CPOREQ(base) (MCM_RD_CPO_CPOREQ(base))

/*! @brief Set the CPOREQ field to a new value. */
#define MCM_WR_CPO_CPOREQ(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOREQ_MASK, MCM_CPO_CPOREQ(value)))
#define MCM_BWR_CPO_CPOREQ(base, value) (MCM_WR_CPO_CPOREQ(base, value))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOACK[1] (RO)
 *
 * Values:
 * - 0 - Compute operation entry has not completed or compute operation exit has
 *     completed.
 * - 1 - Compute operation entry has completed or compute operation exit has not
 *     completed.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOACK field. */
#define MCM_RD_CPO_CPOACK(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOACK_MASK) >> MCM_CPO_CPOACK_SHIFT)
#define MCM_BRD_CPO_CPOACK(base) (MCM_RD_CPO_CPOACK(base))
/*@}*/

/*!
 * @name Register MCM_CPO, field CPOWOI[2] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - When set, the CPOREQ is cleared on any interrupt or exception vector
 *     fetch.
 */
/*@{*/
/*! @brief Read current value of the MCM_CPO_CPOWOI field. */
#define MCM_RD_CPO_CPOWOI(base) ((MCM_CPO_REG(base) & MCM_CPO_CPOWOI_MASK) >> MCM_CPO_CPOWOI_SHIFT)
#define MCM_BRD_CPO_CPOWOI(base) (MCM_RD_CPO_CPOWOI(base))

/*! @brief Set the CPOWOI field to a new value. */
#define MCM_WR_CPO_CPOWOI(base, value) (MCM_RMW_CPO(base, MCM_CPO_CPOWOI_MASK, MCM_CPO_CPOWOI(value)))
#define MCM_BWR_CPO_CPOWOI(base, value) (MCM_WR_CPO_CPOWOI(base, value))
/*@}*/

/*
 * MKS22F25612 NV
 *
 * Flash configuration field
 *
 * Registers defined in this header file:
 * - NV_BACKKEY3 - Backdoor Comparison Key 3.
 * - NV_BACKKEY2 - Backdoor Comparison Key 2.
 * - NV_BACKKEY1 - Backdoor Comparison Key 1.
 * - NV_BACKKEY0 - Backdoor Comparison Key 0.
 * - NV_BACKKEY7 - Backdoor Comparison Key 7.
 * - NV_BACKKEY6 - Backdoor Comparison Key 6.
 * - NV_BACKKEY5 - Backdoor Comparison Key 5.
 * - NV_BACKKEY4 - Backdoor Comparison Key 4.
 * - NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 * - NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 * - NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 * - NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 * - NV_FSEC - Non-volatile Flash Security Register
 * - NV_FOPT - Non-volatile Flash Option Register
 */

#define NV_INSTANCE_COUNT (1U) /*!< Number of instances of the NV module. */
#define FTFA_FlashConfig_IDX (0U) /*!< Instance number for FTFA_FlashConfig. */

/*******************************************************************************
 * NV_BACKKEY3 - Backdoor Comparison Key 3.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY3 - Backdoor Comparison Key 3. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY3 register
 */
/*@{*/
#define NV_RD_BACKKEY3(base)     (NV_BACKKEY3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY2 - Backdoor Comparison Key 2.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY2 - Backdoor Comparison Key 2. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY2 register
 */
/*@{*/
#define NV_RD_BACKKEY2(base)     (NV_BACKKEY2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY1 - Backdoor Comparison Key 1.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY1 - Backdoor Comparison Key 1. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY1 register
 */
/*@{*/
#define NV_RD_BACKKEY1(base)     (NV_BACKKEY1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY0 - Backdoor Comparison Key 0.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY0 - Backdoor Comparison Key 0. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY0 register
 */
/*@{*/
#define NV_RD_BACKKEY0(base)     (NV_BACKKEY0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY7 - Backdoor Comparison Key 7.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY7 - Backdoor Comparison Key 7. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY7 register
 */
/*@{*/
#define NV_RD_BACKKEY7(base)     (NV_BACKKEY7_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY6 - Backdoor Comparison Key 6.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY6 - Backdoor Comparison Key 6. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY6 register
 */
/*@{*/
#define NV_RD_BACKKEY6(base)     (NV_BACKKEY6_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY5 - Backdoor Comparison Key 5.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY5 - Backdoor Comparison Key 5. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY5 register
 */
/*@{*/
#define NV_RD_BACKKEY5(base)     (NV_BACKKEY5_REG(base))
/*@}*/

/*******************************************************************************
 * NV_BACKKEY4 - Backdoor Comparison Key 4.
 ******************************************************************************/

/*!
 * @brief NV_BACKKEY4 - Backdoor Comparison Key 4. (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_BACKKEY4 register
 */
/*@{*/
#define NV_RD_BACKKEY4(base)     (NV_BACKKEY4_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT3 - Non-volatile P-Flash Protection 1 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT3 register
 */
/*@{*/
#define NV_RD_FPROT3(base)       (NV_FPROT3_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT2 - Non-volatile P-Flash Protection 1 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT2 register
 */
/*@{*/
#define NV_RD_FPROT2(base)       (NV_FPROT2_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT1 - Non-volatile P-Flash Protection 0 - Low Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT1 register
 */
/*@{*/
#define NV_RD_FPROT1(base)       (NV_FPROT1_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register
 ******************************************************************************/

/*!
 * @brief NV_FPROT0 - Non-volatile P-Flash Protection 0 - High Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FPROT0 register
 */
/*@{*/
#define NV_RD_FPROT0(base)       (NV_FPROT0_REG(base))
/*@}*/

/*******************************************************************************
 * NV_FSEC - Non-volatile Flash Security Register
 ******************************************************************************/

/*!
 * @brief NV_FSEC - Non-volatile Flash Security Register (RO)
 *
 * Reset value: 0xFFU
 *
 * Allows the user to customize the operation of the MCU at boot time
 */
/*!
 * @name Constants and macros for entire NV_FSEC register
 */
/*@{*/
#define NV_RD_FSEC(base)         (NV_FSEC_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FSEC bitfields
 */

/*!
 * @name Register NV_FSEC, field SEC[1:0] (RO)
 *
 * Values:
 * - 10 - MCU security status is unsecure
 * - 11 - MCU security status is secure
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_SEC field. */
#define NV_RD_FSEC_SEC(base) ((NV_FSEC_REG(base) & NV_FSEC_SEC_MASK) >> NV_FSEC_SEC_SHIFT)
#define NV_BRD_FSEC_SEC(base) (NV_RD_FSEC_SEC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field FSLACC[3:2] (RO)
 *
 * Values:
 * - 10 - Freescale factory access denied
 * - 11 - Freescale factory access granted
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_FSLACC field. */
#define NV_RD_FSEC_FSLACC(base) ((NV_FSEC_REG(base) & NV_FSEC_FSLACC_MASK) >> NV_FSEC_FSLACC_SHIFT)
#define NV_BRD_FSEC_FSLACC(base) (NV_RD_FSEC_FSLACC(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field MEEN[5:4] (RO)
 *
 * Values:
 * - 10 - Mass erase is disabled
 * - 11 - Mass erase is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_MEEN field. */
#define NV_RD_FSEC_MEEN(base) ((NV_FSEC_REG(base) & NV_FSEC_MEEN_MASK) >> NV_FSEC_MEEN_SHIFT)
#define NV_BRD_FSEC_MEEN(base) (NV_RD_FSEC_MEEN(base))
/*@}*/

/*!
 * @name Register NV_FSEC, field KEYEN[7:6] (RO)
 *
 * Values:
 * - 10 - Backdoor key access enabled
 * - 11 - Backdoor key access disabled
 */
/*@{*/
/*! @brief Read current value of the NV_FSEC_KEYEN field. */
#define NV_RD_FSEC_KEYEN(base) ((NV_FSEC_REG(base) & NV_FSEC_KEYEN_MASK) >> NV_FSEC_KEYEN_SHIFT)
#define NV_BRD_FSEC_KEYEN(base) (NV_RD_FSEC_KEYEN(base))
/*@}*/

/*******************************************************************************
 * NV_FOPT - Non-volatile Flash Option Register
 ******************************************************************************/

/*!
 * @brief NV_FOPT - Non-volatile Flash Option Register (RO)
 *
 * Reset value: 0xFFU
 */
/*!
 * @name Constants and macros for entire NV_FOPT register
 */
/*@{*/
#define NV_RD_FOPT(base)         (NV_FOPT_REG(base))
/*@}*/

/*
 * Constants & macros for individual NV_FOPT bitfields
 */

/*!
 * @name Register NV_FOPT, field LPBOOT[0] (RO)
 *
 * Values:
 * - 00 - Low-power boot
 * - 01 - Normal boot
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_LPBOOT field. */
#define NV_RD_FOPT_LPBOOT(base) ((NV_FOPT_REG(base) & NV_FOPT_LPBOOT_MASK) >> NV_FOPT_LPBOOT_SHIFT)
#define NV_BRD_FOPT_LPBOOT(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_LPBOOT_SHIFT))
/*@}*/

/*!
 * @name Register NV_FOPT, field EZPORT_DIS[1] (RO)
 *
 * Values:
 * - 00 - EzPort operation is disabled
 * - 01 - EzPort operation is enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_EZPORT_DIS field. */
#define NV_RD_FOPT_EZPORT_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_EZPORT_DIS_MASK) >> NV_FOPT_EZPORT_DIS_SHIFT)
#define NV_BRD_FOPT_EZPORT_DIS(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_EZPORT_DIS_SHIFT))
/*@}*/

/*!
 * @name Register NV_FOPT, field NMI_DIS[2] (RO)
 *
 * Values:
 * - 00 - NMI interrupts are always blocked
 * - 01 - NMI_b pin/interrupts reset default to enabled
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_NMI_DIS field. */
#define NV_RD_FOPT_NMI_DIS(base) ((NV_FOPT_REG(base) & NV_FOPT_NMI_DIS_MASK) >> NV_FOPT_NMI_DIS_SHIFT)
#define NV_BRD_FOPT_NMI_DIS(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_NMI_DIS_SHIFT))
/*@}*/

/*!
 * @name Register NV_FOPT, field FAST_INIT[5] (RO)
 *
 * Values:
 * - 00 - Slower initialization
 * - 01 - Fast Initialization
 */
/*@{*/
/*! @brief Read current value of the NV_FOPT_FAST_INIT field. */
#define NV_RD_FOPT_FAST_INIT(base) ((NV_FOPT_REG(base) & NV_FOPT_FAST_INIT_MASK) >> NV_FOPT_FAST_INIT_SHIFT)
#define NV_BRD_FOPT_FAST_INIT(base) (BITBAND_ACCESS8(&NV_FOPT_REG(base), NV_FOPT_FAST_INIT_SHIFT))
/*@}*/

/*
 * MKS22F25612 OSC
 *
 * Oscillator
 *
 * Registers defined in this header file:
 * - OSC_CR - OSC Control Register
 * - OSC_DIV - OSC_DIV
 */

#define OSC_INSTANCE_COUNT (1U) /*!< Number of instances of the OSC module. */
#define OSC_IDX (0U) /*!< Instance number for OSC. */

/*******************************************************************************
 * OSC_CR - OSC Control Register
 ******************************************************************************/

/*!
 * @brief OSC_CR - OSC Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * After OSC is enabled and starts generating the clocks, the configurations
 * such as low power and frequency range, must not be changed.
 */
/*!
 * @name Constants and macros for entire OSC_CR register
 */
/*@{*/
#define OSC_RD_CR(base)          (OSC_CR_REG(base))
#define OSC_WR_CR(base, value)   (OSC_CR_REG(base) = (value))
#define OSC_RMW_CR(base, mask, value) (OSC_WR_CR(base, (OSC_RD_CR(base) & ~(mask)) | (value)))
#define OSC_SET_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) |  (value)))
#define OSC_CLR_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) & ~(value)))
#define OSC_TOG_CR(base, value)  (OSC_WR_CR(base, OSC_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual OSC_CR bitfields
 */

/*!
 * @name Register OSC_CR, field SC16P[0] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 16 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC16P field. */
#define OSC_RD_CR_SC16P(base) ((OSC_CR_REG(base) & OSC_CR_SC16P_MASK) >> OSC_CR_SC16P_SHIFT)
#define OSC_BRD_CR_SC16P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define OSC_WR_CR_SC16P(base, value) (OSC_RMW_CR(base, OSC_CR_SC16P_MASK, OSC_CR_SC16P(value)))
#define OSC_BWR_CR_SC16P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC8P[1] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 8 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC8P field. */
#define OSC_RD_CR_SC8P(base) ((OSC_CR_REG(base) & OSC_CR_SC8P_MASK) >> OSC_CR_SC8P_SHIFT)
#define OSC_BRD_CR_SC8P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define OSC_WR_CR_SC8P(base, value) (OSC_RMW_CR(base, OSC_CR_SC8P_MASK, OSC_CR_SC8P(value)))
#define OSC_BWR_CR_SC8P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC4P[2] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 4 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC4P field. */
#define OSC_RD_CR_SC4P(base) ((OSC_CR_REG(base) & OSC_CR_SC4P_MASK) >> OSC_CR_SC4P_SHIFT)
#define OSC_BRD_CR_SC4P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define OSC_WR_CR_SC4P(base, value) (OSC_RMW_CR(base, OSC_CR_SC4P_MASK, OSC_CR_SC4P(value)))
#define OSC_BWR_CR_SC4P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field SC2P[3] (RW)
 *
 * Configures the oscillator load.
 *
 * Values:
 * - 0 - Disable the selection.
 * - 1 - Add 2 pF capacitor to the oscillator load.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_SC2P field. */
#define OSC_RD_CR_SC2P(base) ((OSC_CR_REG(base) & OSC_CR_SC2P_MASK) >> OSC_CR_SC2P_SHIFT)
#define OSC_BRD_CR_SC2P(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define OSC_WR_CR_SC2P(base, value) (OSC_RMW_CR(base, OSC_CR_SC2P_MASK, OSC_CR_SC2P(value)))
#define OSC_BWR_CR_SC2P(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_SC2P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field EREFSTEN[5] (RW)
 *
 * Controls whether or not the external reference clock (OSCERCLK) remains
 * enabled when MCU enters Stop mode.
 *
 * Values:
 * - 0 - External reference clock is disabled in Stop mode.
 * - 1 - External reference clock stays enabled in Stop mode if ERCLKEN is set
 *     before entering Stop mode.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_EREFSTEN field. */
#define OSC_RD_CR_EREFSTEN(base) ((OSC_CR_REG(base) & OSC_CR_EREFSTEN_MASK) >> OSC_CR_EREFSTEN_SHIFT)
#define OSC_BRD_CR_EREFSTEN(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT))

/*! @brief Set the EREFSTEN field to a new value. */
#define OSC_WR_CR_EREFSTEN(base, value) (OSC_RMW_CR(base, OSC_CR_EREFSTEN_MASK, OSC_CR_EREFSTEN(value)))
#define OSC_BWR_CR_EREFSTEN(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_EREFSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register OSC_CR, field ERCLKEN[7] (RW)
 *
 * Enables external reference clock (OSCERCLK) .
 *
 * Values:
 * - 0 - External reference clock is inactive.
 * - 1 - External reference clock is enabled.
 */
/*@{*/
/*! @brief Read current value of the OSC_CR_ERCLKEN field. */
#define OSC_RD_CR_ERCLKEN(base) ((OSC_CR_REG(base) & OSC_CR_ERCLKEN_MASK) >> OSC_CR_ERCLKEN_SHIFT)
#define OSC_BRD_CR_ERCLKEN(base) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT))

/*! @brief Set the ERCLKEN field to a new value. */
#define OSC_WR_CR_ERCLKEN(base, value) (OSC_RMW_CR(base, OSC_CR_ERCLKEN_MASK, OSC_CR_ERCLKEN(value)))
#define OSC_BWR_CR_ERCLKEN(base, value) (BITBAND_ACCESS8(&OSC_CR_REG(base), OSC_CR_ERCLKEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * OSC_DIV - OSC_DIV
 ******************************************************************************/

/*!
 * @brief OSC_DIV - OSC_DIV (RW)
 *
 * Reset value: 0x00U
 *
 * OSC Clock divider register.
 */
/*!
 * @name Constants and macros for entire OSC_DIV register
 */
/*@{*/
#define OSC_RD_DIV(base)         (OSC_DIV_REG(base))
#define OSC_WR_DIV(base, value)  (OSC_DIV_REG(base) = (value))
#define OSC_RMW_DIV(base, mask, value) (OSC_WR_DIV(base, (OSC_RD_DIV(base) & ~(mask)) | (value)))
#define OSC_SET_DIV(base, value) (OSC_WR_DIV(base, OSC_RD_DIV(base) |  (value)))
#define OSC_CLR_DIV(base, value) (OSC_WR_DIV(base, OSC_RD_DIV(base) & ~(value)))
#define OSC_TOG_DIV(base, value) (OSC_WR_DIV(base, OSC_RD_DIV(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual OSC_DIV bitfields
 */

/*!
 * @name Register OSC_DIV, field ERPS[7:6] (RW)
 *
 * ERCLK prescaler. These two bits are used to divide the ERCLK output. The
 * un-divided ERCLK output is not affected by these two bits.
 *
 * Values:
 * - 00 - The divisor ratio is 1.
 * - 01 - The divisor ratio is 2.
 * - 10 - The divisor ratio is 4.
 * - 11 - The divisor ratio is 8.
 */
/*@{*/
/*! @brief Read current value of the OSC_DIV_ERPS field. */
#define OSC_RD_DIV_ERPS(base) ((OSC_DIV_REG(base) & OSC_DIV_ERPS_MASK) >> OSC_DIV_ERPS_SHIFT)
#define OSC_BRD_DIV_ERPS(base) (OSC_RD_DIV_ERPS(base))

/*! @brief Set the ERPS field to a new value. */
#define OSC_WR_DIV_ERPS(base, value) (OSC_RMW_DIV(base, OSC_DIV_ERPS_MASK, OSC_DIV_ERPS(value)))
#define OSC_BWR_DIV_ERPS(base, value) (OSC_WR_DIV_ERPS(base, value))
/*@}*/

/*
 * MKS22F25612 PDB
 *
 * Programmable Delay Block
 *
 * Registers defined in this header file:
 * - PDB_SC - Status and Control register
 * - PDB_MOD - Modulus register
 * - PDB_CNT - Counter register
 * - PDB_IDLY - Interrupt Delay register
 * - PDB_C1 - Channel n Control register 1
 * - PDB_S - Channel n Status register
 * - PDB_DLY - Channel n Delay 0 register
 * - PDB_INTC - DAC Interval Trigger n Control register
 * - PDB_INT - DAC Interval n register
 * - PDB_POEN - Pulse-Out n Enable register
 * - PDB_PODLY - Pulse-Out n Delay register
 */

#define PDB_INSTANCE_COUNT (1U) /*!< Number of instances of the PDB module. */
#define PDB0_IDX (0U) /*!< Instance number for PDB0. */

/*******************************************************************************
 * PDB_SC - Status and Control register
 ******************************************************************************/

/*!
 * @brief PDB_SC - Status and Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_SC register
 */
/*@{*/
#define PDB_RD_SC(base)          (PDB_SC_REG(base))
#define PDB_WR_SC(base, value)   (PDB_SC_REG(base) = (value))
#define PDB_RMW_SC(base, mask, value) (PDB_WR_SC(base, (PDB_RD_SC(base) & ~(mask)) | (value)))
#define PDB_SET_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) |  (value)))
#define PDB_CLR_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) & ~(value)))
#define PDB_TOG_SC(base, value)  (PDB_WR_SC(base, PDB_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_SC bitfields
 */

/*!
 * @name Register PDB_SC, field LDOK[0] (RW)
 *
 * Writing 1 to this bit updates the internal registers of MOD, IDLY, CHnDLYm,
 * DACINTx,and POyDLY with the values written to their buffers. The MOD, IDLY,
 * CHnDLYm, DACINTx, and POyDLY will take effect according to the LDMOD. After 1 is
 * written to the LDOK field, the values in the buffers of above registers are
 * not effective and the buffers cannot be written until the values in buffers are
 * loaded into their internal registers. LDOK can be written only when PDBEN is
 * set or it can be written at the same time with PDBEN being written to 1. It is
 * automatically cleared when the values in buffers are loaded into the internal
 * registers or the PDBEN is cleared. Writing 0 to it has no effect.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDOK field. */
#define PDB_RD_SC_LDOK(base) ((PDB_SC_REG(base) & PDB_SC_LDOK_MASK) >> PDB_SC_LDOK_SHIFT)
#define PDB_BRD_SC_LDOK(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT))

/*! @brief Set the LDOK field to a new value. */
#define PDB_WR_SC_LDOK(base, value) (PDB_RMW_SC(base, PDB_SC_LDOK_MASK, PDB_SC_LDOK(value)))
#define PDB_BWR_SC_LDOK(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_LDOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field CONT[1] (RW)
 *
 * Enables the PDB operation in Continuous mode.
 *
 * Values:
 * - 0 - PDB operation in One-Shot mode
 * - 1 - PDB operation in Continuous mode
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_CONT field. */
#define PDB_RD_SC_CONT(base) ((PDB_SC_REG(base) & PDB_SC_CONT_MASK) >> PDB_SC_CONT_SHIFT)
#define PDB_BRD_SC_CONT(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define PDB_WR_SC_CONT(base, value) (PDB_RMW_SC(base, PDB_SC_CONT_MASK, PDB_SC_CONT(value)))
#define PDB_BWR_SC_CONT(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_CONT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field MULT[3:2] (RW)
 *
 * Selects the multiplication factor of the prescaler divider for the counter
 * clock.
 *
 * Values:
 * - 00 - Multiplication factor is 1.
 * - 01 - Multiplication factor is 10.
 * - 10 - Multiplication factor is 20.
 * - 11 - Multiplication factor is 40.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_MULT field. */
#define PDB_RD_SC_MULT(base) ((PDB_SC_REG(base) & PDB_SC_MULT_MASK) >> PDB_SC_MULT_SHIFT)
#define PDB_BRD_SC_MULT(base) (PDB_RD_SC_MULT(base))

/*! @brief Set the MULT field to a new value. */
#define PDB_WR_SC_MULT(base, value) (PDB_RMW_SC(base, PDB_SC_MULT_MASK, PDB_SC_MULT(value)))
#define PDB_BWR_SC_MULT(base, value) (PDB_WR_SC_MULT(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIE[5] (RW)
 *
 * Enables the PDB interrupt. When this field is set and DMAEN is cleared, PDBIF
 * generates a PDB interrupt.
 *
 * Values:
 * - 0 - PDB interrupt disabled.
 * - 1 - PDB interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIE field. */
#define PDB_RD_SC_PDBIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBIE_MASK) >> PDB_SC_PDBIE_SHIFT)
#define PDB_BRD_SC_PDBIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT))

/*! @brief Set the PDBIE field to a new value. */
#define PDB_WR_SC_PDBIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIE_MASK, PDB_SC_PDBIE(value)))
#define PDB_BWR_SC_PDBIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBIF[6] (RW)
 *
 * This field is set when the counter value is equal to the IDLY register.
 * Writing zero clears this field.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBIF field. */
#define PDB_RD_SC_PDBIF(base) ((PDB_SC_REG(base) & PDB_SC_PDBIF_MASK) >> PDB_SC_PDBIF_SHIFT)
#define PDB_BRD_SC_PDBIF(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT))

/*! @brief Set the PDBIF field to a new value. */
#define PDB_WR_SC_PDBIF(base, value) (PDB_RMW_SC(base, PDB_SC_PDBIF_MASK, PDB_SC_PDBIF(value)))
#define PDB_BWR_SC_PDBIF(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEN[7] (RW)
 *
 * Values:
 * - 0 - PDB disabled. Counter is off.
 * - 1 - PDB enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEN field. */
#define PDB_RD_SC_PDBEN(base) ((PDB_SC_REG(base) & PDB_SC_PDBEN_MASK) >> PDB_SC_PDBEN_SHIFT)
#define PDB_BRD_SC_PDBEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT))

/*! @brief Set the PDBEN field to a new value. */
#define PDB_WR_SC_PDBEN(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEN_MASK, PDB_SC_PDBEN(value)))
#define PDB_BWR_SC_PDBEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field TRGSEL[11:8] (RW)
 *
 * Selects the trigger input source for the PDB. The trigger input source can be
 * internal or external (EXTRG pin), or the software trigger. Refer to chip
 * configuration details for the actual PDB input trigger connections.
 *
 * Values:
 * - 0000 - Trigger-In 0 is selected.
 * - 0001 - Trigger-In 1 is selected.
 * - 0010 - Trigger-In 2 is selected.
 * - 0011 - Trigger-In 3 is selected.
 * - 0100 - Trigger-In 4 is selected.
 * - 0101 - Trigger-In 5 is selected.
 * - 0110 - Trigger-In 6 is selected.
 * - 0111 - Trigger-In 7 is selected.
 * - 1000 - Trigger-In 8 is selected.
 * - 1001 - Trigger-In 9 is selected.
 * - 1010 - Trigger-In 10 is selected.
 * - 1011 - Trigger-In 11 is selected.
 * - 1100 - Trigger-In 12 is selected.
 * - 1101 - Trigger-In 13 is selected.
 * - 1110 - Trigger-In 14 is selected.
 * - 1111 - Software trigger is selected.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_TRGSEL field. */
#define PDB_RD_SC_TRGSEL(base) ((PDB_SC_REG(base) & PDB_SC_TRGSEL_MASK) >> PDB_SC_TRGSEL_SHIFT)
#define PDB_BRD_SC_TRGSEL(base) (PDB_RD_SC_TRGSEL(base))

/*! @brief Set the TRGSEL field to a new value. */
#define PDB_WR_SC_TRGSEL(base, value) (PDB_RMW_SC(base, PDB_SC_TRGSEL_MASK, PDB_SC_TRGSEL(value)))
#define PDB_BWR_SC_TRGSEL(base, value) (PDB_WR_SC_TRGSEL(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field PRESCALER[14:12] (RW)
 *
 * Values:
 * - 000 - Counting uses the peripheral clock divided by multiplication factor
 *     selected by MULT.
 * - 001 - Counting uses the peripheral clock divided by twice of the
 *     multiplication factor selected by MULT.
 * - 010 - Counting uses the peripheral clock divided by four times of the
 *     multiplication factor selected by MULT.
 * - 011 - Counting uses the peripheral clock divided by eight times of the
 *     multiplication factor selected by MULT.
 * - 100 - Counting uses the peripheral clock divided by 16 times of the
 *     multiplication factor selected by MULT.
 * - 101 - Counting uses the peripheral clock divided by 32 times of the
 *     multiplication factor selected by MULT.
 * - 110 - Counting uses the peripheral clock divided by 64 times of the
 *     multiplication factor selected by MULT.
 * - 111 - Counting uses the peripheral clock divided by 128 times of the
 *     multiplication factor selected by MULT.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PRESCALER field. */
#define PDB_RD_SC_PRESCALER(base) ((PDB_SC_REG(base) & PDB_SC_PRESCALER_MASK) >> PDB_SC_PRESCALER_SHIFT)
#define PDB_BRD_SC_PRESCALER(base) (PDB_RD_SC_PRESCALER(base))

/*! @brief Set the PRESCALER field to a new value. */
#define PDB_WR_SC_PRESCALER(base, value) (PDB_RMW_SC(base, PDB_SC_PRESCALER_MASK, PDB_SC_PRESCALER(value)))
#define PDB_BWR_SC_PRESCALER(base, value) (PDB_WR_SC_PRESCALER(base, value))
/*@}*/

/*!
 * @name Register PDB_SC, field DMAEN[15] (RW)
 *
 * When DMA is enabled, the PDBIF flag generates a DMA request instead of an
 * interrupt.
 *
 * Values:
 * - 0 - DMA disabled.
 * - 1 - DMA enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_DMAEN field. */
#define PDB_RD_SC_DMAEN(base) ((PDB_SC_REG(base) & PDB_SC_DMAEN_MASK) >> PDB_SC_DMAEN_SHIFT)
#define PDB_BRD_SC_DMAEN(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT))

/*! @brief Set the DMAEN field to a new value. */
#define PDB_WR_SC_DMAEN(base, value) (PDB_RMW_SC(base, PDB_SC_DMAEN_MASK, PDB_SC_DMAEN(value)))
#define PDB_BWR_SC_DMAEN(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_DMAEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field SWTRIG[16] (WORZ)
 *
 * When PDB is enabled and the software trigger is selected as the trigger input
 * source, writing 1 to this field resets and restarts the counter. Writing 0 to
 * this field has no effect. Reading this field results 0.
 */
/*@{*/
/*! @brief Set the SWTRIG field to a new value. */
#define PDB_WR_SC_SWTRIG(base, value) (PDB_RMW_SC(base, PDB_SC_SWTRIG_MASK, PDB_SC_SWTRIG(value)))
#define PDB_BWR_SC_SWTRIG(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_SWTRIG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field PDBEIE[17] (RW)
 *
 * Enables the PDB sequence error interrupt. When this field is set, any of the
 * PDB channel sequence error flags generates a PDB sequence error interrupt.
 *
 * Values:
 * - 0 - PDB sequence error interrupt disabled.
 * - 1 - PDB sequence error interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_PDBEIE field. */
#define PDB_RD_SC_PDBEIE(base) ((PDB_SC_REG(base) & PDB_SC_PDBEIE_MASK) >> PDB_SC_PDBEIE_SHIFT)
#define PDB_BRD_SC_PDBEIE(base) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT))

/*! @brief Set the PDBEIE field to a new value. */
#define PDB_WR_SC_PDBEIE(base, value) (PDB_RMW_SC(base, PDB_SC_PDBEIE_MASK, PDB_SC_PDBEIE(value)))
#define PDB_BWR_SC_PDBEIE(base, value) (BITBAND_ACCESS32(&PDB_SC_REG(base), PDB_SC_PDBEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_SC, field LDMOD[19:18] (RW)
 *
 * Selects the mode to load the MOD, IDLY, CHnDLYm, INTx, and POyDLY registers,
 * after 1 is written to LDOK.
 *
 * Values:
 * - 00 - The internal registers are loaded with the values from their buffers
 *     immediately after 1 is written to LDOK.
 * - 01 - The internal registers are loaded with the values from their buffers
 *     when the PDB counter reaches the MOD register value after 1 is written to
 *     LDOK.
 * - 10 - The internal registers are loaded with the values from their buffers
 *     when a trigger input event is detected after 1 is written to LDOK.
 * - 11 - The internal registers are loaded with the values from their buffers
 *     when either the PDB counter reaches the MOD register value or a trigger
 *     input event is detected, after 1 is written to LDOK.
 */
/*@{*/
/*! @brief Read current value of the PDB_SC_LDMOD field. */
#define PDB_RD_SC_LDMOD(base) ((PDB_SC_REG(base) & PDB_SC_LDMOD_MASK) >> PDB_SC_LDMOD_SHIFT)
#define PDB_BRD_SC_LDMOD(base) (PDB_RD_SC_LDMOD(base))

/*! @brief Set the LDMOD field to a new value. */
#define PDB_WR_SC_LDMOD(base, value) (PDB_RMW_SC(base, PDB_SC_LDMOD_MASK, PDB_SC_LDMOD(value)))
#define PDB_BWR_SC_LDMOD(base, value) (PDB_WR_SC_LDMOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_MOD - Modulus register
 ******************************************************************************/

/*!
 * @brief PDB_MOD - Modulus register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_MOD register
 */
/*@{*/
#define PDB_RD_MOD(base)         (PDB_MOD_REG(base))
#define PDB_WR_MOD(base, value)  (PDB_MOD_REG(base) = (value))
#define PDB_RMW_MOD(base, mask, value) (PDB_WR_MOD(base, (PDB_RD_MOD(base) & ~(mask)) | (value)))
#define PDB_SET_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) |  (value)))
#define PDB_CLR_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) & ~(value)))
#define PDB_TOG_MOD(base, value) (PDB_WR_MOD(base, PDB_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_MOD bitfields
 */

/*!
 * @name Register PDB_MOD, field MOD[15:0] (RW)
 *
 * Specifies the period of the counter. When the counter reaches this value, it
 * will be reset back to zero. If the PDB is in Continuous mode, the count begins
 * anew. Reading this field returns the value of the internal register that is
 * effective for the current cycle of PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_MOD_MOD field. */
#define PDB_RD_MOD_MOD(base) ((PDB_MOD_REG(base) & PDB_MOD_MOD_MASK) >> PDB_MOD_MOD_SHIFT)
#define PDB_BRD_MOD_MOD(base) (PDB_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define PDB_WR_MOD_MOD(base, value) (PDB_RMW_MOD(base, PDB_MOD_MOD_MASK, PDB_MOD_MOD(value)))
#define PDB_BWR_MOD_MOD(base, value) (PDB_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * PDB_CNT - Counter register
 ******************************************************************************/

/*!
 * @brief PDB_CNT - Counter register (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_CNT register
 */
/*@{*/
#define PDB_RD_CNT(base)         (PDB_CNT_REG(base))
/*@}*/

/*
 * Constants & macros for individual PDB_CNT bitfields
 */

/*!
 * @name Register PDB_CNT, field CNT[15:0] (RO)
 *
 * Contains the current value of the counter.
 */
/*@{*/
/*! @brief Read current value of the PDB_CNT_CNT field. */
#define PDB_RD_CNT_CNT(base) ((PDB_CNT_REG(base) & PDB_CNT_CNT_MASK) >> PDB_CNT_CNT_SHIFT)
#define PDB_BRD_CNT_CNT(base) (PDB_RD_CNT_CNT(base))
/*@}*/

/*******************************************************************************
 * PDB_IDLY - Interrupt Delay register
 ******************************************************************************/

/*!
 * @brief PDB_IDLY - Interrupt Delay register (RW)
 *
 * Reset value: 0x0000FFFFU
 */
/*!
 * @name Constants and macros for entire PDB_IDLY register
 */
/*@{*/
#define PDB_RD_IDLY(base)        (PDB_IDLY_REG(base))
#define PDB_WR_IDLY(base, value) (PDB_IDLY_REG(base) = (value))
#define PDB_RMW_IDLY(base, mask, value) (PDB_WR_IDLY(base, (PDB_RD_IDLY(base) & ~(mask)) | (value)))
#define PDB_SET_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) |  (value)))
#define PDB_CLR_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) & ~(value)))
#define PDB_TOG_IDLY(base, value) (PDB_WR_IDLY(base, PDB_RD_IDLY(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_IDLY bitfields
 */

/*!
 * @name Register PDB_IDLY, field IDLY[15:0] (RW)
 *
 * Specifies the delay value to schedule the PDB interrupt. It can be used to
 * schedule an independent interrupt at some point in the PDB cycle. If enabled, a
 * PDB interrupt is generated, when the counter is equal to the IDLY. Reading
 * this field returns the value of internal register that is effective for the
 * current cycle of the PDB.
 */
/*@{*/
/*! @brief Read current value of the PDB_IDLY_IDLY field. */
#define PDB_RD_IDLY_IDLY(base) ((PDB_IDLY_REG(base) & PDB_IDLY_IDLY_MASK) >> PDB_IDLY_IDLY_SHIFT)
#define PDB_BRD_IDLY_IDLY(base) (PDB_RD_IDLY_IDLY(base))

/*! @brief Set the IDLY field to a new value. */
#define PDB_WR_IDLY_IDLY(base, value) (PDB_RMW_IDLY(base, PDB_IDLY_IDLY_MASK, PDB_IDLY_IDLY(value)))
#define PDB_BWR_IDLY_IDLY(base, value) (PDB_WR_IDLY_IDLY(base, value))
/*@}*/

/*******************************************************************************
 * PDB_C1 - Channel n Control register 1
 ******************************************************************************/

/*!
 * @brief PDB_C1 - Channel n Control register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each PDB channel has one control register, CHnC1. The fields in this register
 * control the functionality of each PDB channel operation.
 */
/*!
 * @name Constants and macros for entire PDB_C1 register
 */
/*@{*/
#define PDB_RD_C1(base, index)   (PDB_C1_REG(base, index))
#define PDB_WR_C1(base, index, value) (PDB_C1_REG(base, index) = (value))
#define PDB_RMW_C1(base, index, mask, value) (PDB_WR_C1(base, index, (PDB_RD_C1(base, index) & ~(mask)) | (value)))
#define PDB_SET_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) |  (value)))
#define PDB_CLR_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) & ~(value)))
#define PDB_TOG_C1(base, index, value) (PDB_WR_C1(base, index, PDB_RD_C1(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_C1 bitfields
 */

/*!
 * @name Register PDB_C1, field EN[7:0] (RW)
 *
 * Enables the PDB ADC pre-trigger outputs. Only lower M pre-trigger fields are
 * implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger disabled.
 * - 1 - PDB channel's corresponding pre-trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_EN field. */
#define PDB_RD_C1_EN(base, index) ((PDB_C1_REG(base, index) & PDB_C1_EN_MASK) >> PDB_C1_EN_SHIFT)
#define PDB_BRD_C1_EN(base, index) (PDB_RD_C1_EN(base, index))

/*! @brief Set the EN field to a new value. */
#define PDB_WR_C1_EN(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_EN_MASK, PDB_C1_EN(value)))
#define PDB_BWR_C1_EN(base, index, value) (PDB_WR_C1_EN(base, index, value))
/*@}*/

/*!
 * @name Register PDB_C1, field TOS[15:8] (RW)
 *
 * These bits select the PDB ADC pre-trigger outputs. Only lower M pre-trigger
 * bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger is in bypassed mode. The
 *     pre-trigger asserts one peripheral clock cycle after a rising edge is detected
 *     on selected trigger input source or software trigger is selected and SWTRIG
 *     is written with 1.
 * - 1 - PDB channel's corresponding pre-trigger asserts when the counter
 *     reaches the channel delay register plus one peripheral clock cycle after a
 *     rising edge is detected on selected trigger input source or software trigger is
 *     selected and SETRIG is written with 1.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_TOS field. */
#define PDB_RD_C1_TOS(base, index) ((PDB_C1_REG(base, index) & PDB_C1_TOS_MASK) >> PDB_C1_TOS_SHIFT)
#define PDB_BRD_C1_TOS(base, index) (PDB_RD_C1_TOS(base, index))

/*! @brief Set the TOS field to a new value. */
#define PDB_WR_C1_TOS(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_TOS_MASK, PDB_C1_TOS(value)))
#define PDB_BWR_C1_TOS(base, index, value) (PDB_WR_C1_TOS(base, index, value))
/*@}*/

/*!
 * @name Register PDB_C1, field BB[23:16] (RW)
 *
 * Enables the PDB ADC pre-trigger operation as back-to-back mode. Only lower M
 * pre-trigger bits are implemented in this MCU. Back-to-back operation enables
 * the ADC conversions complete to trigger the next PDB channel pre-trigger and
 * trigger output, so that the ADC conversions can be triggered on the next set of
 * configuration and results registers. Application code must enable only the
 * back-to-back operation of the PDB pre-triggers at the leading of the back-to-back
 * connection chain.
 *
 * Values:
 * - 0 - PDB channel's corresponding pre-trigger back-to-back operation disabled.
 * - 1 - PDB channel's corresponding pre-trigger back-to-back operation enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_C1_BB field. */
#define PDB_RD_C1_BB(base, index) ((PDB_C1_REG(base, index) & PDB_C1_BB_MASK) >> PDB_C1_BB_SHIFT)
#define PDB_BRD_C1_BB(base, index) (PDB_RD_C1_BB(base, index))

/*! @brief Set the BB field to a new value. */
#define PDB_WR_C1_BB(base, index, value) (PDB_RMW_C1(base, index, PDB_C1_BB_MASK, PDB_C1_BB(value)))
#define PDB_BWR_C1_BB(base, index, value) (PDB_WR_C1_BB(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_S - Channel n Status register
 ******************************************************************************/

/*!
 * @brief PDB_S - Channel n Status register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_S register
 */
/*@{*/
#define PDB_RD_S(base, index)    (PDB_S_REG(base, index))
#define PDB_WR_S(base, index, value) (PDB_S_REG(base, index) = (value))
#define PDB_RMW_S(base, index, mask, value) (PDB_WR_S(base, index, (PDB_RD_S(base, index) & ~(mask)) | (value)))
#define PDB_SET_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) |  (value)))
#define PDB_CLR_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) & ~(value)))
#define PDB_TOG_S(base, index, value) (PDB_WR_S(base, index, PDB_RD_S(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_S bitfields
 */

/*!
 * @name Register PDB_S, field ERR[7:0] (RW)
 *
 * Only the lower M bits are implemented in this MCU.
 *
 * Values:
 * - 0 - Sequence error not detected on PDB channel's corresponding pre-trigger.
 * - 1 - Sequence error detected on PDB channel's corresponding pre-trigger.
 *     ADCn block can be triggered for a conversion by one pre-trigger from PDB
 *     channel n. When one conversion, which is triggered by one of the pre-triggers
 *     from PDB channel n, is in progress, new trigger from PDB channel's
 *     corresponding pre-trigger m cannot be accepted by ADCn, and ERR[m] is set.
 *     Writing 0's to clear the sequence error flags.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_ERR field. */
#define PDB_RD_S_ERR(base, index) ((PDB_S_REG(base, index) & PDB_S_ERR_MASK) >> PDB_S_ERR_SHIFT)
#define PDB_BRD_S_ERR(base, index) (PDB_RD_S_ERR(base, index))

/*! @brief Set the ERR field to a new value. */
#define PDB_WR_S_ERR(base, index, value) (PDB_RMW_S(base, index, PDB_S_ERR_MASK, PDB_S_ERR(value)))
#define PDB_BWR_S_ERR(base, index, value) (PDB_WR_S_ERR(base, index, value))
/*@}*/

/*!
 * @name Register PDB_S, field CF[23:16] (RW)
 *
 * The CF[m] field is set when the PDB counter matches the CHnDLYm. Write 0 to
 * clear these bits.
 */
/*@{*/
/*! @brief Read current value of the PDB_S_CF field. */
#define PDB_RD_S_CF(base, index) ((PDB_S_REG(base, index) & PDB_S_CF_MASK) >> PDB_S_CF_SHIFT)
#define PDB_BRD_S_CF(base, index) (PDB_RD_S_CF(base, index))

/*! @brief Set the CF field to a new value. */
#define PDB_WR_S_CF(base, index, value) (PDB_RMW_S(base, index, PDB_S_CF_MASK, PDB_S_CF(value)))
#define PDB_BWR_S_CF(base, index, value) (PDB_WR_S_CF(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_DLY - Channel n Delay 0 register
 ******************************************************************************/

/*!
 * @brief PDB_DLY - Channel n Delay 0 register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_DLY register
 */
/*@{*/
#define PDB_RD_DLY(base, index, index2) (PDB_DLY_REG(base, index, index2))
#define PDB_WR_DLY(base, index, index2, value) (PDB_DLY_REG(base, index, index2) = (value))
#define PDB_RMW_DLY(base, index, index2, mask, value) (PDB_WR_DLY(base, index, index2, (PDB_RD_DLY(base, index, index2) & ~(mask)) | (value)))
#define PDB_SET_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) |  (value)))
#define PDB_CLR_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) & ~(value)))
#define PDB_TOG_DLY(base, index, index2, value) (PDB_WR_DLY(base, index, index2, PDB_RD_DLY(base, index, index2) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_DLY bitfields
 */

/*!
 * @name Register PDB_DLY, field DLY[15:0] (RW)
 *
 * Specifies the delay value for the channel's corresponding pre-trigger. The
 * pre-trigger asserts when the counter is equal to DLY. Reading this field returns
 * the value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_DLY_DLY field. */
#define PDB_RD_DLY_DLY(base, index, index2) ((PDB_DLY_REG(base, index, index2) & PDB_DLY_DLY_MASK) >> PDB_DLY_DLY_SHIFT)
#define PDB_BRD_DLY_DLY(base, index, index2) (PDB_RD_DLY_DLY(base, index, index2))

/*! @brief Set the DLY field to a new value. */
#define PDB_WR_DLY_DLY(base, index, index2, value) (PDB_RMW_DLY(base, index, index2, PDB_DLY_DLY_MASK, PDB_DLY_DLY(value)))
#define PDB_BWR_DLY_DLY(base, index, index2, value) (PDB_WR_DLY_DLY(base, index, index2, value))
/*@}*/

/*******************************************************************************
 * PDB_INTC - DAC Interval Trigger n Control register
 ******************************************************************************/

/*!
 * @brief PDB_INTC - DAC Interval Trigger n Control register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_INTC register
 */
/*@{*/
#define PDB_RD_INTC(base, index) (PDB_INTC_REG(base, index))
#define PDB_WR_INTC(base, index, value) (PDB_INTC_REG(base, index) = (value))
#define PDB_RMW_INTC(base, index, mask, value) (PDB_WR_INTC(base, index, (PDB_RD_INTC(base, index) & ~(mask)) | (value)))
#define PDB_SET_INTC(base, index, value) (PDB_WR_INTC(base, index, PDB_RD_INTC(base, index) |  (value)))
#define PDB_CLR_INTC(base, index, value) (PDB_WR_INTC(base, index, PDB_RD_INTC(base, index) & ~(value)))
#define PDB_TOG_INTC(base, index, value) (PDB_WR_INTC(base, index, PDB_RD_INTC(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INTC bitfields
 */

/*!
 * @name Register PDB_INTC, field TOE[0] (RW)
 *
 * Enables the DAC interval trigger.
 *
 * Values:
 * - 0 - DAC interval trigger disabled.
 * - 1 - DAC interval trigger enabled.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_TOE field. */
#define PDB_RD_INTC_TOE(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_TOE_MASK) >> PDB_INTC_TOE_SHIFT)
#define PDB_BRD_INTC_TOE(base, index) (BITBAND_ACCESS32(&PDB_INTC_REG(base, index), PDB_INTC_TOE_SHIFT))

/*! @brief Set the TOE field to a new value. */
#define PDB_WR_INTC_TOE(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_TOE_MASK, PDB_INTC_TOE(value)))
#define PDB_BWR_INTC_TOE(base, index, value) (BITBAND_ACCESS32(&PDB_INTC_REG(base, index), PDB_INTC_TOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PDB_INTC, field EXT[1] (RW)
 *
 * This bit enables the external trigger for DAC interval counter.
 *
 * Values:
 * - 0 - DAC external trigger input disabled. DAC interval counter is reset and
 *     started counting when a rising edge is detected on selected trigger input
 *     source or software trigger is selected and SWTRIG is written with 1.
 * - 1 - DAC external trigger input enabled. DAC interval counter is bypassed
 *     and DAC external trigger input triggers the DAC interval trigger.
 */
/*@{*/
/*! @brief Read current value of the PDB_INTC_EXT field. */
#define PDB_RD_INTC_EXT(base, index) ((PDB_INTC_REG(base, index) & PDB_INTC_EXT_MASK) >> PDB_INTC_EXT_SHIFT)
#define PDB_BRD_INTC_EXT(base, index) (BITBAND_ACCESS32(&PDB_INTC_REG(base, index), PDB_INTC_EXT_SHIFT))

/*! @brief Set the EXT field to a new value. */
#define PDB_WR_INTC_EXT(base, index, value) (PDB_RMW_INTC(base, index, PDB_INTC_EXT_MASK, PDB_INTC_EXT(value)))
#define PDB_BWR_INTC_EXT(base, index, value) (BITBAND_ACCESS32(&PDB_INTC_REG(base, index), PDB_INTC_EXT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PDB_INT - DAC Interval n register
 ******************************************************************************/

/*!
 * @brief PDB_INT - DAC Interval n register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_INT register
 */
/*@{*/
#define PDB_RD_INT(base, index)  (PDB_INT_REG(base, index))
#define PDB_WR_INT(base, index, value) (PDB_INT_REG(base, index) = (value))
#define PDB_RMW_INT(base, index, mask, value) (PDB_WR_INT(base, index, (PDB_RD_INT(base, index) & ~(mask)) | (value)))
#define PDB_SET_INT(base, index, value) (PDB_WR_INT(base, index, PDB_RD_INT(base, index) |  (value)))
#define PDB_CLR_INT(base, index, value) (PDB_WR_INT(base, index, PDB_RD_INT(base, index) & ~(value)))
#define PDB_TOG_INT(base, index, value) (PDB_WR_INT(base, index, PDB_RD_INT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_INT bitfields
 */

/*!
 * @name Register PDB_INT, field INT[15:0] (RW)
 *
 * These bits specify the interval value for DAC interval trigger. DAC interval
 * trigger triggers DAC[1:0] update when the DAC interval counter is equal to the
 * DACINT. Reading these bits returns the value of internal register that is
 * effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_INT_INT field. */
#define PDB_RD_INT_INT(base, index) ((PDB_INT_REG(base, index) & PDB_INT_INT_MASK) >> PDB_INT_INT_SHIFT)
#define PDB_BRD_INT_INT(base, index) (PDB_RD_INT_INT(base, index))

/*! @brief Set the INT field to a new value. */
#define PDB_WR_INT_INT(base, index, value) (PDB_RMW_INT(base, index, PDB_INT_INT_MASK, PDB_INT_INT(value)))
#define PDB_BWR_INT_INT(base, index, value) (PDB_WR_INT_INT(base, index, value))
/*@}*/

/*******************************************************************************
 * PDB_POEN - Pulse-Out n Enable register
 ******************************************************************************/

/*!
 * @brief PDB_POEN - Pulse-Out n Enable register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_POEN register
 */
/*@{*/
#define PDB_RD_POEN(base)        (PDB_POEN_REG(base))
#define PDB_WR_POEN(base, value) (PDB_POEN_REG(base) = (value))
#define PDB_RMW_POEN(base, mask, value) (PDB_WR_POEN(base, (PDB_RD_POEN(base) & ~(mask)) | (value)))
#define PDB_SET_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) |  (value)))
#define PDB_CLR_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) & ~(value)))
#define PDB_TOG_POEN(base, value) (PDB_WR_POEN(base, PDB_RD_POEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_POEN bitfields
 */

/*!
 * @name Register PDB_POEN, field POEN[7:0] (RW)
 *
 * Enables the pulse output. Only lower Y bits are implemented in this MCU.
 *
 * Values:
 * - 0 - PDB Pulse-Out disabled
 * - 1 - PDB Pulse-Out enabled
 */
/*@{*/
/*! @brief Read current value of the PDB_POEN_POEN field. */
#define PDB_RD_POEN_POEN(base) ((PDB_POEN_REG(base) & PDB_POEN_POEN_MASK) >> PDB_POEN_POEN_SHIFT)
#define PDB_BRD_POEN_POEN(base) (PDB_RD_POEN_POEN(base))

/*! @brief Set the POEN field to a new value. */
#define PDB_WR_POEN_POEN(base, value) (PDB_RMW_POEN(base, PDB_POEN_POEN_MASK, PDB_POEN_POEN(value)))
#define PDB_BWR_POEN_POEN(base, value) (PDB_WR_POEN_POEN(base, value))
/*@}*/

/*******************************************************************************
 * PDB_PODLY - Pulse-Out n Delay register
 ******************************************************************************/

/*!
 * @brief PDB_PODLY - Pulse-Out n Delay register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire PDB_PODLY register
 */
/*@{*/
#define PDB_RD_PODLY(base, index) (PDB_PODLY_REG(base, index))
#define PDB_WR_PODLY(base, index, value) (PDB_PODLY_REG(base, index) = (value))
#define PDB_RMW_PODLY(base, index, mask, value) (PDB_WR_PODLY(base, index, (PDB_RD_PODLY(base, index) & ~(mask)) | (value)))
#define PDB_SET_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) |  (value)))
#define PDB_CLR_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) & ~(value)))
#define PDB_TOG_PODLY(base, index, value) (PDB_WR_PODLY(base, index, PDB_RD_PODLY(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PDB_PODLY bitfields
 */

/*!
 * @name Register PDB_PODLY, field DLY2[15:0] (RW)
 *
 * These bits specify the delay 2 value for the PDB Pulse-Out. Pulse-Out goes
 * low when the PDB counter is equal to the DLY2. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY2 field. */
#define PDB_RD_PODLY_DLY2(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY2_MASK) >> PDB_PODLY_DLY2_SHIFT)
#define PDB_BRD_PODLY_DLY2(base, index) (PDB_RD_PODLY_DLY2(base, index))

/*! @brief Set the DLY2 field to a new value. */
#define PDB_WR_PODLY_DLY2(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY2_MASK, PDB_PODLY_DLY2(value)))
#define PDB_BWR_PODLY_DLY2(base, index, value) (PDB_WR_PODLY_DLY2(base, index, value))
/*@}*/

/*!
 * @name Register PDB_PODLY, field DLY1[31:16] (RW)
 *
 * These bits specify the delay 1 value for the PDB Pulse-Out. Pulse-Out goes
 * high when the PDB counter is equal to the DLY1. Reading these bits returns the
 * value of internal register that is effective for the current PDB cycle.
 */
/*@{*/
/*! @brief Read current value of the PDB_PODLY_DLY1 field. */
#define PDB_RD_PODLY_DLY1(base, index) ((PDB_PODLY_REG(base, index) & PDB_PODLY_DLY1_MASK) >> PDB_PODLY_DLY1_SHIFT)
#define PDB_BRD_PODLY_DLY1(base, index) (PDB_RD_PODLY_DLY1(base, index))

/*! @brief Set the DLY1 field to a new value. */
#define PDB_WR_PODLY_DLY1(base, index, value) (PDB_RMW_PODLY(base, index, PDB_PODLY_DLY1_MASK, PDB_PODLY_DLY1(value)))
#define PDB_BWR_PODLY_DLY1(base, index, value) (PDB_WR_PODLY_DLY1(base, index, value))
/*@}*/

/*
 * MKS22F25612 PIT
 *
 * Periodic Interrupt Timer
 *
 * Registers defined in this header file:
 * - PIT_MCR - PIT Module Control Register
 * - PIT_LTMR64H - PIT Upper Lifetime Timer Register
 * - PIT_LTMR64L - PIT Lower Lifetime Timer Register
 * - PIT_LDVAL - Timer Load Value Register
 * - PIT_CVAL - Current Timer Value Register
 * - PIT_TCTRL - Timer Control Register
 * - PIT_TFLG - Timer Flag Register
 */

#define PIT_INSTANCE_COUNT (1U) /*!< Number of instances of the PIT module. */
#define PIT_IDX (0U) /*!< Instance number for PIT. */

/*******************************************************************************
 * PIT_MCR - PIT Module Control Register
 ******************************************************************************/

/*!
 * @brief PIT_MCR - PIT Module Control Register (RW)
 *
 * Reset value: 0x00000002U
 *
 * This register enables or disables the PIT timer clocks and controls the
 * timers when the PIT enters the Debug mode. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_MCR register
 */
/*@{*/
#define PIT_RD_MCR(base)         (PIT_MCR_REG(base))
#define PIT_WR_MCR(base, value)  (PIT_MCR_REG(base) = (value))
#define PIT_RMW_MCR(base, mask, value) (PIT_WR_MCR(base, (PIT_RD_MCR(base) & ~(mask)) | (value)))
#define PIT_SET_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) |  (value)))
#define PIT_CLR_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) & ~(value)))
#define PIT_TOG_MCR(base, value) (PIT_WR_MCR(base, PIT_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_MCR bitfields
 */

/*!
 * @name Register PIT_MCR, field FRZ[0] (RW)
 *
 * Allows the timers to be stopped when the device enters the Debug mode.
 *
 * Values:
 * - 0 - Timers continue to run in Debug mode.
 * - 1 - Timers are stopped in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_FRZ field. */
#define PIT_RD_MCR_FRZ(base) ((PIT_MCR_REG(base) & PIT_MCR_FRZ_MASK) >> PIT_MCR_FRZ_SHIFT)
#define PIT_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define PIT_WR_MCR_FRZ(base, value) (PIT_RMW_MCR(base, PIT_MCR_FRZ_MASK, PIT_MCR_FRZ(value)))
#define PIT_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PIT_MCR, field MDIS[1] (RW)
 *
 * Disables the standard timers. This field must be enabled before any other
 * setup is done.
 *
 * Values:
 * - 0 - Clock for standard PIT timers is enabled.
 * - 1 - Clock for standard PIT timers is disabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_MCR_MDIS field. */
#define PIT_RD_MCR_MDIS(base) ((PIT_MCR_REG(base) & PIT_MCR_MDIS_MASK) >> PIT_MCR_MDIS_SHIFT)
#define PIT_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define PIT_WR_MCR_MDIS(base, value) (PIT_RMW_MCR(base, PIT_MCR_MDIS_MASK, PIT_MCR_MDIS(value)))
#define PIT_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&PIT_MCR_REG(base), PIT_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64H - PIT Upper Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64H - PIT Upper Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64H register
 */
/*@{*/
#define PIT_RD_LTMR64H(base)     (PIT_LTMR64H_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LTMR64L - PIT Lower Lifetime Timer Register
 ******************************************************************************/

/*!
 * @brief PIT_LTMR64L - PIT Lower Lifetime Timer Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * This register is intended for applications that chain timer 0 and timer 1 to
 * build a 64-bit lifetimer. To use LTMR64H and LTMR64L, timer 0 and timer 1 need
 * to be chained. To obtain the correct value, first read LTMR64H and then
 * LTMR64L. LTMR64H will have the value of CVAL1 at the time of the first access,
 * LTMR64L will have the value of CVAL0 at the time of the first access, therefore
 * the application does not need to worry about carry-over effects of the running
 * counter. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_LTMR64L register
 */
/*@{*/
#define PIT_RD_LTMR64L(base)     (PIT_LTMR64L_REG(base))
/*@}*/

/*******************************************************************************
 * PIT_LDVAL - Timer Load Value Register
 ******************************************************************************/

/*!
 * @brief PIT_LDVAL - Timer Load Value Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers select the timeout period for the timer interrupts. Access:
 * User read/write
 */
/*!
 * @name Constants and macros for entire PIT_LDVAL register
 */
/*@{*/
#define PIT_RD_LDVAL(base, index) (PIT_LDVAL_REG(base, index))
#define PIT_WR_LDVAL(base, index, value) (PIT_LDVAL_REG(base, index) = (value))
#define PIT_RMW_LDVAL(base, index, mask, value) (PIT_WR_LDVAL(base, index, (PIT_RD_LDVAL(base, index) & ~(mask)) | (value)))
#define PIT_SET_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) |  (value)))
#define PIT_CLR_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) & ~(value)))
#define PIT_TOG_LDVAL(base, index, value) (PIT_WR_LDVAL(base, index, PIT_RD_LDVAL(base, index) ^  (value)))
/*@}*/

/*******************************************************************************
 * PIT_CVAL - Current Timer Value Register
 ******************************************************************************/

/*!
 * @brief PIT_CVAL - Current Timer Value Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * These registers indicate the current timer position. Access: User read only
 */
/*!
 * @name Constants and macros for entire PIT_CVAL register
 */
/*@{*/
#define PIT_RD_CVAL(base, index) (PIT_CVAL_REG(base, index))
/*@}*/

/*******************************************************************************
 * PIT_TCTRL - Timer Control Register
 ******************************************************************************/

/*!
 * @brief PIT_TCTRL - Timer Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the control bits for each timer. Access: User
 * read/write
 */
/*!
 * @name Constants and macros for entire PIT_TCTRL register
 */
/*@{*/
#define PIT_RD_TCTRL(base, index) (PIT_TCTRL_REG(base, index))
#define PIT_WR_TCTRL(base, index, value) (PIT_TCTRL_REG(base, index) = (value))
#define PIT_RMW_TCTRL(base, index, mask, value) (PIT_WR_TCTRL(base, index, (PIT_RD_TCTRL(base, index) & ~(mask)) | (value)))
#define PIT_SET_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) |  (value)))
#define PIT_CLR_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) & ~(value)))
#define PIT_TOG_TCTRL(base, index, value) (PIT_WR_TCTRL(base, index, PIT_RD_TCTRL(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TCTRL bitfields
 */

/*!
 * @name Register PIT_TCTRL, field TEN[0] (RW)
 *
 * Enables or disables the timer.
 *
 * Values:
 * - 0 - Timer n is disabled.
 * - 1 - Timer n is enabled.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TEN field. */
#define PIT_RD_TCTRL_TEN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TEN_MASK) >> PIT_TCTRL_TEN_SHIFT)
#define PIT_BRD_TCTRL_TEN(base, index) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT))

/*! @brief Set the TEN field to a new value. */
#define PIT_WR_TCTRL_TEN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TEN_MASK, PIT_TCTRL_TEN(value)))
#define PIT_BWR_TCTRL_TEN(base, index, value) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field TIE[1] (RW)
 *
 * When an interrupt is pending, or, TFLGn[TIF] is set, enabling the interrupt
 * will immediately cause an interrupt event. To avoid this, the associated
 * TFLGn[TIF] must be cleared first.
 *
 * Values:
 * - 0 - Interrupt requests from Timer n are disabled.
 * - 1 - Interrupt will be requested whenever TIF is set.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_TIE field. */
#define PIT_RD_TCTRL_TIE(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_TIE_MASK) >> PIT_TCTRL_TIE_SHIFT)
#define PIT_BRD_TCTRL_TIE(base, index) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define PIT_WR_TCTRL_TIE(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_TIE_MASK, PIT_TCTRL_TIE(value)))
#define PIT_BWR_TCTRL_TIE(base, index, value) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_TIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PIT_TCTRL, field CHN[2] (RW)
 *
 * When activated, Timer n-1 needs to expire before timer n can decrement by 1.
 * Timer 0 cannot be chained.
 *
 * Values:
 * - 0 - Timer is not chained.
 * - 1 - Timer is chained to previous timer. For example, for Channel 2, if this
 *     field is set, Timer 2 is chained to Timer 1.
 */
/*@{*/
/*! @brief Read current value of the PIT_TCTRL_CHN field. */
#define PIT_RD_TCTRL_CHN(base, index) ((PIT_TCTRL_REG(base, index) & PIT_TCTRL_CHN_MASK) >> PIT_TCTRL_CHN_SHIFT)
#define PIT_BRD_TCTRL_CHN(base, index) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_CHN_SHIFT))

/*! @brief Set the CHN field to a new value. */
#define PIT_WR_TCTRL_CHN(base, index, value) (PIT_RMW_TCTRL(base, index, PIT_TCTRL_CHN_MASK, PIT_TCTRL_CHN(value)))
#define PIT_BWR_TCTRL_CHN(base, index, value) (BITBAND_ACCESS32(&PIT_TCTRL_REG(base, index), PIT_TCTRL_CHN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PIT_TFLG - Timer Flag Register
 ******************************************************************************/

/*!
 * @brief PIT_TFLG - Timer Flag Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers hold the PIT interrupt flags. Access: User read/write
 */
/*!
 * @name Constants and macros for entire PIT_TFLG register
 */
/*@{*/
#define PIT_RD_TFLG(base, index) (PIT_TFLG_REG(base, index))
#define PIT_WR_TFLG(base, index, value) (PIT_TFLG_REG(base, index) = (value))
#define PIT_RMW_TFLG(base, index, mask, value) (PIT_WR_TFLG(base, index, (PIT_RD_TFLG(base, index) & ~(mask)) | (value)))
#define PIT_SET_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) |  (value)))
#define PIT_CLR_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) & ~(value)))
#define PIT_TOG_TFLG(base, index, value) (PIT_WR_TFLG(base, index, PIT_RD_TFLG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PIT_TFLG bitfields
 */

/*!
 * @name Register PIT_TFLG, field TIF[0] (W1C)
 *
 * Sets to 1 at the end of the timer period. Writing 1 to this flag clears it.
 * Writing 0 has no effect. If enabled, or, when TCTRLn[TIE] = 1, TIF causes an
 * interrupt request.
 *
 * Values:
 * - 0 - Timeout has not yet occurred.
 * - 1 - Timeout has occurred.
 */
/*@{*/
/*! @brief Read current value of the PIT_TFLG_TIF field. */
#define PIT_RD_TFLG_TIF(base, index) ((PIT_TFLG_REG(base, index) & PIT_TFLG_TIF_MASK) >> PIT_TFLG_TIF_SHIFT)
#define PIT_BRD_TFLG_TIF(base, index) (BITBAND_ACCESS32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT))

/*! @brief Set the TIF field to a new value. */
#define PIT_WR_TFLG_TIF(base, index, value) (PIT_RMW_TFLG(base, index, PIT_TFLG_TIF_MASK, PIT_TFLG_TIF(value)))
#define PIT_BWR_TFLG_TIF(base, index, value) (BITBAND_ACCESS32(&PIT_TFLG_REG(base, index), PIT_TFLG_TIF_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 PMC
 *
 * Power Management Controller
 *
 * Registers defined in this header file:
 * - PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 * - PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 * - PMC_REGSC - Regulator Status And Control register
 * - PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 */

#define PMC_INSTANCE_COUNT (1U) /*!< Number of instances of the PMC module. */
#define PMC_IDX (0U) /*!< Instance number for PMC. */

/*******************************************************************************
 * PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC1 - Low Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x10U
 *
 * This register contains status and control bits to support the low voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the LVD system is disabled regardless of LVDSC1 settings. To protect
 * systems that must have LVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power or
 * low leakage modes from being enabled. See the device's data sheet for the
 * exact LVD trip voltages. The LVDV bits are reset solely on a POR Only event. The
 * register's other bits are reset on Chip Reset Not VLLS. For more information
 * about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC1 register
 */
/*@{*/
#define PMC_RD_LVDSC1(base)      (PMC_LVDSC1_REG(base))
#define PMC_WR_LVDSC1(base, value) (PMC_LVDSC1_REG(base) = (value))
#define PMC_RMW_LVDSC1(base, mask, value) (PMC_WR_LVDSC1(base, (PMC_RD_LVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) |  (value)))
#define PMC_CLR_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) & ~(value)))
#define PMC_TOG_LVDSC1(base, value) (PMC_WR_LVDSC1(base, PMC_RD_LVDSC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC1 bitfields
 */

/*!
 * @name Register PMC_LVDSC1, field LVDV[1:0] (RW)
 *
 * Selects the LVD trip point voltage (V LVD ).
 *
 * Values:
 * - 00 - Low trip point selected (V LVD = V LVDL )
 * - 01 - High trip point selected (V LVD = V LVDH )
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDV field. */
#define PMC_RD_LVDSC1_LVDV(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDV_MASK) >> PMC_LVDSC1_LVDV_SHIFT)
#define PMC_BRD_LVDSC1_LVDV(base) (PMC_RD_LVDSC1_LVDV(base))

/*! @brief Set the LVDV field to a new value. */
#define PMC_WR_LVDSC1_LVDV(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDV_MASK, PMC_LVDSC1_LVDV(value)))
#define PMC_BWR_LVDSC1_LVDV(base, value) (PMC_WR_LVDSC1_LVDV(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDRE[4] (RW)
 *
 * This write-once bit enables LVDF events to generate a hardware reset.
 * Additional writes are ignored.
 *
 * Values:
 * - 0 - LVDF does not generate hardware resets
 * - 1 - Force an MCU reset when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDRE field. */
#define PMC_RD_LVDSC1_LVDRE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDRE_MASK) >> PMC_LVDSC1_LVDRE_SHIFT)
#define PMC_BRD_LVDSC1_LVDRE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT))

/*! @brief Set the LVDRE field to a new value. */
#define PMC_WR_LVDSC1_LVDRE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDRE_MASK, PMC_LVDSC1_LVDRE(value)))
#define PMC_BWR_LVDSC1_LVDRE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDIE field. */
#define PMC_RD_LVDSC1_LVDIE(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDIE_MASK) >> PMC_LVDSC1_LVDIE_SHIFT)
#define PMC_BRD_LVDSC1_LVDIE(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT))

/*! @brief Set the LVDIE field to a new value. */
#define PMC_WR_LVDSC1_LVDIE(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDIE_MASK, PMC_LVDSC1_LVDIE(value)))
#define PMC_BWR_LVDSC1_LVDIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage detection errors.
 * Write 1 to clear LVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVDACK field to a new value. */
#define PMC_WR_LVDSC1_LVDACK(base, value) (PMC_RMW_LVDSC1(base, PMC_LVDSC1_LVDACK_MASK, PMC_LVDSC1_LVDACK(value)))
#define PMC_BWR_LVDSC1_LVDACK(base, value) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC1, field LVDF[7] (RO)
 *
 * This read-only status field indicates a low-voltage detect event.
 *
 * Values:
 * - 0 - Low-voltage event not detected
 * - 1 - Low-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC1_LVDF field. */
#define PMC_RD_LVDSC1_LVDF(base) ((PMC_LVDSC1_REG(base) & PMC_LVDSC1_LVDF_MASK) >> PMC_LVDSC1_LVDF_SHIFT)
#define PMC_BRD_LVDSC1_LVDF(base) (BITBAND_ACCESS8(&PMC_LVDSC1_REG(base), PMC_LVDSC1_LVDF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register
 ******************************************************************************/

/*!
 * @brief PMC_LVDSC2 - Low Voltage Detect Status And Control 2 register (RW)
 *
 * Reset value: 0x00U
 *
 * This register contains status and control bits to support the low voltage
 * warning function. While the device is in the very low power or low leakage modes,
 * the LVD system is disabled regardless of LVDSC2 settings. See the device's
 * data sheet for the exact LVD trip voltages. The LVW trip voltages depend on LVWV
 * and LVDV. LVWV is reset solely on a POR Only event. The other fields of the
 * register are reset on Chip Reset Not VLLS. For more information about these
 * reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_LVDSC2 register
 */
/*@{*/
#define PMC_RD_LVDSC2(base)      (PMC_LVDSC2_REG(base))
#define PMC_WR_LVDSC2(base, value) (PMC_LVDSC2_REG(base) = (value))
#define PMC_RMW_LVDSC2(base, mask, value) (PMC_WR_LVDSC2(base, (PMC_RD_LVDSC2(base) & ~(mask)) | (value)))
#define PMC_SET_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) |  (value)))
#define PMC_CLR_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) & ~(value)))
#define PMC_TOG_LVDSC2(base, value) (PMC_WR_LVDSC2(base, PMC_RD_LVDSC2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_LVDSC2 bitfields
 */

/*!
 * @name Register PMC_LVDSC2, field LVWV[1:0] (RW)
 *
 * Selects the LVW trip point voltage (VLVW). The actual voltage for the warning
 * depends on LVDSC1[LVDV].
 *
 * Values:
 * - 00 - Low trip point selected (VLVW = VLVW1)
 * - 01 - Mid 1 trip point selected (VLVW = VLVW2)
 * - 10 - Mid 2 trip point selected (VLVW = VLVW3)
 * - 11 - High trip point selected (VLVW = VLVW4)
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWV field. */
#define PMC_RD_LVDSC2_LVWV(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWV_MASK) >> PMC_LVDSC2_LVWV_SHIFT)
#define PMC_BRD_LVDSC2_LVWV(base) (PMC_RD_LVDSC2_LVWV(base))

/*! @brief Set the LVWV field to a new value. */
#define PMC_WR_LVDSC2_LVWV(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWV_MASK, PMC_LVDSC2_LVWV(value)))
#define PMC_BWR_LVDSC2_LVWV(base, value) (PMC_WR_LVDSC2_LVWV(base, value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWIE[5] (RW)
 *
 * Enables hardware interrupt requests for LVWF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when LVWF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWIE field. */
#define PMC_RD_LVDSC2_LVWIE(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWIE_MASK) >> PMC_LVDSC2_LVWIE_SHIFT)
#define PMC_BRD_LVDSC2_LVWIE(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT))

/*! @brief Set the LVWIE field to a new value. */
#define PMC_WR_LVDSC2_LVWIE(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWIE_MASK, PMC_LVDSC2_LVWIE(value)))
#define PMC_BWR_LVDSC2_LVWIE(base, value) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge low voltage warning errors.
 * Write 1 to clear LVWF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the LVWACK field to a new value. */
#define PMC_WR_LVDSC2_LVWACK(base, value) (PMC_RMW_LVDSC2(base, PMC_LVDSC2_LVWACK_MASK, PMC_LVDSC2_LVWACK(value)))
#define PMC_BWR_LVDSC2_LVWACK(base, value) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_LVDSC2, field LVWF[7] (RO)
 *
 * This read-only status field indicates a low-voltage warning event. LVWF is
 * set when VSupply transitions below the trip point, or after reset and VSupply is
 * already below VLVW. LVWF may be 1 after power-on reset, therefore, to use LVW
 * interrupt function, before enabling LVWIE, LVWF must be cleared by writing
 * LVWACK first.
 *
 * Values:
 * - 0 - Low-voltage warning event not detected
 * - 1 - Low-voltage warning event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_LVDSC2_LVWF field. */
#define PMC_RD_LVDSC2_LVWF(base) ((PMC_LVDSC2_REG(base) & PMC_LVDSC2_LVWF_MASK) >> PMC_LVDSC2_LVWF_SHIFT)
#define PMC_BRD_LVDSC2_LVWF(base) (BITBAND_ACCESS8(&PMC_LVDSC2_REG(base), PMC_LVDSC2_LVWF_SHIFT))
/*@}*/

/*******************************************************************************
 * PMC_REGSC - Regulator Status And Control register
 ******************************************************************************/

/*!
 * @brief PMC_REGSC - Regulator Status And Control register (RW)
 *
 * Reset value: 0x04U
 *
 * The PMC contains an internal voltage regulator. The voltage regulator design
 * uses a bandgap reference that is also available through a buffer as input to
 * certain internal peripherals, such as the CMP and ADC. The internal regulator
 * provides a status bit (REGONS) indicating the regulator is in run regulation.
 * This register is reset on Chip Reset Not VLLS and by reset types that trigger
 * Chip Reset not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire PMC_REGSC register
 */
/*@{*/
#define PMC_RD_REGSC(base)       (PMC_REGSC_REG(base))
#define PMC_WR_REGSC(base, value) (PMC_REGSC_REG(base) = (value))
#define PMC_RMW_REGSC(base, mask, value) (PMC_WR_REGSC(base, (PMC_RD_REGSC(base) & ~(mask)) | (value)))
#define PMC_SET_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) |  (value)))
#define PMC_CLR_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) & ~(value)))
#define PMC_TOG_REGSC(base, value) (PMC_WR_REGSC(base, PMC_RD_REGSC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_REGSC bitfields
 */

/*!
 * @name Register PMC_REGSC, field BGBE[0] (RW)
 *
 * Enables the bandgap buffer.
 *
 * Values:
 * - 0 - Bandgap buffer not enabled
 * - 1 - Bandgap buffer enabled
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGBE field. */
#define PMC_RD_REGSC_BGBE(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGBE_MASK) >> PMC_REGSC_BGBE_SHIFT)
#define PMC_BRD_REGSC_BGBE(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT))

/*! @brief Set the BGBE field to a new value. */
#define PMC_WR_REGSC_BGBE(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGBE_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGBE(value)))
#define PMC_BWR_REGSC_BGBE(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGBE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_REGSC, field REGONS[2] (RO)
 *
 * This read-only field provides the current status of the internal voltage
 * regulator.
 *
 * Values:
 * - 0 - Regulator is in stop regulation or in transition to/from it
 * - 1 - Regulator is in run regulation
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_REGONS field. */
#define PMC_RD_REGSC_REGONS(base) ((PMC_REGSC_REG(base) & PMC_REGSC_REGONS_MASK) >> PMC_REGSC_REGONS_SHIFT)
#define PMC_BRD_REGSC_REGONS(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_REGONS_SHIFT))
/*@}*/

/*!
 * @name Register PMC_REGSC, field ACKISO[3] (W1C)
 *
 * Reading this field indicates whether certain peripherals and the I/O pads are
 * in a latched state as a result of having been in a VLLS mode. Writing 1 to
 * this field when it is set releases the I/O pads and certain peripherals to their
 * normal run mode state. After recovering from a VLLS mode, user should restore
 * chip configuration before clearing ACKISO. In particular, pin configuration
 * for enabled LLWU wakeup pins should be restored to avoid any LLWU flag from
 * being falsely set when ACKISO is cleared.
 *
 * Values:
 * - 0 - Peripherals and I/O pads are in normal run state.
 * - 1 - Certain peripherals and I/O pads are in an isolated and latched state.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_ACKISO field. */
#define PMC_RD_REGSC_ACKISO(base) ((PMC_REGSC_REG(base) & PMC_REGSC_ACKISO_MASK) >> PMC_REGSC_ACKISO_SHIFT)
#define PMC_BRD_REGSC_ACKISO(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT))

/*! @brief Set the ACKISO field to a new value. */
#define PMC_WR_REGSC_ACKISO(base, value) (PMC_RMW_REGSC(base, PMC_REGSC_ACKISO_MASK, PMC_REGSC_ACKISO(value)))
#define PMC_BWR_REGSC_ACKISO(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_ACKISO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_REGSC, field BGEN[4] (RW)
 *
 * BGEN controls whether the bandgap is enabled in lower power modes of
 * operation (VLPx, LLS, and VLLSx). When on-chip peripherals require the bandgap voltage
 * reference in low power modes of operation, set BGEN to continue to enable the
 * bandgap operation. When the bandgap voltage reference is not needed in low
 * power modes, clear BGEN to avoid excess power consumption.
 *
 * Values:
 * - 0 - Bandgap voltage reference is disabled in VLPx , LLS , and VLLSx modes.
 * - 1 - Bandgap voltage reference is enabled in VLPx , LLS , and VLLSx modes.
 */
/*@{*/
/*! @brief Read current value of the PMC_REGSC_BGEN field. */
#define PMC_RD_REGSC_BGEN(base) ((PMC_REGSC_REG(base) & PMC_REGSC_BGEN_MASK) >> PMC_REGSC_BGEN_SHIFT)
#define PMC_BRD_REGSC_BGEN(base) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT))

/*! @brief Set the BGEN field to a new value. */
#define PMC_WR_REGSC_BGEN(base, value) (PMC_RMW_REGSC(base, (PMC_REGSC_BGEN_MASK | PMC_REGSC_ACKISO_MASK), PMC_REGSC_BGEN(value)))
#define PMC_BWR_REGSC_BGEN(base, value) (BITBAND_ACCESS8(&PMC_REGSC_REG(base), PMC_REGSC_BGEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PMC_HVDSC1 - High Voltage Detect Status And Control 1 register
 ******************************************************************************/

/*!
 * @brief PMC_HVDSC1 - High Voltage Detect Status And Control 1 register (RW)
 *
 * Reset value: 0x01U
 *
 * This register contains status and control bits to support the high voltage
 * detect function. This register should be written during the reset initialization
 * program to set the desired controls even if the desired settings are the same
 * as the reset settings. While the device is in the very low power or low
 * leakage modes, the HVD system is disabled regardless of HVDSC1 settings. To protect
 * systems that must have HVD always on, configure the Power Mode Protection
 * (PMPROT) register of the SMC module (SMC_PMPROT) to disallow any very low power
 * or low leakage modes from being enabled. See the device's data sheet for the
 * exact HVD trip voltages. This register is reset solely on a POR Only event.For
 * more information about these reset types, refer to the Reset section details.
 */
/*!
 * @name Constants and macros for entire PMC_HVDSC1 register
 */
/*@{*/
#define PMC_RD_HVDSC1(base)      (PMC_HVDSC1_REG(base))
#define PMC_WR_HVDSC1(base, value) (PMC_HVDSC1_REG(base) = (value))
#define PMC_RMW_HVDSC1(base, mask, value) (PMC_WR_HVDSC1(base, (PMC_RD_HVDSC1(base) & ~(mask)) | (value)))
#define PMC_SET_HVDSC1(base, value) (PMC_WR_HVDSC1(base, PMC_RD_HVDSC1(base) |  (value)))
#define PMC_CLR_HVDSC1(base, value) (PMC_WR_HVDSC1(base, PMC_RD_HVDSC1(base) & ~(value)))
#define PMC_TOG_HVDSC1(base, value) (PMC_WR_HVDSC1(base, PMC_RD_HVDSC1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PMC_HVDSC1 bitfields
 */

/*!
 * @name Register PMC_HVDSC1, field HVDV[0] (RW)
 *
 * Selects the HVD trip point voltage (V HVD ).
 *
 * Values:
 * - 0 - Low trip point selected (V HVD = V HVDL )
 * - 1 - High trip point selected (V HVD = V HVDH )
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDV field. */
#define PMC_RD_HVDSC1_HVDV(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDV_MASK) >> PMC_HVDSC1_HVDV_SHIFT)
#define PMC_BRD_HVDSC1_HVDV(base) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDV_SHIFT))

/*! @brief Set the HVDV field to a new value. */
#define PMC_WR_HVDSC1_HVDV(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDV_MASK, PMC_HVDSC1_HVDV(value)))
#define PMC_BWR_HVDSC1_HVDV(base, value) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDRE[4] (RW)
 *
 * This write-once bit enables HVDF events to generate a hardware reset.
 * Additional writes are ignored until the next chip reset.
 *
 * Values:
 * - 0 - HVDF does not generate hardware resets
 * - 1 - Force an MCU reset when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDRE field. */
#define PMC_RD_HVDSC1_HVDRE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDRE_MASK) >> PMC_HVDSC1_HVDRE_SHIFT)
#define PMC_BRD_HVDSC1_HVDRE(base) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDRE_SHIFT))

/*! @brief Set the HVDRE field to a new value. */
#define PMC_WR_HVDSC1_HVDRE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDRE_MASK, PMC_HVDSC1_HVDRE(value)))
#define PMC_BWR_HVDSC1_HVDRE(base, value) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDIE[5] (RW)
 *
 * Enables hardware interrupt requests for HVDF.
 *
 * Values:
 * - 0 - Hardware interrupt disabled (use polling)
 * - 1 - Request a hardware interrupt when HVDF = 1
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDIE field. */
#define PMC_RD_HVDSC1_HVDIE(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDIE_MASK) >> PMC_HVDSC1_HVDIE_SHIFT)
#define PMC_BRD_HVDSC1_HVDIE(base) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDIE_SHIFT))

/*! @brief Set the HVDIE field to a new value. */
#define PMC_WR_HVDSC1_HVDIE(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDIE_MASK, PMC_HVDSC1_HVDIE(value)))
#define PMC_BWR_HVDSC1_HVDIE(base, value) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDACK[6] (WORZ)
 *
 * This write-only field is used to acknowledge high voltage detection errors.
 * Write 1 to clear HVDF. Reads always return 0.
 */
/*@{*/
/*! @brief Set the HVDACK field to a new value. */
#define PMC_WR_HVDSC1_HVDACK(base, value) (PMC_RMW_HVDSC1(base, PMC_HVDSC1_HVDACK_MASK, PMC_HVDSC1_HVDACK(value)))
#define PMC_BWR_HVDSC1_HVDACK(base, value) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PMC_HVDSC1, field HVDF[7] (RO)
 *
 * This read-only status field indicates a high-voltage detect event.
 *
 * Values:
 * - 0 - High-voltage event not detected
 * - 1 - High-voltage event detected
 */
/*@{*/
/*! @brief Read current value of the PMC_HVDSC1_HVDF field. */
#define PMC_RD_HVDSC1_HVDF(base) ((PMC_HVDSC1_REG(base) & PMC_HVDSC1_HVDF_MASK) >> PMC_HVDSC1_HVDF_SHIFT)
#define PMC_BRD_HVDSC1_HVDF(base) (BITBAND_ACCESS8(&PMC_HVDSC1_REG(base), PMC_HVDSC1_HVDF_SHIFT))
/*@}*/

/*
 * MKS22F25612 PORT
 *
 * Pin Control and Interrupts
 *
 * Registers defined in this header file:
 * - PORT_PCR - Pin Control Register n
 * - PORT_GPCLR - Global Pin Control Low Register
 * - PORT_GPCHR - Global Pin Control High Register
 * - PORT_GICLR - Global Interrupt Control Low Register
 * - PORT_GICHR - Global Interrupt Control High Register
 * - PORT_ISFR - Interrupt Status Flag Register
 * - PORT_DFER - Digital Filter Enable Register
 * - PORT_DFCR - Digital Filter Clock Register
 * - PORT_DFWR - Digital Filter Width Register
 */

#define PORT_INSTANCE_COUNT (5U) /*!< Number of instances of the PORT module. */
#define PORTA_IDX (0U) /*!< Instance number for PORTA. */
#define PORTB_IDX (1U) /*!< Instance number for PORTB. */
#define PORTC_IDX (2U) /*!< Instance number for PORTC. */
#define PORTD_IDX (3U) /*!< Instance number for PORTD. */
#define PORTE_IDX (4U) /*!< Instance number for PORTE. */

/*******************************************************************************
 * PORT_PCR - Pin Control Register n
 ******************************************************************************/

/*!
 * @brief PORT_PCR - Pin Control Register n (RW)
 *
 * Reset value: 0x00000000U
 *
 * See the Signal Multiplexing and Pin Assignment chapter for the reset value of
 * this device. See the GPIO Configuration section for details on the available
 * functions for each pin. Do not modify pin configuration registers associated
 * with pins not available in your selected package. All unbonded pins not
 * available in your package will default to DISABLE state for lowest power consumption.
 */
/*!
 * @name Constants and macros for entire PORT_PCR register
 */
/*@{*/
#define PORT_RD_PCR(base, index) (PORT_PCR_REG(base, index))
#define PORT_WR_PCR(base, index, value) (PORT_PCR_REG(base, index) = (value))
#define PORT_RMW_PCR(base, index, mask, value) (PORT_WR_PCR(base, index, (PORT_RD_PCR(base, index) & ~(mask)) | (value)))
#define PORT_SET_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) |  (value)))
#define PORT_CLR_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) & ~(value)))
#define PORT_TOG_PCR(base, index, value) (PORT_WR_PCR(base, index, PORT_RD_PCR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_PCR bitfields
 */

/*!
 * @name Register PORT_PCR, field PS[0] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pulldown resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 * - 1 - Internal pullup resistor is enabled on the corresponding pin, if the
 *     corresponding PE field is set.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PS field. */
#define PORT_RD_PCR_PS(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PS_MASK) >> PORT_PCR_PS_SHIFT)
#define PORT_BRD_PCR_PS(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT))

/*! @brief Set the PS field to a new value. */
#define PORT_WR_PCR_PS(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PS_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PS(value)))
#define PORT_BWR_PCR_PS(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PE[1] (RW)
 *
 * Pull configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Internal pullup or pulldown resistor is not enabled on the
 *     corresponding pin.
 * - 1 - Internal pullup or pulldown resistor is enabled on the corresponding
 *     pin, if the pin is configured as a digital input.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PE field. */
#define PORT_RD_PCR_PE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PE_MASK) >> PORT_PCR_PE_SHIFT)
#define PORT_BRD_PCR_PE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define PORT_WR_PCR_PE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PE(value)))
#define PORT_BWR_PCR_PE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field SRE[2] (RW)
 *
 * Slew rate configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Fast slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 * - 1 - Slow slew rate is configured on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_SRE field. */
#define PORT_RD_PCR_SRE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_SRE_MASK) >> PORT_PCR_SRE_SHIFT)
#define PORT_BRD_PCR_SRE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT))

/*! @brief Set the SRE field to a new value. */
#define PORT_WR_PCR_SRE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_SRE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_SRE(value)))
#define PORT_BWR_PCR_SRE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_SRE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field PFE[4] (RW)
 *
 * Passive filter configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Passive input filter is disabled on the corresponding pin.
 * - 1 - Passive input filter is enabled on the corresponding pin, if the pin is
 *     configured as a digital input. Refer to the device data sheet for filter
 *     characteristics.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_PFE field. */
#define PORT_RD_PCR_PFE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_PFE_MASK) >> PORT_PCR_PFE_SHIFT)
#define PORT_BRD_PCR_PFE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT))

/*! @brief Set the PFE field to a new value. */
#define PORT_WR_PCR_PFE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_PFE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_PFE(value)))
#define PORT_BWR_PCR_PFE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_PFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ODE[5] (RW)
 *
 * Open drain configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Open drain output is disabled on the corresponding pin.
 * - 1 - Open drain output is enabled on the corresponding pin, if the pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ODE field. */
#define PORT_RD_PCR_ODE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ODE_MASK) >> PORT_PCR_ODE_SHIFT)
#define PORT_BRD_PCR_ODE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT))

/*! @brief Set the ODE field to a new value. */
#define PORT_WR_PCR_ODE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_ODE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_ODE(value)))
#define PORT_BWR_PCR_ODE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ODE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field DSE[6] (RW)
 *
 * Drive strength configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Low drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 * - 1 - High drive strength is configured on the corresponding pin, if pin is
 *     configured as a digital output.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_DSE field. */
#define PORT_RD_PCR_DSE(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_DSE_MASK) >> PORT_PCR_DSE_SHIFT)
#define PORT_BRD_PCR_DSE(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT))

/*! @brief Set the DSE field to a new value. */
#define PORT_WR_PCR_DSE(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_DSE_MASK | PORT_PCR_ISF_MASK), PORT_PCR_DSE(value)))
#define PORT_BWR_PCR_DSE(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_DSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field MUX[11:8] (RW)
 *
 * Not all pins support all pin muxing slots. Unimplemented pin muxing slots are
 * reserved and may result in configuring the pin for a different pin muxing
 * slot. The corresponding pin is configured in the following pin muxing slot as
 * follows:
 *
 * Values:
 * - 000 - Pin disabled (Alternative 0) (analog).
 * - 001 - Alternative 1 (GPIO).
 * - 010 - Alternative 2 (chip-specific).
 * - 011 - Alternative 3 (chip-specific).
 * - 100 - Alternative 4 (chip-specific).
 * - 101 - Alternative 5 (chip-specific).
 * - 110 - Alternative 6 (chip-specific).
 * - 111 - Alternative 7 (chip-specific).
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_MUX field. */
#define PORT_RD_PCR_MUX(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_MUX_MASK) >> PORT_PCR_MUX_SHIFT)
#define PORT_BRD_PCR_MUX(base, index) (PORT_RD_PCR_MUX(base, index))

/*! @brief Set the MUX field to a new value. */
#define PORT_WR_PCR_MUX(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_MUX_MASK | PORT_PCR_ISF_MASK), PORT_PCR_MUX(value)))
#define PORT_BWR_PCR_MUX(base, index, value) (PORT_WR_PCR_MUX(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field LK[15] (RW)
 *
 * Values:
 * - 0 - Pin Control Register fields [15:0] are not locked.
 * - 1 - Pin Control Register fields [15:0] are locked and cannot be updated
 *     until the next system reset.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_LK field. */
#define PORT_RD_PCR_LK(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_LK_MASK) >> PORT_PCR_LK_SHIFT)
#define PORT_BRD_PCR_LK(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT))

/*! @brief Set the LK field to a new value. */
#define PORT_WR_PCR_LK(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_LK_MASK | PORT_PCR_ISF_MASK), PORT_PCR_LK(value)))
#define PORT_BWR_PCR_LK(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_LK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register PORT_PCR, field IRQC[19:16] (RW)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * corresponding pin is configured to generate interrupt/DMA request as follows:
 *
 * Values:
 * - 0000 - Interrupt Status Flag (ISF) is disabled.
 * - 0001 - ISF flag and DMA request on rising edge.
 * - 0010 - ISF flag and DMA request on falling edge.
 * - 0011 - ISF flag and DMA request on either edge.
 * - 0100 - Reserved.
 * - 0101 - Flag sets on rising edge.
 * - 0110 - Flag sets on falling edge.
 * - 0111 - Flag sets on either edge.
 * - 1000 - ISF flag and Interrupt when logic 0.
 * - 1001 - ISF flag and Interrupt on rising-edge.
 * - 1010 - ISF flag and Interrupt on falling-edge.
 * - 1011 - ISF flag and Interrupt on either edge.
 * - 1100 - ISF flag and Interrupt when logic 1.
 * - 1101 - Enable active high trigger output, flag is disabled. [The trigger
 *     output goes to the trigger mux, which allows pins to trigger other
 *     peripherals (configurable polarity; 1 pin per port; if multiple pins are
 *     configured, then they are ORed together to create the trigger)]
 * - 1110 - Enable active low trigger output, flag is disabled.
 * - 1111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_IRQC field. */
#define PORT_RD_PCR_IRQC(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_IRQC_MASK) >> PORT_PCR_IRQC_SHIFT)
#define PORT_BRD_PCR_IRQC(base, index) (PORT_RD_PCR_IRQC(base, index))

/*! @brief Set the IRQC field to a new value. */
#define PORT_WR_PCR_IRQC(base, index, value) (PORT_RMW_PCR(base, index, (PORT_PCR_IRQC_MASK | PORT_PCR_ISF_MASK), PORT_PCR_IRQC(value)))
#define PORT_BWR_PCR_IRQC(base, index, value) (PORT_WR_PCR_IRQC(base, index, value))
/*@}*/

/*!
 * @name Register PORT_PCR, field ISF[24] (W1C)
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes.
 *
 * Values:
 * - 0 - Configured interrupt is not detected.
 * - 1 - Configured interrupt is detected. If the pin is configured to generate
 *     a DMA request, then the corresponding flag will be cleared automatically
 *     at the completion of the requested DMA transfer. Otherwise, the flag
 *     remains set until a logic 1 is written to the flag. If the pin is configured for
 *     a level sensitive interrupt and the pin remains asserted, then the flag
 *     is set again immediately after it is cleared.
 */
/*@{*/
/*! @brief Read current value of the PORT_PCR_ISF field. */
#define PORT_RD_PCR_ISF(base, index) ((PORT_PCR_REG(base, index) & PORT_PCR_ISF_MASK) >> PORT_PCR_ISF_SHIFT)
#define PORT_BRD_PCR_ISF(base, index) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT))

/*! @brief Set the ISF field to a new value. */
#define PORT_WR_PCR_ISF(base, index, value) (PORT_RMW_PCR(base, index, PORT_PCR_ISF_MASK, PORT_PCR_ISF(value)))
#define PORT_BWR_PCR_ISF(base, index, value) (BITBAND_ACCESS32(&PORT_PCR_REG(base, index), PORT_PCR_ISF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_GPCLR - Global Pin Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCLR - Global Pin Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCLR register
 */
/*@{*/
#define PORT_RD_GPCLR(base)      (PORT_GPCLR_REG(base))
#define PORT_WR_GPCLR(base, value) (PORT_GPCLR_REG(base) = (value))
#define PORT_RMW_GPCLR(base, mask, value) (PORT_WR_GPCLR(base, (PORT_RD_GPCLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCLR bitfields
 */

/*!
 * @name Register PORT_GPCLR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCLR_GPWD(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWD_MASK, PORT_GPCLR_GPWD(value)))
#define PORT_BWR_GPCLR_GPWD(base, value) (PORT_WR_GPCLR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCLR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCLR_GPWE(base, value) (PORT_RMW_GPCLR(base, PORT_GPCLR_GPWE_MASK, PORT_GPCLR_GPWE(value)))
#define PORT_BWR_GPCLR_GPWE(base, value) (PORT_WR_GPCLR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GPCHR - Global Pin Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GPCHR - Global Pin Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GPCHR register
 */
/*@{*/
#define PORT_RD_GPCHR(base)      (PORT_GPCHR_REG(base))
#define PORT_WR_GPCHR(base, value) (PORT_GPCHR_REG(base) = (value))
#define PORT_RMW_GPCHR(base, mask, value) (PORT_WR_GPCHR(base, (PORT_RD_GPCHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GPCHR bitfields
 */

/*!
 * @name Register PORT_GPCHR, field GPWD[15:0] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [15:0] that are
 * selected by GPWE.
 */
/*@{*/
/*! @brief Set the GPWD field to a new value. */
#define PORT_WR_GPCHR_GPWD(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWD_MASK, PORT_GPCHR_GPWD(value)))
#define PORT_BWR_GPCHR_GPWD(base, value) (PORT_WR_GPCHR_GPWD(base, value))
/*@}*/

/*!
 * @name Register PORT_GPCHR, field GPWE[31:16] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [15:0] update with
 * the value in GPWD. If a selected Pin Control Register is locked then the write
 * to that register is ignored.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GPWE field to a new value. */
#define PORT_WR_GPCHR_GPWE(base, value) (PORT_RMW_GPCHR(base, PORT_GPCHR_GPWE_MASK, PORT_GPCHR_GPWE(value)))
#define PORT_BWR_GPCHR_GPWE(base, value) (PORT_WR_GPCHR_GPWE(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GICLR - Global Interrupt Control Low Register
 ******************************************************************************/

/*!
 * @brief PORT_GICLR - Global Interrupt Control Low Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GICLR register
 */
/*@{*/
#define PORT_RD_GICLR(base)      (PORT_GICLR_REG(base))
#define PORT_WR_GICLR(base, value) (PORT_GICLR_REG(base) = (value))
#define PORT_RMW_GICLR(base, mask, value) (PORT_WR_GICLR(base, (PORT_RD_GICLR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GICLR bitfields
 */

/*!
 * @name Register PORT_GICLR, field GIWE[15:0] (WORZ)
 *
 * Selects which Pin Control Registers (15 through 0) bits [31:16] update with
 * the value in GIWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GIWE field to a new value. */
#define PORT_WR_GICLR_GIWE(base, value) (PORT_RMW_GICLR(base, PORT_GICLR_GIWE_MASK, PORT_GICLR_GIWE(value)))
#define PORT_BWR_GICLR_GIWE(base, value) (PORT_WR_GICLR_GIWE(base, value))
/*@}*/

/*!
 * @name Register PORT_GICLR, field GIWD[31:16] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [31:16] that
 * are selected by GIWE.
 */
/*@{*/
/*! @brief Set the GIWD field to a new value. */
#define PORT_WR_GICLR_GIWD(base, value) (PORT_RMW_GICLR(base, PORT_GICLR_GIWD_MASK, PORT_GICLR_GIWD(value)))
#define PORT_BWR_GICLR_GIWD(base, value) (PORT_WR_GICLR_GIWD(base, value))
/*@}*/

/*******************************************************************************
 * PORT_GICHR - Global Interrupt Control High Register
 ******************************************************************************/

/*!
 * @brief PORT_GICHR - Global Interrupt Control High Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Only 32-bit writes are supported to this register.
 */
/*!
 * @name Constants and macros for entire PORT_GICHR register
 */
/*@{*/
#define PORT_RD_GICHR(base)      (PORT_GICHR_REG(base))
#define PORT_WR_GICHR(base, value) (PORT_GICHR_REG(base) = (value))
#define PORT_RMW_GICHR(base, mask, value) (PORT_WR_GICHR(base, (PORT_RD_GICHR(base) & ~(mask)) | (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_GICHR bitfields
 */

/*!
 * @name Register PORT_GICHR, field GIWE[15:0] (WORZ)
 *
 * Selects which Pin Control Registers (31 through 16) bits [31:16] update with
 * the value in GIWD.
 *
 * Values:
 * - 0 - Corresponding Pin Control Register is not updated with the value in
 *     GPWD.
 * - 1 - Corresponding Pin Control Register is updated with the value in GPWD.
 */
/*@{*/
/*! @brief Set the GIWE field to a new value. */
#define PORT_WR_GICHR_GIWE(base, value) (PORT_RMW_GICHR(base, PORT_GICHR_GIWE_MASK, PORT_GICHR_GIWE(value)))
#define PORT_BWR_GICHR_GIWE(base, value) (PORT_WR_GICHR_GIWE(base, value))
/*@}*/

/*!
 * @name Register PORT_GICHR, field GIWD[31:16] (WORZ)
 *
 * Write value that is written to all Pin Control Registers bits [31:16] that
 * are selected by GIWE.
 */
/*@{*/
/*! @brief Set the GIWD field to a new value. */
#define PORT_WR_GICHR_GIWD(base, value) (PORT_RMW_GICHR(base, PORT_GICHR_GIWD_MASK, PORT_GICHR_GIWD(value)))
#define PORT_BWR_GICHR_GIWD(base, value) (PORT_WR_GICHR_GIWD(base, value))
/*@}*/

/*******************************************************************************
 * PORT_ISFR - Interrupt Status Flag Register
 ******************************************************************************/

/*!
 * @brief PORT_ISFR - Interrupt Status Flag Register (W1C)
 *
 * Reset value: 0x00000000U
 *
 * The pin interrupt configuration is valid in all digital pin muxing modes. The
 * Interrupt Status Flag for each pin is also visible in the corresponding Pin
 * Control Register, and each flag can be cleared in either location.
 */
/*!
 * @name Constants and macros for entire PORT_ISFR register
 */
/*@{*/
#define PORT_RD_ISFR(base)       (PORT_ISFR_REG(base))
#define PORT_WR_ISFR(base, value) (PORT_ISFR_REG(base) = (value))
#define PORT_RMW_ISFR(base, mask, value) (PORT_WR_ISFR(base, (PORT_RD_ISFR(base) & ~(mask)) | (value)))
#define PORT_SET_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) |  (value)))
#define PORT_CLR_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) & ~(value)))
#define PORT_TOG_ISFR(base, value) (PORT_WR_ISFR(base, PORT_RD_ISFR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFER - Digital Filter Enable Register
 ******************************************************************************/

/*!
 * @brief PORT_DFER - Digital Filter Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * The corresponding bit is read only for pins that do not support a digital
 * filter. Refer to the Chapter of Signal Multiplexing and Signal Descriptions for
 * the pins that support digital filter. The digital filter configuration is valid
 * in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFER register
 */
/*@{*/
#define PORT_RD_DFER(base)       (PORT_DFER_REG(base))
#define PORT_WR_DFER(base, value) (PORT_DFER_REG(base) = (value))
#define PORT_RMW_DFER(base, mask, value) (PORT_WR_DFER(base, (PORT_RD_DFER(base) & ~(mask)) | (value)))
#define PORT_SET_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) |  (value)))
#define PORT_CLR_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) & ~(value)))
#define PORT_TOG_DFER(base, value) (PORT_WR_DFER(base, PORT_RD_DFER(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * PORT_DFCR - Digital Filter Clock Register
 ******************************************************************************/

/*!
 * @brief PORT_DFCR - Digital Filter Clock Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFCR register
 */
/*@{*/
#define PORT_RD_DFCR(base)       (PORT_DFCR_REG(base))
#define PORT_WR_DFCR(base, value) (PORT_DFCR_REG(base) = (value))
#define PORT_RMW_DFCR(base, mask, value) (PORT_WR_DFCR(base, (PORT_RD_DFCR(base) & ~(mask)) | (value)))
#define PORT_SET_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) |  (value)))
#define PORT_CLR_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) & ~(value)))
#define PORT_TOG_DFCR(base, value) (PORT_WR_DFCR(base, PORT_RD_DFCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFCR bitfields
 */

/*!
 * @name Register PORT_DFCR, field CS[0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the clock source for the digital input filters. Changing the filter
 * clock source must be done only when all digital filters are disabled.
 *
 * Values:
 * - 0 - Digital filters are clocked by the bus clock.
 * - 1 - Digital filters are clocked by the LPO clock.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFCR_CS field. */
#define PORT_RD_DFCR_CS(base) ((PORT_DFCR_REG(base) & PORT_DFCR_CS_MASK) >> PORT_DFCR_CS_SHIFT)
#define PORT_BRD_DFCR_CS(base) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT))

/*! @brief Set the CS field to a new value. */
#define PORT_WR_DFCR_CS(base, value) (PORT_RMW_DFCR(base, PORT_DFCR_CS_MASK, PORT_DFCR_CS(value)))
#define PORT_BWR_DFCR_CS(base, value) (BITBAND_ACCESS32(&PORT_DFCR_REG(base), PORT_DFCR_CS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * PORT_DFWR - Digital Filter Width Register
 ******************************************************************************/

/*!
 * @brief PORT_DFWR - Digital Filter Width Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register is read only for ports that do not support a digital filter.
 * The digital filter configuration is valid in all digital pin muxing modes.
 */
/*!
 * @name Constants and macros for entire PORT_DFWR register
 */
/*@{*/
#define PORT_RD_DFWR(base)       (PORT_DFWR_REG(base))
#define PORT_WR_DFWR(base, value) (PORT_DFWR_REG(base) = (value))
#define PORT_RMW_DFWR(base, mask, value) (PORT_WR_DFWR(base, (PORT_RD_DFWR(base) & ~(mask)) | (value)))
#define PORT_SET_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) |  (value)))
#define PORT_CLR_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) & ~(value)))
#define PORT_TOG_DFWR(base, value) (PORT_WR_DFWR(base, PORT_RD_DFWR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual PORT_DFWR bitfields
 */

/*!
 * @name Register PORT_DFWR, field FILT[4:0] (RW)
 *
 * The digital filter configuration is valid in all digital pin muxing modes.
 * Configures the maximum size of the glitches, in clock cycles, that the digital
 * filter absorbs for the enabled digital filters. Glitches that are longer than
 * this register setting will pass through the digital filter, and glitches that
 * are equal to or less than this register setting are filtered. Changing the
 * filter length must be done only after all filters are disabled.
 */
/*@{*/
/*! @brief Read current value of the PORT_DFWR_FILT field. */
#define PORT_RD_DFWR_FILT(base) ((PORT_DFWR_REG(base) & PORT_DFWR_FILT_MASK) >> PORT_DFWR_FILT_SHIFT)
#define PORT_BRD_DFWR_FILT(base) (PORT_RD_DFWR_FILT(base))

/*! @brief Set the FILT field to a new value. */
#define PORT_WR_DFWR_FILT(base, value) (PORT_RMW_DFWR(base, PORT_DFWR_FILT_MASK, PORT_DFWR_FILT(value)))
#define PORT_BWR_DFWR_FILT(base, value) (PORT_WR_DFWR_FILT(base, value))
/*@}*/

/*
 * MKS22F25612 RCM
 *
 * Reset Control Module
 *
 * Registers defined in this header file:
 * - RCM_SRS0 - System Reset Status Register 0
 * - RCM_SRS1 - System Reset Status Register 1
 * - RCM_RPFC - Reset Pin Filter Control register
 * - RCM_RPFW - Reset Pin Filter Width register
 * - RCM_SSRS0 - Sticky System Reset Status Register 0
 * - RCM_SSRS1 - Sticky System Reset Status Register 1
 */

#define RCM_INSTANCE_COUNT (1U) /*!< Number of instances of the RCM module. */
#define RCM_IDX (0U) /*!< Instance number for RCM. */

/*******************************************************************************
 * RCM_SRS0 - System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SRS0 - System Reset Status Register 0 (RO)
 *
 * Reset value: 0x82U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x82 LVD (without POR) - 0x02 VLLS mode wakeup due to RESET
 * pin assertion - 0x41 VLLS mode wakeup due to other wakeup sources - 0x01 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS0 register
 */
/*@{*/
#define RCM_RD_SRS0(base)        (RCM_SRS0_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS0 bitfields
 */

/*!
 * @name Register RCM_SRS0, field WAKEUP[0] (RO)
 *
 * Indicates a reset has been caused by an enabled LLWU module wakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset. This bit is cleared by any reset except WAKEUP.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WAKEUP field. */
#define RCM_RD_SRS0_WAKEUP(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WAKEUP_MASK) >> RCM_SRS0_WAKEUP_SHIFT)
#define RCM_BRD_SRS0_WAKEUP(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_WAKEUP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LVD[1] (RO)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LVD field. */
#define RCM_RD_SRS0_LVD(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LVD_MASK) >> RCM_SRS0_LVD_SHIFT)
#define RCM_BRD_SRS0_LVD(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LVD_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOC[2] (RO)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0 - Reset not caused by a loss of external clock.
 * - 1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOC field. */
#define RCM_RD_SRS0_LOC(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOC_MASK) >> RCM_SRS0_LOC_SHIFT)
#define RCM_BRD_SRS0_LOC(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LOC_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field LOL[3] (RO)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0 - Reset not caused by a loss of lock in the PLL
 * - 1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_LOL field. */
#define RCM_RD_SRS0_LOL(base) ((RCM_SRS0_REG(base) & RCM_SRS0_LOL_MASK) >> RCM_SRS0_LOL_SHIFT)
#define RCM_BRD_SRS0_LOL(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_LOL_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field WDOG[5] (RO)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_WDOG field. */
#define RCM_RD_SRS0_WDOG(base) ((RCM_SRS0_REG(base) & RCM_SRS0_WDOG_MASK) >> RCM_SRS0_WDOG_SHIFT)
#define RCM_BRD_SRS0_WDOG(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_WDOG_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field PIN[6] (RO)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_PIN field. */
#define RCM_RD_SRS0_PIN(base) ((RCM_SRS0_REG(base) & RCM_SRS0_PIN_MASK) >> RCM_SRS0_PIN_SHIFT)
#define RCM_BRD_SRS0_PIN(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_PIN_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS0, field POR[7] (RO)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS0_POR field. */
#define RCM_RD_SRS0_POR(base) ((RCM_SRS0_REG(base) & RCM_SRS0_POR_MASK) >> RCM_SRS0_POR_SHIFT)
#define RCM_BRD_SRS0_POR(base) (BITBAND_ACCESS8(&RCM_SRS0_REG(base), RCM_SRS0_POR_SHIFT))
/*@}*/

/*******************************************************************************
 * RCM_SRS1 - System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SRS1 - System Reset Status Register 1 (RO)
 *
 * Reset value: 0x00U
 *
 * This register includes read-only status flags to indicate the source of the
 * most recent reset. The reset state of these bits depends on what caused the MCU
 * to reset. The reset value of this register depends on the reset source: POR
 * (including LVD) - 0x00 LVD (without POR) - 0x00 VLLS mode wakeup - 0x00 Other
 * reset - a bit is set if its corresponding reset source caused the reset
 */
/*!
 * @name Constants and macros for entire RCM_SRS1 register
 */
/*@{*/
#define RCM_RD_SRS1(base)        (RCM_SRS1_REG(base))
/*@}*/

/*
 * Constants & macros for individual RCM_SRS1 bitfields
 */

/*!
 * @name Register RCM_SRS1, field JTAG[0] (RO)
 *
 * Indicates a reset has been caused by JTAG selection of certain IR codes:
 * EXTEST, HIGHZ, and CLAMP.
 *
 * Values:
 * - 0 - Reset not caused by JTAG
 * - 1 - Reset caused by JTAG
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_JTAG field. */
#define RCM_RD_SRS1_JTAG(base) ((RCM_SRS1_REG(base) & RCM_SRS1_JTAG_MASK) >> RCM_SRS1_JTAG_SHIFT)
#define RCM_BRD_SRS1_JTAG(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_JTAG_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field LOCKUP[1] (RO)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_LOCKUP field. */
#define RCM_RD_SRS1_LOCKUP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_LOCKUP_MASK) >> RCM_SRS1_LOCKUP_SHIFT)
#define RCM_BRD_SRS1_LOCKUP(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_LOCKUP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SW[2] (RO)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SW field. */
#define RCM_RD_SRS1_SW(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SW_MASK) >> RCM_SRS1_SW_SHIFT)
#define RCM_BRD_SRS1_SW(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_SW_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field MDM_AP[3] (RO)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_MDM_AP field. */
#define RCM_RD_SRS1_MDM_AP(base) ((RCM_SRS1_REG(base) & RCM_SRS1_MDM_AP_MASK) >> RCM_SRS1_MDM_AP_SHIFT)
#define RCM_BRD_SRS1_MDM_AP(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_MDM_AP_SHIFT))
/*@}*/

/*!
 * @name Register RCM_SRS1, field SACKERR[5] (RO)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SRS1_SACKERR field. */
#define RCM_RD_SRS1_SACKERR(base) ((RCM_SRS1_REG(base) & RCM_SRS1_SACKERR_MASK) >> RCM_SRS1_SACKERR_SHIFT)
#define RCM_BRD_SRS1_SACKERR(base) (BITBAND_ACCESS8(&RCM_SRS1_REG(base), RCM_SRS1_SACKERR_SHIFT))
/*@}*/

/*******************************************************************************
 * RCM_RPFC - Reset Pin Filter Control register
 ******************************************************************************/

/*!
 * @brief RCM_RPFC - Reset Pin Filter Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of bits 2-0 are for Chip POR only. They are unaffected by
 * other reset types. The bus clock filter is reset when disabled or when entering
 * stop mode. The LPO filter is reset when disabled .
 */
/*!
 * @name Constants and macros for entire RCM_RPFC register
 */
/*@{*/
#define RCM_RD_RPFC(base)        (RCM_RPFC_REG(base))
#define RCM_WR_RPFC(base, value) (RCM_RPFC_REG(base) = (value))
#define RCM_RMW_RPFC(base, mask, value) (RCM_WR_RPFC(base, (RCM_RD_RPFC(base) & ~(mask)) | (value)))
#define RCM_SET_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) |  (value)))
#define RCM_CLR_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) & ~(value)))
#define RCM_TOG_RPFC(base, value) (RCM_WR_RPFC(base, RCM_RD_RPFC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFC bitfields
 */

/*!
 * @name Register RCM_RPFC, field RSTFLTSRW[1:0] (RW)
 *
 * Selects how the reset pin filter is enabled in run and wait modes.
 *
 * Values:
 * - 00 - All filtering disabled
 * - 01 - Bus clock filter enabled for normal operation
 * - 10 - LPO clock filter enabled for normal operation
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSRW field. */
#define RCM_RD_RPFC_RSTFLTSRW(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSRW_MASK) >> RCM_RPFC_RSTFLTSRW_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSRW(base) (RCM_RD_RPFC_RSTFLTSRW(base))

/*! @brief Set the RSTFLTSRW field to a new value. */
#define RCM_WR_RPFC_RSTFLTSRW(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSRW_MASK, RCM_RPFC_RSTFLTSRW(value)))
#define RCM_BWR_RPFC_RSTFLTSRW(base, value) (RCM_WR_RPFC_RSTFLTSRW(base, value))
/*@}*/

/*!
 * @name Register RCM_RPFC, field RSTFLTSS[2] (RW)
 *
 * Selects how the reset pin filter is enabled in Stop and VLPS modes , and also
 * during LLS and VLLS modes. On exit from VLLS mode, this bit should be
 * reconfigured before clearing PMC_REGSC[ACKISO].
 *
 * Values:
 * - 0 - All filtering disabled
 * - 1 - LPO clock filter enabled
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFC_RSTFLTSS field. */
#define RCM_RD_RPFC_RSTFLTSS(base) ((RCM_RPFC_REG(base) & RCM_RPFC_RSTFLTSS_MASK) >> RCM_RPFC_RSTFLTSS_SHIFT)
#define RCM_BRD_RPFC_RSTFLTSS(base) (BITBAND_ACCESS8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT))

/*! @brief Set the RSTFLTSS field to a new value. */
#define RCM_WR_RPFC_RSTFLTSS(base, value) (RCM_RMW_RPFC(base, RCM_RPFC_RSTFLTSS_MASK, RCM_RPFC_RSTFLTSS(value)))
#define RCM_BWR_RPFC_RSTFLTSS(base, value) (BITBAND_ACCESS8(&RCM_RPFC_REG(base), RCM_RPFC_RSTFLTSS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RCM_RPFW - Reset Pin Filter Width register
 ******************************************************************************/

/*!
 * @brief RCM_RPFW - Reset Pin Filter Width register (RW)
 *
 * Reset value: 0x00U
 *
 * The reset values of the bits in the RSTFLTSEL field are for Chip POR only.
 * They are unaffected by other reset types.
 */
/*!
 * @name Constants and macros for entire RCM_RPFW register
 */
/*@{*/
#define RCM_RD_RPFW(base)        (RCM_RPFW_REG(base))
#define RCM_WR_RPFW(base, value) (RCM_RPFW_REG(base) = (value))
#define RCM_RMW_RPFW(base, mask, value) (RCM_WR_RPFW(base, (RCM_RD_RPFW(base) & ~(mask)) | (value)))
#define RCM_SET_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) |  (value)))
#define RCM_CLR_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) & ~(value)))
#define RCM_TOG_RPFW(base, value) (RCM_WR_RPFW(base, RCM_RD_RPFW(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_RPFW bitfields
 */

/*!
 * @name Register RCM_RPFW, field RSTFLTSEL[4:0] (RW)
 *
 * Selects the reset pin bus clock filter width.
 *
 * Values:
 * - 00000 - Bus clock filter count is 1
 * - 00001 - Bus clock filter count is 2
 * - 00010 - Bus clock filter count is 3
 * - 00011 - Bus clock filter count is 4
 * - 00100 - Bus clock filter count is 5
 * - 00101 - Bus clock filter count is 6
 * - 00110 - Bus clock filter count is 7
 * - 00111 - Bus clock filter count is 8
 * - 01000 - Bus clock filter count is 9
 * - 01001 - Bus clock filter count is 10
 * - 01010 - Bus clock filter count is 11
 * - 01011 - Bus clock filter count is 12
 * - 01100 - Bus clock filter count is 13
 * - 01101 - Bus clock filter count is 14
 * - 01110 - Bus clock filter count is 15
 * - 01111 - Bus clock filter count is 16
 * - 10000 - Bus clock filter count is 17
 * - 10001 - Bus clock filter count is 18
 * - 10010 - Bus clock filter count is 19
 * - 10011 - Bus clock filter count is 20
 * - 10100 - Bus clock filter count is 21
 * - 10101 - Bus clock filter count is 22
 * - 10110 - Bus clock filter count is 23
 * - 10111 - Bus clock filter count is 24
 * - 11000 - Bus clock filter count is 25
 * - 11001 - Bus clock filter count is 26
 * - 11010 - Bus clock filter count is 27
 * - 11011 - Bus clock filter count is 28
 * - 11100 - Bus clock filter count is 29
 * - 11101 - Bus clock filter count is 30
 * - 11110 - Bus clock filter count is 31
 * - 11111 - Bus clock filter count is 32
 */
/*@{*/
/*! @brief Read current value of the RCM_RPFW_RSTFLTSEL field. */
#define RCM_RD_RPFW_RSTFLTSEL(base) ((RCM_RPFW_REG(base) & RCM_RPFW_RSTFLTSEL_MASK) >> RCM_RPFW_RSTFLTSEL_SHIFT)
#define RCM_BRD_RPFW_RSTFLTSEL(base) (RCM_RD_RPFW_RSTFLTSEL(base))

/*! @brief Set the RSTFLTSEL field to a new value. */
#define RCM_WR_RPFW_RSTFLTSEL(base, value) (RCM_RMW_RPFW(base, RCM_RPFW_RSTFLTSEL_MASK, RCM_RPFW_RSTFLTSEL(value)))
#define RCM_BWR_RPFW_RSTFLTSEL(base, value) (RCM_WR_RPFW_RSTFLTSEL(base, value))
/*@}*/

/*******************************************************************************
 * RCM_SSRS0 - Sticky System Reset Status Register 0
 ******************************************************************************/

/*!
 * @brief RCM_SSRS0 - Sticky System Reset Status Register 0 (RW)
 *
 * Reset value: 0x82U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS0 register
 */
/*@{*/
#define RCM_RD_SSRS0(base)       (RCM_SSRS0_REG(base))
#define RCM_WR_SSRS0(base, value) (RCM_SSRS0_REG(base) = (value))
#define RCM_RMW_SSRS0(base, mask, value) (RCM_WR_SSRS0(base, (RCM_RD_SSRS0(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS0(base, value) (RCM_WR_SSRS0(base, RCM_RD_SSRS0(base) |  (value)))
#define RCM_CLR_SSRS0(base, value) (RCM_WR_SSRS0(base, RCM_RD_SSRS0(base) & ~(value)))
#define RCM_TOG_SSRS0(base, value) (RCM_WR_SSRS0(base, RCM_RD_SSRS0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS0 bitfields
 */

/*!
 * @name Register RCM_SSRS0, field SWAKEUP[0] (W1C)
 *
 * Indicates a reset has been caused by an enabled LLWU modulewakeup source
 * while the chip was in a low leakage mode. In LLS mode, the RESET pin is the only
 * wakeup source that can cause this reset. Any enabled wakeup source in a VLLSx
 * mode causes a reset.
 *
 * Values:
 * - 0 - Reset not caused by LLWU module wakeup source
 * - 1 - Reset caused by LLWU module wakeup source
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWAKEUP field. */
#define RCM_RD_SSRS0_SWAKEUP(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWAKEUP_MASK) >> RCM_SSRS0_SWAKEUP_SHIFT)
#define RCM_BRD_SSRS0_SWAKEUP(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWAKEUP_SHIFT))

/*! @brief Set the SWAKEUP field to a new value. */
#define RCM_WR_SSRS0_SWAKEUP(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWAKEUP(value)))
#define RCM_BWR_SSRS0_SWAKEUP(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWAKEUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLVD[1] (W1C)
 *
 * If PMC_LVDSC1[LVDRE] is set and the supply drops below the LVD trip voltage,
 * an LVD reset occurs. This field is also set by POR.
 *
 * Values:
 * - 0 - Reset not caused by LVD trip or POR
 * - 1 - Reset caused by LVD trip or POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLVD field. */
#define RCM_RD_SSRS0_SLVD(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLVD_MASK) >> RCM_SSRS0_SLVD_SHIFT)
#define RCM_BRD_SSRS0_SLVD(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLVD_SHIFT))

/*! @brief Set the SLVD field to a new value. */
#define RCM_WR_SSRS0_SLVD(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLVD(value)))
#define RCM_BWR_SSRS0_SLVD(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLVD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLOC[2] (W1C)
 *
 * Indicates a reset has been caused by a loss of external clock. The MCG clock
 * monitor must be enabled for a loss of clock to be detected. Refer to the
 * detailed MCG description for information on enabling the clock monitor.
 *
 * Values:
 * - 0 - Reset not caused by a loss of external clock.
 * - 1 - Reset caused by a loss of external clock.
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLOC field. */
#define RCM_RD_SSRS0_SLOC(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLOC_MASK) >> RCM_SSRS0_SLOC_SHIFT)
#define RCM_BRD_SSRS0_SLOC(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOC_SHIFT))

/*! @brief Set the SLOC field to a new value. */
#define RCM_WR_SSRS0_SLOC(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLOC(value)))
#define RCM_BWR_SSRS0_SLOC(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SLOL[3] (W1C)
 *
 * Indicates a reset has been caused by a loss of lock in the MCG PLL. See the
 * MCG description for information on the loss-of-clock event.
 *
 * Values:
 * - 0 - Reset not caused by a loss of lock in the PLL
 * - 1 - Reset caused by a loss of lock in the PLL
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SLOL field. */
#define RCM_RD_SSRS0_SLOL(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SLOL_MASK) >> RCM_SSRS0_SLOL_SHIFT)
#define RCM_BRD_SSRS0_SLOL(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOL_SHIFT))

/*! @brief Set the SLOL field to a new value. */
#define RCM_WR_SSRS0_SLOL(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SLOL(value)))
#define RCM_BWR_SSRS0_SLOL(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SLOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SWDOG[5] (W1C)
 *
 * Indicates a reset has been caused by the watchdog timer timing out. This
 * reset source can be blocked by disabling the watchdog.
 *
 * Values:
 * - 0 - Reset not caused by watchdog timeout
 * - 1 - Reset caused by watchdog timeout
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SWDOG field. */
#define RCM_RD_SSRS0_SWDOG(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SWDOG_MASK) >> RCM_SSRS0_SWDOG_SHIFT)
#define RCM_BRD_SSRS0_SWDOG(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWDOG_SHIFT))

/*! @brief Set the SWDOG field to a new value. */
#define RCM_WR_SSRS0_SWDOG(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SWDOG(value)))
#define RCM_BWR_SSRS0_SWDOG(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SWDOG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPIN[6] (W1C)
 *
 * Indicates a reset has been caused by an active-low level on the external
 * RESET pin.
 *
 * Values:
 * - 0 - Reset not caused by external reset pin
 * - 1 - Reset caused by external reset pin
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPIN field. */
#define RCM_RD_SSRS0_SPIN(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPIN_MASK) >> RCM_SSRS0_SPIN_SHIFT)
#define RCM_BRD_SSRS0_SPIN(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPIN_SHIFT))

/*! @brief Set the SPIN field to a new value. */
#define RCM_WR_SSRS0_SPIN(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPIN_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPOR_MASK), RCM_SSRS0_SPIN(value)))
#define RCM_BWR_SSRS0_SPIN(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPIN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS0, field SPOR[7] (W1C)
 *
 * Indicates a reset has been caused by the power-on detection logic. Because
 * the internal supply voltage was ramping up at the time, the low-voltage reset
 * (LVD) status bit is also set to indicate that the reset occurred while the
 * internal supply was below the LVD threshold.
 *
 * Values:
 * - 0 - Reset not caused by POR
 * - 1 - Reset caused by POR
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS0_SPOR field. */
#define RCM_RD_SSRS0_SPOR(base) ((RCM_SSRS0_REG(base) & RCM_SSRS0_SPOR_MASK) >> RCM_SSRS0_SPOR_SHIFT)
#define RCM_BRD_SSRS0_SPOR(base) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPOR_SHIFT))

/*! @brief Set the SPOR field to a new value. */
#define RCM_WR_SSRS0_SPOR(base, value) (RCM_RMW_SSRS0(base, (RCM_SSRS0_SPOR_MASK | RCM_SSRS0_SWAKEUP_MASK | RCM_SSRS0_SLVD_MASK | RCM_SSRS0_SLOC_MASK | RCM_SSRS0_SLOL_MASK | RCM_SSRS0_SWDOG_MASK | RCM_SSRS0_SPIN_MASK), RCM_SSRS0_SPOR(value)))
#define RCM_BWR_SSRS0_SPOR(base, value) (BITBAND_ACCESS8(&RCM_SSRS0_REG(base), RCM_SSRS0_SPOR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RCM_SSRS1 - Sticky System Reset Status Register 1
 ******************************************************************************/

/*!
 * @brief RCM_SSRS1 - Sticky System Reset Status Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This register includes status flags to indicate all reset sources since the
 * last POR, LVD or VLLS Wakeup that have not been cleared by software. Software
 * can clear the status flags by writing a logic one to a flag.
 */
/*!
 * @name Constants and macros for entire RCM_SSRS1 register
 */
/*@{*/
#define RCM_RD_SSRS1(base)       (RCM_SSRS1_REG(base))
#define RCM_WR_SSRS1(base, value) (RCM_SSRS1_REG(base) = (value))
#define RCM_RMW_SSRS1(base, mask, value) (RCM_WR_SSRS1(base, (RCM_RD_SSRS1(base) & ~(mask)) | (value)))
#define RCM_SET_SSRS1(base, value) (RCM_WR_SSRS1(base, RCM_RD_SSRS1(base) |  (value)))
#define RCM_CLR_SSRS1(base, value) (RCM_WR_SSRS1(base, RCM_RD_SSRS1(base) & ~(value)))
#define RCM_TOG_SSRS1(base, value) (RCM_WR_SSRS1(base, RCM_RD_SSRS1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RCM_SSRS1 bitfields
 */

/*!
 * @name Register RCM_SSRS1, field SJTAG[0] (W1C)
 *
 * Indicates a reset has been caused by JTAG selection of certain IR codes:
 * EXTEST, HIGHZ, and CLAMP.
 *
 * Values:
 * - 0 - Reset not caused by JTAG
 * - 1 - Reset caused by JTAG
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SJTAG field. */
#define RCM_RD_SSRS1_SJTAG(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SJTAG_MASK) >> RCM_SSRS1_SJTAG_SHIFT)
#define RCM_BRD_SSRS1_SJTAG(base) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SJTAG_SHIFT))

/*! @brief Set the SJTAG field to a new value. */
#define RCM_WR_SSRS1_SJTAG(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SJTAG(value)))
#define RCM_BWR_SSRS1_SJTAG(base, value) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SJTAG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SLOCKUP[1] (W1C)
 *
 * Indicates a reset has been caused by the ARM core indication of a LOCKUP
 * event.
 *
 * Values:
 * - 0 - Reset not caused by core LOCKUP event
 * - 1 - Reset caused by core LOCKUP event
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SLOCKUP field. */
#define RCM_RD_SSRS1_SLOCKUP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SLOCKUP_MASK) >> RCM_SSRS1_SLOCKUP_SHIFT)
#define RCM_BRD_SSRS1_SLOCKUP(base) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SLOCKUP_SHIFT))

/*! @brief Set the SLOCKUP field to a new value. */
#define RCM_WR_SSRS1_SLOCKUP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SLOCKUP(value)))
#define RCM_BWR_SSRS1_SLOCKUP(base, value) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SLOCKUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSW[2] (W1C)
 *
 * Indicates a reset has been caused by software setting of SYSRESETREQ bit in
 * Application Interrupt and Reset Control Register in the ARM core.
 *
 * Values:
 * - 0 - Reset not caused by software setting of SYSRESETREQ bit
 * - 1 - Reset caused by software setting of SYSRESETREQ bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSW field. */
#define RCM_RD_SSRS1_SSW(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSW_MASK) >> RCM_SSRS1_SSW_SHIFT)
#define RCM_BRD_SSRS1_SSW(base) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSW_SHIFT))

/*! @brief Set the SSW field to a new value. */
#define RCM_WR_SSRS1_SSW(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSW_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SSW(value)))
#define RCM_BWR_SSRS1_SSW(base, value) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SMDM_AP[3] (W1C)
 *
 * Indicates a reset has been caused by the host debugger system setting of the
 * System Reset Request bit in the MDM-AP Control Register.
 *
 * Values:
 * - 0 - Reset not caused by host debugger system setting of the System Reset
 *     Request bit
 * - 1 - Reset caused by host debugger system setting of the System Reset
 *     Request bit
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SMDM_AP field. */
#define RCM_RD_SSRS1_SMDM_AP(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SMDM_AP_MASK) >> RCM_SSRS1_SMDM_AP_SHIFT)
#define RCM_BRD_SSRS1_SMDM_AP(base) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SMDM_AP_SHIFT))

/*! @brief Set the SMDM_AP field to a new value. */
#define RCM_WR_SSRS1_SMDM_AP(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SMDM_AP_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SSACKERR_MASK), RCM_SSRS1_SMDM_AP(value)))
#define RCM_BWR_SSRS1_SMDM_AP(base, value) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SMDM_AP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RCM_SSRS1, field SSACKERR[5] (W1C)
 *
 * Indicates that after an attempt to enter Stop mode, a reset has been caused
 * by a failure of one or more peripherals to acknowledge within approximately one
 * second to enter stop mode.
 *
 * Values:
 * - 0 - Reset not caused by peripheral failure to acknowledge attempt to enter
 *     stop mode
 * - 1 - Reset caused by peripheral failure to acknowledge attempt to enter stop
 *     mode
 */
/*@{*/
/*! @brief Read current value of the RCM_SSRS1_SSACKERR field. */
#define RCM_RD_SSRS1_SSACKERR(base) ((RCM_SSRS1_REG(base) & RCM_SSRS1_SSACKERR_MASK) >> RCM_SSRS1_SSACKERR_SHIFT)
#define RCM_BRD_SSRS1_SSACKERR(base) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSACKERR_SHIFT))

/*! @brief Set the SSACKERR field to a new value. */
#define RCM_WR_SSRS1_SSACKERR(base, value) (RCM_RMW_SSRS1(base, (RCM_SSRS1_SSACKERR_MASK | RCM_SSRS1_SJTAG_MASK | RCM_SSRS1_SLOCKUP_MASK | RCM_SSRS1_SSW_MASK | RCM_SSRS1_SMDM_AP_MASK), RCM_SSRS1_SSACKERR(value)))
#define RCM_BWR_SSRS1_SSACKERR(base, value) (BITBAND_ACCESS8(&RCM_SSRS1_REG(base), RCM_SSRS1_SSACKERR_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 RFSYS
 *
 * System register file
 *
 * Registers defined in this header file:
 * - RFSYS_REG - Register file register
 */

#define RFSYS_INSTANCE_COUNT (1U) /*!< Number of instances of the RFSYS module. */
#define RFSYS_IDX (0U) /*!< Instance number for RFSYS. */

/*******************************************************************************
 * RFSYS_REG - Register file register
 ******************************************************************************/

/*!
 * @brief RFSYS_REG - Register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFSYS_REG register
 */
/*@{*/
#define RFSYS_RD_REG(base, index) (RFSYS_REG_REG(base, index))
#define RFSYS_WR_REG(base, index, value) (RFSYS_REG_REG(base, index) = (value))
#define RFSYS_RMW_REG(base, index, mask, value) (RFSYS_WR_REG(base, index, (RFSYS_RD_REG(base, index) & ~(mask)) | (value)))
#define RFSYS_SET_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) |  (value)))
#define RFSYS_CLR_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) & ~(value)))
#define RFSYS_TOG_REG(base, index, value) (RFSYS_WR_REG(base, index, RFSYS_RD_REG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RFSYS_REG bitfields
 */

/*!
 * @name Register RFSYS_REG, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LL field. */
#define RFSYS_RD_REG_LL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LL_MASK) >> RFSYS_REG_LL_SHIFT)
#define RFSYS_BRD_REG_LL(base, index) (RFSYS_RD_REG_LL(base, index))

/*! @brief Set the LL field to a new value. */
#define RFSYS_WR_REG_LL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LL_MASK, RFSYS_REG_LL(value)))
#define RFSYS_BWR_REG_LL(base, index, value) (RFSYS_WR_REG_LL(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_LH field. */
#define RFSYS_RD_REG_LH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_LH_MASK) >> RFSYS_REG_LH_SHIFT)
#define RFSYS_BRD_REG_LH(base, index) (RFSYS_RD_REG_LH(base, index))

/*! @brief Set the LH field to a new value. */
#define RFSYS_WR_REG_LH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_LH_MASK, RFSYS_REG_LH(value)))
#define RFSYS_BWR_REG_LH(base, index, value) (RFSYS_WR_REG_LH(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HL field. */
#define RFSYS_RD_REG_HL(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HL_MASK) >> RFSYS_REG_HL_SHIFT)
#define RFSYS_BRD_REG_HL(base, index) (RFSYS_RD_REG_HL(base, index))

/*! @brief Set the HL field to a new value. */
#define RFSYS_WR_REG_HL(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HL_MASK, RFSYS_REG_HL(value)))
#define RFSYS_BWR_REG_HL(base, index, value) (RFSYS_WR_REG_HL(base, index, value))
/*@}*/

/*!
 * @name Register RFSYS_REG, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
/*! @brief Read current value of the RFSYS_REG_HH field. */
#define RFSYS_RD_REG_HH(base, index) ((RFSYS_REG_REG(base, index) & RFSYS_REG_HH_MASK) >> RFSYS_REG_HH_SHIFT)
#define RFSYS_BRD_REG_HH(base, index) (RFSYS_RD_REG_HH(base, index))

/*! @brief Set the HH field to a new value. */
#define RFSYS_WR_REG_HH(base, index, value) (RFSYS_RMW_REG(base, index, RFSYS_REG_HH_MASK, RFSYS_REG_HH(value)))
#define RFSYS_BWR_REG_HH(base, index, value) (RFSYS_WR_REG_HH(base, index, value))
/*@}*/

/*
 * MKS22F25612 RFVBAT
 *
 * VBAT register file
 *
 * Registers defined in this header file:
 * - RFVBAT_REG - VBAT register file register
 */

#define RFVBAT_INSTANCE_COUNT (1U) /*!< Number of instances of the RFVBAT module. */
#define RFVBAT_IDX (0U) /*!< Instance number for RFVBAT. */

/*******************************************************************************
 * RFVBAT_REG - VBAT register file register
 ******************************************************************************/

/*!
 * @brief RFVBAT_REG - VBAT register file register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Each register can be accessed as 8-, 16-, or 32-bits.
 */
/*!
 * @name Constants and macros for entire RFVBAT_REG register
 */
/*@{*/
#define RFVBAT_RD_REG(base, index) (RFVBAT_REG_REG(base, index))
#define RFVBAT_WR_REG(base, index, value) (RFVBAT_REG_REG(base, index) = (value))
#define RFVBAT_RMW_REG(base, index, mask, value) (RFVBAT_WR_REG(base, index, (RFVBAT_RD_REG(base, index) & ~(mask)) | (value)))
#define RFVBAT_SET_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) |  (value)))
#define RFVBAT_CLR_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) & ~(value)))
#define RFVBAT_TOG_REG(base, index, value) (RFVBAT_WR_REG(base, index, RFVBAT_RD_REG(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RFVBAT_REG bitfields
 */

/*!
 * @name Register RFVBAT_REG, field LL[7:0] (RW)
 *
 * Low lower byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LL field. */
#define RFVBAT_RD_REG_LL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LL_MASK) >> RFVBAT_REG_LL_SHIFT)
#define RFVBAT_BRD_REG_LL(base, index) (RFVBAT_RD_REG_LL(base, index))

/*! @brief Set the LL field to a new value. */
#define RFVBAT_WR_REG_LL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LL_MASK, RFVBAT_REG_LL(value)))
#define RFVBAT_BWR_REG_LL(base, index, value) (RFVBAT_WR_REG_LL(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field LH[15:8] (RW)
 *
 * Low higher byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_LH field. */
#define RFVBAT_RD_REG_LH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_LH_MASK) >> RFVBAT_REG_LH_SHIFT)
#define RFVBAT_BRD_REG_LH(base, index) (RFVBAT_RD_REG_LH(base, index))

/*! @brief Set the LH field to a new value. */
#define RFVBAT_WR_REG_LH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_LH_MASK, RFVBAT_REG_LH(value)))
#define RFVBAT_BWR_REG_LH(base, index, value) (RFVBAT_WR_REG_LH(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HL[23:16] (RW)
 *
 * High lower byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HL field. */
#define RFVBAT_RD_REG_HL(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HL_MASK) >> RFVBAT_REG_HL_SHIFT)
#define RFVBAT_BRD_REG_HL(base, index) (RFVBAT_RD_REG_HL(base, index))

/*! @brief Set the HL field to a new value. */
#define RFVBAT_WR_REG_HL(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HL_MASK, RFVBAT_REG_HL(value)))
#define RFVBAT_BWR_REG_HL(base, index, value) (RFVBAT_WR_REG_HL(base, index, value))
/*@}*/

/*!
 * @name Register RFVBAT_REG, field HH[31:24] (RW)
 *
 * High higher byte
 */
/*@{*/
/*! @brief Read current value of the RFVBAT_REG_HH field. */
#define RFVBAT_RD_REG_HH(base, index) ((RFVBAT_REG_REG(base, index) & RFVBAT_REG_HH_MASK) >> RFVBAT_REG_HH_SHIFT)
#define RFVBAT_BRD_REG_HH(base, index) (RFVBAT_RD_REG_HH(base, index))

/*! @brief Set the HH field to a new value. */
#define RFVBAT_WR_REG_HH(base, index, value) (RFVBAT_RMW_REG(base, index, RFVBAT_REG_HH_MASK, RFVBAT_REG_HH(value)))
#define RFVBAT_BWR_REG_HH(base, index, value) (RFVBAT_WR_REG_HH(base, index, value))
/*@}*/

/*
 * MKS22F25612 RNG
 *
 * Random Number Generator Accelerator
 *
 * Registers defined in this header file:
 * - RNG_CR - RNGA Control Register
 * - RNG_SR - RNGA Status Register
 * - RNG_ER - RNGA Entropy Register
 * - RNG_OR - RNGA Output Register
 */

#define RNG_INSTANCE_COUNT (1U) /*!< Number of instances of the RNG module. */
#define RNG_IDX (0U) /*!< Instance number for RNG. */

/*******************************************************************************
 * RNG_CR - RNGA Control Register
 ******************************************************************************/

/*!
 * @brief RNG_CR - RNGA Control Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * Controls the operation of RNGA.
 */
/*!
 * @name Constants and macros for entire RNG_CR register
 */
/*@{*/
#define RNG_RD_CR(base)          (RNG_CR_REG(base))
#define RNG_WR_CR(base, value)   (RNG_CR_REG(base) = (value))
#define RNG_RMW_CR(base, mask, value) (RNG_WR_CR(base, (RNG_RD_CR(base) & ~(mask)) | (value)))
#define RNG_SET_CR(base, value)  (RNG_WR_CR(base, RNG_RD_CR(base) |  (value)))
#define RNG_CLR_CR(base, value)  (RNG_WR_CR(base, RNG_RD_CR(base) & ~(value)))
#define RNG_TOG_CR(base, value)  (RNG_WR_CR(base, RNG_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RNG_CR bitfields
 */

/*!
 * @name Register RNG_CR, field GO[0] (RW)
 *
 * Specifies whether random-data generation and loading (into OR[RANDOUT]) is
 * enabled.This field is sticky. You must reset RNGA to stop RNGA from loading
 * OR[RANDOUT] with data.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_GO field. */
#define RNG_RD_CR_GO(base)   ((RNG_CR_REG(base) & RNG_CR_GO_MASK) >> RNG_CR_GO_SHIFT)
#define RNG_BRD_CR_GO(base)  (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_GO_SHIFT))

/*! @brief Set the GO field to a new value. */
#define RNG_WR_CR_GO(base, value) (RNG_RMW_CR(base, RNG_CR_GO_MASK, RNG_CR_GO(value)))
#define RNG_BWR_CR_GO(base, value) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_GO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RNG_CR, field HA[1] (RW)
 *
 * Enables notification of security violations (via SR[SECV]). A security
 * violation occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0. This field is sticky.
 * After enabling notification of security violations, you must reset RNGA to
 * disable them again.
 *
 * Values:
 * - 0 - Disabled
 * - 1 - Enabled
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_HA field. */
#define RNG_RD_CR_HA(base)   ((RNG_CR_REG(base) & RNG_CR_HA_MASK) >> RNG_CR_HA_SHIFT)
#define RNG_BRD_CR_HA(base)  (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_HA_SHIFT))

/*! @brief Set the HA field to a new value. */
#define RNG_WR_CR_HA(base, value) (RNG_RMW_CR(base, RNG_CR_HA_MASK, RNG_CR_HA(value)))
#define RNG_BWR_CR_HA(base, value) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_HA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RNG_CR, field INTM[2] (RW)
 *
 * Masks the triggering of an error interrupt to the interrupt controller when
 * an OR underflow condition occurs. An OR underflow condition occurs when you
 * read OR[RANDOUT] and SR[OREG_LVL]=0. See the Output Register (OR) description.
 *
 * Values:
 * - 0 - Not masked
 * - 1 - Masked
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_INTM field. */
#define RNG_RD_CR_INTM(base) ((RNG_CR_REG(base) & RNG_CR_INTM_MASK) >> RNG_CR_INTM_SHIFT)
#define RNG_BRD_CR_INTM(base) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_INTM_SHIFT))

/*! @brief Set the INTM field to a new value. */
#define RNG_WR_CR_INTM(base, value) (RNG_RMW_CR(base, RNG_CR_INTM_MASK, RNG_CR_INTM(value)))
#define RNG_BWR_CR_INTM(base, value) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_INTM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RNG_CR, field CLRI[3] (WORZ)
 *
 * Clears the interrupt by resetting the error-interrupt indicator (SR[ERRI]).
 *
 * Values:
 * - 0 - Do not clear the interrupt.
 * - 1 - Clear the interrupt. When you write 1 to this field, RNGA then resets
 *     the error-interrupt indicator (SR[ERRI]). This bit always reads as 0.
 */
/*@{*/
/*! @brief Set the CLRI field to a new value. */
#define RNG_WR_CR_CLRI(base, value) (RNG_RMW_CR(base, RNG_CR_CLRI_MASK, RNG_CR_CLRI(value)))
#define RNG_BWR_CR_CLRI(base, value) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_CLRI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RNG_CR, field SLP[4] (RW)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - Sleep (low-power) mode
 */
/*@{*/
/*! @brief Read current value of the RNG_CR_SLP field. */
#define RNG_RD_CR_SLP(base)  ((RNG_CR_REG(base) & RNG_CR_SLP_MASK) >> RNG_CR_SLP_SHIFT)
#define RNG_BRD_CR_SLP(base) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_SLP_SHIFT))

/*! @brief Set the SLP field to a new value. */
#define RNG_WR_CR_SLP(base, value) (RNG_RMW_CR(base, RNG_CR_SLP_MASK, RNG_CR_SLP(value)))
#define RNG_BWR_CR_SLP(base, value) (BITBAND_ACCESS32(&RNG_CR_REG(base), RNG_CR_SLP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RNG_SR - RNGA Status Register
 ******************************************************************************/

/*!
 * @brief RNG_SR - RNGA Status Register (RO)
 *
 * Reset value: 0x00010000U
 *
 * Indicates the status of RNGA. This register is read-only.
 */
/*!
 * @name Constants and macros for entire RNG_SR register
 */
/*@{*/
#define RNG_RD_SR(base)          (RNG_SR_REG(base))
/*@}*/

/*
 * Constants & macros for individual RNG_SR bitfields
 */

/*!
 * @name Register RNG_SR, field SECV[0] (RO)
 *
 * Used only when high assurance is enabled (CR[HA]). Indicates that a security
 * violation has occurred.This field is sticky. To clear SR[SECV], you must reset
 * RNGA.
 *
 * Values:
 * - 0 - No security violation
 * - 1 - Security violation
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_SECV field. */
#define RNG_RD_SR_SECV(base) ((RNG_SR_REG(base) & RNG_SR_SECV_MASK) >> RNG_SR_SECV_SHIFT)
#define RNG_BRD_SR_SECV(base) (BITBAND_ACCESS32(&RNG_SR_REG(base), RNG_SR_SECV_SHIFT))
/*@}*/

/*!
 * @name Register RNG_SR, field LRS[1] (RO)
 *
 * Indicates whether the most recent read of OR[RANDOUT] caused an OR underflow
 * condition, regardless of whether the error interrupt is masked (CR[INTM]). An
 * OR underflow condition occurs when you read OR[RANDOUT] and SR[OREG_LVL]=0.
 * After you read this register, RNGA writes 0 to this field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_LRS field. */
#define RNG_RD_SR_LRS(base)  ((RNG_SR_REG(base) & RNG_SR_LRS_MASK) >> RNG_SR_LRS_SHIFT)
#define RNG_BRD_SR_LRS(base) (BITBAND_ACCESS32(&RNG_SR_REG(base), RNG_SR_LRS_SHIFT))
/*@}*/

/*!
 * @name Register RNG_SR, field ORU[2] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last read
 * this register (SR) or RNGA was reset, regardless of whether the error
 * interrupt is masked (CR[INTM]). An OR underflow condition occurs when you read
 * OR[RANDOUT] and SR[OREG_LVL]=0. After you read this register, RNGA writes 0 to this
 * field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_ORU field. */
#define RNG_RD_SR_ORU(base)  ((RNG_SR_REG(base) & RNG_SR_ORU_MASK) >> RNG_SR_ORU_SHIFT)
#define RNG_BRD_SR_ORU(base) (BITBAND_ACCESS32(&RNG_SR_REG(base), RNG_SR_ORU_SHIFT))
/*@}*/

/*!
 * @name Register RNG_SR, field ERRI[3] (RO)
 *
 * Indicates whether an OR underflow condition has occurred since you last
 * cleared the error interrupt (CR[CLRI]) or RNGA was reset, regardless of whether the
 * error interrupt is masked (CR[INTM]). An OR underflow condition occurs when
 * you read OR[RANDOUT] and SR[OREG_LVL]=0. After you reset the error-interrupt
 * indicator (via CR[CLRI]), RNGA writes 0 to this field.
 *
 * Values:
 * - 0 - No underflow
 * - 1 - Underflow
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_ERRI field. */
#define RNG_RD_SR_ERRI(base) ((RNG_SR_REG(base) & RNG_SR_ERRI_MASK) >> RNG_SR_ERRI_SHIFT)
#define RNG_BRD_SR_ERRI(base) (BITBAND_ACCESS32(&RNG_SR_REG(base), RNG_SR_ERRI_SHIFT))
/*@}*/

/*!
 * @name Register RNG_SR, field SLP[4] (RO)
 *
 * Specifies whether RNGA is in Sleep or Normal mode. You can also enter Sleep
 * mode by asserting the DOZE signal.
 *
 * Values:
 * - 0 - Normal mode
 * - 1 - Sleep (low-power) mode
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_SLP field. */
#define RNG_RD_SR_SLP(base)  ((RNG_SR_REG(base) & RNG_SR_SLP_MASK) >> RNG_SR_SLP_SHIFT)
#define RNG_BRD_SR_SLP(base) (BITBAND_ACCESS32(&RNG_SR_REG(base), RNG_SR_SLP_SHIFT))
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_LVL[15:8] (RO)
 *
 * Indicates the number of random-data words that are in OR[RANDOUT], which
 * indicates whether OR[RANDOUT] is valid.If you read OR[RANDOUT] when SR[OREG_LVL]
 * is not 0, then the contents of a random number contained in OR[RANDOUT] are
 * returned, and RNGA writes 0 to both OR[RANDOUT] and SR[OREG_LVL].
 *
 * Values:
 * - 0 - No words (empty)
 * - 1 - One word (valid)
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_OREG_LVL field. */
#define RNG_RD_SR_OREG_LVL(base) ((RNG_SR_REG(base) & RNG_SR_OREG_LVL_MASK) >> RNG_SR_OREG_LVL_SHIFT)
#define RNG_BRD_SR_OREG_LVL(base) (RNG_RD_SR_OREG_LVL(base))
/*@}*/

/*!
 * @name Register RNG_SR, field OREG_SIZE[23:16] (RO)
 *
 * Indicates the size of the Output (OR) register in terms of the number of
 * 32-bit random-data words it can hold.
 *
 * Values:
 * - 1 - One word (this value is fixed)
 */
/*@{*/
/*! @brief Read current value of the RNG_SR_OREG_SIZE field. */
#define RNG_RD_SR_OREG_SIZE(base) ((RNG_SR_REG(base) & RNG_SR_OREG_SIZE_MASK) >> RNG_SR_OREG_SIZE_SHIFT)
#define RNG_BRD_SR_OREG_SIZE(base) (RNG_RD_SR_OREG_SIZE(base))
/*@}*/

/*******************************************************************************
 * RNG_ER - RNGA Entropy Register
 ******************************************************************************/

/*!
 * @brief RNG_ER - RNGA Entropy Register (WORZ)
 *
 * Reset value: 0x00000000U
 *
 * Specifies an entropy value that RNGA uses in addition to its ring oscillators
 * to seed its pseudorandom algorithm. This is a write-only register; reads
 * return all zeros.
 */
/*!
 * @name Constants and macros for entire RNG_ER register
 */
/*@{*/
#define RNG_RD_ER(base)          (RNG_ER_REG(base))
#define RNG_WR_ER(base, value)   (RNG_ER_REG(base) = (value))
#define RNG_RMW_ER(base, mask, value) (RNG_WR_ER(base, (RNG_RD_ER(base) & ~(mask)) | (value)))
/*@}*/

/*******************************************************************************
 * RNG_OR - RNGA Output Register
 ******************************************************************************/

/*!
 * @brief RNG_OR - RNGA Output Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * Stores a random-data word generated by RNGA.
 */
/*!
 * @name Constants and macros for entire RNG_OR register
 */
/*@{*/
#define RNG_RD_OR(base)          (RNG_OR_REG(base))
/*@}*/

/*
 * MKS22F25612 RTC
 *
 * Secure Real Time Clock
 *
 * Registers defined in this header file:
 * - RTC_TSR - RTC Time Seconds Register
 * - RTC_TPR - RTC Time Prescaler Register
 * - RTC_TAR - RTC Time Alarm Register
 * - RTC_TCR - RTC Time Compensation Register
 * - RTC_CR - RTC Control Register
 * - RTC_SR - RTC Status Register
 * - RTC_LR - RTC Lock Register
 * - RTC_IER - RTC Interrupt Enable Register
 * - RTC_WAR - RTC Write Access Register
 * - RTC_RAR - RTC Read Access Register
 */

#define RTC_INSTANCE_COUNT (1U) /*!< Number of instances of the RTC module. */
#define RTC_IDX (0U) /*!< Instance number for RTC. */

/*******************************************************************************
 * RTC_TSR - RTC Time Seconds Register
 ******************************************************************************/

/*!
 * @brief RTC_TSR - RTC Time Seconds Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TSR register
 */
/*@{*/
#define RTC_RD_TSR(base)         (RTC_TSR_REG(base))
#define RTC_WR_TSR(base, value)  (RTC_TSR_REG(base) = (value))
#define RTC_RMW_TSR(base, mask, value) (RTC_WR_TSR(base, (RTC_RD_TSR(base) & ~(mask)) | (value)))
#define RTC_SET_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) |  (value)))
#define RTC_CLR_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) & ~(value)))
#define RTC_TOG_TSR(base, value) (RTC_WR_TSR(base, RTC_RD_TSR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TPR - RTC Time Prescaler Register
 ******************************************************************************/

/*!
 * @brief RTC_TPR - RTC Time Prescaler Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TPR register
 */
/*@{*/
#define RTC_RD_TPR(base)         (RTC_TPR_REG(base))
#define RTC_WR_TPR(base, value)  (RTC_TPR_REG(base) = (value))
#define RTC_RMW_TPR(base, mask, value) (RTC_WR_TPR(base, (RTC_RD_TPR(base) & ~(mask)) | (value)))
#define RTC_SET_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) |  (value)))
#define RTC_CLR_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) & ~(value)))
#define RTC_TOG_TPR(base, value) (RTC_WR_TPR(base, RTC_RD_TPR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TPR bitfields
 */

/*!
 * @name Register RTC_TPR, field TPR[15:0] (RW)
 *
 * When the time counter is enabled, the TPR is read only and increments every
 * 32.768 kHz clock cycle. The time counter will read as zero when SR[TOF] or
 * SR[TIF] are set. When the time counter is disabled, the TPR can be read or
 * written. The TSR[TSR] increments when bit 14 of the TPR transitions from a logic one
 * to a logic zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_TPR_TPR field. */
#define RTC_RD_TPR_TPR(base) ((RTC_TPR_REG(base) & RTC_TPR_TPR_MASK) >> RTC_TPR_TPR_SHIFT)
#define RTC_BRD_TPR_TPR(base) (RTC_RD_TPR_TPR(base))

/*! @brief Set the TPR field to a new value. */
#define RTC_WR_TPR_TPR(base, value) (RTC_RMW_TPR(base, RTC_TPR_TPR_MASK, RTC_TPR_TPR(value)))
#define RTC_BWR_TPR_TPR(base, value) (RTC_WR_TPR_TPR(base, value))
/*@}*/

/*******************************************************************************
 * RTC_TAR - RTC Time Alarm Register
 ******************************************************************************/

/*!
 * @brief RTC_TAR - RTC Time Alarm Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TAR register
 */
/*@{*/
#define RTC_RD_TAR(base)         (RTC_TAR_REG(base))
#define RTC_WR_TAR(base, value)  (RTC_TAR_REG(base) = (value))
#define RTC_RMW_TAR(base, mask, value) (RTC_WR_TAR(base, (RTC_RD_TAR(base) & ~(mask)) | (value)))
#define RTC_SET_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) |  (value)))
#define RTC_CLR_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) & ~(value)))
#define RTC_TOG_TAR(base, value) (RTC_WR_TAR(base, RTC_RD_TAR(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * RTC_TCR - RTC Time Compensation Register
 ******************************************************************************/

/*!
 * @brief RTC_TCR - RTC Time Compensation Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_TCR register
 */
/*@{*/
#define RTC_RD_TCR(base)         (RTC_TCR_REG(base))
#define RTC_WR_TCR(base, value)  (RTC_TCR_REG(base) = (value))
#define RTC_RMW_TCR(base, mask, value) (RTC_WR_TCR(base, (RTC_RD_TCR(base) & ~(mask)) | (value)))
#define RTC_SET_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) |  (value)))
#define RTC_CLR_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) & ~(value)))
#define RTC_TOG_TCR(base, value) (RTC_WR_TCR(base, RTC_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_TCR bitfields
 */

/*!
 * @name Register RTC_TCR, field TCR[7:0] (RW)
 *
 * Configures the number of 32.768 kHz clock cycles in each second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 *
 * Values:
 * - 10000000 - Time Prescaler Register overflows every 32896 clock cycles.
 * - 11111111 - Time Prescaler Register overflows every 32769 clock cycles.
 * - 0 - Time Prescaler Register overflows every 32768 clock cycles.
 * - 1 - Time Prescaler Register overflows every 32767 clock cycles.
 * - 1111111 - Time Prescaler Register overflows every 32641 clock cycles.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCR field. */
#define RTC_RD_TCR_TCR(base) ((RTC_TCR_REG(base) & RTC_TCR_TCR_MASK) >> RTC_TCR_TCR_SHIFT)
#define RTC_BRD_TCR_TCR(base) (RTC_RD_TCR_TCR(base))

/*! @brief Set the TCR field to a new value. */
#define RTC_WR_TCR_TCR(base, value) (RTC_RMW_TCR(base, RTC_TCR_TCR_MASK, RTC_TCR_TCR(value)))
#define RTC_BWR_TCR_TCR(base, value) (RTC_WR_TCR_TCR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIR[15:8] (RW)
 *
 * Configures the compensation interval in seconds from 1 to 256 to control how
 * frequently the TCR should adjust the number of 32.768 kHz cycles in each
 * second. The value written should be one less than the number of seconds. For
 * example, write zero to configure for a compensation interval of one second. This
 * register is double buffered and writes do not take affect until the end of the
 * current compensation interval.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIR field. */
#define RTC_RD_TCR_CIR(base) ((RTC_TCR_REG(base) & RTC_TCR_CIR_MASK) >> RTC_TCR_CIR_SHIFT)
#define RTC_BRD_TCR_CIR(base) (RTC_RD_TCR_CIR(base))

/*! @brief Set the CIR field to a new value. */
#define RTC_WR_TCR_CIR(base, value) (RTC_RMW_TCR(base, RTC_TCR_CIR_MASK, RTC_TCR_CIR(value)))
#define RTC_BWR_TCR_CIR(base, value) (RTC_WR_TCR_CIR(base, value))
/*@}*/

/*!
 * @name Register RTC_TCR, field TCV[23:16] (RO)
 *
 * Current value used by the compensation logic for the present second interval.
 * Updated once a second if the CIC equals 0 with the contents of the TCR field.
 * If the CIC does not equal zero then it is loaded with zero (compensation is
 * not enabled for that second increment).
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_TCV field. */
#define RTC_RD_TCR_TCV(base) ((RTC_TCR_REG(base) & RTC_TCR_TCV_MASK) >> RTC_TCR_TCV_SHIFT)
#define RTC_BRD_TCR_TCV(base) (RTC_RD_TCR_TCV(base))
/*@}*/

/*!
 * @name Register RTC_TCR, field CIC[31:24] (RO)
 *
 * Current value of the compensation interval counter. If the compensation
 * interval counter equals zero then it is loaded with the contents of the CIR. If the
 * CIC does not equal zero then it is decremented once a second.
 */
/*@{*/
/*! @brief Read current value of the RTC_TCR_CIC field. */
#define RTC_RD_TCR_CIC(base) ((RTC_TCR_REG(base) & RTC_TCR_CIC_MASK) >> RTC_TCR_CIC_SHIFT)
#define RTC_BRD_TCR_CIC(base) (RTC_RD_TCR_CIC(base))
/*@}*/

/*******************************************************************************
 * RTC_CR - RTC Control Register
 ******************************************************************************/

/*!
 * @brief RTC_CR - RTC Control Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire RTC_CR register
 */
/*@{*/
#define RTC_RD_CR(base)          (RTC_CR_REG(base))
#define RTC_WR_CR(base, value)   (RTC_CR_REG(base) = (value))
#define RTC_RMW_CR(base, mask, value) (RTC_WR_CR(base, (RTC_RD_CR(base) & ~(mask)) | (value)))
#define RTC_SET_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) |  (value)))
#define RTC_CLR_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) & ~(value)))
#define RTC_TOG_CR(base, value)  (RTC_WR_CR(base, RTC_RD_CR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_CR bitfields
 */

/*!
 * @name Register RTC_CR, field SWR[0] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - Resets all RTC registers except for the SWR bit and the RTC_WAR and
 *     RTC_RAR registers . The SWR bit is cleared by VBAT POR and by software
 *     explicitly clearing it.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SWR field. */
#define RTC_RD_CR_SWR(base)  ((RTC_CR_REG(base) & RTC_CR_SWR_MASK) >> RTC_CR_SWR_SHIFT)
#define RTC_BRD_CR_SWR(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT))

/*! @brief Set the SWR field to a new value. */
#define RTC_WR_CR_SWR(base, value) (RTC_RMW_CR(base, RTC_CR_SWR_MASK, RTC_CR_SWR(value)))
#define RTC_BWR_CR_SWR(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SWR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field WPE[1] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin is disabled.
 * - 1 - Wakeup pin is enabled and wakeup pin asserts if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPE field. */
#define RTC_RD_CR_WPE(base)  ((RTC_CR_REG(base) & RTC_CR_WPE_MASK) >> RTC_CR_WPE_SHIFT)
#define RTC_BRD_CR_WPE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT))

/*! @brief Set the WPE field to a new value. */
#define RTC_WR_CR_WPE(base, value) (RTC_RMW_CR(base, RTC_CR_WPE_MASK, RTC_CR_WPE(value)))
#define RTC_BWR_CR_WPE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SUP[2] (RW)
 *
 * Values:
 * - 0 - Non-supervisor mode write accesses are not supported and generate a bus
 *     error.
 * - 1 - Non-supervisor mode write accesses are supported.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SUP field. */
#define RTC_RD_CR_SUP(base)  ((RTC_CR_REG(base) & RTC_CR_SUP_MASK) >> RTC_CR_SUP_SHIFT)
#define RTC_BRD_CR_SUP(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT))

/*! @brief Set the SUP field to a new value. */
#define RTC_WR_CR_SUP(base, value) (RTC_RMW_CR(base, RTC_CR_SUP_MASK, RTC_CR_SUP(value)))
#define RTC_BWR_CR_SUP(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SUP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field UM[3] (RW)
 *
 * Allows SR[TCE] to be written even when the Status Register is locked. When
 * set, the SR[TCE] can always be written if the SR[TIF] or SR[TOF] are set or if
 * the SR[TCE] is clear.
 *
 * Values:
 * - 0 - Registers cannot be written when locked.
 * - 1 - Registers can be written when locked under limited conditions.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_UM field. */
#define RTC_RD_CR_UM(base)   ((RTC_CR_REG(base) & RTC_CR_UM_MASK) >> RTC_CR_UM_SHIFT)
#define RTC_BRD_CR_UM(base)  (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT))

/*! @brief Set the UM field to a new value. */
#define RTC_WR_CR_UM(base, value) (RTC_RMW_CR(base, RTC_CR_UM_MASK, RTC_CR_UM(value)))
#define RTC_BWR_CR_UM(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_UM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field WPS[4] (RW)
 *
 * The wakeup pin is optional and not available on all devices.
 *
 * Values:
 * - 0 - Wakeup pin asserts (active low, open drain) if the RTC interrupt
 *     asserts or the wakeup pin is turned on.
 * - 1 - Wakeup pin instead outputs the RTC 32kHz clock, provided the wakeup pin
 *     is turned on and the 32kHz clock is output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_WPS field. */
#define RTC_RD_CR_WPS(base)  ((RTC_CR_REG(base) & RTC_CR_WPS_MASK) >> RTC_CR_WPS_SHIFT)
#define RTC_BRD_CR_WPS(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT))

/*! @brief Set the WPS field to a new value. */
#define RTC_WR_CR_WPS(base, value) (RTC_RMW_CR(base, RTC_CR_WPS_MASK, RTC_CR_WPS(value)))
#define RTC_BWR_CR_WPS(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_WPS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field OSCE[8] (RW)
 *
 * Values:
 * - 0 - 32.768 kHz oscillator is disabled.
 * - 1 - 32.768 kHz oscillator is enabled. After setting this bit, wait the
 *     oscillator startup time before enabling the time counter to allow the 32.768
 *     kHz clock time to stabilize.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_OSCE field. */
#define RTC_RD_CR_OSCE(base) ((RTC_CR_REG(base) & RTC_CR_OSCE_MASK) >> RTC_CR_OSCE_SHIFT)
#define RTC_BRD_CR_OSCE(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT))

/*! @brief Set the OSCE field to a new value. */
#define RTC_WR_CR_OSCE(base, value) (RTC_RMW_CR(base, RTC_CR_OSCE_MASK, RTC_CR_OSCE(value)))
#define RTC_BWR_CR_OSCE(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_OSCE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field CLKO[9] (RW)
 *
 * Values:
 * - 0 - The 32 kHz clock is output to other peripherals.
 * - 1 - The 32 kHz clock is not output to other peripherals.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_CLKO field. */
#define RTC_RD_CR_CLKO(base) ((RTC_CR_REG(base) & RTC_CR_CLKO_MASK) >> RTC_CR_CLKO_SHIFT)
#define RTC_BRD_CR_CLKO(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT))

/*! @brief Set the CLKO field to a new value. */
#define RTC_WR_CR_CLKO(base, value) (RTC_RMW_CR(base, RTC_CR_CLKO_MASK, RTC_CR_CLKO(value)))
#define RTC_BWR_CR_CLKO(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_CLKO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC16P[10] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC16P field. */
#define RTC_RD_CR_SC16P(base) ((RTC_CR_REG(base) & RTC_CR_SC16P_MASK) >> RTC_CR_SC16P_SHIFT)
#define RTC_BRD_CR_SC16P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT))

/*! @brief Set the SC16P field to a new value. */
#define RTC_WR_CR_SC16P(base, value) (RTC_RMW_CR(base, RTC_CR_SC16P_MASK, RTC_CR_SC16P(value)))
#define RTC_BWR_CR_SC16P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC16P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC8P[11] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC8P field. */
#define RTC_RD_CR_SC8P(base) ((RTC_CR_REG(base) & RTC_CR_SC8P_MASK) >> RTC_CR_SC8P_SHIFT)
#define RTC_BRD_CR_SC8P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT))

/*! @brief Set the SC8P field to a new value. */
#define RTC_WR_CR_SC8P(base, value) (RTC_RMW_CR(base, RTC_CR_SC8P_MASK, RTC_CR_SC8P(value)))
#define RTC_BWR_CR_SC8P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC8P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC4P[12] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC4P field. */
#define RTC_RD_CR_SC4P(base) ((RTC_CR_REG(base) & RTC_CR_SC4P_MASK) >> RTC_CR_SC4P_SHIFT)
#define RTC_BRD_CR_SC4P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT))

/*! @brief Set the SC4P field to a new value. */
#define RTC_WR_CR_SC4P(base, value) (RTC_RMW_CR(base, RTC_CR_SC4P_MASK, RTC_CR_SC4P(value)))
#define RTC_BWR_CR_SC4P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC4P_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_CR, field SC2P[13] (RW)
 *
 * Values:
 * - 0 - Disable the load.
 * - 1 - Enable the additional load.
 */
/*@{*/
/*! @brief Read current value of the RTC_CR_SC2P field. */
#define RTC_RD_CR_SC2P(base) ((RTC_CR_REG(base) & RTC_CR_SC2P_MASK) >> RTC_CR_SC2P_SHIFT)
#define RTC_BRD_CR_SC2P(base) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT))

/*! @brief Set the SC2P field to a new value. */
#define RTC_WR_CR_SC2P(base, value) (RTC_RMW_CR(base, RTC_CR_SC2P_MASK, RTC_CR_SC2P(value)))
#define RTC_BWR_CR_SC2P(base, value) (BITBAND_ACCESS32(&RTC_CR_REG(base), RTC_CR_SC2P_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_SR - RTC Status Register
 ******************************************************************************/

/*!
 * @brief RTC_SR - RTC Status Register (RW)
 *
 * Reset value: 0x00000001U
 */
/*!
 * @name Constants and macros for entire RTC_SR register
 */
/*@{*/
#define RTC_RD_SR(base)          (RTC_SR_REG(base))
#define RTC_WR_SR(base, value)   (RTC_SR_REG(base) = (value))
#define RTC_RMW_SR(base, mask, value) (RTC_WR_SR(base, (RTC_RD_SR(base) & ~(mask)) | (value)))
#define RTC_SET_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) |  (value)))
#define RTC_CLR_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) & ~(value)))
#define RTC_TOG_SR(base, value)  (RTC_WR_SR(base, RTC_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_SR bitfields
 */

/*!
 * @name Register RTC_SR, field TIF[0] (RO)
 *
 * The time invalid flag is set on VBAT POR or software reset. The TSR and TPR
 * do not increment and read as zero when this bit is set. This bit is cleared by
 * writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time is valid.
 * - 1 - Time is invalid and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TIF field. */
#define RTC_RD_SR_TIF(base)  ((RTC_SR_REG(base) & RTC_SR_TIF_MASK) >> RTC_SR_TIF_SHIFT)
#define RTC_BRD_SR_TIF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TIF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TOF[1] (RO)
 *
 * Time overflow flag is set when the time counter is enabled and overflows. The
 * TSR and TPR do not increment and read as zero when this bit is set. This bit
 * is cleared by writing the TSR register when the time counter is disabled.
 *
 * Values:
 * - 0 - Time overflow has not occurred.
 * - 1 - Time overflow has occurred and time counter is read as zero.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TOF field. */
#define RTC_RD_SR_TOF(base)  ((RTC_SR_REG(base) & RTC_SR_TOF_MASK) >> RTC_SR_TOF_SHIFT)
#define RTC_BRD_SR_TOF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TOF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TAF[2] (RO)
 *
 * Time alarm flag is set when the TAR[TAR] equals the TSR[TSR] and the TSR[TSR]
 * increments. This bit is cleared by writing the TAR register.
 *
 * Values:
 * - 0 - Time alarm has not occurred.
 * - 1 - Time alarm has occurred.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TAF field. */
#define RTC_RD_SR_TAF(base)  ((RTC_SR_REG(base) & RTC_SR_TAF_MASK) >> RTC_SR_TAF_SHIFT)
#define RTC_BRD_SR_TAF(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TAF_SHIFT))
/*@}*/

/*!
 * @name Register RTC_SR, field TCE[4] (RW)
 *
 * When time counter is disabled the TSR register and TPR register are
 * writeable, but do not increment. When time counter is enabled the TSR register and TPR
 * register are not writeable, but increment.
 *
 * Values:
 * - 0 - Time counter is disabled.
 * - 1 - Time counter is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_SR_TCE field. */
#define RTC_RD_SR_TCE(base)  ((RTC_SR_REG(base) & RTC_SR_TCE_MASK) >> RTC_SR_TCE_SHIFT)
#define RTC_BRD_SR_TCE(base) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT))

/*! @brief Set the TCE field to a new value. */
#define RTC_WR_SR_TCE(base, value) (RTC_RMW_SR(base, RTC_SR_TCE_MASK, RTC_SR_TCE(value)))
#define RTC_BWR_SR_TCE(base, value) (BITBAND_ACCESS32(&RTC_SR_REG(base), RTC_SR_TCE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_LR - RTC Lock Register
 ******************************************************************************/

/*!
 * @brief RTC_LR - RTC Lock Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_LR register
 */
/*@{*/
#define RTC_RD_LR(base)          (RTC_LR_REG(base))
#define RTC_WR_LR(base, value)   (RTC_LR_REG(base) = (value))
#define RTC_RMW_LR(base, mask, value) (RTC_WR_LR(base, (RTC_RD_LR(base) & ~(mask)) | (value)))
#define RTC_SET_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) |  (value)))
#define RTC_CLR_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) & ~(value)))
#define RTC_TOG_LR(base, value)  (RTC_WR_LR(base, RTC_RD_LR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_LR bitfields
 */

/*!
 * @name Register RTC_LR, field TCL[3] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Time Compensation Register is locked and writes are ignored.
 * - 1 - Time Compensation Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_TCL field. */
#define RTC_RD_LR_TCL(base)  ((RTC_LR_REG(base) & RTC_LR_TCL_MASK) >> RTC_LR_TCL_SHIFT)
#define RTC_BRD_LR_TCL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT))

/*! @brief Set the TCL field to a new value. */
#define RTC_WR_LR_TCL(base, value) (RTC_RMW_LR(base, RTC_LR_TCL_MASK, RTC_LR_TCL(value)))
#define RTC_BWR_LR_TCL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_TCL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field CRL[4] (RW)
 *
 * After being cleared, this bit can only be set by VBAT POR.
 *
 * Values:
 * - 0 - Control Register is locked and writes are ignored.
 * - 1 - Control Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_CRL field. */
#define RTC_RD_LR_CRL(base)  ((RTC_LR_REG(base) & RTC_LR_CRL_MASK) >> RTC_LR_CRL_SHIFT)
#define RTC_BRD_LR_CRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT))

/*! @brief Set the CRL field to a new value. */
#define RTC_WR_LR_CRL(base, value) (RTC_RMW_LR(base, RTC_LR_CRL_MASK, RTC_LR_CRL(value)))
#define RTC_BWR_LR_CRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_CRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field SRL[5] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Status Register is locked and writes are ignored.
 * - 1 - Status Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_SRL field. */
#define RTC_RD_LR_SRL(base)  ((RTC_LR_REG(base) & RTC_LR_SRL_MASK) >> RTC_LR_SRL_SHIFT)
#define RTC_BRD_LR_SRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT))

/*! @brief Set the SRL field to a new value. */
#define RTC_WR_LR_SRL(base, value) (RTC_RMW_LR(base, RTC_LR_SRL_MASK, RTC_LR_SRL(value)))
#define RTC_BWR_LR_SRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_SRL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_LR, field LRL[6] (RW)
 *
 * After being cleared, this bit can be set only by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Lock Register is locked and writes are ignored.
 * - 1 - Lock Register is not locked and writes complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_LR_LRL field. */
#define RTC_RD_LR_LRL(base)  ((RTC_LR_REG(base) & RTC_LR_LRL_MASK) >> RTC_LR_LRL_SHIFT)
#define RTC_BRD_LR_LRL(base) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT))

/*! @brief Set the LRL field to a new value. */
#define RTC_WR_LR_LRL(base, value) (RTC_RMW_LR(base, RTC_LR_LRL_MASK, RTC_LR_LRL(value)))
#define RTC_BWR_LR_LRL(base, value) (BITBAND_ACCESS32(&RTC_LR_REG(base), RTC_LR_LRL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_IER - RTC Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief RTC_IER - RTC Interrupt Enable Register (RW)
 *
 * Reset value: 0x00000007U
 */
/*!
 * @name Constants and macros for entire RTC_IER register
 */
/*@{*/
#define RTC_RD_IER(base)         (RTC_IER_REG(base))
#define RTC_WR_IER(base, value)  (RTC_IER_REG(base) = (value))
#define RTC_RMW_IER(base, mask, value) (RTC_WR_IER(base, (RTC_RD_IER(base) & ~(mask)) | (value)))
#define RTC_SET_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) |  (value)))
#define RTC_CLR_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) & ~(value)))
#define RTC_TOG_IER(base, value) (RTC_WR_IER(base, RTC_RD_IER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_IER bitfields
 */

/*!
 * @name Register RTC_IER, field TIIE[0] (RW)
 *
 * Values:
 * - 0 - Time invalid flag does not generate an interrupt.
 * - 1 - Time invalid flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TIIE field. */
#define RTC_RD_IER_TIIE(base) ((RTC_IER_REG(base) & RTC_IER_TIIE_MASK) >> RTC_IER_TIIE_SHIFT)
#define RTC_BRD_IER_TIIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT))

/*! @brief Set the TIIE field to a new value. */
#define RTC_WR_IER_TIIE(base, value) (RTC_RMW_IER(base, RTC_IER_TIIE_MASK, RTC_IER_TIIE(value)))
#define RTC_BWR_IER_TIIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TIIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TOIE[1] (RW)
 *
 * Values:
 * - 0 - Time overflow flag does not generate an interrupt.
 * - 1 - Time overflow flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TOIE field. */
#define RTC_RD_IER_TOIE(base) ((RTC_IER_REG(base) & RTC_IER_TOIE_MASK) >> RTC_IER_TOIE_SHIFT)
#define RTC_BRD_IER_TOIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define RTC_WR_IER_TOIE(base, value) (RTC_RMW_IER(base, RTC_IER_TOIE_MASK, RTC_IER_TOIE(value)))
#define RTC_BWR_IER_TOIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TAIE[2] (RW)
 *
 * Values:
 * - 0 - Time alarm flag does not generate an interrupt.
 * - 1 - Time alarm flag does generate an interrupt.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TAIE field. */
#define RTC_RD_IER_TAIE(base) ((RTC_IER_REG(base) & RTC_IER_TAIE_MASK) >> RTC_IER_TAIE_SHIFT)
#define RTC_BRD_IER_TAIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT))

/*! @brief Set the TAIE field to a new value. */
#define RTC_WR_IER_TAIE(base, value) (RTC_RMW_IER(base, RTC_IER_TAIE_MASK, RTC_IER_TAIE(value)))
#define RTC_BWR_IER_TAIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TAIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field TSIE[4] (RW)
 *
 * The seconds interrupt is an edge-sensitive interrupt with a dedicated
 * interrupt vector. It is generated once a second and requires no software overhead
 * (there is no corresponding status flag to clear).
 *
 * Values:
 * - 0 - Seconds interrupt is disabled.
 * - 1 - Seconds interrupt is enabled.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_TSIE field. */
#define RTC_RD_IER_TSIE(base) ((RTC_IER_REG(base) & RTC_IER_TSIE_MASK) >> RTC_IER_TSIE_SHIFT)
#define RTC_BRD_IER_TSIE(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT))

/*! @brief Set the TSIE field to a new value. */
#define RTC_WR_IER_TSIE(base, value) (RTC_RMW_IER(base, RTC_IER_TSIE_MASK, RTC_IER_TSIE(value)))
#define RTC_BWR_IER_TSIE(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_TSIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_IER, field WPON[7] (RW)
 *
 * The wakeup pin is optional and not available on all devices. Whenever the
 * wakeup pin is enabled and this bit is set, the wakeup pin will assert.
 *
 * Values:
 * - 0 - No effect.
 * - 1 - If the wakeup pin is enabled, then the wakeup pin will assert.
 */
/*@{*/
/*! @brief Read current value of the RTC_IER_WPON field. */
#define RTC_RD_IER_WPON(base) ((RTC_IER_REG(base) & RTC_IER_WPON_MASK) >> RTC_IER_WPON_SHIFT)
#define RTC_BRD_IER_WPON(base) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT))

/*! @brief Set the WPON field to a new value. */
#define RTC_WR_IER_WPON(base, value) (RTC_RMW_IER(base, RTC_IER_WPON_MASK, RTC_IER_WPON(value)))
#define RTC_BWR_IER_WPON(base, value) (BITBAND_ACCESS32(&RTC_IER_REG(base), RTC_IER_WPON_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_WAR - RTC Write Access Register
 ******************************************************************************/

/*!
 * @brief RTC_WAR - RTC Write Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_WAR register
 */
/*@{*/
#define RTC_RD_WAR(base)         (RTC_WAR_REG(base))
#define RTC_WR_WAR(base, value)  (RTC_WAR_REG(base) = (value))
#define RTC_RMW_WAR(base, mask, value) (RTC_WR_WAR(base, (RTC_RD_WAR(base) & ~(mask)) | (value)))
#define RTC_SET_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) |  (value)))
#define RTC_CLR_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) & ~(value)))
#define RTC_TOG_WAR(base, value) (RTC_WR_WAR(base, RTC_RD_WAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_WAR bitfields
 */

/*!
 * @name Register RTC_WAR, field TSRW[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Seconds Register are ignored.
 * - 1 - Writes to the Time Seconds Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TSRW field. */
#define RTC_RD_WAR_TSRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TSRW_MASK) >> RTC_WAR_TSRW_SHIFT)
#define RTC_BRD_WAR_TSRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT))

/*! @brief Set the TSRW field to a new value. */
#define RTC_WR_WAR_TSRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TSRW_MASK, RTC_WAR_TSRW(value)))
#define RTC_BWR_WAR_TSRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TSRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TPRW[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Prescaler Register are ignored.
 * - 1 - Writes to the Time Prescaler Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TPRW field. */
#define RTC_RD_WAR_TPRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TPRW_MASK) >> RTC_WAR_TPRW_SHIFT)
#define RTC_BRD_WAR_TPRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT))

/*! @brief Set the TPRW field to a new value. */
#define RTC_WR_WAR_TPRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TPRW_MASK, RTC_WAR_TPRW(value)))
#define RTC_BWR_WAR_TPRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TPRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TARW[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Alarm Register are ignored.
 * - 1 - Writes to the Time Alarm Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TARW field. */
#define RTC_RD_WAR_TARW(base) ((RTC_WAR_REG(base) & RTC_WAR_TARW_MASK) >> RTC_WAR_TARW_SHIFT)
#define RTC_BRD_WAR_TARW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT))

/*! @brief Set the TARW field to a new value. */
#define RTC_WR_WAR_TARW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TARW_MASK, RTC_WAR_TARW(value)))
#define RTC_BWR_WAR_TARW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TARW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field TCRW[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Time Compensation Register are ignored.
 * - 1 - Writes to the Time Compensation Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_TCRW field. */
#define RTC_RD_WAR_TCRW(base) ((RTC_WAR_REG(base) & RTC_WAR_TCRW_MASK) >> RTC_WAR_TCRW_SHIFT)
#define RTC_BRD_WAR_TCRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT))

/*! @brief Set the TCRW field to a new value. */
#define RTC_WR_WAR_TCRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_TCRW_MASK, RTC_WAR_TCRW(value)))
#define RTC_BWR_WAR_TCRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_TCRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field CRW[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Control Register are ignored.
 * - 1 - Writes to the Control Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_CRW field. */
#define RTC_RD_WAR_CRW(base) ((RTC_WAR_REG(base) & RTC_WAR_CRW_MASK) >> RTC_WAR_CRW_SHIFT)
#define RTC_BRD_WAR_CRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT))

/*! @brief Set the CRW field to a new value. */
#define RTC_WR_WAR_CRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_CRW_MASK, RTC_WAR_CRW(value)))
#define RTC_BWR_WAR_CRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_CRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field SRW[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Status Register are ignored.
 * - 1 - Writes to the Status Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_SRW field. */
#define RTC_RD_WAR_SRW(base) ((RTC_WAR_REG(base) & RTC_WAR_SRW_MASK) >> RTC_WAR_SRW_SHIFT)
#define RTC_BRD_WAR_SRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT))

/*! @brief Set the SRW field to a new value. */
#define RTC_WR_WAR_SRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_SRW_MASK, RTC_WAR_SRW(value)))
#define RTC_BWR_WAR_SRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_SRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field LRW[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Lock Register are ignored.
 * - 1 - Writes to the Lock Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_LRW field. */
#define RTC_RD_WAR_LRW(base) ((RTC_WAR_REG(base) & RTC_WAR_LRW_MASK) >> RTC_WAR_LRW_SHIFT)
#define RTC_BRD_WAR_LRW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT))

/*! @brief Set the LRW field to a new value. */
#define RTC_WR_WAR_LRW(base, value) (RTC_RMW_WAR(base, RTC_WAR_LRW_MASK, RTC_WAR_LRW(value)))
#define RTC_BWR_WAR_LRW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_LRW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_WAR, field IERW[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Writes to the Interupt Enable Register are ignored.
 * - 1 - Writes to the Interrupt Enable Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_WAR_IERW field. */
#define RTC_RD_WAR_IERW(base) ((RTC_WAR_REG(base) & RTC_WAR_IERW_MASK) >> RTC_WAR_IERW_SHIFT)
#define RTC_BRD_WAR_IERW(base) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT))

/*! @brief Set the IERW field to a new value. */
#define RTC_WR_WAR_IERW(base, value) (RTC_RMW_WAR(base, RTC_WAR_IERW_MASK, RTC_WAR_IERW(value)))
#define RTC_BWR_WAR_IERW(base, value) (BITBAND_ACCESS32(&RTC_WAR_REG(base), RTC_WAR_IERW_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * RTC_RAR - RTC Read Access Register
 ******************************************************************************/

/*!
 * @brief RTC_RAR - RTC Read Access Register (RW)
 *
 * Reset value: 0x000000FFU
 */
/*!
 * @name Constants and macros for entire RTC_RAR register
 */
/*@{*/
#define RTC_RD_RAR(base)         (RTC_RAR_REG(base))
#define RTC_WR_RAR(base, value)  (RTC_RAR_REG(base) = (value))
#define RTC_RMW_RAR(base, mask, value) (RTC_WR_RAR(base, (RTC_RD_RAR(base) & ~(mask)) | (value)))
#define RTC_SET_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) |  (value)))
#define RTC_CLR_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) & ~(value)))
#define RTC_TOG_RAR(base, value) (RTC_WR_RAR(base, RTC_RD_RAR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual RTC_RAR bitfields
 */

/*!
 * @name Register RTC_RAR, field TSRR[0] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Seconds Register are ignored.
 * - 1 - Reads to the Time Seconds Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TSRR field. */
#define RTC_RD_RAR_TSRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TSRR_MASK) >> RTC_RAR_TSRR_SHIFT)
#define RTC_BRD_RAR_TSRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT))

/*! @brief Set the TSRR field to a new value. */
#define RTC_WR_RAR_TSRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TSRR_MASK, RTC_RAR_TSRR(value)))
#define RTC_BWR_RAR_TSRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TSRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TPRR[1] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Pprescaler Register are ignored.
 * - 1 - Reads to the Time Prescaler Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TPRR field. */
#define RTC_RD_RAR_TPRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TPRR_MASK) >> RTC_RAR_TPRR_SHIFT)
#define RTC_BRD_RAR_TPRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT))

/*! @brief Set the TPRR field to a new value. */
#define RTC_WR_RAR_TPRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TPRR_MASK, RTC_RAR_TPRR(value)))
#define RTC_BWR_RAR_TPRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TPRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TARR[2] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Alarm Register are ignored.
 * - 1 - Reads to the Time Alarm Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TARR field. */
#define RTC_RD_RAR_TARR(base) ((RTC_RAR_REG(base) & RTC_RAR_TARR_MASK) >> RTC_RAR_TARR_SHIFT)
#define RTC_BRD_RAR_TARR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT))

/*! @brief Set the TARR field to a new value. */
#define RTC_WR_RAR_TARR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TARR_MASK, RTC_RAR_TARR(value)))
#define RTC_BWR_RAR_TARR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TARR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field TCRR[3] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Time Compensation Register are ignored.
 * - 1 - Reads to the Time Compensation Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_TCRR field. */
#define RTC_RD_RAR_TCRR(base) ((RTC_RAR_REG(base) & RTC_RAR_TCRR_MASK) >> RTC_RAR_TCRR_SHIFT)
#define RTC_BRD_RAR_TCRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT))

/*! @brief Set the TCRR field to a new value. */
#define RTC_WR_RAR_TCRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_TCRR_MASK, RTC_RAR_TCRR(value)))
#define RTC_BWR_RAR_TCRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_TCRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field CRR[4] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Control Register are ignored.
 * - 1 - Reads to the Control Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_CRR field. */
#define RTC_RD_RAR_CRR(base) ((RTC_RAR_REG(base) & RTC_RAR_CRR_MASK) >> RTC_RAR_CRR_SHIFT)
#define RTC_BRD_RAR_CRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT))

/*! @brief Set the CRR field to a new value. */
#define RTC_WR_RAR_CRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_CRR_MASK, RTC_RAR_CRR(value)))
#define RTC_BWR_RAR_CRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_CRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field SRR[5] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Status Register are ignored.
 * - 1 - Reads to the Status Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_SRR field. */
#define RTC_RD_RAR_SRR(base) ((RTC_RAR_REG(base) & RTC_RAR_SRR_MASK) >> RTC_RAR_SRR_SHIFT)
#define RTC_BRD_RAR_SRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT))

/*! @brief Set the SRR field to a new value. */
#define RTC_WR_RAR_SRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_SRR_MASK, RTC_RAR_SRR(value)))
#define RTC_BWR_RAR_SRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_SRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field LRR[6] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Lock Register are ignored.
 * - 1 - Reads to the Lock Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_LRR field. */
#define RTC_RD_RAR_LRR(base) ((RTC_RAR_REG(base) & RTC_RAR_LRR_MASK) >> RTC_RAR_LRR_SHIFT)
#define RTC_BRD_RAR_LRR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT))

/*! @brief Set the LRR field to a new value. */
#define RTC_WR_RAR_LRR(base, value) (RTC_RMW_RAR(base, RTC_RAR_LRR_MASK, RTC_RAR_LRR(value)))
#define RTC_BWR_RAR_LRR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_LRR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register RTC_RAR, field IERR[7] (RW)
 *
 * After being cleared, this bit is set only by system reset. It is not affected
 * by VBAT POR or software reset.
 *
 * Values:
 * - 0 - Reads to the Interrupt Enable Register are ignored.
 * - 1 - Reads to the Interrupt Enable Register complete as normal.
 */
/*@{*/
/*! @brief Read current value of the RTC_RAR_IERR field. */
#define RTC_RD_RAR_IERR(base) ((RTC_RAR_REG(base) & RTC_RAR_IERR_MASK) >> RTC_RAR_IERR_SHIFT)
#define RTC_BRD_RAR_IERR(base) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT))

/*! @brief Set the IERR field to a new value. */
#define RTC_WR_RAR_IERR(base, value) (RTC_RMW_RAR(base, RTC_RAR_IERR_MASK, RTC_RAR_IERR(value)))
#define RTC_BWR_RAR_IERR(base, value) (BITBAND_ACCESS32(&RTC_RAR_REG(base), RTC_RAR_IERR_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 SIM
 *
 * System Integration Module
 *
 * Registers defined in this header file:
 * - SIM_SOPT1 - System Options Register 1
 * - SIM_SOPT2 - System Options Register 2
 * - SIM_SOPT5 - System Options Register 5
 * - SIM_SOPT7 - System Options Register 7
 * - SIM_SOPT9 - System Options Register 9
 * - SIM_SDID - System Device Identification Register
 * - SIM_SCGC4 - System Clock Gating Control Register 4
 * - SIM_SCGC5 - System Clock Gating Control Register 5
 * - SIM_SCGC6 - System Clock Gating Control Register 6
 * - SIM_SCGC7 - System Clock Gating Control Register 7
 * - SIM_CLKDIV1 - System Clock Divider Register 1
 * - SIM_CLKDIV2 - System Clock Divider Register 2
 * - SIM_FCFG1 - Flash Configuration Register 1
 * - SIM_FCFG2 - Flash Configuration Register 2
 * - SIM_UIDH - Unique Identification Register High
 * - SIM_UIDMH - Unique Identification Register Mid-High
 * - SIM_UIDML - Unique Identification Register Mid Low
 * - SIM_UIDL - Unique Identification Register Low
 * - SIM_CLKDIV3 - System Clock Divider Register 3
 * - SIM_MISCCTL - Miscellaneous Control Register
 */

#define SIM_INSTANCE_COUNT (1U) /*!< Number of instances of the SIM module. */
#define SIM_IDX (0U) /*!< Instance number for SIM. */

/*******************************************************************************
 * SIM_SOPT1 - System Options Register 1
 ******************************************************************************/

/*!
 * @brief SIM_SOPT1 - System Options Register 1 (RW)
 *
 * Reset value: 0x00000000U
 *
 * The SOPT1 register is only reset on POR or LVD.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT1 register
 */
/*@{*/
#define SIM_RD_SOPT1(base)       (SIM_SOPT1_REG(base))
#define SIM_WR_SOPT1(base, value) (SIM_SOPT1_REG(base) = (value))
#define SIM_RMW_SOPT1(base, mask, value) (SIM_WR_SOPT1(base, (SIM_RD_SOPT1(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) |  (value)))
#define SIM_CLR_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) & ~(value)))
#define SIM_TOG_SOPT1(base, value) (SIM_WR_SOPT1(base, SIM_RD_SOPT1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT1 bitfields
 */

/*!
 * @name Register SIM_SOPT1, field RAMSIZE[15:12] (RO)
 *
 * This field specifies the amount of system RAM available on the device.
 *
 * Values:
 * - 0001 - 8 KB
 * - 0011 - 16 KB
 * - 0100 - 24 KB
 * - 0101 - 32 KB
 * - 0110 - 48 KB
 * - 0111 - 64 KB
 * - 1000 - 96 KB
 * - 1001 - 128 KB
 * - 1011 - 256 KB
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_RAMSIZE field. */

// Alex:
#define SIM_SOPT1_RAMSIZE_SHIFT                  12
#define SIM_RD_SOPT1_RAMSIZE(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_RAMSIZE_MASK) >> SIM_SOPT1_RAMSIZE_SHIFT)
#define SIM_BRD_SOPT1_RAMSIZE(base) (SIM_RD_SOPT1_RAMSIZE(base))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KOUT[17:16] (RW)
 *
 * Outputs the ERCLK32K on the selected pin in all modes of operation (including
 * LLS/VLLS and System Reset), overriding the existing pin mux configuration for
 * that pin. This field is reset only on POR/LVD.
 *
 * Values:
 * - 00 - ERCLK32K is not output.
 * - 01 - ERCLK32K is output on PTE0.
 * - 10 - ERCLK32K is output on PTE26.
 * - 11 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KOUT field. */
#define SIM_RD_SOPT1_OSC32KOUT(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KOUT_MASK) >> SIM_SOPT1_OSC32KOUT_SHIFT)
#define SIM_BRD_SOPT1_OSC32KOUT(base) (SIM_RD_SOPT1_OSC32KOUT(base))

/*! @brief Set the OSC32KOUT field to a new value. */
#define SIM_WR_SOPT1_OSC32KOUT(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KOUT_MASK, SIM_SOPT1_OSC32KOUT(value)))
#define SIM_BWR_SOPT1_OSC32KOUT(base, value) (SIM_WR_SOPT1_OSC32KOUT(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT1, field OSC32KSEL[19:18] (RW)
 *
 * Selects the 32 kHz clock source (ERCLK32K) for LPTMR. This field is reset
 * only on POR/LVD.
 *
 * Values:
 * - 00 - System oscillator (OSC32KCLK)
 * - 01 - Reserved
 * - 10 - RTC 32.768kHz oscillator
 * - 11 - LPO 1 kHz
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT1_OSC32KSEL field. */
#define SIM_RD_SOPT1_OSC32KSEL(base) ((SIM_SOPT1_REG(base) & SIM_SOPT1_OSC32KSEL_MASK) >> SIM_SOPT1_OSC32KSEL_SHIFT)
#define SIM_BRD_SOPT1_OSC32KSEL(base) (SIM_RD_SOPT1_OSC32KSEL(base))

/*! @brief Set the OSC32KSEL field to a new value. */
#define SIM_WR_SOPT1_OSC32KSEL(base, value) (SIM_RMW_SOPT1(base, SIM_SOPT1_OSC32KSEL_MASK, SIM_SOPT1_OSC32KSEL(value)))
#define SIM_BWR_SOPT1_OSC32KSEL(base, value) (SIM_WR_SOPT1_OSC32KSEL(base, value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT2 - System Options Register 2
 ******************************************************************************/

/*!
 * @brief SIM_SOPT2 - System Options Register 2 (RW)
 *
 * Reset value: 0x00001000U
 *
 * SOPT2 contains the controls for selecting many of the module clock source
 * options on this device. See the Clock Distribution chapter for more information
 * including clocking diagrams and definitions of device clocks.
 */
/*!
 * @name Constants and macros for entire SIM_SOPT2 register
 */
/*@{*/
#define SIM_RD_SOPT2(base)       (SIM_SOPT2_REG(base))
#define SIM_WR_SOPT2(base, value) (SIM_SOPT2_REG(base) = (value))
#define SIM_RMW_SOPT2(base, mask, value) (SIM_WR_SOPT2(base, (SIM_RD_SOPT2(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) |  (value)))
#define SIM_CLR_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) & ~(value)))
#define SIM_TOG_SOPT2(base, value) (SIM_WR_SOPT2(base, SIM_RD_SOPT2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT2 bitfields
 */

/*!
 * @name Register SIM_SOPT2, field LPI2C1SRC[3:2] (RW)
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_LPI2C1SRC field. */
#define SIM_RD_SOPT2_LPI2C1SRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_LPI2C1SRC_MASK) >> SIM_SOPT2_LPI2C1SRC_SHIFT)
#define SIM_BRD_SOPT2_LPI2C1SRC(base) (SIM_RD_SOPT2_LPI2C1SRC(base))

/*! @brief Set the LPI2C1SRC field to a new value. */
#define SIM_WR_SOPT2_LPI2C1SRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_LPI2C1SRC_MASK, SIM_SOPT2_LPI2C1SRC(value)))
#define SIM_BWR_SOPT2_LPI2C1SRC(base, value) (SIM_WR_SOPT2_LPI2C1SRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field RTCCLKOUTSEL[4] (RW)
 *
 * Selects either the RTC 1 Hz clock or the 32.768kHz clock to be output on the
 * RTC_CLKOUT pin.
 *
 * Values:
 * - 0 - RTC 1 Hz clock is output on the RTC_CLKOUT pin.
 * - 1 - RTC 32.768kHz clock is output on the RTC_CLKOUT pin.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_RTCCLKOUTSEL field. */
#define SIM_RD_SOPT2_RTCCLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_RTCCLKOUTSEL_MASK) >> SIM_SOPT2_RTCCLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_RTCCLKOUTSEL(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_RTCCLKOUTSEL_SHIFT))

/*! @brief Set the RTCCLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_RTCCLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_RTCCLKOUTSEL_MASK, SIM_SOPT2_RTCCLKOUTSEL(value)))
#define SIM_BWR_SOPT2_RTCCLKOUTSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_RTCCLKOUTSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field CLKOUTSEL[7:5] (RW)
 *
 * Selects the clock to output on the CLKOUT pin.
 *
 * Values:
 * - 000 - Reserved
 * - 001 - Reserved
 * - 010 - Flash clock
 * - 011 - LPO clock (1 kHz)
 * - 100 - MCGIRCLK
 * - 101 - RTC 32.768kHz clock
 * - 110 - OSCERCLK0
 * - 111 - IRC 48 MHz clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_CLKOUTSEL field. */
#define SIM_RD_SOPT2_CLKOUTSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_CLKOUTSEL_MASK) >> SIM_SOPT2_CLKOUTSEL_SHIFT)
#define SIM_BRD_SOPT2_CLKOUTSEL(base) (SIM_RD_SOPT2_CLKOUTSEL(base))

/*! @brief Set the CLKOUTSEL field to a new value. */
#define SIM_WR_SOPT2_CLKOUTSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_CLKOUTSEL_MASK, SIM_SOPT2_CLKOUTSEL(value)))
#define SIM_BWR_SOPT2_CLKOUTSEL(base, value) (SIM_WR_SOPT2_CLKOUTSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field LPI2C0SRC[11:10] (RW)
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_LPI2C0SRC field. */
#define SIM_RD_SOPT2_LPI2C0SRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_LPI2C0SRC_MASK) >> SIM_SOPT2_LPI2C0SRC_SHIFT)
#define SIM_BRD_SOPT2_LPI2C0SRC(base) (SIM_RD_SOPT2_LPI2C0SRC(base))

/*! @brief Set the LPI2C0SRC field to a new value. */
#define SIM_WR_SOPT2_LPI2C0SRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_LPI2C0SRC_MASK, SIM_SOPT2_LPI2C0SRC(value)))
#define SIM_BWR_SOPT2_LPI2C0SRC(base, value) (SIM_WR_SOPT2_LPI2C0SRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TRACECLKSEL[12] (RW)
 *
 * Selects the core/system clock, or MCG output clock (MCGOUTCLK) as the trace
 * clock source.
 *
 * Values:
 * - 0 - MCGOUTCLK
 * - 1 - Core/system clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TRACECLKSEL field. */
#define SIM_RD_SOPT2_TRACECLKSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TRACECLKSEL_MASK) >> SIM_SOPT2_TRACECLKSEL_SHIFT)
#define SIM_BRD_SOPT2_TRACECLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_TRACECLKSEL_SHIFT))

/*! @brief Set the TRACECLKSEL field to a new value. */
#define SIM_WR_SOPT2_TRACECLKSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TRACECLKSEL_MASK, SIM_SOPT2_TRACECLKSEL(value)))
#define SIM_BWR_SOPT2_TRACECLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_TRACECLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field PLLFLLSEL[17:16] (RW)
 *
 * Selects the high frequency clock for various peripheral clocking options.
 *
 * Values:
 * - 00 - MCGFLLCLK clock
 * - 01 - MCGPLLCLK clock
 * - 10 - Reserved
 * - 11 - IRC48 MHz clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_PLLFLLSEL field. */
#define SIM_RD_SOPT2_PLLFLLSEL(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_PLLFLLSEL_MASK) >> SIM_SOPT2_PLLFLLSEL_SHIFT)
#define SIM_BRD_SOPT2_PLLFLLSEL(base) (SIM_RD_SOPT2_PLLFLLSEL(base))

/*! @brief Set the PLLFLLSEL field to a new value. */
#define SIM_WR_SOPT2_PLLFLLSEL(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_PLLFLLSEL_MASK, SIM_SOPT2_PLLFLLSEL(value)))
#define SIM_BWR_SOPT2_PLLFLLSEL(base, value) (SIM_WR_SOPT2_PLLFLLSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field USBSRC[18] (RW)
 *
 * Selects the clock source for the USB 48 MHz clock.
 *
 * Values:
 * - 0 - External bypass clock (USB_CLKIN).
 * - 1 - MCGFLLCLK, or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL], and then divided by the USB fractional divider as configured by
 *     SIM_CLKDIV2[USBFRAC, USBDIV].
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_USBSRC field. */
#define SIM_RD_SOPT2_USBSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_USBSRC_MASK) >> SIM_SOPT2_USBSRC_SHIFT)
#define SIM_BRD_SOPT2_USBSRC(base) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_USBSRC_SHIFT))

/*! @brief Set the USBSRC field to a new value. */
#define SIM_WR_SOPT2_USBSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_USBSRC_MASK, SIM_SOPT2_USBSRC(value)))
#define SIM_BWR_SOPT2_USBSRC(base, value) (BITBAND_ACCESS32(&SIM_SOPT2_REG(base), SIM_SOPT2_USBSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field FLEXIOSRC[23:22] (RW)
 *
 * Selects the clock source for the FlexIO transmit and receive clock.
 *
 * Values:
 * - 00 - I2S0_MCLK or System clock, selected via SIM_MISCCTRL[FlEXIOS0]
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_FLEXIOSRC field. */
#define SIM_RD_SOPT2_FLEXIOSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_FLEXIOSRC_MASK) >> SIM_SOPT2_FLEXIOSRC_SHIFT)
#define SIM_BRD_SOPT2_FLEXIOSRC(base) (SIM_RD_SOPT2_FLEXIOSRC(base))

/*! @brief Set the FLEXIOSRC field to a new value. */
#define SIM_WR_SOPT2_FLEXIOSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_FLEXIOSRC_MASK, SIM_SOPT2_FLEXIOSRC(value)))
#define SIM_BWR_SOPT2_FLEXIOSRC(base, value) (SIM_WR_SOPT2_FLEXIOSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field TPMSRC[25:24] (RW)
 *
 * Selects the clock source for the TPM counter clock
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_TPMSRC field. */
#define SIM_RD_SOPT2_TPMSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_TPMSRC_MASK) >> SIM_SOPT2_TPMSRC_SHIFT)
#define SIM_BRD_SOPT2_TPMSRC(base) (SIM_RD_SOPT2_TPMSRC(base))

/*! @brief Set the TPMSRC field to a new value. */
#define SIM_WR_SOPT2_TPMSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_TPMSRC_MASK, SIM_SOPT2_TPMSRC(value)))
#define SIM_BWR_SOPT2_TPMSRC(base, value) (SIM_WR_SOPT2_TPMSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT2, field LPUARTSRC[27:26] (RW)
 *
 * Selects the clock source for the LPUART transmit and receive clock.
 *
 * Values:
 * - 00 - Clock disabled
 * - 01 - MCGFLLCLK , or MCGPLLCLK , or IRC48M clock as selected by
 *     SOPT2[PLLFLLSEL].
 * - 10 - OSCERCLK clock
 * - 11 - MCGIRCLK clock
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT2_LPUARTSRC field. */
#define SIM_RD_SOPT2_LPUARTSRC(base) ((SIM_SOPT2_REG(base) & SIM_SOPT2_LPUARTSRC_MASK) >> SIM_SOPT2_LPUARTSRC_SHIFT)
#define SIM_BRD_SOPT2_LPUARTSRC(base) (SIM_RD_SOPT2_LPUARTSRC(base))

/*! @brief Set the LPUARTSRC field to a new value. */
#define SIM_WR_SOPT2_LPUARTSRC(base, value) (SIM_RMW_SOPT2(base, SIM_SOPT2_LPUARTSRC_MASK, SIM_SOPT2_LPUARTSRC(value)))
#define SIM_BWR_SOPT2_LPUARTSRC(base, value) (SIM_WR_SOPT2_LPUARTSRC(base, value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT5 - System Options Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SOPT5 - System Options Register 5 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT5 register
 */
/*@{*/
#define SIM_RD_SOPT5(base)       (SIM_SOPT5_REG(base))
#define SIM_WR_SOPT5(base, value) (SIM_SOPT5_REG(base) = (value))
#define SIM_RMW_SOPT5(base, mask, value) (SIM_WR_SOPT5(base, (SIM_RD_SOPT5(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) |  (value)))
#define SIM_CLR_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) & ~(value)))
#define SIM_TOG_SOPT5(base, value) (SIM_WR_SOPT5(base, SIM_RD_SOPT5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT5 bitfields
 */

/*!
 * @name Register SIM_SOPT5, field UART0TXSRC[1:0] (RW)
 *
 * Selects the source for the UART 0 transmit data.
 *
 * Values:
 * - 00 - UART0_TX pin
 * - 01 - UART0_TX pin modulated with TPM1 channel 0 output
 * - 10 - UART0_TX pin modulated with TPM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0TXSRC field. */
#define SIM_RD_SOPT5_UART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0TXSRC_MASK) >> SIM_SOPT5_UART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0TXSRC(base) (SIM_RD_SOPT5_UART0TXSRC(base))

/*! @brief Set the UART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0TXSRC_MASK, SIM_SOPT5_UART0TXSRC(value)))
#define SIM_BWR_SOPT5_UART0TXSRC(base, value) (SIM_WR_SOPT5_UART0TXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART0RXSRC[3:2] (RW)
 *
 * Selects the source for the UART 0 receive data.
 *
 * Values:
 * - 00 - UART0_RX pin
 * - 01 - CMP0
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART0RXSRC field. */
#define SIM_RD_SOPT5_UART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART0RXSRC_MASK) >> SIM_SOPT5_UART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART0RXSRC(base) (SIM_RD_SOPT5_UART0RXSRC(base))

/*! @brief Set the UART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART0RXSRC_MASK, SIM_SOPT5_UART0RXSRC(value)))
#define SIM_BWR_SOPT5_UART0RXSRC(base, value) (SIM_WR_SOPT5_UART0RXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1TXSRC[5:4] (RW)
 *
 * Selects the source for the UART 1 transmit data.
 *
 * Values:
 * - 00 - UART1_TX pin
 * - 01 - UART1_TX pin modulated with TPM1 channel 0 output
 * - 10 - UART1_TX pin modulated with TPM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1TXSRC field. */
#define SIM_RD_SOPT5_UART1TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1TXSRC_MASK) >> SIM_SOPT5_UART1TXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1TXSRC(base) (SIM_RD_SOPT5_UART1TXSRC(base))

/*! @brief Set the UART1TXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1TXSRC_MASK, SIM_SOPT5_UART1TXSRC(value)))
#define SIM_BWR_SOPT5_UART1TXSRC(base, value) (SIM_WR_SOPT5_UART1TXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field UART1RXSRC[7:6] (RW)
 *
 * Selects the source for the UART 1 receive data.
 *
 * Values:
 * - 00 - UART1_RX pin
 * - 01 - CMP0
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_UART1RXSRC field. */
#define SIM_RD_SOPT5_UART1RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_UART1RXSRC_MASK) >> SIM_SOPT5_UART1RXSRC_SHIFT)
#define SIM_BRD_SOPT5_UART1RXSRC(base) (SIM_RD_SOPT5_UART1RXSRC(base))

/*! @brief Set the UART1RXSRC field to a new value. */
#define SIM_WR_SOPT5_UART1RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_UART1RXSRC_MASK, SIM_SOPT5_UART1RXSRC(value)))
#define SIM_BWR_SOPT5_UART1RXSRC(base, value) (SIM_WR_SOPT5_UART1RXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0TXSRC[17:16] (RW)
 *
 * Selects the source for the UART0 transmit data.
 *
 * Values:
 * - 00 - LPUART0_TX pin
 * - 01 - LPUART0_TX pin modulated with TPM1 channel 0 output
 * - 10 - LPUART0_TX pin modulated with TPM2 channel 0 output
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_LPUART0TXSRC field. */
#define SIM_RD_SOPT5_LPUART0TXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_LPUART0TXSRC_MASK) >> SIM_SOPT5_LPUART0TXSRC_SHIFT)
#define SIM_BRD_SOPT5_LPUART0TXSRC(base) (SIM_RD_SOPT5_LPUART0TXSRC(base))

/*! @brief Set the LPUART0TXSRC field to a new value. */
#define SIM_WR_SOPT5_LPUART0TXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_LPUART0TXSRC_MASK, SIM_SOPT5_LPUART0TXSRC(value)))
#define SIM_BWR_SOPT5_LPUART0TXSRC(base, value) (SIM_WR_SOPT5_LPUART0TXSRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT5, field LPUART0RXSRC[19:18] (RW)
 *
 * Selects the source for the LPUART0 receive data.
 *
 * Values:
 * - 00 - LPUART0_RX pin
 * - 01 - CMP0 output
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT5_LPUART0RXSRC field. */
#define SIM_RD_SOPT5_LPUART0RXSRC(base) ((SIM_SOPT5_REG(base) & SIM_SOPT5_LPUART0RXSRC_MASK) >> SIM_SOPT5_LPUART0RXSRC_SHIFT)
#define SIM_BRD_SOPT5_LPUART0RXSRC(base) (SIM_RD_SOPT5_LPUART0RXSRC(base))

/*! @brief Set the LPUART0RXSRC field to a new value. */
#define SIM_WR_SOPT5_LPUART0RXSRC(base, value) (SIM_RMW_SOPT5(base, SIM_SOPT5_LPUART0RXSRC_MASK, SIM_SOPT5_LPUART0RXSRC(value)))
#define SIM_BWR_SOPT5_LPUART0RXSRC(base, value) (SIM_WR_SOPT5_LPUART0RXSRC(base, value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT7 - System Options Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SOPT7 - System Options Register 7 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT7 register
 */
/*@{*/
#define SIM_RD_SOPT7(base)       (SIM_SOPT7_REG(base))
#define SIM_WR_SOPT7(base, value) (SIM_SOPT7_REG(base) = (value))
#define SIM_RMW_SOPT7(base, mask, value) (SIM_WR_SOPT7(base, (SIM_RD_SOPT7(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) |  (value)))
#define SIM_CLR_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) & ~(value)))
#define SIM_TOG_SOPT7(base, value) (SIM_WR_SOPT7(base, SIM_RD_SOPT7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT7 bitfields
 */

/*!
 * @name Register SIM_SOPT7, field ADC0TRGSEL[3:0] (RW)
 *
 * Selects the ADC0 trigger source when alternative triggers are functional in
 * stop and VLPS modes. .
 *
 * Values:
 * - 0000 - PDB external trigger pin input (PDB0_EXTRG)
 * - 0001 - High speed comparator 0 output
 * - 0010 - Reserved
 * - 0011 - Reserved
 * - 0100 - PIT trigger 0
 * - 0101 - PIT trigger 1
 * - 0110 - PIT trigger 2
 * - 0111 - PIT trigger 3
 * - 1000 - TPM0 overflow
 * - 1001 - TPM1 overflow
 * - 1010 - TPM2 overflow
 * - 1011 - Reserved
 * - 1100 - RTC alarm
 * - 1101 - RTC seconds
 * - 1110 - Low-power timer (LPTMR) trigger
 * - 1111 - TPM1 channel 0 (A pretrigger) and channel 1 (B pretrigger)
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0TRGSEL field. */
#define SIM_RD_SOPT7_ADC0TRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0TRGSEL_MASK) >> SIM_SOPT7_ADC0TRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0TRGSEL(base) (SIM_RD_SOPT7_ADC0TRGSEL(base))

/*! @brief Set the ADC0TRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0TRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0TRGSEL_MASK, SIM_SOPT7_ADC0TRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0TRGSEL(base, value) (SIM_WR_SOPT7_ADC0TRGSEL(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0PRETRGSEL[4] (RW)
 *
 * Selects the ADC0 pre-trigger source when alternative triggers are enabled
 * through ADC0ALTTRGEN. This field is not used when the TPM trigger source is
 * selected.
 *
 * Values:
 * - 0 - Pre-trigger A
 * - 1 - Pre-trigger B
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0PRETRGSEL field. */
#define SIM_RD_SOPT7_ADC0PRETRGSEL(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0PRETRGSEL_MASK) >> SIM_SOPT7_ADC0PRETRGSEL_SHIFT)
#define SIM_BRD_SOPT7_ADC0PRETRGSEL(base) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT))

/*! @brief Set the ADC0PRETRGSEL field to a new value. */
#define SIM_WR_SOPT7_ADC0PRETRGSEL(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0PRETRGSEL_MASK, SIM_SOPT7_ADC0PRETRGSEL(value)))
#define SIM_BWR_SOPT7_ADC0PRETRGSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0PRETRGSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT7, field ADC0ALTTRGEN[7] (RW)
 *
 * Enable alternative conversion triggers for ADC0.
 *
 * Values:
 * - 0 - PDB trigger selected for ADC0.
 * - 1 - Alternate trigger selected for ADC0.
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT7_ADC0ALTTRGEN field. */
#define SIM_RD_SOPT7_ADC0ALTTRGEN(base) ((SIM_SOPT7_REG(base) & SIM_SOPT7_ADC0ALTTRGEN_MASK) >> SIM_SOPT7_ADC0ALTTRGEN_SHIFT)
#define SIM_BRD_SOPT7_ADC0ALTTRGEN(base) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT))

/*! @brief Set the ADC0ALTTRGEN field to a new value. */
#define SIM_WR_SOPT7_ADC0ALTTRGEN(base, value) (SIM_RMW_SOPT7(base, SIM_SOPT7_ADC0ALTTRGEN_MASK, SIM_SOPT7_ADC0ALTTRGEN(value)))
#define SIM_BWR_SOPT7_ADC0ALTTRGEN(base, value) (BITBAND_ACCESS32(&SIM_SOPT7_REG(base), SIM_SOPT7_ADC0ALTTRGEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SOPT9 - System Options Register 9
 ******************************************************************************/

/*!
 * @brief SIM_SOPT9 - System Options Register 9 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_SOPT9 register
 */
/*@{*/
#define SIM_RD_SOPT9(base)       (SIM_SOPT9_REG(base))
#define SIM_WR_SOPT9(base, value) (SIM_SOPT9_REG(base) = (value))
#define SIM_RMW_SOPT9(base, mask, value) (SIM_WR_SOPT9(base, (SIM_RD_SOPT9(base) & ~(mask)) | (value)))
#define SIM_SET_SOPT9(base, value) (SIM_WR_SOPT9(base, SIM_RD_SOPT9(base) |  (value)))
#define SIM_CLR_SOPT9(base, value) (SIM_WR_SOPT9(base, SIM_RD_SOPT9(base) & ~(value)))
#define SIM_TOG_SOPT9(base, value) (SIM_WR_SOPT9(base, SIM_RD_SOPT9(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SOPT9 bitfields
 */

/*!
 * @name Register SIM_SOPT9, field TPM1CH0SRC[19:18] (RW)
 *
 * Selects the source for TPM1 channel 0 input capture. When the TPM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - TPM1_CH0 signal
 * - 01 - CMP0 output
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_TPM1CH0SRC field. */
#define SIM_RD_SOPT9_TPM1CH0SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_TPM1CH0SRC_MASK) >> SIM_SOPT9_TPM1CH0SRC_SHIFT)
#define SIM_BRD_SOPT9_TPM1CH0SRC(base) (SIM_RD_SOPT9_TPM1CH0SRC(base))

/*! @brief Set the TPM1CH0SRC field to a new value. */
#define SIM_WR_SOPT9_TPM1CH0SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_TPM1CH0SRC_MASK, SIM_SOPT9_TPM1CH0SRC(value)))
#define SIM_BWR_SOPT9_TPM1CH0SRC(base, value) (SIM_WR_SOPT9_TPM1CH0SRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field TPM2CH0SRC[21:20] (RW)
 *
 * Selects the source for TPM2 channel 0 input capture. When the TPM is not in
 * input capture mode, clear this field.
 *
 * Values:
 * - 00 - TPM2_CH0 signal
 * - 01 - CMP0 output
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_TPM2CH0SRC field. */
#define SIM_RD_SOPT9_TPM2CH0SRC(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_TPM2CH0SRC_MASK) >> SIM_SOPT9_TPM2CH0SRC_SHIFT)
#define SIM_BRD_SOPT9_TPM2CH0SRC(base) (SIM_RD_SOPT9_TPM2CH0SRC(base))

/*! @brief Set the TPM2CH0SRC field to a new value. */
#define SIM_WR_SOPT9_TPM2CH0SRC(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_TPM2CH0SRC_MASK, SIM_SOPT9_TPM2CH0SRC(value)))
#define SIM_BWR_SOPT9_TPM2CH0SRC(base, value) (SIM_WR_SOPT9_TPM2CH0SRC(base, value))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field TPM0CLKSEL[24] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM0 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - TPM_CLKIN0 pin
 * - 1 - TPM_CLKIN1 pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_TPM0CLKSEL field. */
#define SIM_RD_SOPT9_TPM0CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_TPM0CLKSEL_MASK) >> SIM_SOPT9_TPM0CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_TPM0CLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM0CLKSEL_SHIFT))

/*! @brief Set the TPM0CLKSEL field to a new value. */
#define SIM_WR_SOPT9_TPM0CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_TPM0CLKSEL_MASK, SIM_SOPT9_TPM0CLKSEL(value)))
#define SIM_BWR_SOPT9_TPM0CLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM0CLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field TPM1CLKSEL[25] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM1 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - TPM_CLKIN0 pin
 * - 1 - TPM_CLKIN1 pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_TPM1CLKSEL field. */
#define SIM_RD_SOPT9_TPM1CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_TPM1CLKSEL_MASK) >> SIM_SOPT9_TPM1CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_TPM1CLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM1CLKSEL_SHIFT))

/*! @brief Set the TPM1CLKSEL field to a new value. */
#define SIM_WR_SOPT9_TPM1CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_TPM1CLKSEL_MASK, SIM_SOPT9_TPM1CLKSEL(value)))
#define SIM_BWR_SOPT9_TPM1CLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM1CLKSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SOPT9, field TPM2CLKSEL[26] (RW)
 *
 * Selects the external pin used to drive the clock to the TPM2 module. The
 * selected pin must also be configured for the TPM external clock function through
 * the appropriate pin control register in the port control module.
 *
 * Values:
 * - 0 - TPM_CLKIN0 pin
 * - 1 - TPM_CLKIN1 pin
 */
/*@{*/
/*! @brief Read current value of the SIM_SOPT9_TPM2CLKSEL field. */
#define SIM_RD_SOPT9_TPM2CLKSEL(base) ((SIM_SOPT9_REG(base) & SIM_SOPT9_TPM2CLKSEL_MASK) >> SIM_SOPT9_TPM2CLKSEL_SHIFT)
#define SIM_BRD_SOPT9_TPM2CLKSEL(base) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM2CLKSEL_SHIFT))

/*! @brief Set the TPM2CLKSEL field to a new value. */
#define SIM_WR_SOPT9_TPM2CLKSEL(base, value) (SIM_RMW_SOPT9(base, SIM_SOPT9_TPM2CLKSEL_MASK, SIM_SOPT9_TPM2CLKSEL(value)))
#define SIM_BWR_SOPT9_TPM2CLKSEL(base, value) (BITBAND_ACCESS32(&SIM_SOPT9_REG(base), SIM_SOPT9_TPM2CLKSEL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SDID - System Device Identification Register
 ******************************************************************************/

/*!
 * @brief SIM_SDID - System Device Identification Register (RO)
 *
 * Reset value: 0x00000B80U
 */
/*!
 * @name Constants and macros for entire SIM_SDID register
 */
/*@{*/
#define SIM_RD_SDID(base)        (SIM_SDID_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_SDID bitfields
 */

/*!
 * @name Register SIM_SDID, field PINID[3:0] (RO)
 *
 * Specifies the pincount of the device.
 *
 * Values:
 * - 0000 - Reserved
 * - 0001 - Reserved
 * - 0010 - 32-pin
 * - 0011 - Reserved
 * - 0100 - 48-pin
 * - 0101 - 64-pin
 * - 0110 - 80-pin
 * - 0111 - 81-pin or 121-pin
 * - 1000 - 100-pin
 * - 1001 - 121-pin
 * - 1010 - 144-pin
 * - 1011 - Custom pinout (WLCSP)
 * - 1100 - 169-pin
 * - 1101 - Reserved
 * - 1110 - 256-pin
 * - 1111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_PINID field. */
#define SIM_RD_SDID_PINID(base) ((SIM_SDID_REG(base) & SIM_SDID_PINID_MASK) >> SIM_SDID_PINID_SHIFT)
#define SIM_BRD_SDID_PINID(base) (SIM_RD_SDID_PINID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMID[6:4] (RO)
 *
 * This field is maintained for compatibility only, but has been superceded by
 * the SERIESID, FAMILYID and SUBFAMID fields in this register.
 *
 * Values:
 * - 000 - KS0x or KS1x
 * - 001 - KS2x
 * - 010 - KS3x
 * - 011 - KS4x
 * - 100 - KS5x
 * - 101 - KS6x
 * - 110 - KS7x
 * - 111 - KS8x or KS9x
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMID field. */
#define SIM_RD_SDID_FAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMID_MASK) >> SIM_SDID_FAMID_SHIFT)
#define SIM_BRD_SDID_FAMID(base) (SIM_RD_SDID_FAMID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field DIEID[11:7] (RO)
 *
 * Specifies the silicon feature set identication number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_DIEID field. */
#define SIM_RD_SDID_DIEID(base) ((SIM_SDID_REG(base) & SIM_SDID_DIEID_MASK) >> SIM_SDID_DIEID_SHIFT)
#define SIM_BRD_SDID_DIEID(base) (SIM_RD_SDID_DIEID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field REVID[15:12] (RO)
 *
 * Specifies the silicon implementation number for the device.
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_REVID field. */
#define SIM_RD_SDID_REVID(base) ((SIM_SDID_REG(base) & SIM_SDID_REVID_MASK) >> SIM_SDID_REVID_SHIFT)
#define SIM_BRD_SDID_REVID(base) (SIM_RD_SDID_REVID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field SERIESID[23:20] (RO)
 *
 * Specifies the Kinetis series of the device.
 *
 * Values:
 * - 0000 - Kinetis K series
 * - 0001 - Kinetis L series
 * - 0101 - Kinetis W series
 * - 0110 - Kinetis V series
 * - 0111 - Kinetis KS series
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SERIESID field. */
#define SIM_RD_SDID_SERIESID(base) ((SIM_SDID_REG(base) & SIM_SDID_SERIESID_MASK) >> SIM_SDID_SERIESID_SHIFT)
#define SIM_BRD_SDID_SERIESID(base) (SIM_RD_SDID_SERIESID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field SUBFAMID[27:24] (RO)
 *
 * Specifies the Kinetis sub-family of the device.
 *
 * Values:
 * - 0000 - KSx0 Subfamily
 * - 0010 - KSx2 Subfamily
 * - 0100 - KSx4 Subfamily
 * - 0110 - KSx6 Subfamily
 * - 0111 - KSx7 Subfamily
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_SUBFAMID field. */
#define SIM_RD_SDID_SUBFAMID(base) ((SIM_SDID_REG(base) & SIM_SDID_SUBFAMID_MASK) >> SIM_SDID_SUBFAMID_SHIFT)
#define SIM_BRD_SDID_SUBFAMID(base) (SIM_RD_SDID_SUBFAMID(base))
/*@}*/

/*!
 * @name Register SIM_SDID, field FAMILYID[31:28] (RO)
 *
 * Specifies the Kinetis family of the device.
 *
 * Values:
 * - 0000 - KS0x Family
 * - 0001 - KS1x Family
 * - 0010 - KS2x Family
 * - 0011 - KS3x Family
 * - 0100 - KS4x Family
 * - 0101 - KS5x Family
 * - 0110 - KS6x Family
 * - 0111 - KS7x Family
 * - 1000 - KS8x Family
 * - 1001 - KS9x Family
 */
/*@{*/
/*! @brief Read current value of the SIM_SDID_FAMILYID field. */
#define SIM_RD_SDID_FAMILYID(base) ((SIM_SDID_REG(base) & SIM_SDID_FAMILYID_MASK) >> SIM_SDID_FAMILYID_SHIFT)
#define SIM_BRD_SDID_FAMILYID(base) (SIM_RD_SDID_FAMILYID(base))
/*@}*/

/*******************************************************************************
 * SIM_SCGC4 - System Clock Gating Control Register 4
 ******************************************************************************/

/*!
 * @brief SIM_SCGC4 - System Clock Gating Control Register 4 (RW)
 *
 * Reset value: 0xF0000030U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC4 register
 */
/*@{*/
#define SIM_RD_SCGC4(base)       (SIM_SCGC4_REG(base))
#define SIM_WR_SCGC4(base, value) (SIM_SCGC4_REG(base) = (value))
#define SIM_RMW_SCGC4(base, mask, value) (SIM_WR_SCGC4(base, (SIM_RD_SCGC4(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) |  (value)))
#define SIM_CLR_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) & ~(value)))
#define SIM_TOG_SCGC4(base, value) (SIM_WR_SCGC4(base, SIM_RD_SCGC4(base) ^  (value)))
/*@}*/

/* Unified clock gate bit access macros */
#define SIM_SCGC_BIT_REG(base, index)        (*((volatile uint32_t *)&SIM_SCGC4_REG(base) + (((uint32_t)(index) >> 5) - 3U)))
#define SIM_SCGC_BIT_SHIFT(index)            ((uint32_t)(index) & ((1U << 5) - 1U))
#define SIM_RD_SCGC_BIT(base, index)         (SIM_SCGC_BIT_REG((base), (index)) & (1U << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BRD_SCGC_BIT(base, index)        (BITBAND_ACCESS32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index)))
#define SIM_WR_SCGC_BIT(base, index, value)  (SIM_SCGC_BIT_REG((base), (index)) = (SIM_SCGC_BIT_REG((base), (index)) & ~(1U << SIM_SCGC_BIT_SHIFT(index))) | ((uint32_t)(value) << SIM_SCGC_BIT_SHIFT(index)))
#define SIM_BWR_SCGC_BIT(base, index, value) (BITBAND_ACCESS32(&SIM_SCGC_BIT_REG((base), (index)), SIM_SCGC_BIT_SHIFT(index)) = (uint32_t)(value))

/*
 * Constants & macros for individual SIM_SCGC4 bitfields
 */

/*!
 * @name Register SIM_SCGC4, field EWM[1] (RW)
 *
 * This bit controls the clock gate to the EWM module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_EWM field. */
#define SIM_RD_SCGC4_EWM(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_EWM_MASK) >> SIM_SCGC4_EWM_SHIFT)
#define SIM_BRD_SCGC4_EWM(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT))

/*! @brief Set the EWM field to a new value. */
#define SIM_WR_SCGC4_EWM(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_EWM_MASK, SIM_SCGC4_EWM(value)))
#define SIM_BWR_SCGC4_EWM(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_EWM_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field LPI2C0[6] (RW)
 *
 * This bit controls the clock gate to the LPI2C0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_LPI2C0 field. */
#define SIM_RD_SCGC4_LPI2C0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_LPI2C0_MASK) >> SIM_SCGC4_LPI2C0_SHIFT)
#define SIM_BRD_SCGC4_LPI2C0(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_LPI2C0_SHIFT))

/*! @brief Set the LPI2C0 field to a new value. */
#define SIM_WR_SCGC4_LPI2C0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_LPI2C0_MASK, SIM_SCGC4_LPI2C0(value)))
#define SIM_BWR_SCGC4_LPI2C0(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_LPI2C0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field LPI2C1[7] (RW)
 *
 * This bit controls the clock gate to the LPI2C1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_LPI2C1 field. */
#define SIM_RD_SCGC4_LPI2C1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_LPI2C1_MASK) >> SIM_SCGC4_LPI2C1_SHIFT)
#define SIM_BRD_SCGC4_LPI2C1(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_LPI2C1_SHIFT))

/*! @brief Set the LPI2C1 field to a new value. */
#define SIM_WR_SCGC4_LPI2C1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_LPI2C1_MASK, SIM_SCGC4_LPI2C1(value)))
#define SIM_BWR_SCGC4_LPI2C1(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_LPI2C1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART0[10] (RW)
 *
 * This bit controls the clock gate to the UART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART0 field. */
#define SIM_RD_SCGC4_UART0(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART0_MASK) >> SIM_SCGC4_UART0_SHIFT)
#define SIM_BRD_SCGC4_UART0(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT))

/*! @brief Set the UART0 field to a new value. */
#define SIM_WR_SCGC4_UART0(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART0_MASK, SIM_SCGC4_UART0(value)))
#define SIM_BWR_SCGC4_UART0(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART1[11] (RW)
 *
 * This bit controls the clock gate to the UART1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART1 field. */
#define SIM_RD_SCGC4_UART1(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART1_MASK) >> SIM_SCGC4_UART1_SHIFT)
#define SIM_BRD_SCGC4_UART1(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT))

/*! @brief Set the UART1 field to a new value. */
#define SIM_WR_SCGC4_UART1(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART1_MASK, SIM_SCGC4_UART1(value)))
#define SIM_BWR_SCGC4_UART1(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field UART2[12] (RW)
 *
 * This bit controls the clock gate to the UART2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_UART2 field. */
#define SIM_RD_SCGC4_UART2(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_UART2_MASK) >> SIM_SCGC4_UART2_SHIFT)
#define SIM_BRD_SCGC4_UART2(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT))

/*! @brief Set the UART2 field to a new value. */
#define SIM_WR_SCGC4_UART2(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_UART2_MASK, SIM_SCGC4_UART2(value)))
#define SIM_BWR_SCGC4_UART2(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_UART2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field USBOTG[18] (RW)
 *
 * This bit controls the clock gate to the USB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_USBOTG field. */
#define SIM_RD_SCGC4_USBOTG(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_USBOTG_MASK) >> SIM_SCGC4_USBOTG_SHIFT)
#define SIM_BRD_SCGC4_USBOTG(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_USBOTG_SHIFT))

/*! @brief Set the USBOTG field to a new value. */
#define SIM_WR_SCGC4_USBOTG(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_USBOTG_MASK, SIM_SCGC4_USBOTG(value)))
#define SIM_BWR_SCGC4_USBOTG(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_USBOTG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC4, field CMP[19] (RW)
 *
 * This bit controls the clock gate to the comparator module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC4_CMP field. */
#define SIM_RD_SCGC4_CMP(base) ((SIM_SCGC4_REG(base) & SIM_SCGC4_CMP_MASK) >> SIM_SCGC4_CMP_SHIFT)
#define SIM_BRD_SCGC4_CMP(base) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT))

/*! @brief Set the CMP field to a new value. */
#define SIM_WR_SCGC4_CMP(base, value) (SIM_RMW_SCGC4(base, SIM_SCGC4_CMP_MASK, SIM_SCGC4_CMP(value)))
#define SIM_BWR_SCGC4_CMP(base, value) (BITBAND_ACCESS32(&SIM_SCGC4_REG(base), SIM_SCGC4_CMP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC5 - System Clock Gating Control Register 5
 ******************************************************************************/

/*!
 * @brief SIM_SCGC5 - System Clock Gating Control Register 5 (RW)
 *
 * Reset value: 0x00040182U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC5 register
 */
/*@{*/
#define SIM_RD_SCGC5(base)       (SIM_SCGC5_REG(base))
#define SIM_WR_SCGC5(base, value) (SIM_SCGC5_REG(base) = (value))
#define SIM_RMW_SCGC5(base, mask, value) (SIM_WR_SCGC5(base, (SIM_RD_SCGC5(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) |  (value)))
#define SIM_CLR_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) & ~(value)))
#define SIM_TOG_SCGC5(base, value) (SIM_WR_SCGC5(base, SIM_RD_SCGC5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC5 bitfields
 */

/*!
 * @name Register SIM_SCGC5, field LPTMR[0] (RW)
 *
 * This bit controls software access to the Low Power Timer module.
 *
 * Values:
 * - 0 - Access disabled
 * - 1 - Access enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_LPTMR field. */
#define SIM_RD_SCGC5_LPTMR(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_LPTMR_MASK) >> SIM_SCGC5_LPTMR_SHIFT)
#define SIM_BRD_SCGC5_LPTMR(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTMR_SHIFT))

/*! @brief Set the LPTMR field to a new value. */
#define SIM_WR_SCGC5_LPTMR(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_LPTMR_MASK, SIM_SCGC5_LPTMR(value)))
#define SIM_BWR_SCGC5_LPTMR(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_LPTMR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTA[9] (RW)
 *
 * This bit controls the clock gate to the Port A module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTA field. */
#define SIM_RD_SCGC5_PORTA(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTA_MASK) >> SIM_SCGC5_PORTA_SHIFT)
#define SIM_BRD_SCGC5_PORTA(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT))

/*! @brief Set the PORTA field to a new value. */
#define SIM_WR_SCGC5_PORTA(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTA_MASK, SIM_SCGC5_PORTA(value)))
#define SIM_BWR_SCGC5_PORTA(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTB[10] (RW)
 *
 * This bit controls the clock gate to the Port B module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTB field. */
#define SIM_RD_SCGC5_PORTB(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTB_MASK) >> SIM_SCGC5_PORTB_SHIFT)
#define SIM_BRD_SCGC5_PORTB(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT))

/*! @brief Set the PORTB field to a new value. */
#define SIM_WR_SCGC5_PORTB(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTB_MASK, SIM_SCGC5_PORTB(value)))
#define SIM_BWR_SCGC5_PORTB(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTC[11] (RW)
 *
 * This bit controls the clock gate to the Port C module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTC field. */
#define SIM_RD_SCGC5_PORTC(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTC_MASK) >> SIM_SCGC5_PORTC_SHIFT)
#define SIM_BRD_SCGC5_PORTC(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT))

/*! @brief Set the PORTC field to a new value. */
#define SIM_WR_SCGC5_PORTC(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTC_MASK, SIM_SCGC5_PORTC(value)))
#define SIM_BWR_SCGC5_PORTC(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTD[12] (RW)
 *
 * This bit controls the clock gate to the Port D module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTD field. */
#define SIM_RD_SCGC5_PORTD(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTD_MASK) >> SIM_SCGC5_PORTD_SHIFT)
#define SIM_BRD_SCGC5_PORTD(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT))

/*! @brief Set the PORTD field to a new value. */
#define SIM_WR_SCGC5_PORTD(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTD_MASK, SIM_SCGC5_PORTD(value)))
#define SIM_BWR_SCGC5_PORTD(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field PORTE[13] (RW)
 *
 * This bit controls the clock gate to the Port E module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_PORTE field. */
#define SIM_RD_SCGC5_PORTE(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_PORTE_MASK) >> SIM_SCGC5_PORTE_SHIFT)
#define SIM_BRD_SCGC5_PORTE(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT))

/*! @brief Set the PORTE field to a new value. */
#define SIM_WR_SCGC5_PORTE(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_PORTE_MASK, SIM_SCGC5_PORTE(value)))
#define SIM_BWR_SCGC5_PORTE(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_PORTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC5, field FLEXIO[31] (RW)
 *
 * This bit controls the clock gate to the FlexIO module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC5_FLEXIO field. */
#define SIM_RD_SCGC5_FLEXIO(base) ((SIM_SCGC5_REG(base) & SIM_SCGC5_FLEXIO_MASK) >> SIM_SCGC5_FLEXIO_SHIFT)
#define SIM_BRD_SCGC5_FLEXIO(base) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_FLEXIO_SHIFT))

/*! @brief Set the FLEXIO field to a new value. */
#define SIM_WR_SCGC5_FLEXIO(base, value) (SIM_RMW_SCGC5(base, SIM_SCGC5_FLEXIO_MASK, SIM_SCGC5_FLEXIO(value)))
#define SIM_BWR_SCGC5_FLEXIO(base, value) (BITBAND_ACCESS32(&SIM_SCGC5_REG(base), SIM_SCGC5_FLEXIO_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC6 - System Clock Gating Control Register 6
 ******************************************************************************/

/*!
 * @brief SIM_SCGC6 - System Clock Gating Control Register 6 (RW)
 *
 * Reset value: 0x40000001U
 *
 * DAC0 , and RNGA can be accessed through AIPS0. When accessing through AIPS0,
 * define the clock gate control bits in SCGC6. See the Chip Configuration
 * chapter for the base addresses of RNGA , and DAC0 accessed via AIPS0.
 */
/*!
 * @name Constants and macros for entire SIM_SCGC6 register
 */
/*@{*/
#define SIM_RD_SCGC6(base)       (SIM_SCGC6_REG(base))
#define SIM_WR_SCGC6(base, value) (SIM_SCGC6_REG(base) = (value))
#define SIM_RMW_SCGC6(base, mask, value) (SIM_WR_SCGC6(base, (SIM_RD_SCGC6(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) |  (value)))
#define SIM_CLR_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) & ~(value)))
#define SIM_TOG_SCGC6(base, value) (SIM_WR_SCGC6(base, SIM_RD_SCGC6(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC6 bitfields
 */

/*!
 * @name Register SIM_SCGC6, field FTF[0] (RW)
 *
 * This bit controls the clock gate to the flash memory. Flash reads are still
 * supported while the flash memory is clock gated, but entry into low power modes
 * is blocked.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FTF field. */
#define SIM_RD_SCGC6_FTF(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FTF_MASK) >> SIM_SCGC6_FTF_SHIFT)
#define SIM_BRD_SCGC6_FTF(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTF_SHIFT))

/*! @brief Set the FTF field to a new value. */
#define SIM_WR_SCGC6_FTF(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FTF_MASK, SIM_SCGC6_FTF(value)))
#define SIM_BWR_SCGC6_FTF(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FTF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DMAMUX[1] (RW)
 *
 * This bit controls the clock gate to the DMA Mux module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DMAMUX field. */
#define SIM_RD_SCGC6_DMAMUX(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DMAMUX_MASK) >> SIM_SCGC6_DMAMUX_SHIFT)
#define SIM_BRD_SCGC6_DMAMUX(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT))

/*! @brief Set the DMAMUX field to a new value. */
#define SIM_WR_SCGC6_DMAMUX(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DMAMUX_MASK, SIM_SCGC6_DMAMUX(value)))
#define SIM_BWR_SCGC6_DMAMUX(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DMAMUX_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FLEXCAN0[4] (RW)
 *
 * This bit controls the clock gate to the FlexCAN0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FLEXCAN0 field. */
#define SIM_RD_SCGC6_FLEXCAN0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FLEXCAN0_MASK) >> SIM_SCGC6_FLEXCAN0_SHIFT)
#define SIM_BRD_SCGC6_FLEXCAN0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN0_SHIFT))

/*! @brief Set the FLEXCAN0 field to a new value. */
#define SIM_WR_SCGC6_FLEXCAN0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FLEXCAN0_MASK, SIM_SCGC6_FLEXCAN0(value)))
#define SIM_BWR_SCGC6_FLEXCAN0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field FLEXCAN1[5] (RW)
 *
 * This bit controls the clock gate to the FlexCAN1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_FLEXCAN1 field. */
#define SIM_RD_SCGC6_FLEXCAN1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_FLEXCAN1_MASK) >> SIM_SCGC6_FLEXCAN1_SHIFT)
#define SIM_BRD_SCGC6_FLEXCAN1(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN1_SHIFT))

/*! @brief Set the FLEXCAN1 field to a new value. */
#define SIM_WR_SCGC6_FLEXCAN1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_FLEXCAN1_MASK, SIM_SCGC6_FLEXCAN1(value)))
#define SIM_BWR_SCGC6_FLEXCAN1(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_FLEXCAN1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RNGA[9] (RW)
 *
 * This bit controls the clock gate to the RNGA module.
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_RNGA field. */
#define SIM_RD_SCGC6_RNGA(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_RNGA_MASK) >> SIM_SCGC6_RNGA_SHIFT)
#define SIM_BRD_SCGC6_RNGA(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RNGA_SHIFT))

/*! @brief Set the RNGA field to a new value. */
#define SIM_WR_SCGC6_RNGA(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_RNGA_MASK, SIM_SCGC6_RNGA(value)))
#define SIM_BWR_SCGC6_RNGA(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RNGA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field LPUART0[10] (RW)
 *
 * This bit controls the clock gate to the LPUART0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_LPUART0 field. */
#define SIM_RD_SCGC6_LPUART0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_LPUART0_MASK) >> SIM_SCGC6_LPUART0_SHIFT)
#define SIM_BRD_SCGC6_LPUART0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_LPUART0_SHIFT))

/*! @brief Set the LPUART0 field to a new value. */
#define SIM_WR_SCGC6_LPUART0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_LPUART0_MASK, SIM_SCGC6_LPUART0(value)))
#define SIM_BWR_SCGC6_LPUART0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_LPUART0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI0[12] (RW)
 *
 * This bit controls the clock gate to the SPI0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI0 field. */
#define SIM_RD_SCGC6_SPI0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI0_MASK) >> SIM_SCGC6_SPI0_SHIFT)
#define SIM_BRD_SCGC6_SPI0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT))

/*! @brief Set the SPI0 field to a new value. */
#define SIM_WR_SCGC6_SPI0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI0_MASK, SIM_SCGC6_SPI0(value)))
#define SIM_BWR_SCGC6_SPI0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field SPI1[13] (RW)
 *
 * This bit controls the clock gate to the SPI1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_SPI1 field. */
#define SIM_RD_SCGC6_SPI1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_SPI1_MASK) >> SIM_SCGC6_SPI1_SHIFT)
#define SIM_BRD_SCGC6_SPI1(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI1_SHIFT))

/*! @brief Set the SPI1 field to a new value. */
#define SIM_WR_SCGC6_SPI1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_SPI1_MASK, SIM_SCGC6_SPI1(value)))
#define SIM_BWR_SCGC6_SPI1(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_SPI1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field I2S0[15] (RW)
 *
 * This bit controls the clock gate to the I 2 S0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_I2S0 field. */
#define SIM_RD_SCGC6_I2S0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_I2S0_MASK) >> SIM_SCGC6_I2S0_SHIFT)
#define SIM_BRD_SCGC6_I2S0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S0_SHIFT))

/*! @brief Set the I2S0 field to a new value. */
#define SIM_WR_SCGC6_I2S0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_I2S0_MASK, SIM_SCGC6_I2S0(value)))
#define SIM_BWR_SCGC6_I2S0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field I2S1[16] (RW)
 *
 * This bit controls the clock gate to the I 2 S1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_I2S1 field. */
#define SIM_RD_SCGC6_I2S1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_I2S1_MASK) >> SIM_SCGC6_I2S1_SHIFT)
#define SIM_BRD_SCGC6_I2S1(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S1_SHIFT))

/*! @brief Set the I2S1 field to a new value. */
#define SIM_WR_SCGC6_I2S1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_I2S1_MASK, SIM_SCGC6_I2S1(value)))
#define SIM_BWR_SCGC6_I2S1(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_I2S1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field CRC[18] (RW)
 *
 * This bit controls the clock gate to the CRC module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_CRC field. */
#define SIM_RD_SCGC6_CRC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_CRC_MASK) >> SIM_SCGC6_CRC_SHIFT)
#define SIM_BRD_SCGC6_CRC(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT))

/*! @brief Set the CRC field to a new value. */
#define SIM_WR_SCGC6_CRC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_CRC_MASK, SIM_SCGC6_CRC(value)))
#define SIM_BWR_SCGC6_CRC(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_CRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PDB[22] (RW)
 *
 * This bit controls the clock gate to the PDB module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PDB field. */
#define SIM_RD_SCGC6_PDB(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PDB_MASK) >> SIM_SCGC6_PDB_SHIFT)
#define SIM_BRD_SCGC6_PDB(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT))

/*! @brief Set the PDB field to a new value. */
#define SIM_WR_SCGC6_PDB(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PDB_MASK, SIM_SCGC6_PDB(value)))
#define SIM_BWR_SCGC6_PDB(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PDB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field PIT[23] (RW)
 *
 * This bit controls the clock gate to the PIT module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_PIT field. */
#define SIM_RD_SCGC6_PIT(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_PIT_MASK) >> SIM_SCGC6_PIT_SHIFT)
#define SIM_BRD_SCGC6_PIT(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT))

/*! @brief Set the PIT field to a new value. */
#define SIM_WR_SCGC6_PIT(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_PIT_MASK, SIM_SCGC6_PIT(value)))
#define SIM_BWR_SCGC6_PIT(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_PIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM0[24] (RW)
 *
 * This bit controls the clock gate to the TPM0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM0 field. */
#define SIM_RD_SCGC6_TPM0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM0_MASK) >> SIM_SCGC6_TPM0_SHIFT)
#define SIM_BRD_SCGC6_TPM0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM0_SHIFT))

/*! @brief Set the TPM0 field to a new value. */
#define SIM_WR_SCGC6_TPM0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM0_MASK, SIM_SCGC6_TPM0(value)))
#define SIM_BWR_SCGC6_TPM0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM1[25] (RW)
 *
 * This bit controls the clock gate to the TPM1 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM1 field. */
#define SIM_RD_SCGC6_TPM1(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM1_MASK) >> SIM_SCGC6_TPM1_SHIFT)
#define SIM_BRD_SCGC6_TPM1(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM1_SHIFT))

/*! @brief Set the TPM1 field to a new value. */
#define SIM_WR_SCGC6_TPM1(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM1_MASK, SIM_SCGC6_TPM1(value)))
#define SIM_BWR_SCGC6_TPM1(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field TPM2[26] (RW)
 *
 * This bit controls the clock gate to the TPM2 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_TPM2 field. */
#define SIM_RD_SCGC6_TPM2(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_TPM2_MASK) >> SIM_SCGC6_TPM2_SHIFT)
#define SIM_BRD_SCGC6_TPM2(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM2_SHIFT))

/*! @brief Set the TPM2 field to a new value. */
#define SIM_WR_SCGC6_TPM2(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_TPM2_MASK, SIM_SCGC6_TPM2(value)))
#define SIM_BWR_SCGC6_TPM2(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_TPM2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field ADC0[27] (RW)
 *
 * This bit controls the clock gate to the ADC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_ADC0 field. */
#define SIM_RD_SCGC6_ADC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_ADC0_MASK) >> SIM_SCGC6_ADC0_SHIFT)
#define SIM_BRD_SCGC6_ADC0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT))

/*! @brief Set the ADC0 field to a new value. */
#define SIM_WR_SCGC6_ADC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_ADC0_MASK, SIM_SCGC6_ADC0(value)))
#define SIM_BWR_SCGC6_ADC0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_ADC0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field RTC[29] (RW)
 *
 * This bit controls software access and interrupts to the RTC module.
 *
 * Values:
 * - 0 - Access and interrupts disabled
 * - 1 - Access and interrupts enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_RTC field. */
#define SIM_RD_SCGC6_RTC(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_RTC_MASK) >> SIM_SCGC6_RTC_SHIFT)
#define SIM_BRD_SCGC6_RTC(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RTC_SHIFT))

/*! @brief Set the RTC field to a new value. */
#define SIM_WR_SCGC6_RTC(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_RTC_MASK, SIM_SCGC6_RTC(value)))
#define SIM_BWR_SCGC6_RTC(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_RTC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_SCGC6, field DAC0[31] (RW)
 *
 * This bit controls the clock gate to the DAC0 module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC6_DAC0 field. */
#define SIM_RD_SCGC6_DAC0(base) ((SIM_SCGC6_REG(base) & SIM_SCGC6_DAC0_MASK) >> SIM_SCGC6_DAC0_SHIFT)
#define SIM_BRD_SCGC6_DAC0(base) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DAC0_SHIFT))

/*! @brief Set the DAC0 field to a new value. */
#define SIM_WR_SCGC6_DAC0(base, value) (SIM_RMW_SCGC6(base, SIM_SCGC6_DAC0_MASK, SIM_SCGC6_DAC0(value)))
#define SIM_BWR_SCGC6_DAC0(base, value) (BITBAND_ACCESS32(&SIM_SCGC6_REG(base), SIM_SCGC6_DAC0_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_SCGC7 - System Clock Gating Control Register 7
 ******************************************************************************/

/*!
 * @brief SIM_SCGC7 - System Clock Gating Control Register 7 (RW)
 *
 * Reset value: 0x00000002U
 */
/*!
 * @name Constants and macros for entire SIM_SCGC7 register
 */
/*@{*/
#define SIM_RD_SCGC7(base)       (SIM_SCGC7_REG(base))
#define SIM_WR_SCGC7(base, value) (SIM_SCGC7_REG(base) = (value))
#define SIM_RMW_SCGC7(base, mask, value) (SIM_WR_SCGC7(base, (SIM_RD_SCGC7(base) & ~(mask)) | (value)))
#define SIM_SET_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) |  (value)))
#define SIM_CLR_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) & ~(value)))
#define SIM_TOG_SCGC7(base, value) (SIM_WR_SCGC7(base, SIM_RD_SCGC7(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_SCGC7 bitfields
 */

/*!
 * @name Register SIM_SCGC7, field DMA[1] (RW)
 *
 * This bit controls the clock gate to the DMA module.
 *
 * Values:
 * - 0 - Clock disabled
 * - 1 - Clock enabled
 */
/*@{*/
/*! @brief Read current value of the SIM_SCGC7_DMA field. */
#define SIM_RD_SCGC7_DMA(base) ((SIM_SCGC7_REG(base) & SIM_SCGC7_DMA_MASK) >> SIM_SCGC7_DMA_SHIFT)
#define SIM_BRD_SCGC7_DMA(base) (BITBAND_ACCESS32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define SIM_WR_SCGC7_DMA(base, value) (SIM_RMW_SCGC7(base, SIM_SCGC7_DMA_MASK, SIM_SCGC7_DMA(value)))
#define SIM_BWR_SCGC7_DMA(base, value) (BITBAND_ACCESS32(&SIM_SCGC7_REG(base), SIM_SCGC7_DMA_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV1 - System Clock Divider Register 1
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV1 - System Clock Divider Register 1 (RW)
 *
 * Reset value: 0x00010000U
 *
 * When updating CLKDIV1, update all fields using the one write command. The
 * CLKDIV1 register cannot be written to when the device is in VLPR mode.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV1 register
 */
/*@{*/
#define SIM_RD_CLKDIV1(base)     (SIM_CLKDIV1_REG(base))
#define SIM_WR_CLKDIV1(base, value) (SIM_CLKDIV1_REG(base) = (value))
#define SIM_RMW_CLKDIV1(base, mask, value) (SIM_WR_CLKDIV1(base, (SIM_RD_CLKDIV1(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) |  (value)))
#define SIM_CLR_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) & ~(value)))
#define SIM_TOG_CLKDIV1(base, value) (SIM_WR_CLKDIV1(base, SIM_RD_CLKDIV1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV1 bitfields
 */

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV4[19:16] (RW)
 *
 * This field sets the divide value for the flash clock from MCGOUTCLK. At the
 * end of reset, it is loaded with either 0001 or 1111 depending on
 * FTF_FOPT[LPBOOT]. The flash clock frequency must be an integer divide of the system clock
 * frequency.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV4 field. */
#define SIM_RD_CLKDIV1_OUTDIV4(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV4_MASK) >> SIM_CLKDIV1_OUTDIV4_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV4(base) (SIM_RD_CLKDIV1_OUTDIV4(base))

/*! @brief Set the OUTDIV4 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV4(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV4_MASK, SIM_CLKDIV1_OUTDIV4(value)))
#define SIM_BWR_CLKDIV1_OUTDIV4(base, value) (SIM_WR_CLKDIV1_OUTDIV4(base, value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV2[27:24] (RW)
 *
 * This field sets the divide value for the bus clock from MCGOUTCLK. At the end
 * of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT]. The bus clock frequency must be an integer divide of the core/system clock
 * frequency.
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV2 field. */
#define SIM_RD_CLKDIV1_OUTDIV2(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV2_MASK) >> SIM_CLKDIV1_OUTDIV2_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV2(base) (SIM_RD_CLKDIV1_OUTDIV2(base))

/*! @brief Set the OUTDIV2 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV2(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV2_MASK, SIM_CLKDIV1_OUTDIV2(value)))
#define SIM_BWR_CLKDIV1_OUTDIV2(base, value) (SIM_WR_CLKDIV1_OUTDIV2(base, value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV1, field OUTDIV1[31:28] (RW)
 *
 * This field sets the divide value for the core/system clock from MCGOUTCLK. At
 * the end of reset, it is loaded with either 0000 or 0111 depending on
 * FTF_FOPT[LPBOOT].
 *
 * Values:
 * - 0000 - Divide-by-1.
 * - 0001 - Divide-by-2.
 * - 0010 - Divide-by-3.
 * - 0011 - Divide-by-4.
 * - 0100 - Divide-by-5.
 * - 0101 - Divide-by-6.
 * - 0110 - Divide-by-7.
 * - 0111 - Divide-by-8.
 * - 1000 - Divide-by-9.
 * - 1001 - Divide-by-10.
 * - 1010 - Divide-by-11.
 * - 1011 - Divide-by-12.
 * - 1100 - Divide-by-13.
 * - 1101 - Divide-by-14.
 * - 1110 - Divide-by-15.
 * - 1111 - Divide-by-16.
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV1_OUTDIV1 field. */
#define SIM_RD_CLKDIV1_OUTDIV1(base) ((SIM_CLKDIV1_REG(base) & SIM_CLKDIV1_OUTDIV1_MASK) >> SIM_CLKDIV1_OUTDIV1_SHIFT)
#define SIM_BRD_CLKDIV1_OUTDIV1(base) (SIM_RD_CLKDIV1_OUTDIV1(base))

/*! @brief Set the OUTDIV1 field to a new value. */
#define SIM_WR_CLKDIV1_OUTDIV1(base, value) (SIM_RMW_CLKDIV1(base, SIM_CLKDIV1_OUTDIV1_MASK, SIM_CLKDIV1_OUTDIV1(value)))
#define SIM_BWR_CLKDIV1_OUTDIV1(base, value) (SIM_WR_CLKDIV1_OUTDIV1(base, value))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV2 - System Clock Divider Register 2
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV2 - System Clock Divider Register 2 (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV2 register
 */
/*@{*/
#define SIM_RD_CLKDIV2(base)     (SIM_CLKDIV2_REG(base))
#define SIM_WR_CLKDIV2(base, value) (SIM_CLKDIV2_REG(base) = (value))
#define SIM_RMW_CLKDIV2(base, mask, value) (SIM_WR_CLKDIV2(base, (SIM_RD_CLKDIV2(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) |  (value)))
#define SIM_CLR_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) & ~(value)))
#define SIM_TOG_CLKDIV2(base, value) (SIM_WR_CLKDIV2(base, SIM_RD_CLKDIV2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV2 bitfields
 */

/*!
 * @name Register SIM_CLKDIV2, field USBFRAC[0] (RW)
 *
 * This field sets the fraction multiply value for the fractional clock divider
 * when the MCGFLLCLK, or MCGPLLCLK , or IRC48M clock is the USB clock source
 * (SOPT2[USBSRC] = 1). Divider output clock = Divider input clock * [ (USBFRAC+1) /
 * (USBDIV+1) ]
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV2_USBFRAC field. */
#define SIM_RD_CLKDIV2_USBFRAC(base) ((SIM_CLKDIV2_REG(base) & SIM_CLKDIV2_USBFRAC_MASK) >> SIM_CLKDIV2_USBFRAC_SHIFT)
#define SIM_BRD_CLKDIV2_USBFRAC(base) (BITBAND_ACCESS32(&SIM_CLKDIV2_REG(base), SIM_CLKDIV2_USBFRAC_SHIFT))

/*! @brief Set the USBFRAC field to a new value. */
#define SIM_WR_CLKDIV2_USBFRAC(base, value) (SIM_RMW_CLKDIV2(base, SIM_CLKDIV2_USBFRAC_MASK, SIM_CLKDIV2_USBFRAC(value)))
#define SIM_BWR_CLKDIV2_USBFRAC(base, value) (BITBAND_ACCESS32(&SIM_CLKDIV2_REG(base), SIM_CLKDIV2_USBFRAC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV2, field USBDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider when the
 * MCGFLLCLK, or MCGPLLCLK , or IRC48M clock is the USB clock source (SOPT2[USBSRC]
 * = 1). Divider output clock = Divider input clock * [ (USBFRAC+1) / (USBDIV+1)
 * ]
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV2_USBDIV field. */
#define SIM_RD_CLKDIV2_USBDIV(base) ((SIM_CLKDIV2_REG(base) & SIM_CLKDIV2_USBDIV_MASK) >> SIM_CLKDIV2_USBDIV_SHIFT)
#define SIM_BRD_CLKDIV2_USBDIV(base) (SIM_RD_CLKDIV2_USBDIV(base))

/*! @brief Set the USBDIV field to a new value. */
#define SIM_WR_CLKDIV2_USBDIV(base, value) (SIM_RMW_CLKDIV2(base, SIM_CLKDIV2_USBDIV_MASK, SIM_CLKDIV2_USBDIV(value)))
#define SIM_BWR_CLKDIV2_USBDIV(base, value) (SIM_WR_CLKDIV2_USBDIV(base, value))
/*@}*/

/*******************************************************************************
 * SIM_FCFG1 - Flash Configuration Register 1
 ******************************************************************************/

/*!
 * @brief SIM_FCFG1 - Flash Configuration Register 1 (RW)
 *
 * Reset value: 0xFF0F0F00U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG1 register
 */
/*@{*/
#define SIM_RD_FCFG1(base)       (SIM_FCFG1_REG(base))
#define SIM_WR_FCFG1(base, value) (SIM_FCFG1_REG(base) = (value))
#define SIM_RMW_FCFG1(base, mask, value) (SIM_WR_FCFG1(base, (SIM_RD_FCFG1(base) & ~(mask)) | (value)))
#define SIM_SET_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) |  (value)))
#define SIM_CLR_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) & ~(value)))
#define SIM_TOG_FCFG1(base, value) (SIM_WR_FCFG1(base, SIM_RD_FCFG1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG1 bitfields
 */

/*!
 * @name Register SIM_FCFG1, field FLASHDIS[0] (RW)
 *
 * Flash accesses are disabled (and generate a bus error) and the Flash memory
 * is placed in a low power state. This bit should not be changed during VLP
 * modes. Relocate the interrupt vectors out of Flash memory before disabling the
 * Flash.
 *
 * Values:
 * - 0 - Flash is enabled
 * - 1 - Flash is disabled
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDIS field. */
#define SIM_RD_FCFG1_FLASHDIS(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDIS_MASK) >> SIM_FCFG1_FLASHDIS_SHIFT)
#define SIM_BRD_FCFG1_FLASHDIS(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT))

/*! @brief Set the FLASHDIS field to a new value. */
#define SIM_WR_FCFG1_FLASHDIS(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDIS_MASK, SIM_FCFG1_FLASHDIS(value)))
#define SIM_BWR_FCFG1_FLASHDIS(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field FLASHDOZE[1] (RW)
 *
 * When set, Flash memory is disabled for the duration of Wait mode. An attempt
 * by the DMA or other bus master to access the Flash when the Flash is disabled
 * will result in a bus error. This bit should be clear during VLP modes. The
 * Flash will be automatically enabled again at the end of Wait mode so interrupt
 * vectors do not need to be relocated out of Flash memory. The wakeup time from
 * Wait mode is extended when this bit is set.
 *
 * Values:
 * - 0 - Flash remains enabled during Wait mode
 * - 1 - Flash is disabled for the duration of Wait mode
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_FLASHDOZE field. */
#define SIM_RD_FCFG1_FLASHDOZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_FLASHDOZE_MASK) >> SIM_FCFG1_FLASHDOZE_SHIFT)
#define SIM_BRD_FCFG1_FLASHDOZE(base) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT))

/*! @brief Set the FLASHDOZE field to a new value. */
#define SIM_WR_FCFG1_FLASHDOZE(base, value) (SIM_RMW_FCFG1(base, SIM_FCFG1_FLASHDOZE_MASK, SIM_FCFG1_FLASHDOZE(value)))
#define SIM_BWR_FCFG1_FLASHDOZE(base, value) (BITBAND_ACCESS32(&SIM_FCFG1_REG(base), SIM_FCFG1_FLASHDOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_FCFG1, field PFSIZE[27:24] (RO)
 *
 * This field specifies the amount of program flash memory available on the
 * device . Undefined values are reserved.
 *
 * Values:
 * - 0011 - 32 KB of program flash memory
 * - 0101 - 64 KB of program flash memory
 * - 0111 - 128 KB of program flash memory
 * - 1001 - 256 KB of program flash memory
 * - 1011 - 512 KB of program flash memory
 * - 1101 - 1024 KB of program flash memory
 * - 1111 - 256 KB of program flash memory
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG1_PFSIZE field. */
#define SIM_RD_FCFG1_PFSIZE(base) ((SIM_FCFG1_REG(base) & SIM_FCFG1_PFSIZE_MASK) >> SIM_FCFG1_PFSIZE_SHIFT)
#define SIM_BRD_FCFG1_PFSIZE(base) (SIM_RD_FCFG1_PFSIZE(base))
/*@}*/

/*******************************************************************************
 * SIM_FCFG2 - Flash Configuration Register 2
 ******************************************************************************/

/*!
 * @brief SIM_FCFG2 - Flash Configuration Register 2 (RO)
 *
 * Reset value: 0x20800000U
 */
/*!
 * @name Constants and macros for entire SIM_FCFG2 register
 */
/*@{*/
#define SIM_RD_FCFG2(base)       (SIM_FCFG2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SIM_FCFG2 bitfields
 */

/*!
 * @name Register SIM_FCFG2, field MAXADDR0[30:24] (RO)
 *
 * This field concatenated with 13 trailing zeros indicates the first invalid
 * address of each program flash block. For example, if MAXADDR0 = 0x20 the first
 * invalid address of flash block 0 is 0x0004_0000. This would be the MAXADDR0
 * value for a device with 256 KB program flash in flash block 0.
 */
/*@{*/
/*! @brief Read current value of the SIM_FCFG2_MAXADDR0 field. */
#define SIM_RD_FCFG2_MAXADDR0(base) ((SIM_FCFG2_REG(base) & SIM_FCFG2_MAXADDR0_MASK) >> SIM_FCFG2_MAXADDR0_SHIFT)
#define SIM_BRD_FCFG2_MAXADDR0(base) (SIM_RD_FCFG2_MAXADDR0(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDH - Unique Identification Register High
 ******************************************************************************/

/*!
 * @brief SIM_UIDH - Unique Identification Register High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDH register
 */
/*@{*/
#define SIM_RD_UIDH(base)        (SIM_UIDH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDMH - Unique Identification Register Mid-High
 ******************************************************************************/

/*!
 * @brief SIM_UIDMH - Unique Identification Register Mid-High (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDMH register
 */
/*@{*/
#define SIM_RD_UIDMH(base)       (SIM_UIDMH_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDML - Unique Identification Register Mid Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDML - Unique Identification Register Mid Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDML register
 */
/*@{*/
#define SIM_RD_UIDML(base)       (SIM_UIDML_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_UIDL - Unique Identification Register Low
 ******************************************************************************/

/*!
 * @brief SIM_UIDL - Unique Identification Register Low (RO)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire SIM_UIDL register
 */
/*@{*/
#define SIM_RD_UIDL(base)        (SIM_UIDL_REG(base))
/*@}*/

/*******************************************************************************
 * SIM_CLKDIV3 - System Clock Divider Register 3
 ******************************************************************************/

/*!
 * @brief SIM_CLKDIV3 - System Clock Divider Register 3 (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register should only be written when the LPUART, FlexIO and TPM modules
 * are disabled.
 */
/*!
 * @name Constants and macros for entire SIM_CLKDIV3 register
 */
/*@{*/
#define SIM_RD_CLKDIV3(base)     (SIM_CLKDIV3_REG(base))
#define SIM_WR_CLKDIV3(base, value) (SIM_CLKDIV3_REG(base) = (value))
#define SIM_RMW_CLKDIV3(base, mask, value) (SIM_WR_CLKDIV3(base, (SIM_RD_CLKDIV3(base) & ~(mask)) | (value)))
#define SIM_SET_CLKDIV3(base, value) (SIM_WR_CLKDIV3(base, SIM_RD_CLKDIV3(base) |  (value)))
#define SIM_CLR_CLKDIV3(base, value) (SIM_WR_CLKDIV3(base, SIM_RD_CLKDIV3(base) & ~(value)))
#define SIM_TOG_CLKDIV3(base, value) (SIM_WR_CLKDIV3(base, SIM_RD_CLKDIV3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_CLKDIV3 bitfields
 */

/*!
 * @name Register SIM_CLKDIV3, field PLLFLLFRAC[0] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for various peripherals. The source clock for the fractional clock
 * divider is set by the SOPT2 PLLFLLSEL register bit. Divider output clock = Divider
 * input clock * ((PLLFLLFRAC+1)/(PLLFLLDIV+1))
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV3_PLLFLLFRAC field. */
#define SIM_RD_CLKDIV3_PLLFLLFRAC(base) ((SIM_CLKDIV3_REG(base) & SIM_CLKDIV3_PLLFLLFRAC_MASK) >> SIM_CLKDIV3_PLLFLLFRAC_SHIFT)
#define SIM_BRD_CLKDIV3_PLLFLLFRAC(base) (BITBAND_ACCESS32(&SIM_CLKDIV3_REG(base), SIM_CLKDIV3_PLLFLLFRAC_SHIFT))

/*! @brief Set the PLLFLLFRAC field to a new value. */
#define SIM_WR_CLKDIV3_PLLFLLFRAC(base, value) (SIM_RMW_CLKDIV3(base, SIM_CLKDIV3_PLLFLLFRAC_MASK, SIM_CLKDIV3_PLLFLLFRAC(value)))
#define SIM_BWR_CLKDIV3_PLLFLLFRAC(base, value) (BITBAND_ACCESS32(&SIM_CLKDIV3_REG(base), SIM_CLKDIV3_PLLFLLFRAC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SIM_CLKDIV3, field PLLFLLDIV[3:1] (RW)
 *
 * This field sets the divide value for the fractional clock divider used as a
 * source for various peripheral clocks. The source clock for the fractional clock
 * divider is set by the SOPT2 PLLFLLSEL register bit. Divider output clock =
 * Divider input clock * ((PLLFLLFRAC+1)/(PLLFLLDIV+1))
 */
/*@{*/
/*! @brief Read current value of the SIM_CLKDIV3_PLLFLLDIV field. */
#define SIM_RD_CLKDIV3_PLLFLLDIV(base) ((SIM_CLKDIV3_REG(base) & SIM_CLKDIV3_PLLFLLDIV_MASK) >> SIM_CLKDIV3_PLLFLLDIV_SHIFT)
#define SIM_BRD_CLKDIV3_PLLFLLDIV(base) (SIM_RD_CLKDIV3_PLLFLLDIV(base))

/*! @brief Set the PLLFLLDIV field to a new value. */
#define SIM_WR_CLKDIV3_PLLFLLDIV(base, value) (SIM_RMW_CLKDIV3(base, SIM_CLKDIV3_PLLFLLDIV_MASK, SIM_CLKDIV3_PLLFLLDIV(value)))
#define SIM_BWR_CLKDIV3_PLLFLLDIV(base, value) (SIM_WR_CLKDIV3_PLLFLLDIV(base, value))
/*@}*/

/*******************************************************************************
 * SIM_MISCCTL - Miscellaneous Control Register
 ******************************************************************************/

/*!
 * @brief SIM_MISCCTL - Miscellaneous Control Register (RW)
 *
 * Reset value: 0x00000003U
 */
/*!
 * @name Constants and macros for entire SIM_MISCCTL register
 */
/*@{*/
#define SIM_RD_MISCCTL(base)     (SIM_MISCCTL_REG(base))
#define SIM_WR_MISCCTL(base, value) (SIM_MISCCTL_REG(base) = (value))
#define SIM_RMW_MISCCTL(base, mask, value) (SIM_WR_MISCCTL(base, (SIM_RD_MISCCTL(base) & ~(mask)) | (value)))
#define SIM_SET_MISCCTL(base, value) (SIM_WR_MISCCTL(base, SIM_RD_MISCCTL(base) |  (value)))
#define SIM_CLR_MISCCTL(base, value) (SIM_WR_MISCCTL(base, SIM_RD_MISCCTL(base) & ~(value)))
#define SIM_TOG_MISCCTL(base, value) (SIM_WR_MISCCTL(base, SIM_RD_MISCCTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SIM_MISCCTL bitfields
 */

/*!
 * @name Register SIM_MISCCTL, field UARTSELONUSB[1:0] (RW)
 *
 * Values:
 * - 00 - UART0
 * - 01 - UART1
 * - 10 - UART2
 * - 11 - LPUART (default)
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCCTL_UARTSELONUSB field. */
#define SIM_RD_MISCCTL_UARTSELONUSB(base) ((SIM_MISCCTL_REG(base) & SIM_MISCCTL_UARTSELONUSB_MASK) >> SIM_MISCCTL_UARTSELONUSB_SHIFT)
#define SIM_BRD_MISCCTL_UARTSELONUSB(base) (SIM_RD_MISCCTL_UARTSELONUSB(base))

/*! @brief Set the UARTSELONUSB field to a new value. */
#define SIM_WR_MISCCTL_UARTSELONUSB(base, value) (SIM_RMW_MISCCTL(base, SIM_MISCCTL_UARTSELONUSB_MASK, SIM_MISCCTL_UARTSELONUSB(value)))
#define SIM_BWR_MISCCTL_UARTSELONUSB(base, value) (SIM_WR_MISCCTL_UARTSELONUSB(base, value))
/*@}*/

/*!
 * @name Register SIM_MISCCTL, field FlexIOS0[2] (RW)
 *
 * Values:
 * - 0 - system clock
 * - 1 - I2S0_MCLK
 */
/*@{*/
/*! @brief Read current value of the SIM_MISCCTL_FlexIOS0 field. */
#define SIM_RD_MISCCTL_FlexIOS0(base) ((SIM_MISCCTL_REG(base) & SIM_MISCCTL_FlexIOS0_MASK) >> SIM_MISCCTL_FlexIOS0_SHIFT)
#define SIM_BRD_MISCCTL_FlexIOS0(base) (BITBAND_ACCESS32(&SIM_MISCCTL_REG(base), SIM_MISCCTL_FlexIOS0_SHIFT))

/*! @brief Set the FlexIOS0 field to a new value. */
#define SIM_WR_MISCCTL_FlexIOS0(base, value) (SIM_RMW_MISCCTL(base, SIM_MISCCTL_FlexIOS0_MASK, SIM_MISCCTL_FlexIOS0(value)))
#define SIM_BWR_MISCCTL_FlexIOS0(base, value) (BITBAND_ACCESS32(&SIM_MISCCTL_REG(base), SIM_MISCCTL_FlexIOS0_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 SMC
 *
 * System Mode Controller
 *
 * Registers defined in this header file:
 * - SMC_PMPROT - Power Mode Protection register
 * - SMC_PMCTRL - Power Mode Control register
 * - SMC_STOPCTRL - Stop Control Register
 * - SMC_PMSTAT - Power Mode Status register
 */

#define SMC_INSTANCE_COUNT (1U) /*!< Number of instances of the SMC module. */
#define SMC_IDX (0U) /*!< Instance number for SMC. */

/*******************************************************************************
 * SMC_PMPROT - Power Mode Protection register
 ******************************************************************************/

/*!
 * @brief SMC_PMPROT - Power Mode Protection register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides protection for entry into any low-power run or stop
 * mode. The enabling of the low-power run or stop mode occurs by configuring the
 * Power Mode Control register (PMCTRL). The PMPROT register can be written only
 * once after any system reset. If the MCU is configured for a disallowed or
 * reserved power mode, the MCU remains in its current power mode. For example, if the
 * MCU is in normal RUN mode and AVLP is 0, an attempt to enter VLPR mode using
 * PMCTRL[RUNM] is blocked and PMCTRL[RUNM] remains 00b, indicating the MCU is
 * still in Normal Run mode. This register is reset on Chip Reset not VLLS and by
 * reset types that trigger Chip Reset not VLLS. It is unaffected by reset types
 * that do not trigger Chip Reset not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMPROT register
 */
/*@{*/
#define SMC_RD_PMPROT(base)      (SMC_PMPROT_REG(base))
#define SMC_WR_PMPROT(base, value) (SMC_PMPROT_REG(base) = (value))
#define SMC_RMW_PMPROT(base, mask, value) (SMC_WR_PMPROT(base, (SMC_RD_PMPROT(base) & ~(mask)) | (value)))
#define SMC_SET_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) |  (value)))
#define SMC_CLR_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) & ~(value)))
#define SMC_TOG_PMPROT(base, value) (SMC_WR_PMPROT(base, SMC_RD_PMPROT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMPROT bitfields
 */

/*!
 * @name Register SMC_PMPROT, field AVLLS[1] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write once
 * bit allows the MCU to enter any very-low-leakage stop mode (VLLSx).
 *
 * Values:
 * - 0 - Any VLLSx mode is not allowed
 * - 1 - Any VLLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLLS field. */
#define SMC_RD_PMPROT_AVLLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLLS_MASK) >> SMC_PMPROT_AVLLS_SHIFT)
#define SMC_BRD_PMPROT_AVLLS(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT))

/*! @brief Set the AVLLS field to a new value. */
#define SMC_WR_PMPROT_AVLLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLLS_MASK, SMC_PMPROT_AVLLS(value)))
#define SMC_BWR_PMPROT_AVLLS(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field ALLS[3] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any low-leakage stop mode (LLS).
 *
 * Values:
 * - 0 - Any LLSx mode is not allowed
 * - 1 - Any LLSx mode is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_ALLS field. */
#define SMC_RD_PMPROT_ALLS(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_ALLS_MASK) >> SMC_PMPROT_ALLS_SHIFT)
#define SMC_BRD_PMPROT_ALLS(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT))

/*! @brief Set the ALLS field to a new value. */
#define SMC_WR_PMPROT_ALLS(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_ALLS_MASK, SMC_PMPROT_ALLS(value)))
#define SMC_BWR_PMPROT_ALLS(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_ALLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AVLP[5] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter any very-low-power mode (VLPR, VLPW, and VLPS).
 *
 * Values:
 * - 0 - VLPR, VLPW, and VLPS are not allowed.
 * - 1 - VLPR, VLPW, and VLPS are allowed.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AVLP field. */
#define SMC_RD_PMPROT_AVLP(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AVLP_MASK) >> SMC_PMPROT_AVLP_SHIFT)
#define SMC_BRD_PMPROT_AVLP(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT))

/*! @brief Set the AVLP field to a new value. */
#define SMC_WR_PMPROT_AVLP(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AVLP_MASK, SMC_PMPROT_AVLP(value)))
#define SMC_BWR_PMPROT_AVLP(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AVLP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_PMPROT, field AHSRUN[7] (RW)
 *
 * Provided the appropriate control bits are set up in PMCTRL, this write-once
 * field allows the MCU to enter High Speed Run mode (HSRUN).
 *
 * Values:
 * - 0 - HSRUN is not allowed
 * - 1 - HSRUN is allowed
 */
/*@{*/
/*! @brief Read current value of the SMC_PMPROT_AHSRUN field. */
#define SMC_RD_PMPROT_AHSRUN(base) ((SMC_PMPROT_REG(base) & SMC_PMPROT_AHSRUN_MASK) >> SMC_PMPROT_AHSRUN_SHIFT)
#define SMC_BRD_PMPROT_AHSRUN(base) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT))

/*! @brief Set the AHSRUN field to a new value. */
#define SMC_WR_PMPROT_AHSRUN(base, value) (SMC_RMW_PMPROT(base, SMC_PMPROT_AHSRUN_MASK, SMC_PMPROT_AHSRUN(value)))
#define SMC_BWR_PMPROT_AHSRUN(base, value) (BITBAND_ACCESS8(&SMC_PMPROT_REG(base), SMC_PMPROT_AHSRUN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SMC_PMCTRL - Power Mode Control register
 ******************************************************************************/

/*!
 * @brief SMC_PMCTRL - Power Mode Control register (RW)
 *
 * Reset value: 0x00U
 *
 * The PMCTRL register controls entry into low-power Run and Stop modes,
 * provided that the selected power mode is allowed via an appropriate setting of the
 * protection (PMPROT) register. This register is reset on Chip POR not VLLS and by
 * reset types that trigger Chip POR not VLLS. It is unaffected by reset types
 * that do not trigger Chip POR not VLLS. See the Reset section details for more
 * information.
 */
/*!
 * @name Constants and macros for entire SMC_PMCTRL register
 */
/*@{*/
#define SMC_RD_PMCTRL(base)      (SMC_PMCTRL_REG(base))
#define SMC_WR_PMCTRL(base, value) (SMC_PMCTRL_REG(base) = (value))
#define SMC_RMW_PMCTRL(base, mask, value) (SMC_WR_PMCTRL(base, (SMC_RD_PMCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) |  (value)))
#define SMC_CLR_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) & ~(value)))
#define SMC_TOG_PMCTRL(base, value) (SMC_WR_PMCTRL(base, SMC_RD_PMCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_PMCTRL bitfields
 */

/*!
 * @name Register SMC_PMCTRL, field STOPM[2:0] (RW)
 *
 * When written, controls entry into the selected stop mode when Sleep-Now or
 * Sleep-On-Exit mode is entered with SLEEPDEEP=1 . Writes to this field are
 * blocked if the protection level has not been enabled using the PMPROT register.
 * After any system reset, this field is cleared by hardware on any successful write
 * to the PMPROT register. When set to VLLSxor LLSx, the LLSM in the STOPCTRL
 * register is used to further select the particular VLLSor LLS submode which will
 * be entered. When set to STOP, the PSTOPO bits in the STOPCTRL register can be
 * used to select a Partial Stop mode if desired.
 *
 * Values:
 * - 000 - Normal Stop (STOP)
 * - 001 - Reserved
 * - 010 - Very-Low-Power Stop (VLPS)
 * - 011 - Low-Leakage Stop (LLSx)
 * - 100 - Very-Low-Leakage Stop (VLLSx)
 * - 101 - Reserved
 * - 110 - Reseved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPM field. */
#define SMC_RD_PMCTRL_STOPM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPM_MASK) >> SMC_PMCTRL_STOPM_SHIFT)
#define SMC_BRD_PMCTRL_STOPM(base) (SMC_RD_PMCTRL_STOPM(base))

/*! @brief Set the STOPM field to a new value. */
#define SMC_WR_PMCTRL_STOPM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_STOPM_MASK, SMC_PMCTRL_STOPM(value)))
#define SMC_BWR_PMCTRL_STOPM(base, value) (SMC_WR_PMCTRL_STOPM(base, value))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field STOPA[3] (RO)
 *
 * When set, this read-only status bit indicates an interrupt occured during the
 * previous stop mode entry sequence, preventing the system from entering that
 * mode. This field is cleared by reset or by hardware at the beginning of any
 * stop mode entry sequence and is set if the sequence was aborted.
 *
 * Values:
 * - 0 - The previous stop mode entry was successsful.
 * - 1 - The previous stop mode entry was aborted.
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_STOPA field. */
#define SMC_RD_PMCTRL_STOPA(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_STOPA_MASK) >> SMC_PMCTRL_STOPA_SHIFT)
#define SMC_BRD_PMCTRL_STOPA(base) (BITBAND_ACCESS8(&SMC_PMCTRL_REG(base), SMC_PMCTRL_STOPA_SHIFT))
/*@}*/

/*!
 * @name Register SMC_PMCTRL, field RUNM[6:5] (RW)
 *
 * When written, causes entry into the selected run mode. Writes to this field
 * are blocked if the protection level has not been enabled using the PMPROT
 * register. RUNM may be set to VLPR only when PMSTAT=RUN. After being written to
 * VLPR, RUNM should not be written back to RUN until PMSTAT=VLPR. RUNM may be set to
 * HSRUN only when PMSTAT=RUN. After being programmed to HSRUN, RUNM should not
 * be programmed back to RUN until PMSTAT=HSRUN. Also, stop mode entry should not
 * be attempted while RUNM=HSRUN or PMSTAT=HSRUN.
 *
 * Values:
 * - 00 - Normal Run mode (RUN)
 * - 01 - Reserved
 * - 10 - Very-Low-Power Run mode (VLPR)
 * - 11 - High Speed Run mode (HSRUN)
 */
/*@{*/
/*! @brief Read current value of the SMC_PMCTRL_RUNM field. */
#define SMC_RD_PMCTRL_RUNM(base) ((SMC_PMCTRL_REG(base) & SMC_PMCTRL_RUNM_MASK) >> SMC_PMCTRL_RUNM_SHIFT)
#define SMC_BRD_PMCTRL_RUNM(base) (SMC_RD_PMCTRL_RUNM(base))

/*! @brief Set the RUNM field to a new value. */
#define SMC_WR_PMCTRL_RUNM(base, value) (SMC_RMW_PMCTRL(base, SMC_PMCTRL_RUNM_MASK, SMC_PMCTRL_RUNM(value)))
#define SMC_BWR_PMCTRL_RUNM(base, value) (SMC_WR_PMCTRL_RUNM(base, value))
/*@}*/

/*******************************************************************************
 * SMC_STOPCTRL - Stop Control Register
 ******************************************************************************/

/*!
 * @brief SMC_STOPCTRL - Stop Control Register (RW)
 *
 * Reset value: 0x03U
 *
 * The STOPCTRL register provides various control bits allowing the user to fine
 * tune power consumption during the stop mode selected by the STOPM field. This
 * register is reset on Chip POR not VLLS and by reset types that trigger Chip
 * POR not VLLS. It is unaffected by reset types that do not trigger Chip POR not
 * VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_STOPCTRL register
 */
/*@{*/
#define SMC_RD_STOPCTRL(base)    (SMC_STOPCTRL_REG(base))
#define SMC_WR_STOPCTRL(base, value) (SMC_STOPCTRL_REG(base) = (value))
#define SMC_RMW_STOPCTRL(base, mask, value) (SMC_WR_STOPCTRL(base, (SMC_RD_STOPCTRL(base) & ~(mask)) | (value)))
#define SMC_SET_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) |  (value)))
#define SMC_CLR_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) & ~(value)))
#define SMC_TOG_STOPCTRL(base, value) (SMC_WR_STOPCTRL(base, SMC_RD_STOPCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SMC_STOPCTRL bitfields
 */

/*!
 * @name Register SMC_STOPCTRL, field LLSM[2:0] (RW)
 *
 * This field controls which LLS orVLLS sub-mode to enter if STOPM = LLSx
 * orVLLSx.
 *
 * Values:
 * - 000 - VLLS0 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 001 - VLLS1 if PMCTRL[STOPM]=VLLSx, reserved if PMCTRL[STOPM]=LLSx
 * - 010 - VLLS2 if PMCTRL[STOPM]=VLLSx, LLS2 if PMCTRL[STOPM]=LLSx
 * - 011 - VLLS3 if PMCTRL[STOPM]=VLLSx, LLS3 if PMCTRL[STOPM]=LLSx
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_LLSM field. */
#define SMC_RD_STOPCTRL_LLSM(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_LLSM_MASK) >> SMC_STOPCTRL_LLSM_SHIFT)
#define SMC_BRD_STOPCTRL_LLSM(base) (SMC_RD_STOPCTRL_LLSM(base))

/*! @brief Set the LLSM field to a new value. */
#define SMC_WR_STOPCTRL_LLSM(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_LLSM_MASK, SMC_STOPCTRL_LLSM(value)))
#define SMC_BWR_STOPCTRL_LLSM(base, value) (SMC_WR_STOPCTRL_LLSM(base, value))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PORPO[5] (RW)
 *
 * This bit controls whether the POR detect circuit is enabled in VLLS0 mode.
 *
 * Values:
 * - 0 - POR detect circuit is enabled in VLLS0
 * - 1 - POR detect circuit is disabled in VLLS0
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PORPO field. */
#define SMC_RD_STOPCTRL_PORPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PORPO_MASK) >> SMC_STOPCTRL_PORPO_SHIFT)
#define SMC_BRD_STOPCTRL_PORPO(base) (BITBAND_ACCESS8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT))

/*! @brief Set the PORPO field to a new value. */
#define SMC_WR_STOPCTRL_PORPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PORPO_MASK, SMC_STOPCTRL_PORPO(value)))
#define SMC_BWR_STOPCTRL_PORPO(base, value) (BITBAND_ACCESS8(&SMC_STOPCTRL_REG(base), SMC_STOPCTRL_PORPO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SMC_STOPCTRL, field PSTOPO[7:6] (RW)
 *
 * These bits control whether a Partial Stop mode is entered when STOPM=STOP.
 * When entering a Partial Stop mode from RUN (or VLPR) mode, the PMC, MCG and
 * flash remain fully powered, allowing the device to wakeup almost instantaneously
 * at the expense of higher power consumption. In PSTOP2, only system clocks are
 * gated allowing peripherals running on bus clock to remain fully functional. In
 * PSTOP1, both system and bus clocks are gated.
 *
 * Values:
 * - 00 - STOP - Normal Stop mode
 * - 01 - PSTOP1 - Partial Stop with both system and bus clocks disabled
 * - 10 - PSTOP2 - Partial Stop with system clock disabled and bus clock enabled
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SMC_STOPCTRL_PSTOPO field. */
#define SMC_RD_STOPCTRL_PSTOPO(base) ((SMC_STOPCTRL_REG(base) & SMC_STOPCTRL_PSTOPO_MASK) >> SMC_STOPCTRL_PSTOPO_SHIFT)
#define SMC_BRD_STOPCTRL_PSTOPO(base) (SMC_RD_STOPCTRL_PSTOPO(base))

/*! @brief Set the PSTOPO field to a new value. */
#define SMC_WR_STOPCTRL_PSTOPO(base, value) (SMC_RMW_STOPCTRL(base, SMC_STOPCTRL_PSTOPO_MASK, SMC_STOPCTRL_PSTOPO(value)))
#define SMC_BWR_STOPCTRL_PSTOPO(base, value) (SMC_WR_STOPCTRL_PSTOPO(base, value))
/*@}*/

/*******************************************************************************
 * SMC_PMSTAT - Power Mode Status register
 ******************************************************************************/

/*!
 * @brief SMC_PMSTAT - Power Mode Status register (RO)
 *
 * Reset value: 0x01U
 *
 * PMSTAT is a read-only, one-hot register which indicates the current power
 * mode of the system. This register is reset on Chip POR not VLLS and by reset
 * types that trigger Chip POR not VLLS. It is unaffected by reset types that do not
 * trigger Chip POR not VLLS. See the Reset section details for more information.
 */
/*!
 * @name Constants and macros for entire SMC_PMSTAT register
 */
/*@{*/
#define SMC_RD_PMSTAT(base)      (SMC_PMSTAT_REG(base))
/*@}*/

/*
 * MKS22F25612 SPI
 *
 * Serial Peripheral Interface
 *
 * Registers defined in this header file:
 * - SPI_MCR - Module Configuration Register
 * - SPI_TCR - Transfer Count Register
 * - SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 * - SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 * - SPI_SR - Status Register
 * - SPI_RSER - DMA/Interrupt Request Select and Enable Register
 * - SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 * - SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 * - SPI_POPR - POP RX FIFO Register
 * - SPI_TXFR0 - Transmit FIFO Registers
 * - SPI_TXFR1 - Transmit FIFO Registers
 * - SPI_TXFR2 - Transmit FIFO Registers
 * - SPI_TXFR3 - Transmit FIFO Registers
 * - SPI_RXFR0 - Receive FIFO Registers
 * - SPI_RXFR1 - Receive FIFO Registers
 * - SPI_RXFR2 - Receive FIFO Registers
 * - SPI_RXFR3 - Receive FIFO Registers
 */

#define SPI_INSTANCE_COUNT (2U) /*!< Number of instances of the SPI module. */
#define SPI0_IDX (0U) /*!< Instance number for SPI0. */
#define SPI1_IDX (1U) /*!< Instance number for SPI1. */

/*******************************************************************************
 * SPI_MCR - Module Configuration Register
 ******************************************************************************/

/*!
 * @brief SPI_MCR - Module Configuration Register (RW)
 *
 * Reset value: 0x00004001U
 *
 * Contains bits to configure various attributes associated with the module
 * operations. The HALT and MDIS bits can be changed at any time, but the effect
 * takes place only on the next frame boundary. Only the HALT and MDIS bits in the
 * MCR can be changed, while the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_MCR register
 */
/*@{*/
#define SPI_RD_MCR(base)         (SPI_MCR_REG(base))
#define SPI_WR_MCR(base, value)  (SPI_MCR_REG(base) = (value))
#define SPI_RMW_MCR(base, mask, value) (SPI_WR_MCR(base, (SPI_RD_MCR(base) & ~(mask)) | (value)))
#define SPI_SET_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) |  (value)))
#define SPI_CLR_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) & ~(value)))
#define SPI_TOG_MCR(base, value) (SPI_WR_MCR(base, SPI_RD_MCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_MCR bitfields
 */

/*!
 * @name Register SPI_MCR, field HALT[0] (RW)
 *
 * The HALT bit starts and stops frame transfers. See Start and Stop of Module
 * transfers
 *
 * Values:
 * - 0 - Start transfers.
 * - 1 - Stop transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_HALT field. */
#define SPI_RD_MCR_HALT(base) ((SPI_MCR_REG(base) & SPI_MCR_HALT_MASK) >> SPI_MCR_HALT_SHIFT)
#define SPI_BRD_MCR_HALT(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT))

/*! @brief Set the HALT field to a new value. */
#define SPI_WR_MCR_HALT(base, value) (SPI_RMW_MCR(base, SPI_MCR_HALT_MASK, SPI_MCR_HALT(value)))
#define SPI_BWR_MCR_HALT(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_HALT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field SMPL_PT[9:8] (RW)
 *
 * Controls when the module master samples SIN in Modified Transfer Format. This
 * field is valid only when CPHA bit in CTARn[CPHA] is 0.
 *
 * Values:
 * - 00 - 0 protocol clock cycles between SCK edge and SIN sample
 * - 01 - 1 protocol clock cycle between SCK edge and SIN sample
 * - 10 - 2 protocol clock cycles between SCK edge and SIN sample
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_SMPL_PT field. */
#define SPI_RD_MCR_SMPL_PT(base) ((SPI_MCR_REG(base) & SPI_MCR_SMPL_PT_MASK) >> SPI_MCR_SMPL_PT_SHIFT)
#define SPI_BRD_MCR_SMPL_PT(base) (SPI_RD_MCR_SMPL_PT(base))

/*! @brief Set the SMPL_PT field to a new value. */
#define SPI_WR_MCR_SMPL_PT(base, value) (SPI_RMW_MCR(base, SPI_MCR_SMPL_PT_MASK, SPI_MCR_SMPL_PT(value)))
#define SPI_BWR_MCR_SMPL_PT(base, value) (SPI_WR_MCR_SMPL_PT(base, value))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_RXF[10] (WORZ)
 *
 * Flushes the RX FIFO. Writing a 1 to CLR_RXF clears the RX Counter. The
 * CLR_RXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the RX FIFO counter.
 * - 1 - Clear the RX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_RXF field to a new value. */
#define SPI_WR_MCR_CLR_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_RXF_MASK, SPI_MCR_CLR_RXF(value)))
#define SPI_BWR_MCR_CLR_RXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CLR_RXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field CLR_TXF[11] (WORZ)
 *
 * Flushes the TX FIFO. Writing a 1 to CLR_TXF clears the TX FIFO Counter. The
 * CLR_TXF bit is always read as zero.
 *
 * Values:
 * - 0 - Do not clear the TX FIFO counter.
 * - 1 - Clear the TX FIFO counter.
 */
/*@{*/
/*! @brief Set the CLR_TXF field to a new value. */
#define SPI_WR_MCR_CLR_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_CLR_TXF_MASK, SPI_MCR_CLR_TXF(value)))
#define SPI_BWR_MCR_CLR_TXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CLR_TXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_RXF[12] (RW)
 *
 * When the RX FIFO is disabled, the receive part of the module operates as a
 * simplified double-buffered SPI. This bit can only be written when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - RX FIFO is enabled.
 * - 1 - RX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_RXF field. */
#define SPI_RD_MCR_DIS_RXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_RXF_MASK) >> SPI_MCR_DIS_RXF_SHIFT)
#define SPI_BRD_MCR_DIS_RXF(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT))

/*! @brief Set the DIS_RXF field to a new value. */
#define SPI_WR_MCR_DIS_RXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_RXF_MASK, SPI_MCR_DIS_RXF(value)))
#define SPI_BWR_MCR_DIS_RXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_RXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DIS_TXF[13] (RW)
 *
 * When the TX FIFO is disabled, the transmit part of the module operates as a
 * simplified double-buffered SPI. This bit can be written only when the MDIS bit
 * is cleared.
 *
 * Values:
 * - 0 - TX FIFO is enabled.
 * - 1 - TX FIFO is disabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DIS_TXF field. */
#define SPI_RD_MCR_DIS_TXF(base) ((SPI_MCR_REG(base) & SPI_MCR_DIS_TXF_MASK) >> SPI_MCR_DIS_TXF_SHIFT)
#define SPI_BRD_MCR_DIS_TXF(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT))

/*! @brief Set the DIS_TXF field to a new value. */
#define SPI_WR_MCR_DIS_TXF(base, value) (SPI_RMW_MCR(base, SPI_MCR_DIS_TXF_MASK, SPI_MCR_DIS_TXF(value)))
#define SPI_BWR_MCR_DIS_TXF(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DIS_TXF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MDIS[14] (RW)
 *
 * Allows the clock to be stopped to the non-memory mapped logic in the module
 * effectively putting it in a software-controlled power-saving state. The reset
 * value of the MDIS bit is parameterized, with a default reset value of 1. When
 * the module is used in Slave Mode, it is recommended to leave this bit 0,
 * because a slave doesn't have control over master transactions.
 *
 * Values:
 * - 0 - Enables the module clocks.
 * - 1 - Allows external logic to disable the module clocks.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MDIS field. */
#define SPI_RD_MCR_MDIS(base) ((SPI_MCR_REG(base) & SPI_MCR_MDIS_MASK) >> SPI_MCR_MDIS_SHIFT)
#define SPI_BRD_MCR_MDIS(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT))

/*! @brief Set the MDIS field to a new value. */
#define SPI_WR_MCR_MDIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_MDIS_MASK, SPI_MCR_MDIS(value)))
#define SPI_BWR_MCR_MDIS(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DOZE[15] (RW)
 *
 * Provides support for an externally controlled Doze mode power-saving
 * mechanism.
 *
 * Values:
 * - 0 - Doze mode has no effect on the module.
 * - 1 - Doze mode disables the module.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DOZE field. */
#define SPI_RD_MCR_DOZE(base) ((SPI_MCR_REG(base) & SPI_MCR_DOZE_MASK) >> SPI_MCR_DOZE_SHIFT)
#define SPI_BRD_MCR_DOZE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT))

/*! @brief Set the DOZE field to a new value. */
#define SPI_WR_MCR_DOZE(base, value) (SPI_RMW_MCR(base, SPI_MCR_DOZE_MASK, SPI_MCR_DOZE(value)))
#define SPI_BWR_MCR_DOZE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_DOZE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSIS[21:16] (RW)
 *
 * Determines the inactive state of PCSx. Refer to the chip-specific SPI
 * information for the number of PCS signals used in this chip. The effect of this bit
 * only takes place when module is enabled. Ensure that this bit is configured
 * correctly before enabling the DSPI interface.
 *
 * Values:
 * - 0 - The inactive state of PCSx is low.
 * - 1 - The inactive state of PCSx is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSIS field. */
#define SPI_RD_MCR_PCSIS(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSIS_MASK) >> SPI_MCR_PCSIS_SHIFT)
#define SPI_BRD_MCR_PCSIS(base) (SPI_RD_MCR_PCSIS(base))

/*! @brief Set the PCSIS field to a new value. */
#define SPI_WR_MCR_PCSIS(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSIS_MASK, SPI_MCR_PCSIS(value)))
#define SPI_BWR_MCR_PCSIS(base, value) (SPI_WR_MCR_PCSIS(base, value))
/*@}*/

/*!
 * @name Register SPI_MCR, field ROOE[24] (RW)
 *
 * In the RX FIFO overflow condition, configures the module to ignore the
 * incoming serial data or overwrite existing data. If the RX FIFO is full and new data
 * is received, the data from the transfer, generating the overflow, is ignored
 * or shifted into the shift register.
 *
 * Values:
 * - 0 - Incoming data is ignored.
 * - 1 - Incoming data is shifted into the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_ROOE field. */
#define SPI_RD_MCR_ROOE(base) ((SPI_MCR_REG(base) & SPI_MCR_ROOE_MASK) >> SPI_MCR_ROOE_SHIFT)
#define SPI_BRD_MCR_ROOE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT))

/*! @brief Set the ROOE field to a new value. */
#define SPI_WR_MCR_ROOE(base, value) (SPI_RMW_MCR(base, SPI_MCR_ROOE_MASK, SPI_MCR_ROOE(value)))
#define SPI_BWR_MCR_ROOE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_ROOE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field PCSSE[25] (RW)
 *
 * Enables the PCS5/ PCSS to operate as a PCS Strobe output signal.
 *
 * Values:
 * - 0 - PCS5/ PCSS is used as the Peripheral Chip Select[5] signal.
 * - 1 - PCS5/ PCSS is used as an active-low PCS Strobe signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_PCSSE field. */
#define SPI_RD_MCR_PCSSE(base) ((SPI_MCR_REG(base) & SPI_MCR_PCSSE_MASK) >> SPI_MCR_PCSSE_SHIFT)
#define SPI_BRD_MCR_PCSSE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_PCSSE_SHIFT))

/*! @brief Set the PCSSE field to a new value. */
#define SPI_WR_MCR_PCSSE(base, value) (SPI_RMW_MCR(base, SPI_MCR_PCSSE_MASK, SPI_MCR_PCSSE(value)))
#define SPI_BWR_MCR_PCSSE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_PCSSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MTFE[26] (RW)
 *
 * Enables a modified transfer format to be used.
 *
 * Values:
 * - 0 - Modified SPI transfer format disabled.
 * - 1 - Modified SPI transfer format enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MTFE field. */
#define SPI_RD_MCR_MTFE(base) ((SPI_MCR_REG(base) & SPI_MCR_MTFE_MASK) >> SPI_MCR_MTFE_SHIFT)
#define SPI_BRD_MCR_MTFE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT))

/*! @brief Set the MTFE field to a new value. */
#define SPI_WR_MCR_MTFE(base, value) (SPI_RMW_MCR(base, SPI_MCR_MTFE_MASK, SPI_MCR_MTFE(value)))
#define SPI_BWR_MCR_MTFE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MTFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field FRZ[27] (RW)
 *
 * Enables transfers to be stopped on the next frame boundary when the device
 * enters Debug mode.
 *
 * Values:
 * - 0 - Do not halt serial transfers in Debug mode.
 * - 1 - Halt serial transfers in Debug mode.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_FRZ field. */
#define SPI_RD_MCR_FRZ(base) ((SPI_MCR_REG(base) & SPI_MCR_FRZ_MASK) >> SPI_MCR_FRZ_SHIFT)
#define SPI_BRD_MCR_FRZ(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT))

/*! @brief Set the FRZ field to a new value. */
#define SPI_WR_MCR_FRZ(base, value) (SPI_RMW_MCR(base, SPI_MCR_FRZ_MASK, SPI_MCR_FRZ(value)))
#define SPI_BWR_MCR_FRZ(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_FRZ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field DCONF[29:28] (RO)
 *
 * Selects among the different configurations of the module.
 *
 * Values:
 * - 00 - SPI
 * - 01 - Reserved
 * - 10 - Reserved
 * - 11 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_DCONF field. */
#define SPI_RD_MCR_DCONF(base) ((SPI_MCR_REG(base) & SPI_MCR_DCONF_MASK) >> SPI_MCR_DCONF_SHIFT)
#define SPI_BRD_MCR_DCONF(base) (SPI_RD_MCR_DCONF(base))
/*@}*/

/*!
 * @name Register SPI_MCR, field CONT_SCKE[30] (RW)
 *
 * Enables the Serial Communication Clock (SCK) to run continuously.
 *
 * Values:
 * - 0 - Continuous SCK disabled.
 * - 1 - Continuous SCK enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_CONT_SCKE field. */
#define SPI_RD_MCR_CONT_SCKE(base) ((SPI_MCR_REG(base) & SPI_MCR_CONT_SCKE_MASK) >> SPI_MCR_CONT_SCKE_SHIFT)
#define SPI_BRD_MCR_CONT_SCKE(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT))

/*! @brief Set the CONT_SCKE field to a new value. */
#define SPI_WR_MCR_CONT_SCKE(base, value) (SPI_RMW_MCR(base, SPI_MCR_CONT_SCKE_MASK, SPI_MCR_CONT_SCKE(value)))
#define SPI_BWR_MCR_CONT_SCKE(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_CONT_SCKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_MCR, field MSTR[31] (RW)
 *
 * Enables either Master mode (if supported) or Slave mode (if supported)
 * operation.
 *
 * Values:
 * - 0 - Enables Slave mode
 * - 1 - Enables Master mode
 */
/*@{*/
/*! @brief Read current value of the SPI_MCR_MSTR field. */
#define SPI_RD_MCR_MSTR(base) ((SPI_MCR_REG(base) & SPI_MCR_MSTR_MASK) >> SPI_MCR_MSTR_SHIFT)
#define SPI_BRD_MCR_MSTR(base) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT))

/*! @brief Set the MSTR field to a new value. */
#define SPI_WR_MCR_MSTR(base, value) (SPI_RMW_MCR(base, SPI_MCR_MSTR_MASK, SPI_MCR_MSTR(value)))
#define SPI_BWR_MCR_MSTR(base, value) (BITBAND_ACCESS32(&SPI_MCR_REG(base), SPI_MCR_MSTR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_TCR - Transfer Count Register
 ******************************************************************************/

/*!
 * @brief SPI_TCR - Transfer Count Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * TCR contains a counter that indicates the number of SPI transfers made. The
 * transfer counter is intended to assist in queue management. Do not write the
 * TCR when the module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_TCR register
 */
/*@{*/
#define SPI_RD_TCR(base)         (SPI_TCR_REG(base))
#define SPI_WR_TCR(base, value)  (SPI_TCR_REG(base) = (value))
#define SPI_RMW_TCR(base, mask, value) (SPI_WR_TCR(base, (SPI_RD_TCR(base) & ~(mask)) | (value)))
#define SPI_SET_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) |  (value)))
#define SPI_CLR_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) & ~(value)))
#define SPI_TOG_TCR(base, value) (SPI_WR_TCR(base, SPI_RD_TCR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_TCR bitfields
 */

/*!
 * @name Register SPI_TCR, field SPI_TCNT[31:16] (RW)
 *
 * Counts the number of SPI transfers the module makes. The SPI_TCNT field
 * increments every time the last bit of an SPI frame is transmitted. A value written
 * to SPI_TCNT presets the counter to that value. SPI_TCNT is reset to zero at
 * the beginning of the frame when the CTCNT field is set in the executing SPI
 * command. The Transfer Counter wraps around; incrementing the counter past 65535
 * resets the counter to zero.
 */
/*@{*/
/*! @brief Read current value of the SPI_TCR_SPI_TCNT field. */
#define SPI_RD_TCR_SPI_TCNT(base) ((SPI_TCR_REG(base) & SPI_TCR_SPI_TCNT_MASK) >> SPI_TCR_SPI_TCNT_SHIFT)
#define SPI_BRD_TCR_SPI_TCNT(base) (SPI_RD_TCR_SPI_TCNT(base))

/*! @brief Set the SPI_TCNT field to a new value. */
#define SPI_WR_TCR_SPI_TCNT(base, value) (SPI_RMW_TCR(base, SPI_TCR_SPI_TCNT_MASK, SPI_TCR_SPI_TCNT(value)))
#define SPI_BWR_TCR_SPI_TCNT(base, value) (SPI_WR_TCR_SPI_TCNT(base, value))
/*@}*/

/*******************************************************************************
 * SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR_SLAVE - Clock and Transfer Attributes Register (In Slave Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * When the module is configured as an SPI bus slave, the CTAR0 register is used.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR_SLAVE register
 */
/*@{*/
#define SPI_RD_CTAR_SLAVE(base, index) (SPI_CTAR_SLAVE_REG(base, index))
#define SPI_WR_CTAR_SLAVE(base, index, value) (SPI_CTAR_SLAVE_REG(base, index) = (value))
#define SPI_RMW_CTAR_SLAVE(base, index, mask, value) (SPI_WR_CTAR_SLAVE(base, index, (SPI_RD_CTAR_SLAVE(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) |  (value)))
#define SPI_CLR_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) & ~(value)))
#define SPI_TOG_CTAR_SLAVE(base, index, value) (SPI_WR_CTAR_SLAVE(base, index, SPI_RD_CTAR_SLAVE(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR_SLAVE bitfields
 */

/*!
 * @name Register SPI_CTAR_SLAVE, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPHA field. */
#define SPI_RD_CTAR_SLAVE_CPHA(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPHA_MASK) >> SPI_CTAR_SLAVE_CPHA_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPHA(base, index) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPHA(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPHA_MASK, SPI_CTAR_SLAVE_CPHA(value)))
#define SPI_BWR_CTAR_SLAVE_CPHA(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPHA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_CPOL field. */
#define SPI_RD_CTAR_SLAVE_CPOL(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_CPOL_MASK) >> SPI_CTAR_SLAVE_CPOL_SHIFT)
#define SPI_BRD_CTAR_SLAVE_CPOL(base, index) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_SLAVE_CPOL(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_CPOL_MASK, SPI_CTAR_SLAVE_CPOL(value)))
#define SPI_BWR_CTAR_SLAVE_CPOL(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_SLAVE_REG(base, index), SPI_CTAR_SLAVE_CPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR_SLAVE, field FMSZ[30:27] (RW)
 *
 * The number of bits transfered per frame is equal to the FMSZ field value plus
 * 1. Note that the minimum valid value of frame size is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_SLAVE_FMSZ field. */
#define SPI_RD_CTAR_SLAVE_FMSZ(base, index) ((SPI_CTAR_SLAVE_REG(base, index) & SPI_CTAR_SLAVE_FMSZ_MASK) >> SPI_CTAR_SLAVE_FMSZ_SHIFT)
#define SPI_BRD_CTAR_SLAVE_FMSZ(base, index) (SPI_RD_CTAR_SLAVE_FMSZ(base, index))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_RMW_CTAR_SLAVE(base, index, SPI_CTAR_SLAVE_FMSZ_MASK, SPI_CTAR_SLAVE_FMSZ(value)))
#define SPI_BWR_CTAR_SLAVE_FMSZ(base, index, value) (SPI_WR_CTAR_SLAVE_FMSZ(base, index, value))
/*@}*/

/*******************************************************************************
 * SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode)
 ******************************************************************************/

/*!
 * @brief SPI_CTAR - Clock and Transfer Attributes Register (In Master Mode) (RW)
 *
 * Reset value: 0x78000000U
 *
 * CTAR registers are used to define different transfer attributes. Do not write
 * to the CTAR registers while the module is in the Running state. In Master
 * mode, the CTAR registers define combinations of transfer attributes such as frame
 * size, clock phase and polarity, data bit ordering, baud rate, and various
 * delays. In slave mode, a subset of the bitfields in CTAR0 are used to set the
 * slave transfer attributes. When the module is configured as an SPI master, the
 * CTAS field in the command portion of the TX FIFO entry selects which of the CTAR
 * registers is used. When the module is configured as an SPI bus slave, it uses
 * the CTAR0 register.
 */
/*!
 * @name Constants and macros for entire SPI_CTAR register
 */
/*@{*/
#define SPI_RD_CTAR(base, index) (SPI_CTAR_REG(base, index))
#define SPI_WR_CTAR(base, index, value) (SPI_CTAR_REG(base, index) = (value))
#define SPI_RMW_CTAR(base, index, mask, value) (SPI_WR_CTAR(base, index, (SPI_RD_CTAR(base, index) & ~(mask)) | (value)))
#define SPI_SET_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) |  (value)))
#define SPI_CLR_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) & ~(value)))
#define SPI_TOG_CTAR(base, index, value) (SPI_WR_CTAR(base, index, SPI_RD_CTAR(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_CTAR bitfields
 */

/*!
 * @name Register SPI_CTAR, field BR[3:0] (RW)
 *
 * Selects the scaler value for the baud rate. This field is used only in master
 * mode. The prescaled protocol clock is divided by the Baud Rate Scaler to
 * generate the frequency of the SCK. The baud rate is computed according to the
 * following equation: SCK baud rate = (fP /PBR) x [(1+DBR)/BR] The following table
 * lists the baud rate scaler values. Baud Rate Scaler CTARn[BR] Baud Rate Scaler
 * Value 0000 2 0001 4 0010 6 0011 8 0100 16 0101 32 0110 64 0111 128 1000 256
 * 1001 512 1010 1024 1011 2048 1100 4096 1101 8192 1110 16384 1111 32768
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_BR field. */
#define SPI_RD_CTAR_BR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_BR_MASK) >> SPI_CTAR_BR_SHIFT)
#define SPI_BRD_CTAR_BR(base, index) (SPI_RD_CTAR_BR(base, index))

/*! @brief Set the BR field to a new value. */
#define SPI_WR_CTAR_BR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_BR_MASK, SPI_CTAR_BR(value)))
#define SPI_BWR_CTAR_BR(base, index, value) (SPI_WR_CTAR_BR(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DT[7:4] (RW)
 *
 * Selects the Delay after Transfer Scaler. This field is used only in master
 * mode. The Delay after Transfer is the time between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the next
 * frame. In the Continuous Serial Communications Clock operation, the DT value
 * is fixed to one SCK clock period, The Delay after Transfer is a multiple of the
 * protocol clock period, and it is computed according to the following
 * equation: tDT = (1/fP ) x PDT x DT See Delay Scaler Encoding table in CTARn[CSSCK] bit
 * field description for scaler values.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DT field. */
#define SPI_RD_CTAR_DT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DT_MASK) >> SPI_CTAR_DT_SHIFT)
#define SPI_BRD_CTAR_DT(base, index) (SPI_RD_CTAR_DT(base, index))

/*! @brief Set the DT field to a new value. */
#define SPI_WR_CTAR_DT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DT_MASK, SPI_CTAR_DT(value)))
#define SPI_BWR_CTAR_DT(base, index, value) (SPI_WR_CTAR_DT(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field ASC[11:8] (RW)
 *
 * Selects the scaler value for the After SCK Delay. This field is used only in
 * master mode. The After SCK Delay is the delay between the last edge of SCK and
 * the negation of PCS. The delay is a multiple of the protocol clock period,
 * and it is computed according to the following equation: t ASC = (1/fP) x PASC x
 * ASC See Delay Scaler Encoding table in CTARn[CSSCK] bit field description for
 * scaler values. Refer After SCK Delay (tASC ) for more details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_ASC field. */
#define SPI_RD_CTAR_ASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_ASC_MASK) >> SPI_CTAR_ASC_SHIFT)
#define SPI_BRD_CTAR_ASC(base, index) (SPI_RD_CTAR_ASC(base, index))

/*! @brief Set the ASC field to a new value. */
#define SPI_WR_CTAR_ASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_ASC_MASK, SPI_CTAR_ASC(value)))
#define SPI_BWR_CTAR_ASC(base, index, value) (SPI_WR_CTAR_ASC(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CSSCK[15:12] (RW)
 *
 * Selects the scaler value for the PCS to SCK delay. This field is used only in
 * master mode. The PCS to SCK Delay is the delay between the assertion of PCS
 * and the first edge of the SCK. The delay is a multiple of the protocol clock
 * period, and it is computed according to the following equation: t CSC = (1/fP )
 * x PCSSCK x CSSCK. The following table lists the delay scaler values. Delay
 * Scaler Encoding Field Value Delay Scaler Value 0000 2 0001 4 0010 8 0011 16 0100
 * 32 0101 64 0110 128 0111 256 1000 512 1001 1024 1010 2048 1011 4096 1100 8192
 * 1101 16384 1110 32768 1111 65536 Refer PCS to SCK Delay (tCSC ) for more
 * details.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CSSCK field. */
#define SPI_RD_CTAR_CSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CSSCK_MASK) >> SPI_CTAR_CSSCK_SHIFT)
#define SPI_BRD_CTAR_CSSCK(base, index) (SPI_RD_CTAR_CSSCK(base, index))

/*! @brief Set the CSSCK field to a new value. */
#define SPI_WR_CTAR_CSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CSSCK_MASK, SPI_CTAR_CSSCK(value)))
#define SPI_BWR_CTAR_CSSCK(base, index, value) (SPI_WR_CTAR_CSSCK(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PBR[17:16] (RW)
 *
 * Selects the prescaler value for the baud rate. This field is used only in
 * master mode. The baud rate is the frequency of the SCK. The protocol clock is
 * divided by the prescaler value before the baud rate selection takes place. See
 * the BR field description for details on how to compute the baud rate.
 *
 * Values:
 * - 00 - Baud Rate Prescaler value is 2.
 * - 01 - Baud Rate Prescaler value is 3.
 * - 10 - Baud Rate Prescaler value is 5.
 * - 11 - Baud Rate Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PBR field. */
#define SPI_RD_CTAR_PBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PBR_MASK) >> SPI_CTAR_PBR_SHIFT)
#define SPI_BRD_CTAR_PBR(base, index) (SPI_RD_CTAR_PBR(base, index))

/*! @brief Set the PBR field to a new value. */
#define SPI_WR_CTAR_PBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PBR_MASK, SPI_CTAR_PBR(value)))
#define SPI_BWR_CTAR_PBR(base, index, value) (SPI_WR_CTAR_PBR(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PDT[19:18] (RW)
 *
 * Selects the prescaler value for the delay between the negation of the PCS
 * signal at the end of a frame and the assertion of PCS at the beginning of the
 * next frame. The PDT field is only used in master mode. See the DT field
 * description for details on how to compute the Delay after Transfer. Refer Delay after
 * Transfer (tDT ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PDT field. */
#define SPI_RD_CTAR_PDT(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PDT_MASK) >> SPI_CTAR_PDT_SHIFT)
#define SPI_BRD_CTAR_PDT(base, index) (SPI_RD_CTAR_PDT(base, index))

/*! @brief Set the PDT field to a new value. */
#define SPI_WR_CTAR_PDT(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PDT_MASK, SPI_CTAR_PDT(value)))
#define SPI_BWR_CTAR_PDT(base, index, value) (SPI_WR_CTAR_PDT(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PASC[21:20] (RW)
 *
 * Selects the prescaler value for the delay between the last edge of SCK and
 * the negation of PCS. See the ASC field description for information on how to
 * compute the After SCK Delay. Refer After SCK Delay (tASC ) for more details.
 *
 * Values:
 * - 00 - Delay after Transfer Prescaler value is 1.
 * - 01 - Delay after Transfer Prescaler value is 3.
 * - 10 - Delay after Transfer Prescaler value is 5.
 * - 11 - Delay after Transfer Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PASC field. */
#define SPI_RD_CTAR_PASC(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PASC_MASK) >> SPI_CTAR_PASC_SHIFT)
#define SPI_BRD_CTAR_PASC(base, index) (SPI_RD_CTAR_PASC(base, index))

/*! @brief Set the PASC field to a new value. */
#define SPI_WR_CTAR_PASC(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PASC_MASK, SPI_CTAR_PASC(value)))
#define SPI_BWR_CTAR_PASC(base, index, value) (SPI_WR_CTAR_PASC(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field PCSSCK[23:22] (RW)
 *
 * Selects the prescaler value for the delay between assertion of PCS and the
 * first edge of the SCK. See the CSSCK field description for information on how to
 * compute the PCS to SCK Delay. Refer PCS to SCK Delay (tCSC ) for more details.
 *
 * Values:
 * - 00 - PCS to SCK Prescaler value is 1.
 * - 01 - PCS to SCK Prescaler value is 3.
 * - 10 - PCS to SCK Prescaler value is 5.
 * - 11 - PCS to SCK Prescaler value is 7.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_PCSSCK field. */
#define SPI_RD_CTAR_PCSSCK(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_PCSSCK_MASK) >> SPI_CTAR_PCSSCK_SHIFT)
#define SPI_BRD_CTAR_PCSSCK(base, index) (SPI_RD_CTAR_PCSSCK(base, index))

/*! @brief Set the PCSSCK field to a new value. */
#define SPI_WR_CTAR_PCSSCK(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_PCSSCK_MASK, SPI_CTAR_PCSSCK(value)))
#define SPI_BWR_CTAR_PCSSCK(base, index, value) (SPI_WR_CTAR_PCSSCK(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field LSBFE[24] (RW)
 *
 * Specifies whether the LSB or MSB of the frame is transferred first.
 *
 * Values:
 * - 0 - Data is transferred MSB first.
 * - 1 - Data is transferred LSB first.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_LSBFE field. */
#define SPI_RD_CTAR_LSBFE(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_LSBFE_MASK) >> SPI_CTAR_LSBFE_SHIFT)
#define SPI_BRD_CTAR_LSBFE(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT))

/*! @brief Set the LSBFE field to a new value. */
#define SPI_WR_CTAR_LSBFE(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_LSBFE_MASK, SPI_CTAR_LSBFE(value)))
#define SPI_BWR_CTAR_LSBFE(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_LSBFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPHA[25] (RW)
 *
 * Selects which edge of SCK causes data to change and which edge causes data to
 * be captured. This bit is used in both master and slave mode. For successful
 * communication between serial devices, the devices must have identical clock
 * phase settings. In Continuous SCK mode, the bit value is ignored and the
 * transfers are done as if the CPHA bit is set to 1.
 *
 * Values:
 * - 0 - Data is captured on the leading edge of SCK and changed on the
 *     following edge.
 * - 1 - Data is changed on the leading edge of SCK and captured on the
 *     following edge.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPHA field. */
#define SPI_RD_CTAR_CPHA(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPHA_MASK) >> SPI_CTAR_CPHA_SHIFT)
#define SPI_BRD_CTAR_CPHA(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT))

/*! @brief Set the CPHA field to a new value. */
#define SPI_WR_CTAR_CPHA(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPHA_MASK, SPI_CTAR_CPHA(value)))
#define SPI_BWR_CTAR_CPHA(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPHA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field CPOL[26] (RW)
 *
 * Selects the inactive state of the Serial Communications Clock (SCK). This bit
 * is used in both master and slave mode. For successful communication between
 * serial devices, the devices must have identical clock polarities. When the
 * Continuous Selection Format is selected, switching between clock polarities
 * without stopping the module can cause errors in the transfer due to the peripheral
 * device interpreting the switch of clock polarity as a valid clock edge. In case
 * of Continuous SCK mode, when the module goes in low power mode(disabled),
 * inactive state of SCK is not guaranted.
 *
 * Values:
 * - 0 - The inactive state value of SCK is low.
 * - 1 - The inactive state value of SCK is high.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_CPOL field. */
#define SPI_RD_CTAR_CPOL(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_CPOL_MASK) >> SPI_CTAR_CPOL_SHIFT)
#define SPI_BRD_CTAR_CPOL(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT))

/*! @brief Set the CPOL field to a new value. */
#define SPI_WR_CTAR_CPOL(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_CPOL_MASK, SPI_CTAR_CPOL(value)))
#define SPI_BWR_CTAR_CPOL(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_CPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field FMSZ[30:27] (RW)
 *
 * The number of bits transferred per frame is equal to the FMSZ value plus 1.
 * Regardless of the transmission mode, the minimum valid frame size value is 4.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_FMSZ field. */
#define SPI_RD_CTAR_FMSZ(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_FMSZ_MASK) >> SPI_CTAR_FMSZ_SHIFT)
#define SPI_BRD_CTAR_FMSZ(base, index) (SPI_RD_CTAR_FMSZ(base, index))

/*! @brief Set the FMSZ field to a new value. */
#define SPI_WR_CTAR_FMSZ(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_FMSZ_MASK, SPI_CTAR_FMSZ(value)))
#define SPI_BWR_CTAR_FMSZ(base, index, value) (SPI_WR_CTAR_FMSZ(base, index, value))
/*@}*/

/*!
 * @name Register SPI_CTAR, field DBR[31] (RW)
 *
 * Doubles the effective baud rate of the Serial Communications Clock (SCK).
 * This field is used only in master mode. It effectively halves the Baud Rate
 * division ratio, supporting faster frequencies, and odd division ratios for the
 * Serial Communications Clock (SCK). When the DBR bit is set, the duty cycle of the
 * Serial Communications Clock (SCK) depends on the value in the Baud Rate
 * Prescaler and the Clock Phase bit as listed in the following table. See the BR field
 * description for details on how to compute the baud rate. SPI SCK Duty Cycle
 * DBR CPHA PBR SCK Duty Cycle 0 any any 50/50 1 0 00 50/50 1 0 01 33/66 1 0 10
 * 40/60 1 0 11 43/57 1 1 00 50/50 1 1 01 66/33 1 1 10 60/40 1 1 11 57/43
 *
 * Values:
 * - 0 - The baud rate is computed normally with a 50/50 duty cycle.
 * - 1 - The baud rate is doubled with the duty cycle depending on the Baud Rate
 *     Prescaler.
 */
/*@{*/
/*! @brief Read current value of the SPI_CTAR_DBR field. */
#define SPI_RD_CTAR_DBR(base, index) ((SPI_CTAR_REG(base, index) & SPI_CTAR_DBR_MASK) >> SPI_CTAR_DBR_SHIFT)
#define SPI_BRD_CTAR_DBR(base, index) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT))

/*! @brief Set the DBR field to a new value. */
#define SPI_WR_CTAR_DBR(base, index, value) (SPI_RMW_CTAR(base, index, SPI_CTAR_DBR_MASK, SPI_CTAR_DBR(value)))
#define SPI_BWR_CTAR_DBR(base, index, value) (BITBAND_ACCESS32(&SPI_CTAR_REG(base, index), SPI_CTAR_DBR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_SR - Status Register
 ******************************************************************************/

/*!
 * @brief SPI_SR - Status Register (RW)
 *
 * Reset value: 0x02000000U
 *
 * SR contains status and flag bits. The bits reflect the status of the module
 * and indicate the occurrence of events that can generate interrupt or DMA
 * requests. Software can clear flag bits in the SR by writing a 1 to them. Writing a 0
 * to a flag bit has no effect. This register may not be writable in Module
 * Disable mode due to the use of power saving mechanisms.
 */
/*!
 * @name Constants and macros for entire SPI_SR register
 */
/*@{*/
#define SPI_RD_SR(base)          (SPI_SR_REG(base))
#define SPI_WR_SR(base, value)   (SPI_SR_REG(base) = (value))
#define SPI_RMW_SR(base, mask, value) (SPI_WR_SR(base, (SPI_RD_SR(base) & ~(mask)) | (value)))
#define SPI_SET_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) |  (value)))
#define SPI_CLR_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) & ~(value)))
#define SPI_TOG_SR(base, value)  (SPI_WR_SR(base, SPI_RD_SR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_SR bitfields
 */

/*!
 * @name Register SPI_SR, field POPNXTPTR[3:0] (RO)
 *
 * Contains a pointer to the RX FIFO entry to be returned when the POPR is read.
 * The POPNXTPTR is updated when the POPR is read.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_POPNXTPTR field. */
#define SPI_RD_SR_POPNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_POPNXTPTR_MASK) >> SPI_SR_POPNXTPTR_SHIFT)
#define SPI_BRD_SR_POPNXTPTR(base) (SPI_RD_SR_POPNXTPTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field RXCTR[7:4] (RO)
 *
 * Indicates the number of entries in the RX FIFO. The RXCTR is decremented
 * every time the POPR is read. The RXCTR is incremented every time data is
 * transferred from the shift register to the RX FIFO.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RXCTR field. */
#define SPI_RD_SR_RXCTR(base) ((SPI_SR_REG(base) & SPI_SR_RXCTR_MASK) >> SPI_SR_RXCTR_SHIFT)
#define SPI_BRD_SR_RXCTR(base) (SPI_RD_SR_RXCTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field TXNXTPTR[11:8] (RO)
 *
 * Indicates which TX FIFO entry is transmitted during the next transfer. The
 * TXNXTPTR field is updated every time SPI data is transferred from the TX FIFO to
 * the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXNXTPTR field. */
#define SPI_RD_SR_TXNXTPTR(base) ((SPI_SR_REG(base) & SPI_SR_TXNXTPTR_MASK) >> SPI_SR_TXNXTPTR_SHIFT)
#define SPI_BRD_SR_TXNXTPTR(base) (SPI_RD_SR_TXNXTPTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field TXCTR[15:12] (RO)
 *
 * Indicates the number of valid entries in the TX FIFO. The TXCTR is
 * incremented every time the PUSHR is written. The TXCTR is decremented every time an SPI
 * command is executed and the SPI data is transferred to the shift register.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXCTR field. */
#define SPI_RD_SR_TXCTR(base) ((SPI_SR_REG(base) & SPI_SR_TXCTR_MASK) >> SPI_SR_TXCTR_SHIFT)
#define SPI_BRD_SR_TXCTR(base) (SPI_RD_SR_TXCTR(base))
/*@}*/

/*!
 * @name Register SPI_SR, field RFDF[17] (W1C)
 *
 * Provides a method for the module to request that entries be removed from the
 * RX FIFO. The bit is set while the RX FIFO is not empty. The RFDF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller when
 * the RX FIFO is empty.
 *
 * Values:
 * - 0 - RX FIFO is empty.
 * - 1 - RX FIFO is not empty.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFDF field. */
#define SPI_RD_SR_RFDF(base) ((SPI_SR_REG(base) & SPI_SR_RFDF_MASK) >> SPI_SR_RFDF_SHIFT)
#define SPI_BRD_SR_RFDF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT))

/*! @brief Set the RFDF field to a new value. */
#define SPI_WR_SR_RFDF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFDF(value)))
#define SPI_BWR_SR_RFDF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFDF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field RFOF[19] (W1C)
 *
 * Indicates an overflow condition in the RX FIFO. The field is set when the RX
 * FIFO and shift register are full and a transfer is initiated. The bit remains
 * set until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No Rx FIFO overflow.
 * - 1 - Rx FIFO overflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_RFOF field. */
#define SPI_RD_SR_RFOF(base) ((SPI_SR_REG(base) & SPI_SR_RFOF_MASK) >> SPI_SR_RFOF_SHIFT)
#define SPI_BRD_SR_RFOF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT))

/*! @brief Set the RFOF field to a new value. */
#define SPI_WR_SR_RFOF(base, value) (SPI_RMW_SR(base, (SPI_SR_RFOF_MASK | SPI_SR_RFDF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_RFOF(value)))
#define SPI_BWR_SR_RFOF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_RFOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TFFF[25] (W1C)
 *
 * Provides a method for the module to request more entries to be added to the
 * TX FIFO. The TFFF bit is set while the TX FIFO is not full. The TFFF bit can be
 * cleared by writing 1 to it or by acknowledgement from the DMA controller to
 * the TX FIFO full request.
 *
 * Values:
 * - 0 - TX FIFO is full.
 * - 1 - TX FIFO is not full.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFFF field. */
#define SPI_RD_SR_TFFF(base) ((SPI_SR_REG(base) & SPI_SR_TFFF_MASK) >> SPI_SR_TFFF_SHIFT)
#define SPI_BRD_SR_TFFF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT))

/*! @brief Set the TFFF field to a new value. */
#define SPI_WR_SR_TFFF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFFF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFFF(value)))
#define SPI_BWR_SR_TFFF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFFF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TFUF[27] (W1C)
 *
 * Indicates an underflow condition in the TX FIFO. The transmit underflow
 * condition is detected only for SPI blocks operating in Slave mode and SPI
 * configuration. TFUF is set when the TX FIFO of the module operating in SPI Slave mode
 * is empty and an external SPI master initiates a transfer. The TFUF bit remains
 * set until cleared by writing 1 to it.
 *
 * Values:
 * - 0 - No TX FIFO underflow.
 * - 1 - TX FIFO underflow has occurred.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TFUF field. */
#define SPI_RD_SR_TFUF(base) ((SPI_SR_REG(base) & SPI_SR_TFUF_MASK) >> SPI_SR_TFUF_SHIFT)
#define SPI_BRD_SR_TFUF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT))

/*! @brief Set the TFUF field to a new value. */
#define SPI_WR_SR_TFUF(base, value) (SPI_RMW_SR(base, (SPI_SR_TFUF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_TFUF(value)))
#define SPI_BWR_SR_TFUF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TFUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field EOQF[28] (W1C)
 *
 * Indicates that the last entry in a queue has been transmitted when the module
 * is in Master mode. The EOQF bit is set when the TX FIFO entry has the EOQ bit
 * set in the command halfword and the end of the transfer is reached. The EOQF
 * bit remains set until cleared by writing a 1 to it. When the EOQF bit is set,
 * the TXRXS bit is automatically cleared.
 *
 * Values:
 * - 0 - EOQ is not set in the executing command.
 * - 1 - EOQ is set in the executing SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_EOQF field. */
#define SPI_RD_SR_EOQF(base) ((SPI_SR_REG(base) & SPI_SR_EOQF_MASK) >> SPI_SR_EOQF_SHIFT)
#define SPI_BRD_SR_EOQF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT))

/*! @brief Set the EOQF field to a new value. */
#define SPI_WR_SR_EOQF(base, value) (SPI_RMW_SR(base, (SPI_SR_EOQF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_TXRXS_MASK | SPI_SR_TCF_MASK), SPI_SR_EOQF(value)))
#define SPI_BWR_SR_EOQF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_EOQF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TXRXS[30] (W1C)
 *
 * Reflects the run status of the module.
 *
 * Values:
 * - 0 - Transmit and receive operations are disabled (The module is in Stopped
 *     state).
 * - 1 - Transmit and receive operations are enabled (The module is in Running
 *     state).
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TXRXS field. */
#define SPI_RD_SR_TXRXS(base) ((SPI_SR_REG(base) & SPI_SR_TXRXS_MASK) >> SPI_SR_TXRXS_SHIFT)
#define SPI_BRD_SR_TXRXS(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT))

/*! @brief Set the TXRXS field to a new value. */
#define SPI_WR_SR_TXRXS(base, value) (SPI_RMW_SR(base, (SPI_SR_TXRXS_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TCF_MASK), SPI_SR_TXRXS(value)))
#define SPI_BWR_SR_TXRXS(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TXRXS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_SR, field TCF[31] (W1C)
 *
 * Indicates that all bits in a frame have been shifted out. TCF remains set
 * until it is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - Transfer not complete.
 * - 1 - Transfer complete.
 */
/*@{*/
/*! @brief Read current value of the SPI_SR_TCF field. */
#define SPI_RD_SR_TCF(base)  ((SPI_SR_REG(base) & SPI_SR_TCF_MASK) >> SPI_SR_TCF_SHIFT)
#define SPI_BRD_SR_TCF(base) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT))

/*! @brief Set the TCF field to a new value. */
#define SPI_WR_SR_TCF(base, value) (SPI_RMW_SR(base, (SPI_SR_TCF_MASK | SPI_SR_RFDF_MASK | SPI_SR_RFOF_MASK | SPI_SR_TFFF_MASK | SPI_SR_TFUF_MASK | SPI_SR_EOQF_MASK | SPI_SR_TXRXS_MASK), SPI_SR_TCF(value)))
#define SPI_BWR_SR_TCF(base, value) (BITBAND_ACCESS32(&SPI_SR_REG(base), SPI_SR_TCF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_RSER - DMA/Interrupt Request Select and Enable Register
 ******************************************************************************/

/*!
 * @brief SPI_RSER - DMA/Interrupt Request Select and Enable Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * RSER controls DMA and interrupt requests. Do not write to the RSER while the
 * module is in the Running state.
 */
/*!
 * @name Constants and macros for entire SPI_RSER register
 */
/*@{*/
#define SPI_RD_RSER(base)        (SPI_RSER_REG(base))
#define SPI_WR_RSER(base, value) (SPI_RSER_REG(base) = (value))
#define SPI_RMW_RSER(base, mask, value) (SPI_WR_RSER(base, (SPI_RD_RSER(base) & ~(mask)) | (value)))
#define SPI_SET_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) |  (value)))
#define SPI_CLR_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) & ~(value)))
#define SPI_TOG_RSER(base, value) (SPI_WR_RSER(base, SPI_RD_RSER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_RSER bitfields
 */

/*!
 * @name Register SPI_RSER, field RFDF_DIRS[16] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When the
 * RFDF flag bit in the SR is set, and the RFDF_RE bit in the RSER is set, the
 * RFDF_DIRS bit selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - Interrupt request.
 * - 1 - DMA request.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_DIRS field. */
#define SPI_RD_RSER_RFDF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_DIRS_MASK) >> SPI_RSER_RFDF_DIRS_SHIFT)
#define SPI_BRD_RSER_RFDF_DIRS(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT))

/*! @brief Set the RFDF_DIRS field to a new value. */
#define SPI_WR_RSER_RFDF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_DIRS_MASK, SPI_RSER_RFDF_DIRS(value)))
#define SPI_BWR_RSER_RFDF_DIRS(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_DIRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFDF_RE[17] (RW)
 *
 * Enables the RFDF flag in the SR to generate a request. The RFDF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - RFDF interrupt or DMA requests are disabled.
 * - 1 - RFDF interrupt or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFDF_RE field. */
#define SPI_RD_RSER_RFDF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFDF_RE_MASK) >> SPI_RSER_RFDF_RE_SHIFT)
#define SPI_BRD_RSER_RFDF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT))

/*! @brief Set the RFDF_RE field to a new value. */
#define SPI_WR_RSER_RFDF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFDF_RE_MASK, SPI_RSER_RFDF_RE(value)))
#define SPI_BWR_RSER_RFDF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFDF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field RFOF_RE[19] (RW)
 *
 * Enables the RFOF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - RFOF interrupt requests are disabled.
 * - 1 - RFOF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_RFOF_RE field. */
#define SPI_RD_RSER_RFOF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_RFOF_RE_MASK) >> SPI_RSER_RFOF_RE_SHIFT)
#define SPI_BRD_RSER_RFOF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT))

/*! @brief Set the RFOF_RE field to a new value. */
#define SPI_WR_RSER_RFOF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_RFOF_RE_MASK, SPI_RSER_RFOF_RE(value)))
#define SPI_BWR_RSER_RFOF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_RFOF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_DIRS[24] (RW)
 *
 * Selects between generating a DMA request or an interrupt request. When
 * SR[TFFF] and RSER[TFFF_RE] are set, this field selects between generating an
 * interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF flag generates interrupt requests.
 * - 1 - TFFF flag generates DMA requests.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_DIRS field. */
#define SPI_RD_RSER_TFFF_DIRS(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_DIRS_MASK) >> SPI_RSER_TFFF_DIRS_SHIFT)
#define SPI_BRD_RSER_TFFF_DIRS(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT))

/*! @brief Set the TFFF_DIRS field to a new value. */
#define SPI_WR_RSER_TFFF_DIRS(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_DIRS_MASK, SPI_RSER_TFFF_DIRS(value)))
#define SPI_BWR_RSER_TFFF_DIRS(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_DIRS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFFF_RE[25] (RW)
 *
 * Enables the TFFF flag in the SR to generate a request. The TFFF_DIRS bit
 * selects between generating an interrupt request or a DMA request.
 *
 * Values:
 * - 0 - TFFF interrupts or DMA requests are disabled.
 * - 1 - TFFF interrupts or DMA requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFFF_RE field. */
#define SPI_RD_RSER_TFFF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFFF_RE_MASK) >> SPI_RSER_TFFF_RE_SHIFT)
#define SPI_BRD_RSER_TFFF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT))

/*! @brief Set the TFFF_RE field to a new value. */
#define SPI_WR_RSER_TFFF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFFF_RE_MASK, SPI_RSER_TFFF_RE(value)))
#define SPI_BWR_RSER_TFFF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFFF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TFUF_RE[27] (RW)
 *
 * Enables the TFUF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TFUF interrupt requests are disabled.
 * - 1 - TFUF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TFUF_RE field. */
#define SPI_RD_RSER_TFUF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TFUF_RE_MASK) >> SPI_RSER_TFUF_RE_SHIFT)
#define SPI_BRD_RSER_TFUF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT))

/*! @brief Set the TFUF_RE field to a new value. */
#define SPI_WR_RSER_TFUF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TFUF_RE_MASK, SPI_RSER_TFUF_RE(value)))
#define SPI_BWR_RSER_TFUF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TFUF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field EOQF_RE[28] (RW)
 *
 * Enables the EOQF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - EOQF interrupt requests are disabled.
 * - 1 - EOQF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_EOQF_RE field. */
#define SPI_RD_RSER_EOQF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_EOQF_RE_MASK) >> SPI_RSER_EOQF_RE_SHIFT)
#define SPI_BRD_RSER_EOQF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT))

/*! @brief Set the EOQF_RE field to a new value. */
#define SPI_WR_RSER_EOQF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_EOQF_RE_MASK, SPI_RSER_EOQF_RE(value)))
#define SPI_BWR_RSER_EOQF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_EOQF_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_RSER, field TCF_RE[31] (RW)
 *
 * Enables TCF flag in the SR to generate an interrupt request.
 *
 * Values:
 * - 0 - TCF interrupt requests are disabled.
 * - 1 - TCF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the SPI_RSER_TCF_RE field. */
#define SPI_RD_RSER_TCF_RE(base) ((SPI_RSER_REG(base) & SPI_RSER_TCF_RE_MASK) >> SPI_RSER_TCF_RE_SHIFT)
#define SPI_BRD_RSER_TCF_RE(base) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT))

/*! @brief Set the TCF_RE field to a new value. */
#define SPI_WR_RSER_TCF_RE(base, value) (SPI_RMW_RSER(base, SPI_RSER_TCF_RE_MASK, SPI_RSER_TCF_RE(value)))
#define SPI_BWR_RSER_TCF_RE(base, value) (BITBAND_ACCESS32(&SPI_RSER_REG(base), SPI_RSER_TCF_RE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR - PUSH TX FIFO Register In Master Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR - PUSH TX FIFO Register In Master Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO. An 8- or 16-bit write access
 * transfers all 32 bits to the TX FIFO. In Master mode, the register transfers
 * 16 bits of data and 16 bits of command information. A read access of PUSHR
 * returns the topmost TX FIFO entry. When the module is disabled, writing to this
 * register does not update the FIFO. Therefore, any reads performed while the
 * module is disabled return the last PUSHR write performed while the module was
 * still enabled. A read access of PUSHR returns the topmost TX FIFO entry. When the
 * module is disabled, writing to this register does not update the FIFO.
 * Therefore, any reads performed while the module is disabled return the last PUSHR
 * write performed while the module was still enabled.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR register
 */
/*@{*/
#define SPI_RD_PUSHR(base)       (SPI_PUSHR_REG(base))
#define SPI_WR_PUSHR(base, value) (SPI_PUSHR_REG(base) = (value))
#define SPI_RMW_PUSHR(base, mask, value) (SPI_WR_PUSHR(base, (SPI_RD_PUSHR(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) |  (value)))
#define SPI_CLR_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) & ~(value)))
#define SPI_TOG_PUSHR(base, value) (SPI_WR_PUSHR(base, SPI_RD_PUSHR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR bitfields
 */

/*!
 * @name Register SPI_PUSHR, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_TXDATA field. */
#define SPI_RD_PUSHR_TXDATA(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_TXDATA_MASK) >> SPI_PUSHR_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_TXDATA(base) (SPI_RD_PUSHR_TXDATA(base))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_TXDATA(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_TXDATA_MASK, SPI_PUSHR_TXDATA(value)))
#define SPI_BWR_PUSHR_TXDATA(base, value) (SPI_WR_PUSHR_TXDATA(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field PCS[21:16] (RW)
 *
 * Select which PCS signals are to be asserted for the transfer. Refer to the
 * chip-specific SPI information for the number of PCS signals used in this chip.
 *
 * Values:
 * - 0 - Negate the PCS[x] signal.
 * - 1 - Assert the PCS[x] signal.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_PCS field. */
#define SPI_RD_PUSHR_PCS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_PCS_MASK) >> SPI_PUSHR_PCS_SHIFT)
#define SPI_BRD_PUSHR_PCS(base) (SPI_RD_PUSHR_PCS(base))

/*! @brief Set the PCS field to a new value. */
#define SPI_WR_PUSHR_PCS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_PCS_MASK, SPI_PUSHR_PCS(value)))
#define SPI_BWR_PUSHR_PCS(base, value) (SPI_WR_PUSHR_PCS(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTCNT[26] (RW)
 *
 * Clears the TCNT field in the TCR register. The TCNT field is cleared before
 * the module starts transmitting the current SPI frame.
 *
 * Values:
 * - 0 - Do not clear the TCR[TCNT] field.
 * - 1 - Clear the TCR[TCNT] field.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTCNT field. */
#define SPI_RD_PUSHR_CTCNT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTCNT_MASK) >> SPI_PUSHR_CTCNT_SHIFT)
#define SPI_BRD_PUSHR_CTCNT(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT))

/*! @brief Set the CTCNT field to a new value. */
#define SPI_WR_PUSHR_CTCNT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTCNT_MASK, SPI_PUSHR_CTCNT(value)))
#define SPI_BWR_PUSHR_CTCNT(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CTCNT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field EOQ[27] (RW)
 *
 * Host software uses this bit to signal to the module that the current SPI
 * transfer is the last in a queue. At the end of the transfer, the EOQF bit in the
 * SR is set.
 *
 * Values:
 * - 0 - The SPI data is not the last data to transfer.
 * - 1 - The SPI data is the last data to transfer.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_EOQ field. */
#define SPI_RD_PUSHR_EOQ(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_EOQ_MASK) >> SPI_PUSHR_EOQ_SHIFT)
#define SPI_BRD_PUSHR_EOQ(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT))

/*! @brief Set the EOQ field to a new value. */
#define SPI_WR_PUSHR_EOQ(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_EOQ_MASK, SPI_PUSHR_EOQ(value)))
#define SPI_BWR_PUSHR_EOQ(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_EOQ_SHIFT) = (value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CTAS[30:28] (RW)
 *
 * Selects which CTAR to use in master mode to specify the transfer attributes
 * for the associated SPI frame. In SPI Slave mode, CTAR0 is used. See the chip
 * specific section for details to determine how many CTARs this device has. You
 * should not program a value in this field for a register that is not present.
 *
 * Values:
 * - 000 - CTAR0
 * - 001 - CTAR1
 * - 010 - Reserved
 * - 011 - Reserved
 * - 100 - Reserved
 * - 101 - Reserved
 * - 110 - Reserved
 * - 111 - Reserved
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CTAS field. */
#define SPI_RD_PUSHR_CTAS(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CTAS_MASK) >> SPI_PUSHR_CTAS_SHIFT)
#define SPI_BRD_PUSHR_CTAS(base) (SPI_RD_PUSHR_CTAS(base))

/*! @brief Set the CTAS field to a new value. */
#define SPI_WR_PUSHR_CTAS(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CTAS_MASK, SPI_PUSHR_CTAS(value)))
#define SPI_BWR_PUSHR_CTAS(base, value) (SPI_WR_PUSHR_CTAS(base, value))
/*@}*/

/*!
 * @name Register SPI_PUSHR, field CONT[31] (RW)
 *
 * Selects a continuous selection format. The bit is used in SPI Master mode.
 * The bit enables the selected PCS signals to remain asserted between transfers.
 *
 * Values:
 * - 0 - Return PCSn signals to their inactive state between transfers.
 * - 1 - Keep PCSn signals asserted between transfers.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_CONT field. */
#define SPI_RD_PUSHR_CONT(base) ((SPI_PUSHR_REG(base) & SPI_PUSHR_CONT_MASK) >> SPI_PUSHR_CONT_SHIFT)
#define SPI_BRD_PUSHR_CONT(base) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT))

/*! @brief Set the CONT field to a new value. */
#define SPI_WR_PUSHR_CONT(base, value) (SPI_RMW_PUSHR(base, SPI_PUSHR_CONT_MASK, SPI_PUSHR_CONT(value)))
#define SPI_BWR_PUSHR_CONT(base, value) (BITBAND_ACCESS32(&SPI_PUSHR_REG(base), SPI_PUSHR_CONT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode
 ******************************************************************************/

/*!
 * @brief SPI_PUSHR_SLAVE - PUSH TX FIFO Register In Slave Mode (RW)
 *
 * Reset value: 0x00000000U
 *
 * Specifies data to be transferred to the TX FIFO in slave mode. An 8- or
 * 16-bit write access to PUSHR transfers the 16-bit TXDATA field to the TX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_PUSHR_SLAVE register
 */
/*@{*/
#define SPI_RD_PUSHR_SLAVE(base) (SPI_PUSHR_SLAVE_REG(base))
#define SPI_WR_PUSHR_SLAVE(base, value) (SPI_PUSHR_SLAVE_REG(base) = (value))
#define SPI_RMW_PUSHR_SLAVE(base, mask, value) (SPI_WR_PUSHR_SLAVE(base, (SPI_RD_PUSHR_SLAVE(base) & ~(mask)) | (value)))
#define SPI_SET_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) |  (value)))
#define SPI_CLR_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) & ~(value)))
#define SPI_TOG_PUSHR_SLAVE(base, value) (SPI_WR_PUSHR_SLAVE(base, SPI_RD_PUSHR_SLAVE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual SPI_PUSHR_SLAVE bitfields
 */

/*!
 * @name Register SPI_PUSHR_SLAVE, field TXDATA[15:0] (RW)
 *
 * Holds SPI data to be transferred according to the associated SPI command.
 */
/*@{*/
/*! @brief Read current value of the SPI_PUSHR_SLAVE_TXDATA field. */
#define SPI_RD_PUSHR_SLAVE_TXDATA(base) ((SPI_PUSHR_SLAVE_REG(base) & SPI_PUSHR_SLAVE_TXDATA_MASK) >> SPI_PUSHR_SLAVE_TXDATA_SHIFT)
#define SPI_BRD_PUSHR_SLAVE_TXDATA(base) (SPI_RD_PUSHR_SLAVE_TXDATA(base))

/*! @brief Set the TXDATA field to a new value. */
#define SPI_WR_PUSHR_SLAVE_TXDATA(base, value) (SPI_RMW_PUSHR_SLAVE(base, SPI_PUSHR_SLAVE_TXDATA_MASK, SPI_PUSHR_SLAVE_TXDATA(value)))
#define SPI_BWR_PUSHR_SLAVE_TXDATA(base, value) (SPI_WR_PUSHR_SLAVE_TXDATA(base, value))
/*@}*/

/*******************************************************************************
 * SPI_POPR - POP RX FIFO Register
 ******************************************************************************/

/*!
 * @brief SPI_POPR - POP RX FIFO Register (RO)
 *
 * Reset value: 0x00000000U
 *
 * POPR is used to read the RX FIFO. Eight- or sixteen-bit read accesses to the
 * POPR have the same effect on the RX FIFO as 32-bit read accesses. A write to
 * this register will generate a Transfer Error.
 */
/*!
 * @name Constants and macros for entire SPI_POPR register
 */
/*@{*/
#define SPI_RD_POPR(base)        (SPI_POPR_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR0 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR0 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR0 register
 */
/*@{*/
#define SPI_RD_TXFR0(base)       (SPI_TXFR0_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR0 bitfields
 */

/*!
 * @name Register SPI_TXFR0, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXDATA field. */
#define SPI_RD_TXFR0_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXDATA_MASK) >> SPI_TXFR0_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXDATA(base) (SPI_RD_TXFR0_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR0, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR0_TXCMD_TXDATA field. */
#define SPI_RD_TXFR0_TXCMD_TXDATA(base) ((SPI_TXFR0_REG(base) & SPI_TXFR0_TXCMD_TXDATA_MASK) >> SPI_TXFR0_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR0_TXCMD_TXDATA(base) (SPI_RD_TXFR0_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR1 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR1 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR1 register
 */
/*@{*/
#define SPI_RD_TXFR1(base)       (SPI_TXFR1_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR1 bitfields
 */

/*!
 * @name Register SPI_TXFR1, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXDATA field. */
#define SPI_RD_TXFR1_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXDATA_MASK) >> SPI_TXFR1_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXDATA(base) (SPI_RD_TXFR1_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR1, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR1_TXCMD_TXDATA field. */
#define SPI_RD_TXFR1_TXCMD_TXDATA(base) ((SPI_TXFR1_REG(base) & SPI_TXFR1_TXCMD_TXDATA_MASK) >> SPI_TXFR1_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR1_TXCMD_TXDATA(base) (SPI_RD_TXFR1_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR2 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR2 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR2 register
 */
/*@{*/
#define SPI_RD_TXFR2(base)       (SPI_TXFR2_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR2 bitfields
 */

/*!
 * @name Register SPI_TXFR2, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXDATA field. */
#define SPI_RD_TXFR2_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXDATA_MASK) >> SPI_TXFR2_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXDATA(base) (SPI_RD_TXFR2_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR2, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR2_TXCMD_TXDATA field. */
#define SPI_RD_TXFR2_TXCMD_TXDATA(base) ((SPI_TXFR2_REG(base) & SPI_TXFR2_TXCMD_TXDATA_MASK) >> SPI_TXFR2_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR2_TXCMD_TXDATA(base) (SPI_RD_TXFR2_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_TXFR3 - Transmit FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_TXFR3 - Transmit FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * TXFRn registers provide visibility into the TX FIFO for debugging purposes.
 * Each register is an entry in the TX FIFO. The registers are read-only and
 * cannot be modified. Reading the TXFRx registers does not alter the state of the TX
 * FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_TXFR3 register
 */
/*@{*/
#define SPI_RD_TXFR3(base)       (SPI_TXFR3_REG(base))
/*@}*/

/*
 * Constants & macros for individual SPI_TXFR3 bitfields
 */

/*!
 * @name Register SPI_TXFR3, field TXDATA[15:0] (RO)
 *
 * Contains the SPI data to be shifted out.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXDATA field. */
#define SPI_RD_TXFR3_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXDATA_MASK) >> SPI_TXFR3_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXDATA(base) (SPI_RD_TXFR3_TXDATA(base))
/*@}*/

/*!
 * @name Register SPI_TXFR3, field TXCMD_TXDATA[31:16] (RO)
 *
 * In Master mode the TXCMD field contains the command that sets the transfer
 * attributes for the SPI data. In Slave mode, this field is reserved.
 */
/*@{*/
/*! @brief Read current value of the SPI_TXFR3_TXCMD_TXDATA field. */
#define SPI_RD_TXFR3_TXCMD_TXDATA(base) ((SPI_TXFR3_REG(base) & SPI_TXFR3_TXCMD_TXDATA_MASK) >> SPI_TXFR3_TXCMD_TXDATA_SHIFT)
#define SPI_BRD_TXFR3_TXCMD_TXDATA(base) (SPI_RD_TXFR3_TXCMD_TXDATA(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR0 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR0 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR0 register
 */
/*@{*/
#define SPI_RD_RXFR0(base)       (SPI_RXFR0_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR1 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR1 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR1 register
 */
/*@{*/
#define SPI_RD_RXFR1(base)       (SPI_RXFR1_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR2 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR2 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR2 register
 */
/*@{*/
#define SPI_RD_RXFR2(base)       (SPI_RXFR2_REG(base))
/*@}*/

/*******************************************************************************
 * SPI_RXFR3 - Receive FIFO Registers
 ******************************************************************************/

/*!
 * @brief SPI_RXFR3 - Receive FIFO Registers (RO)
 *
 * Reset value: 0x00000000U
 *
 * RXFRn provide visibility into the RX FIFO for debugging purposes. Each
 * register is an entry in the RX FIFO. The RXFR registers are read-only. Reading the
 * RXFRx registers does not alter the state of the RX FIFO.
 */
/*!
 * @name Constants and macros for entire SPI_RXFR3 register
 */
/*@{*/
#define SPI_RD_RXFR3(base)       (SPI_RXFR3_REG(base))
/*@}*/

/*
 * MKS22F25612 TPM
 *
 * Timer/PWM Module
 *
 * Registers defined in this header file:
 * - TPM_VERID - Version ID Register
 * - TPM_PARAM - Parameter Register
 * - TPM_GLOBAL - TPM Global Register
 * - TPM_SC - Status and Control
 * - TPM_CNT - Counter
 * - TPM_MOD - Modulo
 * - TPM_STATUS - Capture and Compare Status
 * - TPM_CnSC - Channel (n) Status and Control
 * - TPM_CnV - Channel (n) Value
 * - TPM_COMBINE - Combine Channel Register
 * - TPM_TRIG - Channel Trigger
 * - TPM_POL - Channel Polarity
 * - TPM_FILTER - Filter Control
 * - TPM_QDCTRL - Quadrature Decoder Control and Status
 * - TPM_CONF - Configuration
 */

#define TPM_INSTANCE_COUNT (3U) /*!< Number of instances of the TPM module. */
#define TPM0_IDX (0U) /*!< Instance number for TPM0. */
#define TPM1_IDX (1U) /*!< Instance number for TPM1. */
#define TPM2_IDX (2U) /*!< Instance number for TPM2. */

/*******************************************************************************
 * TPM_VERID - Version ID Register
 ******************************************************************************/

/*!
 * @brief TPM_VERID - Version ID Register (RO)
 *
 * Reset value: 0x05000007U
 */
/*!
 * @name Constants and macros for entire TPM_VERID register
 */
/*@{*/
#define TPM_RD_VERID(base)       (TPM_VERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual TPM_VERID bitfields
 */

/*!
 * @name Register TPM_VERID, field FEATURE[15:0] (RO)
 *
 * Values:
 * - 1 - Standard feature set.
 * - 11 - Standard feature set with Filter and Combine registers implemented.
 * - 111 - Standard feature set with Filter, Combine and Quadrature registers
 *     implemented.
 */
/*@{*/
/*! @brief Read current value of the TPM_VERID_FEATURE field. */
#define TPM_RD_VERID_FEATURE(base) ((TPM_VERID_REG(base) & TPM_VERID_FEATURE_MASK) >> TPM_VERID_FEATURE_SHIFT)
#define TPM_BRD_VERID_FEATURE(base) (TPM_RD_VERID_FEATURE(base))
/*@}*/

/*!
 * @name Register TPM_VERID, field MINOR[23:16] (RO)
 *
 * This read only field returns the minor version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the TPM_VERID_MINOR field. */
#define TPM_RD_VERID_MINOR(base) ((TPM_VERID_REG(base) & TPM_VERID_MINOR_MASK) >> TPM_VERID_MINOR_SHIFT)
#define TPM_BRD_VERID_MINOR(base) (TPM_RD_VERID_MINOR(base))
/*@}*/

/*!
 * @name Register TPM_VERID, field MAJOR[31:24] (RO)
 *
 * This read only field returns the major version number for the module
 * specification.
 */
/*@{*/
/*! @brief Read current value of the TPM_VERID_MAJOR field. */
#define TPM_RD_VERID_MAJOR(base) ((TPM_VERID_REG(base) & TPM_VERID_MAJOR_MASK) >> TPM_VERID_MAJOR_SHIFT)
#define TPM_BRD_VERID_MAJOR(base) (TPM_RD_VERID_MAJOR(base))
/*@}*/

/*******************************************************************************
 * TPM_PARAM - Parameter Register
 ******************************************************************************/

/*!
 * @brief TPM_PARAM - Parameter Register (RO)
 *
 * Reset value: 0x00101006U
 */
/*!
 * @name Constants and macros for entire TPM_PARAM register
 */
/*@{*/
#define TPM_RD_PARAM(base)       (TPM_PARAM_REG(base))
/*@}*/

/*
 * Constants & macros for individual TPM_PARAM bitfields
 */

/*!
 * @name Register TPM_PARAM, field CHAN[7:0] (RO)
 *
 * Number of timer channels implemented.
 */
/*@{*/
/*! @brief Read current value of the TPM_PARAM_CHAN field. */
#define TPM_RD_PARAM_CHAN(base) ((TPM_PARAM_REG(base) & TPM_PARAM_CHAN_MASK) >> TPM_PARAM_CHAN_SHIFT)
#define TPM_BRD_PARAM_CHAN(base) (TPM_RD_PARAM_CHAN(base))
/*@}*/

/*!
 * @name Register TPM_PARAM, field TRIG[15:8] (RO)
 *
 * Number of trigger inputs implemented.
 */
/*@{*/
/*! @brief Read current value of the TPM_PARAM_TRIG field. */
#define TPM_RD_PARAM_TRIG(base) ((TPM_PARAM_REG(base) & TPM_PARAM_TRIG_MASK) >> TPM_PARAM_TRIG_SHIFT)
#define TPM_BRD_PARAM_TRIG(base) (TPM_RD_PARAM_TRIG(base))
/*@}*/

/*!
 * @name Register TPM_PARAM, field WIDTH[23:16] (RO)
 *
 * Width of the counter and timer channels.
 */
/*@{*/
/*! @brief Read current value of the TPM_PARAM_WIDTH field. */
#define TPM_RD_PARAM_WIDTH(base) ((TPM_PARAM_REG(base) & TPM_PARAM_WIDTH_MASK) >> TPM_PARAM_WIDTH_SHIFT)
#define TPM_BRD_PARAM_WIDTH(base) (TPM_RD_PARAM_WIDTH(base))
/*@}*/

/*******************************************************************************
 * TPM_GLOBAL - TPM Global Register
 ******************************************************************************/

/*!
 * @brief TPM_GLOBAL - TPM Global Register (RW)
 *
 * Reset value: 0x00000000U
 */
/*!
 * @name Constants and macros for entire TPM_GLOBAL register
 */
/*@{*/
#define TPM_RD_GLOBAL(base)      (TPM_GLOBAL_REG(base))
#define TPM_WR_GLOBAL(base, value) (TPM_GLOBAL_REG(base) = (value))
#define TPM_RMW_GLOBAL(base, mask, value) (TPM_WR_GLOBAL(base, (TPM_RD_GLOBAL(base) & ~(mask)) | (value)))
#define TPM_SET_GLOBAL(base, value) (TPM_WR_GLOBAL(base, TPM_RD_GLOBAL(base) |  (value)))
#define TPM_CLR_GLOBAL(base, value) (TPM_WR_GLOBAL(base, TPM_RD_GLOBAL(base) & ~(value)))
#define TPM_TOG_GLOBAL(base, value) (TPM_WR_GLOBAL(base, TPM_RD_GLOBAL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_GLOBAL bitfields
 */

/*!
 * @name Register TPM_GLOBAL, field RST[1] (RW)
 *
 * Reset all internal logic and registers, except the Global Register. Remains
 * set until cleared by software.
 *
 * Values:
 * - 0 - Module is not reset.
 * - 1 - Module is reset.
 */
/*@{*/
/*! @brief Read current value of the TPM_GLOBAL_RST field. */
#define TPM_RD_GLOBAL_RST(base) ((TPM_GLOBAL_REG(base) & TPM_GLOBAL_RST_MASK) >> TPM_GLOBAL_RST_SHIFT)
#define TPM_BRD_GLOBAL_RST(base) (BITBAND_ACCESS32(&TPM_GLOBAL_REG(base), TPM_GLOBAL_RST_SHIFT))

/*! @brief Set the RST field to a new value. */
#define TPM_WR_GLOBAL_RST(base, value) (TPM_RMW_GLOBAL(base, TPM_GLOBAL_RST_MASK, TPM_GLOBAL_RST(value)))
#define TPM_BWR_GLOBAL_RST(base, value) (BITBAND_ACCESS32(&TPM_GLOBAL_REG(base), TPM_GLOBAL_RST_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_SC - Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_SC - Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * SC contains the overflow status flag and control bits used to configure the
 * interrupt enable, module configuration and prescaler factor. These controls
 * relate to all channels within this module.
 */
/*!
 * @name Constants and macros for entire TPM_SC register
 */
/*@{*/
#define TPM_RD_SC(base)          (TPM_SC_REG(base))
#define TPM_WR_SC(base, value)   (TPM_SC_REG(base) = (value))
#define TPM_RMW_SC(base, mask, value) (TPM_WR_SC(base, (TPM_RD_SC(base) & ~(mask)) | (value)))
#define TPM_SET_SC(base, value)  (TPM_WR_SC(base, TPM_RD_SC(base) |  (value)))
#define TPM_CLR_SC(base, value)  (TPM_WR_SC(base, TPM_RD_SC(base) & ~(value)))
#define TPM_TOG_SC(base, value)  (TPM_WR_SC(base, TPM_RD_SC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_SC bitfields
 */

/*!
 * @name Register TPM_SC, field PS[2:0] (RW)
 *
 * Selects one of 8 division factors for the clock mode selected by CMOD. This
 * field is write protected. It can be written only when the counter is disabled.
 *
 * Values:
 * - 000 - Divide by 1
 * - 001 - Divide by 2
 * - 010 - Divide by 4
 * - 011 - Divide by 8
 * - 100 - Divide by 16
 * - 101 - Divide by 32
 * - 110 - Divide by 64
 * - 111 - Divide by 128
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_PS field. */
#define TPM_RD_SC_PS(base)   ((TPM_SC_REG(base) & TPM_SC_PS_MASK) >> TPM_SC_PS_SHIFT)
#define TPM_BRD_SC_PS(base)  (TPM_RD_SC_PS(base))

/*! @brief Set the PS field to a new value. */
#define TPM_WR_SC_PS(base, value) (TPM_RMW_SC(base, (TPM_SC_PS_MASK | TPM_SC_TOF_MASK), TPM_SC_PS(value)))
#define TPM_BWR_SC_PS(base, value) (TPM_WR_SC_PS(base, value))
/*@}*/

/*!
 * @name Register TPM_SC, field CMOD[4:3] (RW)
 *
 * Selects the TPM counter clock modes. When disabling the counter, this field
 * remain set until acknolwedged in the TPM clock domain.
 *
 * Values:
 * - 00 - TPM counter is disabled
 * - 01 - TPM counter increments on every TPM counter clock
 * - 10 - TPM counter increments on rising edge of TPM_EXTCLK synchronized to
 *     the TPM counter clock
 * - 11 - TPM counter increments on rising edge of the selected external input
 *     trigger.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CMOD field. */
#define TPM_RD_SC_CMOD(base) ((TPM_SC_REG(base) & TPM_SC_CMOD_MASK) >> TPM_SC_CMOD_SHIFT)
#define TPM_BRD_SC_CMOD(base) (TPM_RD_SC_CMOD(base))

/*! @brief Set the CMOD field to a new value. */
#define TPM_WR_SC_CMOD(base, value) (TPM_RMW_SC(base, (TPM_SC_CMOD_MASK | TPM_SC_TOF_MASK), TPM_SC_CMOD(value)))
#define TPM_BWR_SC_CMOD(base, value) (TPM_WR_SC_CMOD(base, value))
/*@}*/

/*!
 * @name Register TPM_SC, field CPWMS[5] (RW)
 *
 * Selects CPWM mode. This mode configures the TPM to operate in up-down
 * counting mode. This field is write protected. It can be written only when the counter
 * is disabled.
 *
 * Values:
 * - 0 - TPM counter operates in up counting mode.
 * - 1 - TPM counter operates in up-down counting mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_CPWMS field. */
#define TPM_RD_SC_CPWMS(base) ((TPM_SC_REG(base) & TPM_SC_CPWMS_MASK) >> TPM_SC_CPWMS_SHIFT)
#define TPM_BRD_SC_CPWMS(base) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_CPWMS_SHIFT))

/*! @brief Set the CPWMS field to a new value. */
#define TPM_WR_SC_CPWMS(base, value) (TPM_RMW_SC(base, (TPM_SC_CPWMS_MASK | TPM_SC_TOF_MASK), TPM_SC_CPWMS(value)))
#define TPM_BWR_SC_CPWMS(base, value) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_CPWMS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_SC, field TOIE[6] (RW)
 *
 * Enables TPM overflow interrupts.
 *
 * Values:
 * - 0 - Disable TOF interrupts. Use software polling or DMA request.
 * - 1 - Enable TOF interrupts. An interrupt is generated when TOF equals one.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOIE field. */
#define TPM_RD_SC_TOIE(base) ((TPM_SC_REG(base) & TPM_SC_TOIE_MASK) >> TPM_SC_TOIE_SHIFT)
#define TPM_BRD_SC_TOIE(base) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_TOIE_SHIFT))

/*! @brief Set the TOIE field to a new value. */
#define TPM_WR_SC_TOIE(base, value) (TPM_RMW_SC(base, (TPM_SC_TOIE_MASK | TPM_SC_TOF_MASK), TPM_SC_TOIE(value)))
#define TPM_BWR_SC_TOIE(base, value) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_TOIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_SC, field TOF[7] (W1C)
 *
 * Set by hardware when the TPM counter equals the value in the MOD register and
 * increments. Writing a 1 to TOF clears it. Writing a 0 to TOF has no effect.
 * If another TPM overflow occurs between the flag setting and the flag clearing,
 * the write operation has no effect; therefore, TOF remains set indicating
 * another overflow has occurred. In this case a TOF interrupt request is not lost due
 * to a delay in clearing the previous TOF.
 *
 * Values:
 * - 0 - TPM counter has not overflowed.
 * - 1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_TOF field. */
#define TPM_RD_SC_TOF(base)  ((TPM_SC_REG(base) & TPM_SC_TOF_MASK) >> TPM_SC_TOF_SHIFT)
#define TPM_BRD_SC_TOF(base) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_TOF_SHIFT))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_SC_TOF(base, value) (TPM_RMW_SC(base, TPM_SC_TOF_MASK, TPM_SC_TOF(value)))
#define TPM_BWR_SC_TOF(base, value) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_TOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_SC, field DMA[8] (RW)
 *
 * Enables DMA transfers for the overflow flag.
 *
 * Values:
 * - 0 - Disables DMA transfers.
 * - 1 - Enables DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_SC_DMA field. */
#define TPM_RD_SC_DMA(base)  ((TPM_SC_REG(base) & TPM_SC_DMA_MASK) >> TPM_SC_DMA_SHIFT)
#define TPM_BRD_SC_DMA(base) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_SC_DMA(base, value) (TPM_RMW_SC(base, (TPM_SC_DMA_MASK | TPM_SC_TOF_MASK), TPM_SC_DMA(value)))
#define TPM_BWR_SC_DMA(base, value) (BITBAND_ACCESS32(&TPM_SC_REG(base), TPM_SC_DMA_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_CNT - Counter
 ******************************************************************************/

/*!
 * @brief TPM_CNT - Counter (RW)
 *
 * Reset value: 0x00000000U
 *
 * The CNT register contains the TPM counter value. Reset clears the CNT
 * register. Writing any value to COUNT also clears the counter. When debug is active,
 * the TPM counter does not increment unless configured otherwise. Reading the CNT
 * register adds two wait states to the register access due to synchronization
 * delays.
 */
/*!
 * @name Constants and macros for entire TPM_CNT register
 */
/*@{*/
#define TPM_RD_CNT(base)         (TPM_CNT_REG(base))
#define TPM_WR_CNT(base, value)  (TPM_CNT_REG(base) = (value))
#define TPM_RMW_CNT(base, mask, value) (TPM_WR_CNT(base, (TPM_RD_CNT(base) & ~(mask)) | (value)))
#define TPM_SET_CNT(base, value) (TPM_WR_CNT(base, TPM_RD_CNT(base) |  (value)))
#define TPM_CLR_CNT(base, value) (TPM_WR_CNT(base, TPM_RD_CNT(base) & ~(value)))
#define TPM_TOG_CNT(base, value) (TPM_WR_CNT(base, TPM_RD_CNT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CNT bitfields
 */

/*!
 * @name Register TPM_CNT, field COUNT[15:0] (RW)
 */
/*@{*/
/*! @brief Read current value of the TPM_CNT_COUNT field. */
#define TPM_RD_CNT_COUNT(base) ((TPM_CNT_REG(base) & TPM_CNT_COUNT_MASK) >> TPM_CNT_COUNT_SHIFT)
#define TPM_BRD_CNT_COUNT(base) (TPM_RD_CNT_COUNT(base))

/*! @brief Set the COUNT field to a new value. */
#define TPM_WR_CNT_COUNT(base, value) (TPM_RMW_CNT(base, TPM_CNT_COUNT_MASK, TPM_CNT_COUNT(value)))
#define TPM_BWR_CNT_COUNT(base, value) (TPM_WR_CNT_COUNT(base, value))
/*@}*/

/*******************************************************************************
 * TPM_MOD - Modulo
 ******************************************************************************/

/*!
 * @brief TPM_MOD - Modulo (RW)
 *
 * Reset value: 0x0000FFFFU
 *
 * The Modulo register contains the modulo value for the TPM counter. When the
 * TPM counter reaches the modulo value and increments, the overflow flag (TOF) is
 * set and the next value of TPM counter depends on the selected counting method
 * (see CounterThe TPM has a 16-bit counter that is used by the channels either
 * for input or output modes. ). Writing to the MOD register latches the value
 * into a buffer. The MOD register is updated with the value of its write buffer
 * according to MOD Register Update . Additional writes to the MOD write buffer are
 * ignored until the register has been updated. It is recommended to initialize
 * the TPM counter (write to CNT) before writing to the MOD register to avoid
 * confusion about when the first counter overflow will occur.
 */
/*!
 * @name Constants and macros for entire TPM_MOD register
 */
/*@{*/
#define TPM_RD_MOD(base)         (TPM_MOD_REG(base))
#define TPM_WR_MOD(base, value)  (TPM_MOD_REG(base) = (value))
#define TPM_RMW_MOD(base, mask, value) (TPM_WR_MOD(base, (TPM_RD_MOD(base) & ~(mask)) | (value)))
#define TPM_SET_MOD(base, value) (TPM_WR_MOD(base, TPM_RD_MOD(base) |  (value)))
#define TPM_CLR_MOD(base, value) (TPM_WR_MOD(base, TPM_RD_MOD(base) & ~(value)))
#define TPM_TOG_MOD(base, value) (TPM_WR_MOD(base, TPM_RD_MOD(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_MOD bitfields
 */

/*!
 * @name Register TPM_MOD, field MOD[15:0] (RW)
 *
 * This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_MOD_MOD field. */
#define TPM_RD_MOD_MOD(base) ((TPM_MOD_REG(base) & TPM_MOD_MOD_MASK) >> TPM_MOD_MOD_SHIFT)
#define TPM_BRD_MOD_MOD(base) (TPM_RD_MOD_MOD(base))

/*! @brief Set the MOD field to a new value. */
#define TPM_WR_MOD_MOD(base, value) (TPM_RMW_MOD(base, TPM_MOD_MOD_MASK, TPM_MOD_MOD(value)))
#define TPM_BWR_MOD_MOD(base, value) (TPM_WR_MOD_MOD(base, value))
/*@}*/

/*******************************************************************************
 * TPM_STATUS - Capture and Compare Status
 ******************************************************************************/

/*!
 * @brief TPM_STATUS - Capture and Compare Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * The STATUS register contains a copy of the status flag, CnSC[CHnF] for each
 * TPM channel, as well as SC[TOF], for software convenience. Each CHnF bit in
 * STATUS is a mirror of CHnF bit in CnSC. All CHnF bits can be checked using only
 * one read of STATUS. All CHnF bits can be cleared by writing all ones to STATUS.
 * Hardware sets the individual channel flags when an event occurs on the
 * channel. Writing a 1 to CHF clears it. Writing a 0 to CHF has no effect. If another
 * event occurs between the flag setting and the write operation, the write
 * operation has no effect; therefore, CHF remains set indicating another event has
 * occurred. In this case a CHF interrupt request is not lost due to the clearing
 * sequence for a previous CHF.
 */
/*!
 * @name Constants and macros for entire TPM_STATUS register
 */
/*@{*/
#define TPM_RD_STATUS(base)      (TPM_STATUS_REG(base))
#define TPM_WR_STATUS(base, value) (TPM_STATUS_REG(base) = (value))
#define TPM_RMW_STATUS(base, mask, value) (TPM_WR_STATUS(base, (TPM_RD_STATUS(base) & ~(mask)) | (value)))
#define TPM_SET_STATUS(base, value) (TPM_WR_STATUS(base, TPM_RD_STATUS(base) |  (value)))
#define TPM_CLR_STATUS(base, value) (TPM_WR_STATUS(base, TPM_RD_STATUS(base) & ~(value)))
#define TPM_TOG_STATUS(base, value) (TPM_WR_STATUS(base, TPM_RD_STATUS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_STATUS bitfields
 */

/*!
 * @name Register TPM_STATUS, field CH0F[0] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH0F field. */
#define TPM_RD_STATUS_CH0F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH0F_MASK) >> TPM_STATUS_CH0F_SHIFT)
#define TPM_BRD_STATUS_CH0F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH0F_SHIFT))

/*! @brief Set the CH0F field to a new value. */
#define TPM_WR_STATUS_CH0F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH0F(value)))
#define TPM_BWR_STATUS_CH0F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH0F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH1F[1] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH1F field. */
#define TPM_RD_STATUS_CH1F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH1F_MASK) >> TPM_STATUS_CH1F_SHIFT)
#define TPM_BRD_STATUS_CH1F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH1F_SHIFT))

/*! @brief Set the CH1F field to a new value. */
#define TPM_WR_STATUS_CH1F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH1F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH1F(value)))
#define TPM_BWR_STATUS_CH1F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH1F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH2F[2] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH2F field. */
#define TPM_RD_STATUS_CH2F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH2F_MASK) >> TPM_STATUS_CH2F_SHIFT)
#define TPM_BRD_STATUS_CH2F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH2F_SHIFT))

/*! @brief Set the CH2F field to a new value. */
#define TPM_WR_STATUS_CH2F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH2F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH2F(value)))
#define TPM_BWR_STATUS_CH2F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH2F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH3F[3] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH3F field. */
#define TPM_RD_STATUS_CH3F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH3F_MASK) >> TPM_STATUS_CH3F_SHIFT)
#define TPM_BRD_STATUS_CH3F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH3F_SHIFT))

/*! @brief Set the CH3F field to a new value. */
#define TPM_WR_STATUS_CH3F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH3F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH3F(value)))
#define TPM_BWR_STATUS_CH3F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH3F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH4F[4] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH4F field. */
#define TPM_RD_STATUS_CH4F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH4F_MASK) >> TPM_STATUS_CH4F_SHIFT)
#define TPM_BRD_STATUS_CH4F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH4F_SHIFT))

/*! @brief Set the CH4F field to a new value. */
#define TPM_WR_STATUS_CH4F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH4F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH5F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH4F(value)))
#define TPM_BWR_STATUS_CH4F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH4F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field CH5F[5] (W1C)
 *
 * See the register description.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_CH5F field. */
#define TPM_RD_STATUS_CH5F(base) ((TPM_STATUS_REG(base) & TPM_STATUS_CH5F_MASK) >> TPM_STATUS_CH5F_SHIFT)
#define TPM_BRD_STATUS_CH5F(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH5F_SHIFT))

/*! @brief Set the CH5F field to a new value. */
#define TPM_WR_STATUS_CH5F(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_CH5F_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_TOF_MASK), TPM_STATUS_CH5F(value)))
#define TPM_BWR_STATUS_CH5F(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_CH5F_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_STATUS, field TOF[8] (W1C)
 *
 * See register description
 *
 * Values:
 * - 0 - TPM counter has not overflowed.
 * - 1 - TPM counter has overflowed.
 */
/*@{*/
/*! @brief Read current value of the TPM_STATUS_TOF field. */
#define TPM_RD_STATUS_TOF(base) ((TPM_STATUS_REG(base) & TPM_STATUS_TOF_MASK) >> TPM_STATUS_TOF_SHIFT)
#define TPM_BRD_STATUS_TOF(base) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_TOF_SHIFT))

/*! @brief Set the TOF field to a new value. */
#define TPM_WR_STATUS_TOF(base, value) (TPM_RMW_STATUS(base, (TPM_STATUS_TOF_MASK | TPM_STATUS_CH0F_MASK | TPM_STATUS_CH1F_MASK | TPM_STATUS_CH2F_MASK | TPM_STATUS_CH3F_MASK | TPM_STATUS_CH4F_MASK | TPM_STATUS_CH5F_MASK), TPM_STATUS_TOF(value)))
#define TPM_BWR_STATUS_TOF(base, value) (BITBAND_ACCESS32(&TPM_STATUS_REG(base), TPM_STATUS_TOF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_CnSC - Channel (n) Status and Control
 ******************************************************************************/

/*!
 * @brief TPM_CnSC - Channel (n) Status and Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * CnSC contains the channel-interrupt-status flag and control bits used to
 * configure the interrupt enable, channel configuration, and pin function. When
 * switching from one channel mode to a different channel mode, the channel must
 * first be disabled and this must be acknowledged in the TPM counter clock domain.
 * Mode, Edge, and Level Selection CPWMS MSnB:MSnA ELSnB:ELSnA Mode Configuration
 * X 00 00 None Channel disabled X 01 00 Software compare Pin not used for TPM 0
 * 00 01 Input capture Capture on Rising Edge Only 10 Capture on Falling Edge
 * Only 11 Capture on Rising or Falling Edge 01 01 Output compare Toggle Output on
 * match 10 Clear Output on match 11 Set Output on match 10 10 Edge-aligned PWM
 * High-true pulses (clear Output on match, set Output on reload) X1 Low-true
 * pulses (set Output on match, clear Output on reload) 11 10 Output compare Pulse
 * Output low on match 01 Pulse Output high on match 1 10 10 Center-aligned PWM
 * High-true pulses (clear Output on match-up, set Output on match-down) 01 Low-true
 * pulses (set Output on match-up, clear Output on match-down)
 */
/*!
 * @name Constants and macros for entire TPM_CnSC register
 */
/*@{*/
#define TPM_RD_CnSC(base, index) (TPM_CnSC_REG(base, index))
#define TPM_WR_CnSC(base, index, value) (TPM_CnSC_REG(base, index) = (value))
#define TPM_RMW_CnSC(base, index, mask, value) (TPM_WR_CnSC(base, index, (TPM_RD_CnSC(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnSC(base, index, value) (TPM_WR_CnSC(base, index, TPM_RD_CnSC(base, index) |  (value)))
#define TPM_CLR_CnSC(base, index, value) (TPM_WR_CnSC(base, index, TPM_RD_CnSC(base, index) & ~(value)))
#define TPM_TOG_CnSC(base, index, value) (TPM_WR_CnSC(base, index, TPM_RD_CnSC(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnSC bitfields
 */

/*!
 * @name Register TPM_CnSC, field DMA[0] (RW)
 *
 * Enables DMA transfers for the channel.
 *
 * Values:
 * - 0 - Disable DMA transfers.
 * - 1 - Enable DMA transfers.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_DMA field. */
#define TPM_RD_CnSC_DMA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_DMA_MASK) >> TPM_CnSC_DMA_SHIFT)
#define TPM_BRD_CnSC_DMA(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_DMA_SHIFT))

/*! @brief Set the DMA field to a new value. */
#define TPM_WR_CnSC_DMA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_DMA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_DMA(value)))
#define TPM_BWR_CnSC_DMA(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_DMA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSA[2] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSA field. */
#define TPM_RD_CnSC_ELSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSA_MASK) >> TPM_CnSC_ELSA_SHIFT)
#define TPM_BRD_CnSC_ELSA(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSA_SHIFT))

/*! @brief Set the ELSA field to a new value. */
#define TPM_WR_CnSC_ELSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSA(value)))
#define TPM_BWR_CnSC_ELSA(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field ELSB[3] (RW)
 *
 * The functionality of ELSB and ELSA depends on the channel mode. When a
 * channel is disabled, this field will not change state until acknowledged in the TPM
 * counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_ELSB field. */
#define TPM_RD_CnSC_ELSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_ELSB_MASK) >> TPM_CnSC_ELSB_SHIFT)
#define TPM_BRD_CnSC_ELSB(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSB_SHIFT))

/*! @brief Set the ELSB field to a new value. */
#define TPM_WR_CnSC_ELSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_ELSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_ELSB(value)))
#define TPM_BWR_CnSC_ELSB(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_ELSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSA[4] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSA field. */
#define TPM_RD_CnSC_MSA(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSA_MASK) >> TPM_CnSC_MSA_SHIFT)
#define TPM_BRD_CnSC_MSA(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSA_SHIFT))

/*! @brief Set the MSA field to a new value. */
#define TPM_WR_CnSC_MSA(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSA_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSA(value)))
#define TPM_BWR_CnSC_MSA(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSA_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field MSB[5] (RW)
 *
 * Used for further selections in the channel logic. Its functionality is
 * dependent on the channel mode. When a channel is disabled, this field will not
 * change state until acknowledged in the TPM counter clock domain.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_MSB field. */
#define TPM_RD_CnSC_MSB(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_MSB_MASK) >> TPM_CnSC_MSB_SHIFT)
#define TPM_BRD_CnSC_MSB(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSB_SHIFT))

/*! @brief Set the MSB field to a new value. */
#define TPM_WR_CnSC_MSB(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_MSB_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_MSB(value)))
#define TPM_BWR_CnSC_MSB(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_MSB_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHIE[6] (RW)
 *
 * Enables channel interrupts.
 *
 * Values:
 * - 0 - Disable channel interrupts.
 * - 1 - Enable channel interrupts.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHIE field. */
#define TPM_RD_CnSC_CHIE(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHIE_MASK) >> TPM_CnSC_CHIE_SHIFT)
#define TPM_BRD_CnSC_CHIE(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHIE_SHIFT))

/*! @brief Set the CHIE field to a new value. */
#define TPM_WR_CnSC_CHIE(base, index, value) (TPM_RMW_CnSC(base, index, (TPM_CnSC_CHIE_MASK | TPM_CnSC_CHF_MASK), TPM_CnSC_CHIE(value)))
#define TPM_BWR_CnSC_CHIE(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CnSC, field CHF[7] (W1C)
 *
 * Set by hardware when an event occurs on the channel. CHF is cleared by
 * writing a 1 to the CHF bit. Writing a 0 to CHF has no effect. If another event
 * occurs between the CHF sets and the write operation, the write operation has no
 * effect; therefore, CHF remains set indicating another event has occurred. In this
 * case a CHF interrupt request is not lost due to the delay in clearing the
 * previous CHF.
 *
 * Values:
 * - 0 - No channel event has occurred.
 * - 1 - A channel event has occurred.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnSC_CHF field. */
#define TPM_RD_CnSC_CHF(base, index) ((TPM_CnSC_REG(base, index) & TPM_CnSC_CHF_MASK) >> TPM_CnSC_CHF_SHIFT)
#define TPM_BRD_CnSC_CHF(base, index) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHF_SHIFT))

/*! @brief Set the CHF field to a new value. */
#define TPM_WR_CnSC_CHF(base, index, value) (TPM_RMW_CnSC(base, index, TPM_CnSC_CHF_MASK, TPM_CnSC_CHF(value)))
#define TPM_BWR_CnSC_CHF(base, index, value) (BITBAND_ACCESS32(&TPM_CnSC_REG(base, index), TPM_CnSC_CHF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_CnV - Channel (n) Value
 ******************************************************************************/

/*!
 * @brief TPM_CnV - Channel (n) Value (RW)
 *
 * Reset value: 0x00000000U
 *
 * These registers contain the captured TPM counter value for the input modes or
 * the match value for the output modes. In input capture mode, any write to a
 * CnV register is ignored. In compare modes, writing to a CnV register latches
 * the value into a buffer. A CnV register is updated with the value of its write
 * buffer according to CnV Register Update . Additional writes to the CnV write
 * buffer are ignored until the register has been updated.
 */
/*!
 * @name Constants and macros for entire TPM_CnV register
 */
/*@{*/
#define TPM_RD_CnV(base, index)  (TPM_CnV_REG(base, index))
#define TPM_WR_CnV(base, index, value) (TPM_CnV_REG(base, index) = (value))
#define TPM_RMW_CnV(base, index, mask, value) (TPM_WR_CnV(base, index, (TPM_RD_CnV(base, index) & ~(mask)) | (value)))
#define TPM_SET_CnV(base, index, value) (TPM_WR_CnV(base, index, TPM_RD_CnV(base, index) |  (value)))
#define TPM_CLR_CnV(base, index, value) (TPM_WR_CnV(base, index, TPM_RD_CnV(base, index) & ~(value)))
#define TPM_TOG_CnV(base, index, value) (TPM_WR_CnV(base, index, TPM_RD_CnV(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CnV bitfields
 */

/*!
 * @name Register TPM_CnV, field VAL[15:0] (RW)
 *
 * Captured TPM counter value of the input modes or the match value for the
 * output modes. This field must be written with single 16-bit or 32-bit access.
 */
/*@{*/
/*! @brief Read current value of the TPM_CnV_VAL field. */
#define TPM_RD_CnV_VAL(base, index) ((TPM_CnV_REG(base, index) & TPM_CnV_VAL_MASK) >> TPM_CnV_VAL_SHIFT)
#define TPM_BRD_CnV_VAL(base, index) (TPM_RD_CnV_VAL(base, index))

/*! @brief Set the VAL field to a new value. */
#define TPM_WR_CnV_VAL(base, index, value) (TPM_RMW_CnV(base, index, TPM_CnV_VAL_MASK, TPM_CnV_VAL(value)))
#define TPM_BWR_CnV_VAL(base, index, value) (TPM_WR_CnV_VAL(base, index, value))
/*@}*/

/*******************************************************************************
 * TPM_COMBINE - Combine Channel Register
 ******************************************************************************/

/*!
 * @brief TPM_COMBINE - Combine Channel Register (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register contains the control bits used to configure the combine channel
 * modes for each pair of channels (n) and (n+1), where n is all the even
 * numbered channels.
 */
/*!
 * @name Constants and macros for entire TPM_COMBINE register
 */
/*@{*/
#define TPM_RD_COMBINE(base)     (TPM_COMBINE_REG(base))
#define TPM_WR_COMBINE(base, value) (TPM_COMBINE_REG(base) = (value))
#define TPM_RMW_COMBINE(base, mask, value) (TPM_WR_COMBINE(base, (TPM_RD_COMBINE(base) & ~(mask)) | (value)))
#define TPM_SET_COMBINE(base, value) (TPM_WR_COMBINE(base, TPM_RD_COMBINE(base) |  (value)))
#define TPM_CLR_COMBINE(base, value) (TPM_WR_COMBINE(base, TPM_RD_COMBINE(base) & ~(value)))
#define TPM_TOG_COMBINE(base, value) (TPM_WR_COMBINE(base, TPM_RD_COMBINE(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_COMBINE bitfields
 */

/*!
 * @name Register TPM_COMBINE, field COMBINE0[0] (RW)
 *
 * Enables the combine feature for channels 0 and 1. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0 - Channels 0 and 1 are independent.
 * - 1 - Channels 0 and 1 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE0 field. */
#define TPM_RD_COMBINE_COMBINE0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE0_MASK) >> TPM_COMBINE_COMBINE0_SHIFT)
#define TPM_BRD_COMBINE_COMBINE0(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE0_SHIFT))

/*! @brief Set the COMBINE0 field to a new value. */
#define TPM_WR_COMBINE_COMBINE0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE0_MASK, TPM_COMBINE_COMBINE0(value)))
#define TPM_BWR_COMBINE_COMBINE0(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP0[1] (RW)
 *
 * When set in combine mode, the even channel is used for the input capture and
 * 1st compare, the odd channel is used for the 2nd compare.
 *
 * Values:
 * - 0 - Even channel is used for input capture and 1st compare.
 * - 1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP0 field. */
#define TPM_RD_COMBINE_COMSWAP0(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP0_MASK) >> TPM_COMBINE_COMSWAP0_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP0(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP0_SHIFT))

/*! @brief Set the COMSWAP0 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP0(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP0_MASK, TPM_COMBINE_COMSWAP0(value)))
#define TPM_BWR_COMBINE_COMSWAP0(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMBINE1[8] (RW)
 *
 * Enables the combine feature for channels 2 and 3. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0 - Channels 2 and 3 are independent.
 * - 1 - Channels 2 and 3 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE1 field. */
#define TPM_RD_COMBINE_COMBINE1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE1_MASK) >> TPM_COMBINE_COMBINE1_SHIFT)
#define TPM_BRD_COMBINE_COMBINE1(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE1_SHIFT))

/*! @brief Set the COMBINE1 field to a new value. */
#define TPM_WR_COMBINE_COMBINE1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE1_MASK, TPM_COMBINE_COMBINE1(value)))
#define TPM_BWR_COMBINE_COMBINE1(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP1[9] (RW)
 *
 * When set in combine mode, the odd channel is used for the input capture and
 * 1st compare, the even channel is used for the 2nd compare.
 *
 * Values:
 * - 0 - Even channel is used for input capture and 1st compare.
 * - 1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP1 field. */
#define TPM_RD_COMBINE_COMSWAP1(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP1_MASK) >> TPM_COMBINE_COMSWAP1_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP1(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP1_SHIFT))

/*! @brief Set the COMSWAP1 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP1(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP1_MASK, TPM_COMBINE_COMSWAP1(value)))
#define TPM_BWR_COMBINE_COMSWAP1(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMBINE2[16] (RW)
 *
 * Enables the combine feature for channels 2 and 3. In input capture mode, the
 * combined channels use the even channel input. In software compare modes, the
 * even channel match asserts the output trigger and the odd channel match negates
 * the output trigger. In PWM modes, the even channel match is used for the 1st
 * compare and odd channel match for the 2nd compare.
 *
 * Values:
 * - 0 - Channels 4 and 5 are independent.
 * - 1 - Channels 4 and 5 are combined.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMBINE2 field. */
#define TPM_RD_COMBINE_COMBINE2(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMBINE2_MASK) >> TPM_COMBINE_COMBINE2_SHIFT)
#define TPM_BRD_COMBINE_COMBINE2(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE2_SHIFT))

/*! @brief Set the COMBINE2 field to a new value. */
#define TPM_WR_COMBINE_COMBINE2(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMBINE2_MASK, TPM_COMBINE_COMBINE2(value)))
#define TPM_BWR_COMBINE_COMBINE2(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMBINE2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_COMBINE, field COMSWAP2[17] (RW)
 *
 * When set in combine mode, the even channel is used for the input capture and
 * 1st compare, the odd channel is used for the 2nd compare.
 *
 * Values:
 * - 0 - Even channel is used for input capture and 1st compare.
 * - 1 - Odd channel is used for input capture and 1st compare.
 */
/*@{*/
/*! @brief Read current value of the TPM_COMBINE_COMSWAP2 field. */
#define TPM_RD_COMBINE_COMSWAP2(base) ((TPM_COMBINE_REG(base) & TPM_COMBINE_COMSWAP2_MASK) >> TPM_COMBINE_COMSWAP2_SHIFT)
#define TPM_BRD_COMBINE_COMSWAP2(base) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP2_SHIFT))

/*! @brief Set the COMSWAP2 field to a new value. */
#define TPM_WR_COMBINE_COMSWAP2(base, value) (TPM_RMW_COMBINE(base, TPM_COMBINE_COMSWAP2_MASK, TPM_COMBINE_COMSWAP2(value)))
#define TPM_BWR_COMBINE_COMSWAP2(base, value) (BITBAND_ACCESS32(&TPM_COMBINE_REG(base), TPM_COMBINE_COMSWAP2_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_TRIG - Channel Trigger
 ******************************************************************************/

/*!
 * @brief TPM_TRIG - Channel Trigger (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register configures the trigger input for each channel.
 */
/*!
 * @name Constants and macros for entire TPM_TRIG register
 */
/*@{*/
#define TPM_RD_TRIG(base)        (TPM_TRIG_REG(base))
#define TPM_WR_TRIG(base, value) (TPM_TRIG_REG(base) = (value))
#define TPM_RMW_TRIG(base, mask, value) (TPM_WR_TRIG(base, (TPM_RD_TRIG(base) & ~(mask)) | (value)))
#define TPM_SET_TRIG(base, value) (TPM_WR_TRIG(base, TPM_RD_TRIG(base) |  (value)))
#define TPM_CLR_TRIG(base, value) (TPM_WR_TRIG(base, TPM_RD_TRIG(base) & ~(value)))
#define TPM_TOG_TRIG(base, value) (TPM_WR_TRIG(base, TPM_RD_TRIG(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_TRIG bitfields
 */

/*!
 * @name Register TPM_TRIG, field TRIG0[0] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG0 field. */
#define TPM_RD_TRIG_TRIG0(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG0_MASK) >> TPM_TRIG_TRIG0_SHIFT)
#define TPM_BRD_TRIG_TRIG0(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG0_SHIFT))

/*! @brief Set the TRIG0 field to a new value. */
#define TPM_WR_TRIG_TRIG0(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG0_MASK, TPM_TRIG_TRIG0(value)))
#define TPM_BWR_TRIG_TRIG0(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_TRIG, field TRIG1[1] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG1 field. */
#define TPM_RD_TRIG_TRIG1(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG1_MASK) >> TPM_TRIG_TRIG1_SHIFT)
#define TPM_BRD_TRIG_TRIG1(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG1_SHIFT))

/*! @brief Set the TRIG1 field to a new value. */
#define TPM_WR_TRIG_TRIG1(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG1_MASK, TPM_TRIG_TRIG1(value)))
#define TPM_BWR_TRIG_TRIG1(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_TRIG, field TRIG2[2] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG2 field. */
#define TPM_RD_TRIG_TRIG2(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG2_MASK) >> TPM_TRIG_TRIG2_SHIFT)
#define TPM_BRD_TRIG_TRIG2(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG2_SHIFT))

/*! @brief Set the TRIG2 field to a new value. */
#define TPM_WR_TRIG_TRIG2(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG2_MASK, TPM_TRIG_TRIG2(value)))
#define TPM_BWR_TRIG_TRIG2(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_TRIG, field TRIG3[3] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG3 field. */
#define TPM_RD_TRIG_TRIG3(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG3_MASK) >> TPM_TRIG_TRIG3_SHIFT)
#define TPM_BRD_TRIG_TRIG3(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG3_SHIFT))

/*! @brief Set the TRIG3 field to a new value. */
#define TPM_WR_TRIG_TRIG3(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG3_MASK, TPM_TRIG_TRIG3(value)))
#define TPM_BWR_TRIG_TRIG3(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_TRIG, field TRIG4[4] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG4 field. */
#define TPM_RD_TRIG_TRIG4(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG4_MASK) >> TPM_TRIG_TRIG4_SHIFT)
#define TPM_BRD_TRIG_TRIG4(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG4_SHIFT))

/*! @brief Set the TRIG4 field to a new value. */
#define TPM_WR_TRIG_TRIG4(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG4_MASK, TPM_TRIG_TRIG4(value)))
#define TPM_BWR_TRIG_TRIG4(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_TRIG, field TRIG5[5] (RW)
 *
 * Values:
 * - 0 - No effect.
 * - 1 - The input trigger is used for input capture and modulates output (for
 *     output compare and PWM).
 */
/*@{*/
/*! @brief Read current value of the TPM_TRIG_TRIG5 field. */
#define TPM_RD_TRIG_TRIG5(base) ((TPM_TRIG_REG(base) & TPM_TRIG_TRIG5_MASK) >> TPM_TRIG_TRIG5_SHIFT)
#define TPM_BRD_TRIG_TRIG5(base) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG5_SHIFT))

/*! @brief Set the TRIG5 field to a new value. */
#define TPM_WR_TRIG_TRIG5(base, value) (TPM_RMW_TRIG(base, TPM_TRIG_TRIG5_MASK, TPM_TRIG_TRIG5(value)))
#define TPM_BWR_TRIG_TRIG5(base, value) (BITBAND_ACCESS32(&TPM_TRIG_REG(base), TPM_TRIG_TRIG5_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_POL - Channel Polarity
 ******************************************************************************/

/*!
 * @brief TPM_POL - Channel Polarity (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register defines the input and output polarity of each of the channels.
 */
/*!
 * @name Constants and macros for entire TPM_POL register
 */
/*@{*/
#define TPM_RD_POL(base)         (TPM_POL_REG(base))
#define TPM_WR_POL(base, value)  (TPM_POL_REG(base) = (value))
#define TPM_RMW_POL(base, mask, value) (TPM_WR_POL(base, (TPM_RD_POL(base) & ~(mask)) | (value)))
#define TPM_SET_POL(base, value) (TPM_WR_POL(base, TPM_RD_POL(base) |  (value)))
#define TPM_CLR_POL(base, value) (TPM_WR_POL(base, TPM_RD_POL(base) & ~(value)))
#define TPM_TOG_POL(base, value) (TPM_WR_POL(base, TPM_RD_POL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_POL bitfields
 */

/*!
 * @name Register TPM_POL, field POL0[0] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL0 field. */
#define TPM_RD_POL_POL0(base) ((TPM_POL_REG(base) & TPM_POL_POL0_MASK) >> TPM_POL_POL0_SHIFT)
#define TPM_BRD_POL_POL0(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL0_SHIFT))

/*! @brief Set the POL0 field to a new value. */
#define TPM_WR_POL_POL0(base, value) (TPM_RMW_POL(base, TPM_POL_POL0_MASK, TPM_POL_POL0(value)))
#define TPM_BWR_POL_POL0(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_POL, field POL1[1] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL1 field. */
#define TPM_RD_POL_POL1(base) ((TPM_POL_REG(base) & TPM_POL_POL1_MASK) >> TPM_POL_POL1_SHIFT)
#define TPM_BRD_POL_POL1(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL1_SHIFT))

/*! @brief Set the POL1 field to a new value. */
#define TPM_WR_POL_POL1(base, value) (TPM_RMW_POL(base, TPM_POL_POL1_MASK, TPM_POL_POL1(value)))
#define TPM_BWR_POL_POL1(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL1_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_POL, field POL2[2] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL2 field. */
#define TPM_RD_POL_POL2(base) ((TPM_POL_REG(base) & TPM_POL_POL2_MASK) >> TPM_POL_POL2_SHIFT)
#define TPM_BRD_POL_POL2(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL2_SHIFT))

/*! @brief Set the POL2 field to a new value. */
#define TPM_WR_POL_POL2(base, value) (TPM_RMW_POL(base, TPM_POL_POL2_MASK, TPM_POL_POL2(value)))
#define TPM_BWR_POL_POL2(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_POL, field POL3[3] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL3 field. */
#define TPM_RD_POL_POL3(base) ((TPM_POL_REG(base) & TPM_POL_POL3_MASK) >> TPM_POL_POL3_SHIFT)
#define TPM_BRD_POL_POL3(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL3_SHIFT))

/*! @brief Set the POL3 field to a new value. */
#define TPM_WR_POL_POL3(base, value) (TPM_RMW_POL(base, TPM_POL_POL3_MASK, TPM_POL_POL3(value)))
#define TPM_BWR_POL_POL3(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL3_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_POL, field POL4[4] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL4 field. */
#define TPM_RD_POL_POL4(base) ((TPM_POL_REG(base) & TPM_POL_POL4_MASK) >> TPM_POL_POL4_SHIFT)
#define TPM_BRD_POL_POL4(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL4_SHIFT))

/*! @brief Set the POL4 field to a new value. */
#define TPM_WR_POL_POL4(base, value) (TPM_RMW_POL(base, TPM_POL_POL4_MASK, TPM_POL_POL4(value)))
#define TPM_BWR_POL_POL4(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL4_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_POL, field POL5[5] (RW)
 *
 * Values:
 * - 0 - The channel polarity is active high.
 * - 1 - The channel polarity is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_POL_POL5 field. */
#define TPM_RD_POL_POL5(base) ((TPM_POL_REG(base) & TPM_POL_POL5_MASK) >> TPM_POL_POL5_SHIFT)
#define TPM_BRD_POL_POL5(base) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL5_SHIFT))

/*! @brief Set the POL5 field to a new value. */
#define TPM_WR_POL_POL5(base, value) (TPM_RMW_POL(base, TPM_POL_POL5_MASK, TPM_POL_POL5(value)))
#define TPM_BWR_POL_POL5(base, value) (BITBAND_ACCESS32(&TPM_POL_REG(base), TPM_POL_POL5_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_FILTER - Filter Control
 ******************************************************************************/

/*!
 * @brief TPM_FILTER - Filter Control (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the filter value of the channel inputs, and an
 * additional output delay value for the channel outputs. In PWM combine modes, the
 * filter can effectively implements deadtime insertion.
 */
/*!
 * @name Constants and macros for entire TPM_FILTER register
 */
/*@{*/
#define TPM_RD_FILTER(base)      (TPM_FILTER_REG(base))
#define TPM_WR_FILTER(base, value) (TPM_FILTER_REG(base) = (value))
#define TPM_RMW_FILTER(base, mask, value) (TPM_WR_FILTER(base, (TPM_RD_FILTER(base) & ~(mask)) | (value)))
#define TPM_SET_FILTER(base, value) (TPM_WR_FILTER(base, TPM_RD_FILTER(base) |  (value)))
#define TPM_CLR_FILTER(base, value) (TPM_WR_FILTER(base, TPM_RD_FILTER(base) & ~(value)))
#define TPM_TOG_FILTER(base, value) (TPM_WR_FILTER(base, TPM_RD_FILTER(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_FILTER bitfields
 */

/*!
 * @name Register TPM_FILTER, field CH0FVAL[3:0] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH0FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH0FVAL field. */
#define TPM_RD_FILTER_CH0FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH0FVAL_MASK) >> TPM_FILTER_CH0FVAL_SHIFT)
#define TPM_BRD_FILTER_CH0FVAL(base) (TPM_RD_FILTER_CH0FVAL(base))

/*! @brief Set the CH0FVAL field to a new value. */
#define TPM_WR_FILTER_CH0FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH0FVAL_MASK, TPM_FILTER_CH0FVAL(value)))
#define TPM_BWR_FILTER_CH0FVAL(base, value) (TPM_WR_FILTER_CH0FVAL(base, value))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH1FVAL[7:4] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH1FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH1FVAL field. */
#define TPM_RD_FILTER_CH1FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH1FVAL_MASK) >> TPM_FILTER_CH1FVAL_SHIFT)
#define TPM_BRD_FILTER_CH1FVAL(base) (TPM_RD_FILTER_CH1FVAL(base))

/*! @brief Set the CH1FVAL field to a new value. */
#define TPM_WR_FILTER_CH1FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH1FVAL_MASK, TPM_FILTER_CH1FVAL(value)))
#define TPM_BWR_FILTER_CH1FVAL(base, value) (TPM_WR_FILTER_CH1FVAL(base, value))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH2FVAL[11:8] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH2FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH2FVAL field. */
#define TPM_RD_FILTER_CH2FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH2FVAL_MASK) >> TPM_FILTER_CH2FVAL_SHIFT)
#define TPM_BRD_FILTER_CH2FVAL(base) (TPM_RD_FILTER_CH2FVAL(base))

/*! @brief Set the CH2FVAL field to a new value. */
#define TPM_WR_FILTER_CH2FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH2FVAL_MASK, TPM_FILTER_CH2FVAL(value)))
#define TPM_BWR_FILTER_CH2FVAL(base, value) (TPM_WR_FILTER_CH2FVAL(base, value))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH3FVAL[15:12] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH3FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH3FVAL field. */
#define TPM_RD_FILTER_CH3FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH3FVAL_MASK) >> TPM_FILTER_CH3FVAL_SHIFT)
#define TPM_BRD_FILTER_CH3FVAL(base) (TPM_RD_FILTER_CH3FVAL(base))

/*! @brief Set the CH3FVAL field to a new value. */
#define TPM_WR_FILTER_CH3FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH3FVAL_MASK, TPM_FILTER_CH3FVAL(value)))
#define TPM_BWR_FILTER_CH3FVAL(base, value) (TPM_WR_FILTER_CH3FVAL(base, value))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH4FVAL[19:16] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH4FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH4FVAL field. */
#define TPM_RD_FILTER_CH4FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH4FVAL_MASK) >> TPM_FILTER_CH4FVAL_SHIFT)
#define TPM_BRD_FILTER_CH4FVAL(base) (TPM_RD_FILTER_CH4FVAL(base))

/*! @brief Set the CH4FVAL field to a new value. */
#define TPM_WR_FILTER_CH4FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH4FVAL_MASK, TPM_FILTER_CH4FVAL(value)))
#define TPM_BWR_FILTER_CH4FVAL(base, value) (TPM_WR_FILTER_CH4FVAL(base, value))
/*@}*/

/*!
 * @name Register TPM_FILTER, field CH5FVAL[23:20] (RW)
 *
 * Selects the filter value for the channel input and the delay value for the
 * channel output. The filter/delay is disabled when the value is zero, otherwise
 * the filter/delay is configured as (CH5FVAL * 4) clock cycles.
 */
/*@{*/
/*! @brief Read current value of the TPM_FILTER_CH5FVAL field. */
#define TPM_RD_FILTER_CH5FVAL(base) ((TPM_FILTER_REG(base) & TPM_FILTER_CH5FVAL_MASK) >> TPM_FILTER_CH5FVAL_SHIFT)
#define TPM_BRD_FILTER_CH5FVAL(base) (TPM_RD_FILTER_CH5FVAL(base))

/*! @brief Set the CH5FVAL field to a new value. */
#define TPM_WR_FILTER_CH5FVAL(base, value) (TPM_RMW_FILTER(base, TPM_FILTER_CH5FVAL_MASK, TPM_FILTER_CH5FVAL(value)))
#define TPM_BWR_FILTER_CH5FVAL(base, value) (TPM_WR_FILTER_CH5FVAL(base, value))
/*@}*/

/*******************************************************************************
 * TPM_QDCTRL - Quadrature Decoder Control and Status
 ******************************************************************************/

/*!
 * @brief TPM_QDCTRL - Quadrature Decoder Control and Status (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register has the control and status bits for the quadrature decoder mode.
 */
/*!
 * @name Constants and macros for entire TPM_QDCTRL register
 */
/*@{*/
#define TPM_RD_QDCTRL(base)      (TPM_QDCTRL_REG(base))
#define TPM_WR_QDCTRL(base, value) (TPM_QDCTRL_REG(base) = (value))
#define TPM_RMW_QDCTRL(base, mask, value) (TPM_WR_QDCTRL(base, (TPM_RD_QDCTRL(base) & ~(mask)) | (value)))
#define TPM_SET_QDCTRL(base, value) (TPM_WR_QDCTRL(base, TPM_RD_QDCTRL(base) |  (value)))
#define TPM_CLR_QDCTRL(base, value) (TPM_WR_QDCTRL(base, TPM_RD_QDCTRL(base) & ~(value)))
#define TPM_TOG_QDCTRL(base, value) (TPM_WR_QDCTRL(base, TPM_RD_QDCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_QDCTRL bitfields
 */

/*!
 * @name Register TPM_QDCTRL, field QUADEN[0] (RW)
 *
 * Enables the quadrature decoder mode. In this mode, the channel 0 and channel
 * 1 inputs control the TPM counter direction and can only be used for software
 * compare. The quadrature decoder mode has precedence over the other modes.
 *
 * Values:
 * - 0 - Quadrature decoder mode is disabled.
 * - 1 - Quadrature decoder mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADEN field. */
#define TPM_RD_QDCTRL_QUADEN(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADEN_MASK) >> TPM_QDCTRL_QUADEN_SHIFT)
#define TPM_BRD_QDCTRL_QUADEN(base) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADEN_SHIFT))

/*! @brief Set the QUADEN field to a new value. */
#define TPM_WR_QDCTRL_QUADEN(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADEN_MASK, TPM_QDCTRL_QUADEN(value)))
#define TPM_BWR_QDCTRL_QUADEN(base, value) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field TOFDIR[1] (RO)
 *
 * Indicates if the TOF bit was set on the top or the bottom of counting.
 *
 * Values:
 * - 0 - TOF bit was set on the bottom of counting. There was an FTM counter
 *     decrement and FTM counter changes from its minimum value (zero) to its
 *     maximum value (MOD register).
 * - 1 - TOF bit was set on the top of counting. There was an FTM counter
 *     increment and FTM counter changes from its maximum value (MOD register) to its
 *     minimum value (zero).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_TOFDIR field. */
#define TPM_RD_QDCTRL_TOFDIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_TOFDIR_MASK) >> TPM_QDCTRL_TOFDIR_SHIFT)
#define TPM_BRD_QDCTRL_TOFDIR(base) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_TOFDIR_SHIFT))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADIR[2] (RO)
 *
 * Indicates the counting direction.
 *
 * Values:
 * - 0 - Counter direction is decreasing (counter decrement).
 * - 1 - Counter direction is increasing (counter increment).
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADIR field. */
#define TPM_RD_QDCTRL_QUADIR(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADIR_MASK) >> TPM_QDCTRL_QUADIR_SHIFT)
#define TPM_BRD_QDCTRL_QUADIR(base) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADIR_SHIFT))
/*@}*/

/*!
 * @name Register TPM_QDCTRL, field QUADMODE[3] (RW)
 *
 * Selects the encoding mode used in the quadrature decoder mode.
 *
 * Values:
 * - 0 - Phase encoding mode.
 * - 1 - Count and direction encoding mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_QDCTRL_QUADMODE field. */
#define TPM_RD_QDCTRL_QUADMODE(base) ((TPM_QDCTRL_REG(base) & TPM_QDCTRL_QUADMODE_MASK) >> TPM_QDCTRL_QUADMODE_SHIFT)
#define TPM_BRD_QDCTRL_QUADMODE(base) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADMODE_SHIFT))

/*! @brief Set the QUADMODE field to a new value. */
#define TPM_WR_QDCTRL_QUADMODE(base, value) (TPM_RMW_QDCTRL(base, TPM_QDCTRL_QUADMODE_MASK, TPM_QDCTRL_QUADMODE(value)))
#define TPM_BWR_QDCTRL_QUADMODE(base, value) (BITBAND_ACCESS32(&TPM_QDCTRL_REG(base), TPM_QDCTRL_QUADMODE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * TPM_CONF - Configuration
 ******************************************************************************/

/*!
 * @brief TPM_CONF - Configuration (RW)
 *
 * Reset value: 0x00000000U
 *
 * This register selects the behavior in debug and wait modes and the use of an
 * external global time base.
 */
/*!
 * @name Constants and macros for entire TPM_CONF register
 */
/*@{*/
#define TPM_RD_CONF(base)        (TPM_CONF_REG(base))
#define TPM_WR_CONF(base, value) (TPM_CONF_REG(base) = (value))
#define TPM_RMW_CONF(base, mask, value) (TPM_WR_CONF(base, (TPM_RD_CONF(base) & ~(mask)) | (value)))
#define TPM_SET_CONF(base, value) (TPM_WR_CONF(base, TPM_RD_CONF(base) |  (value)))
#define TPM_CLR_CONF(base, value) (TPM_WR_CONF(base, TPM_RD_CONF(base) & ~(value)))
#define TPM_TOG_CONF(base, value) (TPM_WR_CONF(base, TPM_RD_CONF(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual TPM_CONF bitfields
 */

/*!
 * @name Register TPM_CONF, field DOZEEN[5] (RW)
 *
 * Configures the TPM behavior in wait mode.
 *
 * Values:
 * - 0 - Internal TPM counter continues in Doze mode.
 * - 1 - Internal TPM counter is paused and does not increment during Doze mode.
 *     Trigger inputs and input capture events are also ignored.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DOZEEN field. */
#define TPM_RD_CONF_DOZEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_DOZEEN_MASK) >> TPM_CONF_DOZEEN_SHIFT)
#define TPM_BRD_CONF_DOZEEN(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_DOZEEN_SHIFT))

/*! @brief Set the DOZEEN field to a new value. */
#define TPM_WR_CONF_DOZEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_DOZEEN_MASK, TPM_CONF_DOZEEN(value)))
#define TPM_BWR_CONF_DOZEEN(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_DOZEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field DBGMODE[7:6] (RW)
 *
 * Configures the TPM behavior in debug mode. All other configurations are
 * reserved.
 *
 * Values:
 * - 00 - TPM counter is paused and does not increment during debug mode.
 *     Trigger inputs and input capture events are also ignored.
 * - 11 - TPM counter continues in debug mode.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_DBGMODE field. */
#define TPM_RD_CONF_DBGMODE(base) ((TPM_CONF_REG(base) & TPM_CONF_DBGMODE_MASK) >> TPM_CONF_DBGMODE_SHIFT)
#define TPM_BRD_CONF_DBGMODE(base) (TPM_RD_CONF_DBGMODE(base))

/*! @brief Set the DBGMODE field to a new value. */
#define TPM_WR_CONF_DBGMODE(base, value) (TPM_RMW_CONF(base, TPM_CONF_DBGMODE_MASK, TPM_CONF_DBGMODE(value)))
#define TPM_BWR_CONF_DBGMODE(base, value) (TPM_WR_CONF_DBGMODE(base, value))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBSYNC[8] (RW)
 *
 * When enabled, the TPM counter is synchronized to the global time base. It
 * uses the global timebase enable, trigger and overflow to ensure the TPM counter
 * starts incrementing at the same time as the global timebase, stops incrementing
 * at the same time as the global timebase and is reset at the same time as the
 * global timebase. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0 - Global timebase synchronization disabled.
 * - 1 - Global timebase synchronization enabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_GTBSYNC field. */
#define TPM_RD_CONF_GTBSYNC(base) ((TPM_CONF_REG(base) & TPM_CONF_GTBSYNC_MASK) >> TPM_CONF_GTBSYNC_SHIFT)
#define TPM_BRD_CONF_GTBSYNC(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_GTBSYNC_SHIFT))

/*! @brief Set the GTBSYNC field to a new value. */
#define TPM_WR_CONF_GTBSYNC(base, value) (TPM_RMW_CONF(base, TPM_CONF_GTBSYNC_MASK, TPM_CONF_GTBSYNC(value)))
#define TPM_BWR_CONF_GTBSYNC(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_GTBSYNC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field GTBEEN[9] (RW)
 *
 * Configures the TPM to use an externally generated global time base counter.
 * When an externally generated timebase is used, the internal TPM counter is not
 * used by the channels but can be used to generate a periodic interruptor DMA
 * request using the Modulo register and timer overflow flag.
 *
 * Values:
 * - 0 - All channels use the internally generated TPM counter as their timebase
 * - 1 - All channels use an externally generated global timebase as their
 *     timebase
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_GTBEEN field. */
#define TPM_RD_CONF_GTBEEN(base) ((TPM_CONF_REG(base) & TPM_CONF_GTBEEN_MASK) >> TPM_CONF_GTBEEN_SHIFT)
#define TPM_BRD_CONF_GTBEEN(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_GTBEEN_SHIFT))

/*! @brief Set the GTBEEN field to a new value. */
#define TPM_WR_CONF_GTBEEN(base, value) (TPM_RMW_CONF(base, TPM_CONF_GTBEEN_MASK, TPM_CONF_GTBEEN(value)))
#define TPM_BWR_CONF_GTBEEN(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_GTBEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOT[16] (RW)
 *
 * When set, the TPM counter will not start incrementing after it is enabled
 * until a rising edge on the selected trigger input is detected. If the TPM counter
 * is stopped due to an overflow, a rising edge on the selected trigger input
 * will also cause the TPM counter to start incrementing again. The trigger input
 * is ignored if the TPM counter is paused during debug mode or doze mode. This
 * field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - TPM counter starts to increment immediately, once it is enabled.
 * - 1 - TPM counter only starts to increment when it a rising edge on the
 *     selected input trigger is detected, after it has been enabled or after it has
 *     stopped due to overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOT field. */
#define TPM_RD_CONF_CSOT(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOT_MASK) >> TPM_CONF_CSOT_SHIFT)
#define TPM_BRD_CONF_CSOT(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CSOT_SHIFT))

/*! @brief Set the CSOT field to a new value. */
#define TPM_WR_CONF_CSOT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOT_MASK, TPM_CONF_CSOT(value)))
#define TPM_BWR_CONF_CSOT(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CSOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field CSOO[17] (RW)
 *
 * When set, the TPM counter will stop incrementing once the counter equals the
 * MOD value and incremented (this also sets the TOF). Reloading the counter with
 * 0 due to writing to the counter register or due to a trigger input does not
 * cause the counter to stop incrementing. Once the counter has stopped
 * incrementing, the counter will not start incrementing unless it is disabled and then
 * enabled again, or a rising edge on the selected trigger input is detected when
 * CSOT set. This field should only be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - TPM counter continues incrementing or decrementing after overflow
 * - 1 - TPM counter stops incrementing or decrementing after overflow.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CSOO field. */
#define TPM_RD_CONF_CSOO(base) ((TPM_CONF_REG(base) & TPM_CONF_CSOO_MASK) >> TPM_CONF_CSOO_SHIFT)
#define TPM_BRD_CONF_CSOO(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CSOO_SHIFT))

/*! @brief Set the CSOO field to a new value. */
#define TPM_WR_CONF_CSOO(base, value) (TPM_RMW_CONF(base, TPM_CONF_CSOO_MASK, TPM_CONF_CSOO(value)))
#define TPM_BWR_CONF_CSOO(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CSOO_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field CROT[18] (RW)
 *
 * When set, the TPM counter will reload with 0 (and initialize PWM outputs to
 * their default value) when a rising edge is detected on the selected trigger
 * input. The trigger input is ignored if the TPM counter is paused during debug
 * mode or doze mode. This field should only be changed when the TPM counter is
 * disabled.
 *
 * Values:
 * - 0 - Counter is not reloaded due to a rising edge on the selected input
 *     trigger
 * - 1 - Counter is reloaded when a rising edge is detected on the selected
 *     input trigger
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CROT field. */
#define TPM_RD_CONF_CROT(base) ((TPM_CONF_REG(base) & TPM_CONF_CROT_MASK) >> TPM_CONF_CROT_SHIFT)
#define TPM_BRD_CONF_CROT(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CROT_SHIFT))

/*! @brief Set the CROT field to a new value. */
#define TPM_WR_CONF_CROT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CROT_MASK, TPM_CONF_CROT(value)))
#define TPM_BWR_CONF_CROT(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CROT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field CPOT[19] (RW)
 *
 * When enabled, the counter will pause incrementing while the trigger remains
 * asserted (level sensitive). This field should only be changed when the TPM
 * counter is disabled.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_CPOT field. */
#define TPM_RD_CONF_CPOT(base) ((TPM_CONF_REG(base) & TPM_CONF_CPOT_MASK) >> TPM_CONF_CPOT_SHIFT)
#define TPM_BRD_CONF_CPOT(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CPOT_SHIFT))

/*! @brief Set the CPOT field to a new value. */
#define TPM_WR_CONF_CPOT(base, value) (TPM_RMW_CONF(base, TPM_CONF_CPOT_MASK, TPM_CONF_CPOT(value)))
#define TPM_BWR_CONF_CPOT(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_CPOT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGPOL[22] (RW)
 *
 * Selects the polarity of the external trigger source. This field should only
 * be changed when the TPM counter is disabled.
 *
 * Values:
 * - 0 - Trigger is active high.
 * - 1 - Trigger is active low.
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGPOL field. */
#define TPM_RD_CONF_TRGPOL(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGPOL_MASK) >> TPM_CONF_TRGPOL_SHIFT)
#define TPM_BRD_CONF_TRGPOL(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_TRGPOL_SHIFT))

/*! @brief Set the TRGPOL field to a new value. */
#define TPM_WR_CONF_TRGPOL(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGPOL_MASK, TPM_CONF_TRGPOL(value)))
#define TPM_BWR_CONF_TRGPOL(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_TRGPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSRC[23] (RW)
 *
 * Selects between internal (channel pin input capture) or external trigger
 * sources. When selecting an internal trigger, the channel selected should be
 * configured for input capture. Only a rising edge input capture can be used to
 * initially start the counter using the CSOT configuration; either rising edge or
 * falling edge input capture can be used to reload the counter using the CROT
 * configuration; and the state of the channel input pin is used to pause the counter
 * using the CPOT configuration. The channel polarity register can be used to
 * invert the polarity of the channel input pins. This field should only be changed
 * when the TPM counter is disabled.
 *
 * Values:
 * - 0 - Trigger source selected by TRGSEL is external.
 * - 1 - Trigger source selected by TRGSEL is internal (channel pin input
 *     capture).
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGSRC field. */
#define TPM_RD_CONF_TRGSRC(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGSRC_MASK) >> TPM_CONF_TRGSRC_SHIFT)
#define TPM_BRD_CONF_TRGSRC(base) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_TRGSRC_SHIFT))

/*! @brief Set the TRGSRC field to a new value. */
#define TPM_WR_CONF_TRGSRC(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGSRC_MASK, TPM_CONF_TRGSRC(value)))
#define TPM_BWR_CONF_TRGSRC(base, value) (BITBAND_ACCESS32(&TPM_CONF_REG(base), TPM_CONF_TRGSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register TPM_CONF, field TRGSEL[27:24] (RW)
 *
 * Selects the input trigger to use for starting, reloading and/or pausing the
 * counter. The source of the trigger (external or internal to the TPM) is
 * configured by the TRGSRC field. This field should only be changed when the TPM
 * counter is disabled. Refer to the chip configuration section for available external
 * trigger options. The available internal trigger sources are listed below.
 *
 * Values:
 * - 0001 - Channel 0 pin input capture
 * - 0010 - Channel 1 pin input capture
 * - 0011 - Channel 0 or Channel 1 pin input capture
 * - 0100 - Channel 2 pin input capture
 * - 0101 - Channel 0 or Channel 2 pin input capture
 * - 0110 - Channel 1 or Channel 2 pin input capture
 * - 0111 - Channel 0 or Channel 1 or Channel 2 pin input capture
 * - 1000 - Channel 3 pin input capture
 * - 1001 - Channel 0 or Channel 3 pin input capture
 * - 1010 - Channel 1 or Channel 3 pin input capture
 * - 1011 - Channel 0 or Channel 1 or Channel 3 pin input capture
 * - 1100 - Channel 2 or Channel 3 pin input capture
 * - 1101 - Channel 0 or Channel 2 or Channel 3 pin input capture
 * - 1110 - Channel 1 or Channel 2 or Channel 3 pin input capture
 * - 1111 - Channel 0 or Channel 1 or Channel 2 or Channel 3 pin input capture
 */
/*@{*/
/*! @brief Read current value of the TPM_CONF_TRGSEL field. */
#define TPM_RD_CONF_TRGSEL(base) ((TPM_CONF_REG(base) & TPM_CONF_TRGSEL_MASK) >> TPM_CONF_TRGSEL_SHIFT)
#define TPM_BRD_CONF_TRGSEL(base) (TPM_RD_CONF_TRGSEL(base))

/*! @brief Set the TRGSEL field to a new value. */
#define TPM_WR_CONF_TRGSEL(base, value) (TPM_RMW_CONF(base, TPM_CONF_TRGSEL_MASK, TPM_CONF_TRGSEL(value)))
#define TPM_BWR_CONF_TRGSEL(base, value) (TPM_WR_CONF_TRGSEL(base, value))
/*@}*/

/*
 * MKS22F25612 UART
 *
 * Serial Communication Interface
 *
 * Registers defined in this header file:
 * - UART_BDH - UART Baud Rate Registers: High
 * - UART_BDL - UART Baud Rate Registers: Low
 * - UART_C1 - UART Control Register 1
 * - UART_C2 - UART Control Register 2
 * - UART_S1 - UART Status Register 1
 * - UART_S2 - UART Status Register 2
 * - UART_C3 - UART Control Register 3
 * - UART_D - UART Data Register
 * - UART_MA1 - UART Match Address Registers 1
 * - UART_MA2 - UART Match Address Registers 2
 * - UART_C4 - UART Control Register 4
 * - UART_C5 - UART Control Register 5
 * - UART_ED - UART Extended Data Register
 * - UART_MODEM - UART Modem Register
 * - UART_IR - UART Infrared Register
 * - UART_PFIFO - UART FIFO Parameters
 * - UART_CFIFO - UART FIFO Control Register
 * - UART_SFIFO - UART FIFO Status Register
 * - UART_TWFIFO - UART FIFO Transmit Watermark
 * - UART_TCFIFO - UART FIFO Transmit Count
 * - UART_RWFIFO - UART FIFO Receive Watermark
 * - UART_RCFIFO - UART FIFO Receive Count
 * - UART_C7816 - UART 7816 Control Register
 * - UART_IE7816 - UART 7816 Interrupt Enable Register
 * - UART_IS7816 - UART 7816 Interrupt Status Register
 * - UART_WP7816 - UART 7816 Wait Parameter Register
 * - UART_WN7816 - UART 7816 Wait N Register
 * - UART_WF7816 - UART 7816 Wait FD Register
 * - UART_ET7816 - UART 7816 Error Threshold Register
 * - UART_TL7816 - UART 7816 Transmit Length Register
 * - UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 * - UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 * - UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 * - UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 * - UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 * - UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 * - UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 */

#define UART_INSTANCE_COUNT (3U) /*!< Number of instances of the UART module. */
#define UART0_IDX (0U) /*!< Instance number for UART0. */
#define UART1_IDX (1U) /*!< Instance number for UART1. */
#define UART2_IDX (2U) /*!< Instance number for UART2. */

/*******************************************************************************
 * UART_BDH - UART Baud Rate Registers: High
 ******************************************************************************/

/*!
 * @brief UART_BDH - UART Baud Rate Registers: High (RW)
 *
 * Reset value: 0x00U
 *
 * This register, along with the BDL register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting
 * (SBR[12:0]), first write to BDH to buffer the high half of the new value and then write
 * to BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is,
 * when C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDH register
 */
/*@{*/
#define UART_RD_BDH(base)        (UART_BDH_REG(base))
#define UART_WR_BDH(base, value) (UART_BDH_REG(base) = (value))
#define UART_RMW_BDH(base, mask, value) (UART_WR_BDH(base, (UART_RD_BDH(base) & ~(mask)) | (value)))
#define UART_SET_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) |  (value)))
#define UART_CLR_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) & ~(value)))
#define UART_TOG_BDH(base, value) (UART_WR_BDH(base, UART_RD_BDH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_BDH bitfields
 */

/*!
 * @name Register UART_BDH, field SBR[4:0] (RW)
 *
 * The baud rate for the UART is determined by the 13 SBR fields. See Baud rate
 * generation for details. The baud rate generator is disabled until C2[TE] or
 * C2[RE] is set for the first time after reset.The baud rate generator is disabled
 * when SBR = 0. Writing to BDH has no effect without writing to BDL, because
 * writing to BDH puts the data in a temporary location until BDL is written.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBR field. */
#define UART_RD_BDH_SBR(base) ((UART_BDH_REG(base) & UART_BDH_SBR_MASK) >> UART_BDH_SBR_SHIFT)
#define UART_BRD_BDH_SBR(base) (UART_RD_BDH_SBR(base))

/*! @brief Set the SBR field to a new value. */
#define UART_WR_BDH_SBR(base, value) (UART_RMW_BDH(base, UART_BDH_SBR_MASK, UART_BDH_SBR(value)))
#define UART_BWR_BDH_SBR(base, value) (UART_WR_BDH_SBR(base, value))
/*@}*/

/*!
 * @name Register UART_BDH, field SBNS[5] (RW)
 *
 * SBNS selects the number of stop bits present in a data frame. This field
 * valid for all 8, 9 and 10 bit data formats available. This field is not valid when
 * C7816[ISO7816E] is enabled.
 *
 * Values:
 * - 0 - Data frame consists of a single stop bit.
 * - 1 - Data frame consists of two stop bits.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_SBNS field. */
#define UART_RD_BDH_SBNS(base) ((UART_BDH_REG(base) & UART_BDH_SBNS_MASK) >> UART_BDH_SBNS_SHIFT)
#define UART_BRD_BDH_SBNS(base) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_SBNS_SHIFT))

/*! @brief Set the SBNS field to a new value. */
#define UART_WR_BDH_SBNS(base, value) (UART_RMW_BDH(base, UART_BDH_SBNS_MASK, UART_BDH_SBNS(value)))
#define UART_BWR_BDH_SBNS(base, value) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_SBNS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_BDH, field RXEDGIE[6] (RW)
 *
 * Enables the receive input active edge, RXEDGIF, to generate interrupt
 * requests.
 *
 * Values:
 * - 0 - Hardware interrupts from RXEDGIF disabled using polling.
 * - 1 - RXEDGIF interrupt request enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_RXEDGIE field. */
#define UART_RD_BDH_RXEDGIE(base) ((UART_BDH_REG(base) & UART_BDH_RXEDGIE_MASK) >> UART_BDH_RXEDGIE_SHIFT)
#define UART_BRD_BDH_RXEDGIE(base) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT))

/*! @brief Set the RXEDGIE field to a new value. */
#define UART_WR_BDH_RXEDGIE(base, value) (UART_RMW_BDH(base, UART_BDH_RXEDGIE_MASK, UART_BDH_RXEDGIE(value)))
#define UART_BWR_BDH_RXEDGIE(base, value) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_RXEDGIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_BDH, field LBKDIE[7] (RW)
 *
 * Enables the LIN break detect flag, LBKDIF, to generate interrupt requests
 * based on the state of LBKDDMAS. or DMA transfer requests,
 *
 * Values:
 * - 0 - LBKDIF interrupt and DMA transfer requests disabled.
 * - 1 - LBKDIF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_BDH_LBKDIE field. */
#define UART_RD_BDH_LBKDIE(base) ((UART_BDH_REG(base) & UART_BDH_LBKDIE_MASK) >> UART_BDH_LBKDIE_SHIFT)
#define UART_BRD_BDH_LBKDIE(base) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT))

/*! @brief Set the LBKDIE field to a new value. */
#define UART_WR_BDH_LBKDIE(base, value) (UART_RMW_BDH(base, UART_BDH_LBKDIE_MASK, UART_BDH_LBKDIE(value)))
#define UART_BWR_BDH_LBKDIE(base, value) (BITBAND_ACCESS8(&UART_BDH_REG(base), UART_BDH_LBKDIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_BDL - UART Baud Rate Registers: Low
 ******************************************************************************/

/*!
 * @brief UART_BDL - UART Baud Rate Registers: Low (RW)
 *
 * Reset value: 0x04U
 *
 * This register, along with the BDH register, controls the prescale divisor for
 * UART baud rate generation. To update the 13-bit baud rate setting, SBR[12:0],
 * first write to BDH to buffer the high half of the new value and then write to
 * BDL. The working value in BDH does not change until BDL is written. BDL is
 * reset to a nonzero value, but after reset, the baud rate generator remains
 * disabled until the first time the receiver or transmitter is enabled, that is, when
 * C2[RE] or C2[TE] is set.
 */
/*!
 * @name Constants and macros for entire UART_BDL register
 */
/*@{*/
#define UART_RD_BDL(base)        (UART_BDL_REG(base))
#define UART_WR_BDL(base, value) (UART_BDL_REG(base) = (value))
#define UART_RMW_BDL(base, mask, value) (UART_WR_BDL(base, (UART_RD_BDL(base) & ~(mask)) | (value)))
#define UART_SET_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) |  (value)))
#define UART_CLR_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) & ~(value)))
#define UART_TOG_BDL(base, value) (UART_WR_BDL(base, UART_RD_BDL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_C1 - UART Control Register 1
 ******************************************************************************/

/*!
 * @brief UART_C1 - UART Control Register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * This read/write register controls various optional features of the UART
 * system.
 */
/*!
 * @name Constants and macros for entire UART_C1 register
 */
/*@{*/
#define UART_RD_C1(base)         (UART_C1_REG(base))
#define UART_WR_C1(base, value)  (UART_C1_REG(base) = (value))
#define UART_RMW_C1(base, mask, value) (UART_WR_C1(base, (UART_RD_C1(base) & ~(mask)) | (value)))
#define UART_SET_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) |  (value)))
#define UART_CLR_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) & ~(value)))
#define UART_TOG_C1(base, value) (UART_WR_C1(base, UART_RD_C1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C1 bitfields
 */

/*!
 * @name Register UART_C1, field PT[0] (RW)
 *
 * Determines whether the UART generates and checks for even parity or odd
 * parity. With even parity, an even number of 1s clears the parity bit and an odd
 * number of 1s sets the parity bit. With odd parity, an odd number of 1s clears the
 * parity bit and an even number of 1s sets the parity bit. This field must be
 * cleared when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Even parity.
 * - 1 - Odd parity.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PT field. */
#define UART_RD_C1_PT(base)  ((UART_C1_REG(base) & UART_C1_PT_MASK) >> UART_C1_PT_SHIFT)
#define UART_BRD_C1_PT(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PT_SHIFT))

/*! @brief Set the PT field to a new value. */
#define UART_WR_C1_PT(base, value) (UART_RMW_C1(base, UART_C1_PT_MASK, UART_C1_PT(value)))
#define UART_BWR_C1_PT(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field PE[1] (RW)
 *
 * Enables the parity function. When parity is enabled, parity function inserts
 * a parity bit in the bit position immediately preceding the stop bit. This
 * field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Parity function disabled.
 * - 1 - Parity function enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_PE field. */
#define UART_RD_C1_PE(base)  ((UART_C1_REG(base) & UART_C1_PE_MASK) >> UART_C1_PE_SHIFT)
#define UART_BRD_C1_PE(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PE_SHIFT))

/*! @brief Set the PE field to a new value. */
#define UART_WR_C1_PE(base, value) (UART_RMW_C1(base, UART_C1_PE_MASK, UART_C1_PE(value)))
#define UART_BWR_C1_PE(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_PE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field ILT[2] (RW)
 *
 * Determines when the receiver starts counting logic 1s as idle character bits.
 * The count begins either after a valid start bit or after the stop bit. If the
 * count begins after the start bit, then a string of logic 1s preceding the
 * stop bit can cause false recognition of an idle character. Beginning the count
 * after the stop bit avoids false idle character recognition, but requires
 * properly synchronized transmissions. In case the UART is programmed with ILT = 1, a
 * logic of 1'b0 is automatically shifted after a received stop bit, therefore
 * resetting the idle count. In case the UART is programmed for IDLE line wakeup
 * (RWU = 1 and WAKE = 0), ILT has no effect on when the receiver starts counting
 * logic 1s as idle character bits. In idle line wakeup, an idle character is
 * recognized at anytime the receiver sees 10, 11, or 12 1s depending on the M, PE,
 * and C4[M10] fields.
 *
 * Values:
 * - 0 - Idle character bit count starts after start bit.
 * - 1 - Idle character bit count starts after stop bit.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_ILT field. */
#define UART_RD_C1_ILT(base) ((UART_C1_REG(base) & UART_C1_ILT_MASK) >> UART_C1_ILT_SHIFT)
#define UART_BRD_C1_ILT(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_ILT_SHIFT))

/*! @brief Set the ILT field to a new value. */
#define UART_WR_C1_ILT(base, value) (UART_RMW_C1(base, UART_C1_ILT_MASK, UART_C1_ILT(value)))
#define UART_BWR_C1_ILT(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_ILT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field WAKE[3] (RW)
 *
 * Determines which condition wakes the UART: Address mark in the most
 * significant bit position of a received data character, or An idle condition on the
 * receive pin input signal.
 *
 * Values:
 * - 0 - Idle line wakeup.
 * - 1 - Address mark wakeup.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_WAKE field. */
#define UART_RD_C1_WAKE(base) ((UART_C1_REG(base) & UART_C1_WAKE_MASK) >> UART_C1_WAKE_SHIFT)
#define UART_BRD_C1_WAKE(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT))

/*! @brief Set the WAKE field to a new value. */
#define UART_WR_C1_WAKE(base, value) (UART_RMW_C1(base, UART_C1_WAKE_MASK, UART_C1_WAKE(value)))
#define UART_BWR_C1_WAKE(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_WAKE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field M[4] (RW)
 *
 * This field must be set when C7816[ISO_7816E] is set/enabled.
 *
 * Values:
 * - 0 - Normal-start + 8 data bits (MSB/LSB first as determined by MSBF) + stop.
 * - 1 - Use-start + 9 data bits (MSB/LSB first as determined by MSBF) + stop.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_M field. */
#define UART_RD_C1_M(base)   ((UART_C1_REG(base) & UART_C1_M_MASK) >> UART_C1_M_SHIFT)
#define UART_BRD_C1_M(base)  (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_M_SHIFT))

/*! @brief Set the M field to a new value. */
#define UART_WR_C1_M(base, value) (UART_RMW_C1(base, UART_C1_M_MASK, UART_C1_M(value)))
#define UART_BWR_C1_M(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_M_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field RSRC[5] (RW)
 *
 * This field has no meaning or effect unless the LOOPS field is set. When LOOPS
 * is set, the RSRC field determines the source for the receiver shift register
 * input.
 *
 * Values:
 * - 0 - Selects internal loop back mode. The receiver input is internally
 *     connected to transmitter output.
 * - 1 - Single wire UART mode where the receiver input is connected to the
 *     transmit pin input signal.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_RSRC field. */
#define UART_RD_C1_RSRC(base) ((UART_C1_REG(base) & UART_C1_RSRC_MASK) >> UART_C1_RSRC_SHIFT)
#define UART_BRD_C1_RSRC(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT))

/*! @brief Set the RSRC field to a new value. */
#define UART_WR_C1_RSRC(base, value) (UART_RMW_C1(base, UART_C1_RSRC_MASK, UART_C1_RSRC(value)))
#define UART_BWR_C1_RSRC(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_RSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field UARTSWAI[6] (RW)
 *
 * Values:
 * - 0 - UART clock continues to run in Wait mode.
 * - 1 - UART clock freezes while CPU is in Wait mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_UARTSWAI field. */
#define UART_RD_C1_UARTSWAI(base) ((UART_C1_REG(base) & UART_C1_UARTSWAI_MASK) >> UART_C1_UARTSWAI_SHIFT)
#define UART_BRD_C1_UARTSWAI(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT))

/*! @brief Set the UARTSWAI field to a new value. */
#define UART_WR_C1_UARTSWAI(base, value) (UART_RMW_C1(base, UART_C1_UARTSWAI_MASK, UART_C1_UARTSWAI(value)))
#define UART_BWR_C1_UARTSWAI(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_UARTSWAI_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C1, field LOOPS[7] (RW)
 *
 * When LOOPS is set, the RxD pin is disconnected from the UART and the
 * transmitter output is internally connected to the receiver input. The transmitter and
 * the receiver must be enabled to use the loop function.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - Loop mode where transmitter output is internally connected to receiver
 *     input. The receiver input is determined by RSRC.
 */
/*@{*/
/*! @brief Read current value of the UART_C1_LOOPS field. */
#define UART_RD_C1_LOOPS(base) ((UART_C1_REG(base) & UART_C1_LOOPS_MASK) >> UART_C1_LOOPS_SHIFT)
#define UART_BRD_C1_LOOPS(base) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT))

/*! @brief Set the LOOPS field to a new value. */
#define UART_WR_C1_LOOPS(base, value) (UART_RMW_C1(base, UART_C1_LOOPS_MASK, UART_C1_LOOPS(value)))
#define UART_BWR_C1_LOOPS(base, value) (BITBAND_ACCESS8(&UART_C1_REG(base), UART_C1_LOOPS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C2 - UART Control Register 2
 ******************************************************************************/

/*!
 * @brief UART_C2 - UART Control Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * This register can be read or written at any time.
 */
/*!
 * @name Constants and macros for entire UART_C2 register
 */
/*@{*/
#define UART_RD_C2(base)         (UART_C2_REG(base))
#define UART_WR_C2(base, value)  (UART_C2_REG(base) = (value))
#define UART_RMW_C2(base, mask, value) (UART_WR_C2(base, (UART_RD_C2(base) & ~(mask)) | (value)))
#define UART_SET_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) |  (value)))
#define UART_CLR_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) & ~(value)))
#define UART_TOG_C2(base, value) (UART_WR_C2(base, UART_RD_C2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C2 bitfields
 */

/*!
 * @name Register UART_C2, field SBK[0] (RW)
 *
 * Toggling SBK sends one break character from the following: See Transmitting
 * break characters for the number of logic 0s for the different configurations.
 * Toggling implies clearing the SBK field before the break character has finished
 * transmitting. As long as SBK is set, the transmitter continues to send
 * complete break characters (10, 11, or 12 bits, or 13 or 14 bits). Ensure that C2[TE]
 * is asserted atleast 1 clock before assertion of this bit. 10, 11, or 12 logic
 * 0s if S2[BRK13] is cleared 13 or 14 logic 0s if S2[BRK13] is set. This field
 * must be cleared when C7816[ISO_7816E] is set.
 *
 * Values:
 * - 0 - Normal transmitter operation.
 * - 1 - Queue break characters to be sent.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_SBK field. */
#define UART_RD_C2_SBK(base) ((UART_C2_REG(base) & UART_C2_SBK_MASK) >> UART_C2_SBK_SHIFT)
#define UART_BRD_C2_SBK(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_SBK_SHIFT))

/*! @brief Set the SBK field to a new value. */
#define UART_WR_C2_SBK(base, value) (UART_RMW_C2(base, UART_C2_SBK_MASK, UART_C2_SBK(value)))
#define UART_BWR_C2_SBK(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_SBK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RWU[1] (RW)
 *
 * This field can be set to place the UART receiver in a standby state. RWU
 * automatically clears when an RWU event occurs, that is, an IDLE event when
 * C1[WAKE] is clear or an address match when C1[WAKE] is set. This field must be
 * cleared when C7816[ISO_7816E] is set. RWU must be set only with C1[WAKE] = 0 (wakeup
 * on idle) if the channel is currently not idle. This can be determined by
 * S2[RAF]. If the flag is set to wake up an IDLE event and the channel is already
 * idle, it is possible that the UART will discard data. This is because the data
 * must be received or a LIN break detected after an IDLE is detected before IDLE
 * is allowed to reasserted.
 *
 * Values:
 * - 0 - Normal operation.
 * - 1 - RWU enables the wakeup function and inhibits further receiver interrupt
 *     requests. Normally, hardware wakes the receiver by automatically clearing
 *     RWU.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RWU field. */
#define UART_RD_C2_RWU(base) ((UART_C2_REG(base) & UART_C2_RWU_MASK) >> UART_C2_RWU_SHIFT)
#define UART_BRD_C2_RWU(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RWU_SHIFT))

/*! @brief Set the RWU field to a new value. */
#define UART_WR_C2_RWU(base, value) (UART_RMW_C2(base, UART_C2_RWU_MASK, UART_C2_RWU(value)))
#define UART_BWR_C2_RWU(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RWU_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RE[2] (RW)
 *
 * Enables the UART receiver.
 *
 * Values:
 * - 0 - Receiver off.
 * - 1 - Receiver on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RE field. */
#define UART_RD_C2_RE(base)  ((UART_C2_REG(base) & UART_C2_RE_MASK) >> UART_C2_RE_SHIFT)
#define UART_BRD_C2_RE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RE_SHIFT))

/*! @brief Set the RE field to a new value. */
#define UART_WR_C2_RE(base, value) (UART_RMW_C2(base, UART_C2_RE_MASK, UART_C2_RE(value)))
#define UART_BWR_C2_RE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TE[3] (RW)
 *
 * Enables the UART transmitter. TE can be used to queue an idle preamble by
 * clearing and then setting TE. When C7816[ISO_7816E] is set/enabled and
 * C7816[TTYPE] = 1, this field is automatically cleared after the requested block has been
 * transmitted. This condition is detected when TL7816[TLEN] = 0 and four
 * additional characters are transmitted.
 *
 * Values:
 * - 0 - Transmitter off.
 * - 1 - Transmitter on.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TE field. */
#define UART_RD_C2_TE(base)  ((UART_C2_REG(base) & UART_C2_TE_MASK) >> UART_C2_TE_SHIFT)
#define UART_BRD_C2_TE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TE_SHIFT))

/*! @brief Set the TE field to a new value. */
#define UART_WR_C2_TE(base, value) (UART_RMW_C2(base, UART_C2_TE_MASK, UART_C2_TE(value)))
#define UART_BWR_C2_TE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field ILIE[4] (RW)
 *
 * Enables the idle line flag, S1[IDLE], to generate interrupt requests
 *
 * Values:
 * - 0 - IDLE interrupt requests disabled.
 * - 1 - IDLE interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_ILIE field. */
#define UART_RD_C2_ILIE(base) ((UART_C2_REG(base) & UART_C2_ILIE_MASK) >> UART_C2_ILIE_SHIFT)
#define UART_BRD_C2_ILIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT))

/*! @brief Set the ILIE field to a new value. */
#define UART_WR_C2_ILIE(base, value) (UART_RMW_C2(base, UART_C2_ILIE_MASK, UART_C2_ILIE(value)))
#define UART_BWR_C2_ILIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_ILIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field RIE[5] (RW)
 *
 * Enables S1[RDRF] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[RDMAS].
 *
 * Values:
 * - 0 - RDRF interrupt and DMA transfer requests disabled.
 * - 1 - RDRF interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_RIE field. */
#define UART_RD_C2_RIE(base) ((UART_C2_REG(base) & UART_C2_RIE_MASK) >> UART_C2_RIE_SHIFT)
#define UART_BRD_C2_RIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RIE_SHIFT))

/*! @brief Set the RIE field to a new value. */
#define UART_WR_C2_RIE(base, value) (UART_RMW_C2(base, UART_C2_RIE_MASK, UART_C2_RIE(value)))
#define UART_BWR_C2_RIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_RIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TCIE[6] (RW)
 *
 * Enables the transmission complete flag, S1[TC], to generate interrupt
 * requests .
 *
 * Values:
 * - 0 - TC interrupt requests disabled.
 * - 1 - TC interrupt requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TCIE field. */
#define UART_RD_C2_TCIE(base) ((UART_C2_REG(base) & UART_C2_TCIE_MASK) >> UART_C2_TCIE_SHIFT)
#define UART_BRD_C2_TCIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT))

/*! @brief Set the TCIE field to a new value. */
#define UART_WR_C2_TCIE(base, value) (UART_RMW_C2(base, UART_C2_TCIE_MASK, UART_C2_TCIE(value)))
#define UART_BWR_C2_TCIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TCIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C2, field TIE[7] (RW)
 *
 * Enables S1[TDRE] to generate interrupt requests or DMA transfer requests,
 * based on the state of C5[TDMAS]. If C2[TIE] and C5[TDMAS] are both set, then TCIE
 * must be cleared, and D[D] must not be written unless servicing a DMA request.
 *
 * Values:
 * - 0 - TDRE interrupt and DMA transfer requests disabled.
 * - 1 - TDRE interrupt or DMA transfer requests enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C2_TIE field. */
#define UART_RD_C2_TIE(base) ((UART_C2_REG(base) & UART_C2_TIE_MASK) >> UART_C2_TIE_SHIFT)
#define UART_BRD_C2_TIE(base) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TIE_SHIFT))

/*! @brief Set the TIE field to a new value. */
#define UART_WR_C2_TIE(base, value) (UART_RMW_C2(base, UART_C2_TIE_MASK, UART_C2_TIE(value)))
#define UART_BWR_C2_TIE(base, value) (BITBAND_ACCESS8(&UART_C2_REG(base), UART_C2_TIE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_S1 - UART Status Register 1
 ******************************************************************************/

/*!
 * @brief UART_S1 - UART Status Register 1 (RO)
 *
 * Reset value: 0xC0U
 *
 * The S1 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. This register can also be polled by the MCU to check the
 * status of its fields. To clear a flag, the status register should be read followed
 * by a read or write to D register, depending on the interrupt flag type. Other
 * instructions can be executed between the two steps as long the handling of
 * I/O is not compromised, but the order of operations is important for flag
 * clearing. When a flag is configured to trigger a DMA request, assertion of the
 * associated DMA done signal from the DMA controller clears the flag. If the
 * condition that results in the assertion of the flag, interrupt, or DMA request is not
 * resolved prior to clearing the flag, the flag, and interrupt/DMA request,
 * reasserts. For example, if the DMA or interrupt service routine fails to write
 * sufficient data to the transmit buffer to raise it above the watermark level, the
 * flag reasserts and generates another interrupt or DMA request. Reading an
 * empty data register to clear one of the flags of the S1 register causes the FIFO
 * pointers to become misaligned. A receive FIFO flush reinitializes the
 * pointers. A better way to prevent this situation is to always leave one byte in FIFO
 * and this byte will be read eventually in clearing the flag bit.
 */
/*!
 * @name Constants and macros for entire UART_S1 register
 */
/*@{*/
#define UART_RD_S1(base)         (UART_S1_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_S1 bitfields
 */

/*!
 * @name Register UART_S1, field PF[0] (RO)
 *
 * PF is set when PE is set and the parity of the received data does not match
 * its parity bit. The PF is not set in the case of an overrun condition. When PF
 * is set, it indicates only that a dataword was received with parity error since
 * the last time it was cleared. There is no guarantee that the first dataword
 * read from the receive buffer has a parity error or that there is only one
 * dataword in the buffer that was received with a parity error, unless the receive
 * buffer has a depth of one. To clear PF, read S1 and then read D., S2[LBKDE] is
 * disabled, Within the receive buffer structure the received dataword is tagged
 * if it is received with a parity error. This information is available by reading
 * the ED register prior to reading the D register.
 *
 * Values:
 * - 0 - No parity error detected since the last time this flag was cleared. If
 *     the receive buffer has a depth greater than 1, then there may be data in
 *     the receive buffer what was received with a parity error.
 * - 1 - At least one dataword was received with a parity error since the last
 *     time this flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_PF field. */
#define UART_RD_S1_PF(base)  ((UART_S1_REG(base) & UART_S1_PF_MASK) >> UART_S1_PF_SHIFT)
#define UART_BRD_S1_PF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_PF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field FE[1] (RO)
 *
 * FE is set when a logic 0 is accepted as the stop bit. When BDH[SBNS] is set,
 * then FE will set when a logic 0 is accepted for either of the two stop bits.
 * FE does not set in the case of an overrun or while the LIN break detect feature
 * is enabled (S2[LBKDE] = 1). FE inhibits further data reception until it is
 * cleared. To clear FE, read S1 with FE set and then read D. The last data in the
 * receive buffer represents the data that was received with the frame error
 * enabled. Framing errors are not supported when 7816E is set/enabled. However, if
 * this flag is set, data is still not received in 7816 mode.
 *
 * Values:
 * - 0 - No framing error detected.
 * - 1 - Framing error.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_FE field. */
#define UART_RD_S1_FE(base)  ((UART_S1_REG(base) & UART_S1_FE_MASK) >> UART_S1_FE_SHIFT)
#define UART_BRD_S1_FE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_FE_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field NF[2] (RO)
 *
 * NF is set when the UART detects noise on the receiver input. NF does not
 * become set in the case of an overrun or while the LIN break detect feature is
 * enabled (S2[LBKDE] = 1). When NF is set, it indicates only that a dataword has
 * been received with noise since the last time it was cleared. There is no
 * guarantee that the first dataword read from the receive buffer has noise or that there
 * is only one dataword in the buffer that was received with noise unless the
 * receive buffer has a depth of one. To clear NF, read S1 and then read D.
 *
 * Values:
 * - 0 - No noise detected since the last time this flag was cleared. If the
 *     receive buffer has a depth greater than 1 then there may be data in the
 *     receiver buffer that was received with noise.
 * - 1 - At least one dataword was received with noise detected since the last
 *     time the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_NF field. */
#define UART_RD_S1_NF(base)  ((UART_S1_REG(base) & UART_S1_NF_MASK) >> UART_S1_NF_SHIFT)
#define UART_BRD_S1_NF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_NF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field OR[3] (RO)
 *
 * OR is set when software fails to prevent the receive data register from
 * overflowing with data. The OR bit is set immediately after the stop bit has been
 * completely received for the dataword that overflows the buffer and all the other
 * error flags (FE, NF, and PF) are prevented from setting. The data in the
 * shift register is lost, but the data already in the UART data registers is not
 * affected. If the OR flag is set, no data is stored in the data buffer even if
 * sufficient room exists. Additionally, while the OR flag is set, the RDRF and IDLE
 * flags are blocked from asserting, that is, transition from an inactive to an
 * active state. To clear OR, read S1 when OR is set and then read D. See
 * functional description for more details regarding the operation of the OR bit.If
 * LBKDE is enabled and a LIN Break is detected, the OR field asserts if S2[LBKDIF]
 * is not cleared before the next data character is received. In 7816 mode, it is
 * possible to configure a NACK to be returned by programing C7816[ONACK].
 *
 * Values:
 * - 0 - No overrun has occurred since the last time the flag was cleared.
 * - 1 - Overrun has occurred or the overrun flag has not been cleared since the
 *     last overrun occured.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_OR field. */
#define UART_RD_S1_OR(base)  ((UART_S1_REG(base) & UART_S1_OR_MASK) >> UART_S1_OR_SHIFT)
#define UART_BRD_S1_OR(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_OR_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field IDLE[4] (RO)
 *
 * After the IDLE flag is cleared, a frame must be received (although not
 * necessarily stored in the data buffer, for example if C2[RWU] is set), or a LIN
 * break character must set the S2[LBKDIF] flag before an idle condition can set the
 * IDLE flag. To clear IDLE, read UART status S1 with IDLE set and then read D.
 * IDLE is set when either of the following appear on the receiver input: 10
 * consecutive logic 1s if C1[M] = 0 11 consecutive logic 1s if C1[M] = 1 and C4[M10]
 * = 0 12 consecutive logic 1s if C1[M] = 1, C4[M10] = 1, and C1[PE] = 1 Idle
 * detection is not supported when 7816E is set/enabled and hence this flag is
 * ignored. When RWU is set and WAKE is cleared, an idle line condition sets the IDLE
 * flag if RWUID is set, else the IDLE flag does not become set.
 *
 * Values:
 * - 0 - Receiver input is either active now or has never become active since
 *     the IDLE flag was last cleared.
 * - 1 - Receiver input has become idle or the flag has not been cleared since
 *     it last asserted.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_IDLE field. */
#define UART_RD_S1_IDLE(base) ((UART_S1_REG(base) & UART_S1_IDLE_MASK) >> UART_S1_IDLE_SHIFT)
#define UART_BRD_S1_IDLE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_IDLE_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field RDRF[5] (RO)
 *
 * RDRF is set when the number of datawords in the receive buffer is equal to or
 * more than the number indicated by RWFIFO[RXWATER]. A dataword that is in the
 * process of being received is not included in the count. To clear RDRF, read S1
 * when RDRF is set and then read D. For more efficient interrupt and DMA
 * operation, read all data except the final value from the buffer, using D/C3[T8]/ED.
 * Then read S1 and the final data value, resulting in the clearing of the RDRF
 * flag. Even if RDRF is set, data will continue to be received until an overrun
 * condition occurs.RDRF is prevented from setting while S2[LBKDE] is set.
 * Additionally, when S2[LBKDE] is set, the received datawords are stored in the receive
 * buffer but over-write each other.
 *
 * Values:
 * - 0 - The number of datawords in the receive buffer is less than the number
 *     indicated by RXWATER.
 * - 1 - The number of datawords in the receive buffer is equal to or greater
 *     than the number indicated by RXWATER at some point in time since this flag
 *     was last cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_RDRF field. */
#define UART_RD_S1_RDRF(base) ((UART_S1_REG(base) & UART_S1_RDRF_MASK) >> UART_S1_RDRF_SHIFT)
#define UART_BRD_S1_RDRF(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_RDRF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field TC[6] (RO)
 *
 * TC is set when the transmit buffer is empty and no data, preamble, or break
 * character is being transmitted. When TC is set, the transmit data output signal
 * becomes idle (logic 1). TC is cleared by reading S1 with TC set and then
 * doing one of the following: When C7816[ISO_7816E] is set/enabled, this field is
 * set after any NACK signal has been received, but prior to any corresponding
 * guard times expiring. Writing to D to transmit new data. Queuing a preamble by
 * clearing and then setting C2[TE]. Queuing a break character by writing 1 to SBK
 * in C2.
 *
 * Values:
 * - 0 - Transmitter active (sending data, a preamble, or a break).
 * - 1 - Transmitter idle (transmission activity complete).
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TC field. */
#define UART_RD_S1_TC(base)  ((UART_S1_REG(base) & UART_S1_TC_MASK) >> UART_S1_TC_SHIFT)
#define UART_BRD_S1_TC(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_TC_SHIFT))
/*@}*/

/*!
 * @name Register UART_S1, field TDRE[7] (RO)
 *
 * TDRE will set when the number of datawords in the transmit buffer (D and
 * C3[T8])is equal to or less than the number indicated by TWFIFO[TXWATER]. A
 * character that is in the process of being transmitted is not included in the count.
 * To clear TDRE, read S1 when TDRE is set and then write to the UART data
 * register (D). For more efficient interrupt servicing, all data except the final value
 * to be written to the buffer must be written to D/C3[T8]. Then S1 can be read
 * before writing the final data value, resulting in the clearing of the TRDE
 * flag. This is more efficient because the TDRE reasserts until the watermark has
 * been exceeded. So, attempting to clear the TDRE with every write will be
 * ineffective until sufficient data has been written.
 *
 * Values:
 * - 0 - The amount of data in the transmit buffer is greater than the value
 *     indicated by TWFIFO[TXWATER].
 * - 1 - The amount of data in the transmit buffer is less than or equal to the
 *     value indicated by TWFIFO[TXWATER] at some point in time since the flag
 *     has been cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_S1_TDRE field. */
#define UART_RD_S1_TDRE(base) ((UART_S1_REG(base) & UART_S1_TDRE_MASK) >> UART_S1_TDRE_SHIFT)
#define UART_BRD_S1_TDRE(base) (BITBAND_ACCESS8(&UART_S1_REG(base), UART_S1_TDRE_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_S2 - UART Status Register 2
 ******************************************************************************/

/*!
 * @brief UART_S2 - UART Status Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * The S2 register provides inputs to the MCU for generation of UART interrupts
 * or DMA requests. Also, this register can be polled by the MCU to check the
 * status of these bits. This register can be read or written at any time, with the
 * exception of the MSBF and RXINV bits, which should be changed by the user only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_S2 register
 */
/*@{*/
#define UART_RD_S2(base)         (UART_S2_REG(base))
#define UART_WR_S2(base, value)  (UART_S2_REG(base) = (value))
#define UART_RMW_S2(base, mask, value) (UART_WR_S2(base, (UART_RD_S2(base) & ~(mask)) | (value)))
#define UART_SET_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) |  (value)))
#define UART_CLR_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) & ~(value)))
#define UART_TOG_S2(base, value) (UART_WR_S2(base, UART_RD_S2(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_S2 bitfields
 */

/*!
 * @name Register UART_S2, field RAF[0] (RO)
 *
 * RAF is set when the UART receiver detects a logic 0 during the RT1 time
 * period of the start bit search. RAF is cleared when the receiver detects an idle
 * character when C7816[ISO7816E] is cleared/disabled. When C7816[ISO7816E] is
 * enabled, the RAF is cleared if the C7816[TTYPE] = 0 expires or the C7816[TTYPE] =
 * 1 expires.In case C7816[ISO7816E] is set and C7816[TTYPE] = 0, it is possible
 * to configure the guard time to 12. However, if a NACK is required to be
 * transmitted, the data transfer actually takes 13 ETU with the 13th ETU slot being a
 * inactive buffer. Therefore, in this situation, the RAF may deassert one ETU
 * prior to actually being inactive.
 *
 * Values:
 * - 0 - UART receiver idle/inactive waiting for a start bit.
 * - 1 - UART receiver active, RxD input not idle.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RAF field. */
#define UART_RD_S2_RAF(base) ((UART_S2_REG(base) & UART_S2_RAF_MASK) >> UART_S2_RAF_SHIFT)
#define UART_BRD_S2_RAF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RAF_SHIFT))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDE[1] (RW)
 *
 * Enables the LIN Break detection feature. While LBKDE is set, S1[RDRF],
 * S1[NF], S1[FE], and S1[PF] are prevented from setting. When LBKDE is set, see .
 * Overrun operation LBKDE must be cleared when C7816[ISO7816E] is set.
 *
 * Values:
 * - 0 - Break character detection is disabled.
 * - 1 - Break character is detected at length of 11 bit times if C1[M] = 0 or
 *     12 bits time if C1[M] = 1.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDE field. */
#define UART_RD_S2_LBKDE(base) ((UART_S2_REG(base) & UART_S2_LBKDE_MASK) >> UART_S2_LBKDE_SHIFT)
#define UART_BRD_S2_LBKDE(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT))

/*! @brief Set the LBKDE field to a new value. */
#define UART_WR_S2_LBKDE(base, value) (UART_RMW_S2(base, (UART_S2_LBKDE_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_LBKDE(value)))
#define UART_BWR_S2_LBKDE(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field BRK13[2] (RW)
 *
 * Determines whether the transmit break character is 10, 11, or 12 bits long,
 * or 13 or 14 bits long. See for the length of the break character for the
 * different configurations. The detection of a framing error is not affected by this
 * field. Transmitting break characters
 *
 * Values:
 * - 0 - Break character is 10, 11, or 12 bits long.
 * - 1 - Break character is 13 or 14 bits long.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_BRK13 field. */
#define UART_RD_S2_BRK13(base) ((UART_S2_REG(base) & UART_S2_BRK13_MASK) >> UART_S2_BRK13_SHIFT)
#define UART_BRD_S2_BRK13(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT))

/*! @brief Set the BRK13 field to a new value. */
#define UART_WR_S2_BRK13(base, value) (UART_RMW_S2(base, (UART_S2_BRK13_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_BRK13(value)))
#define UART_BWR_S2_BRK13(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_BRK13_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RWUID[3] (RW)
 *
 * When RWU is set and WAKE is cleared, this field controls whether the idle
 * character that wakes the receiver sets S1[IDLE]. This field must be cleared when
 * C7816[ISO7816E] is set/enabled.
 *
 * Values:
 * - 0 - S1[IDLE] is not set upon detection of an idle character.
 * - 1 - S1[IDLE] is set upon detection of an idle character.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RWUID field. */
#define UART_RD_S2_RWUID(base) ((UART_S2_REG(base) & UART_S2_RWUID_MASK) >> UART_S2_RWUID_SHIFT)
#define UART_BRD_S2_RWUID(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT))

/*! @brief Set the RWUID field to a new value. */
#define UART_WR_S2_RWUID(base, value) (UART_RMW_S2(base, (UART_S2_RWUID_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RWUID(value)))
#define UART_BWR_S2_RWUID(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RWUID_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the received data input. In NRZ
 * format, a one is represented by a mark and a zero is represented by a space for
 * normal polarity, and the opposite for inverted polarity. In IrDA format, a
 * zero is represented by short high pulse in the middle of a bit time remaining
 * idle low for a one for normal polarity. A zero is represented by a short low
 * pulse in the middle of a bit time remaining idle high for a one for inverted
 * polarity. This field is automatically set when C7816[INIT] and C7816[ISO7816E] are
 * enabled and an initial character is detected in T = 0 protocol mode. Setting
 * RXINV inverts the RxD input for data bits, start and stop bits, break, and
 * idle. When C7816[ISO7816E] is set/enabled, only the data bits and the parity bit
 * are inverted.
 *
 * Values:
 * - 0 - Receive data is not inverted.
 * - 1 - Receive data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXINV field. */
#define UART_RD_S2_RXINV(base) ((UART_S2_REG(base) & UART_S2_RXINV_MASK) >> UART_S2_RXINV_SHIFT)
#define UART_BRD_S2_RXINV(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT))

/*! @brief Set the RXINV field to a new value. */
#define UART_WR_S2_RXINV(base, value) (UART_RMW_S2(base, (UART_S2_RXINV_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXINV(value)))
#define UART_BWR_S2_RXINV(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field MSBF[5] (RW)
 *
 * Setting this field reverses the order of the bits that are transmitted and
 * received on the wire. This field does not affect the polarity of the bits, the
 * location of the parity bit, or the location of the start or stop bits. This
 * field is automatically set when C7816[INIT] and C7816[ISO7816E] are enabled and
 * an initial character is detected in T = 0 protocol mode.
 *
 * Values:
 * - 0 - LSB (bit0) is the first bit that is transmitted following the start
 *     bit. Further, the first bit received after the start bit is identified as
 *     bit0.
 * - 1 - MSB (bit8, bit7 or bit6) is the first bit that is transmitted following
 *     the start bit, depending on the setting of C1[M] and C1[PE]. Further, the
 *     first bit received after the start bit is identified as bit8, bit7, or
 *     bit6, depending on the setting of C1[M] and C1[PE].
 */
/*@{*/
/*! @brief Read current value of the UART_S2_MSBF field. */
#define UART_RD_S2_MSBF(base) ((UART_S2_REG(base) & UART_S2_MSBF_MASK) >> UART_S2_MSBF_SHIFT)
#define UART_BRD_S2_MSBF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT))

/*! @brief Set the MSBF field to a new value. */
#define UART_WR_S2_MSBF(base, value) (UART_RMW_S2(base, (UART_S2_MSBF_MASK | UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_MSBF(value)))
#define UART_BWR_S2_MSBF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_MSBF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field RXEDGIF[6] (W1C)
 *
 * RXEDGIF is set when an active edge occurs on the RxD pin. The active edge is
 * falling if RXINV = 0, and rising if RXINV=1. RXEDGIF is cleared by writing a 1
 * to it. See for additional details. RXEDGIF description The active edge is
 * detected only in two wire mode and on receiving data coming from the RxD pin.
 *
 * Values:
 * - 0 - No active edge on the receive pin has occurred.
 * - 1 - An active edge on the receive pin has occurred.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_RXEDGIF field. */
#define UART_RD_S2_RXEDGIF(base) ((UART_S2_REG(base) & UART_S2_RXEDGIF_MASK) >> UART_S2_RXEDGIF_SHIFT)
#define UART_BRD_S2_RXEDGIF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT))

/*! @brief Set the RXEDGIF field to a new value. */
#define UART_WR_S2_RXEDGIF(base, value) (UART_RMW_S2(base, (UART_S2_RXEDGIF_MASK | UART_S2_LBKDIF_MASK), UART_S2_RXEDGIF(value)))
#define UART_BWR_S2_RXEDGIF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_RXEDGIF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_S2, field LBKDIF[7] (W1C)
 *
 * LBKDIF is set when LBKDE is set and a LIN break character is detected on the
 * receiver input. The LIN break characters are 11 consecutive logic 0s if C1[M]
 * = 0 or 12 consecutive logic 0s if C1[M] = 1. LBKDIF is set after receiving the
 * last LIN break character. LBKDIF is cleared by writing a 1 to it.
 *
 * Values:
 * - 0 - No LIN break character detected.
 * - 1 - LIN break character detected.
 */
/*@{*/
/*! @brief Read current value of the UART_S2_LBKDIF field. */
#define UART_RD_S2_LBKDIF(base) ((UART_S2_REG(base) & UART_S2_LBKDIF_MASK) >> UART_S2_LBKDIF_SHIFT)
#define UART_BRD_S2_LBKDIF(base) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT))

/*! @brief Set the LBKDIF field to a new value. */
#define UART_WR_S2_LBKDIF(base, value) (UART_RMW_S2(base, (UART_S2_LBKDIF_MASK | UART_S2_RXEDGIF_MASK), UART_S2_LBKDIF(value)))
#define UART_BWR_S2_LBKDIF(base, value) (BITBAND_ACCESS8(&UART_S2_REG(base), UART_S2_LBKDIF_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C3 - UART Control Register 3
 ******************************************************************************/

/*!
 * @brief UART_C3 - UART Control Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Writing R8 does not have any effect. TXDIR and TXINV can be changed only
 * between transmit and receive packets.
 */
/*!
 * @name Constants and macros for entire UART_C3 register
 */
/*@{*/
#define UART_RD_C3(base)         (UART_C3_REG(base))
#define UART_WR_C3(base, value)  (UART_C3_REG(base) = (value))
#define UART_RMW_C3(base, mask, value) (UART_WR_C3(base, (UART_RD_C3(base) & ~(mask)) | (value)))
#define UART_SET_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) |  (value)))
#define UART_CLR_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) & ~(value)))
#define UART_TOG_C3(base, value) (UART_WR_C3(base, UART_RD_C3(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C3 bitfields
 */

/*!
 * @name Register UART_C3, field PEIE[0] (RW)
 *
 * Enables the parity error flag, S1[PF], to generate interrupt requests.
 *
 * Values:
 * - 0 - PF interrupt requests are disabled.
 * - 1 - PF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_PEIE field. */
#define UART_RD_C3_PEIE(base) ((UART_C3_REG(base) & UART_C3_PEIE_MASK) >> UART_C3_PEIE_SHIFT)
#define UART_BRD_C3_PEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT))

/*! @brief Set the PEIE field to a new value. */
#define UART_WR_C3_PEIE(base, value) (UART_RMW_C3(base, UART_C3_PEIE_MASK, UART_C3_PEIE(value)))
#define UART_BWR_C3_PEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_PEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field FEIE[1] (RW)
 *
 * Enables the framing error flag, S1[FE], to generate interrupt requests.
 *
 * Values:
 * - 0 - FE interrupt requests are disabled.
 * - 1 - FE interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_FEIE field. */
#define UART_RD_C3_FEIE(base) ((UART_C3_REG(base) & UART_C3_FEIE_MASK) >> UART_C3_FEIE_SHIFT)
#define UART_BRD_C3_FEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT))

/*! @brief Set the FEIE field to a new value. */
#define UART_WR_C3_FEIE(base, value) (UART_RMW_C3(base, UART_C3_FEIE_MASK, UART_C3_FEIE(value)))
#define UART_BWR_C3_FEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_FEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field NEIE[2] (RW)
 *
 * Enables the noise flag, S1[NF], to generate interrupt requests.
 *
 * Values:
 * - 0 - NF interrupt requests are disabled.
 * - 1 - NF interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_NEIE field. */
#define UART_RD_C3_NEIE(base) ((UART_C3_REG(base) & UART_C3_NEIE_MASK) >> UART_C3_NEIE_SHIFT)
#define UART_BRD_C3_NEIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT))

/*! @brief Set the NEIE field to a new value. */
#define UART_WR_C3_NEIE(base, value) (UART_RMW_C3(base, UART_C3_NEIE_MASK, UART_C3_NEIE(value)))
#define UART_BWR_C3_NEIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_NEIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field ORIE[3] (RW)
 *
 * Enables the overrun error flag, S1[OR], to generate interrupt requests.
 *
 * Values:
 * - 0 - OR interrupts are disabled.
 * - 1 - OR interrupt requests are enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_ORIE field. */
#define UART_RD_C3_ORIE(base) ((UART_C3_REG(base) & UART_C3_ORIE_MASK) >> UART_C3_ORIE_SHIFT)
#define UART_BRD_C3_ORIE(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT))

/*! @brief Set the ORIE field to a new value. */
#define UART_WR_C3_ORIE(base, value) (UART_RMW_C3(base, UART_C3_ORIE_MASK, UART_C3_ORIE(value)))
#define UART_BWR_C3_ORIE(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_ORIE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field TXINV[4] (RW)
 *
 * Setting this field reverses the polarity of the transmitted data output. In
 * NRZ format, a one is represented by a mark and a zero is represented by a space
 * for normal polarity, and the opposite for inverted polarity. In IrDA format,
 * a zero is represented by short high pulse in the middle of a bit time
 * remaining idle low for a one for normal polarity, and a zero is represented by short
 * low pulse in the middle of a bit time remaining idle high for a one for
 * inverted polarity. This field is automatically set when C7816[INIT] and
 * C7816[ISO7816E] are enabled and an initial character is detected in T = 0 protocol mode.
 * Setting TXINV inverts all transmitted values, including idle, break, start, and
 * stop bits. In loop mode, if TXINV is set, the receiver gets the transmit
 * inversion bit when RXINV is disabled. When C7816[ISO7816E] is set/enabled then only
 * the transmitted data bits and parity bit are inverted.
 *
 * Values:
 * - 0 - Transmit data is not inverted.
 * - 1 - Transmit data is inverted.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXINV field. */
#define UART_RD_C3_TXINV(base) ((UART_C3_REG(base) & UART_C3_TXINV_MASK) >> UART_C3_TXINV_SHIFT)
#define UART_BRD_C3_TXINV(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT))

/*! @brief Set the TXINV field to a new value. */
#define UART_WR_C3_TXINV(base, value) (UART_RMW_C3(base, UART_C3_TXINV_MASK, UART_C3_TXINV(value)))
#define UART_BWR_C3_TXINV(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXINV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field TXDIR[5] (RW)
 *
 * Determines whether the TXD pin is used as an input or output in the
 * single-wire mode of operation. This field is relevant only to the single wire mode.
 * When C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 1, this field is
 * automatically cleared after the requested block is transmitted. This condition is
 * detected when TL7816[TLEN] = 0 and 4 additional characters are transmitted.
 * Additionally, if C7816[ISO7816E] is set/enabled and C7816[TTYPE] = 0 and a NACK is
 * being transmitted, the hardware automatically overrides this field as needed. In
 * this situation, TXDIR does not reflect the temporary state associated with
 * the NACK.
 *
 * Values:
 * - 0 - TXD pin is an input in single wire mode.
 * - 1 - TXD pin is an output in single wire mode.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_TXDIR field. */
#define UART_RD_C3_TXDIR(base) ((UART_C3_REG(base) & UART_C3_TXDIR_MASK) >> UART_C3_TXDIR_SHIFT)
#define UART_BRD_C3_TXDIR(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT))

/*! @brief Set the TXDIR field to a new value. */
#define UART_WR_C3_TXDIR(base, value) (UART_RMW_C3(base, UART_C3_TXDIR_MASK, UART_C3_TXDIR(value)))
#define UART_BWR_C3_TXDIR(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_TXDIR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field T8[6] (RW)
 *
 * T8 is the ninth data bit transmitted when the UART is configured for 9-bit
 * data format, that is, if C1[M] = 1 or C4[M10] = 1. If the value of T8 is the
 * same as in the previous transmission, T8 does not have to be rewritten. The same
 * value is transmitted until T8 is rewritten. To correctly transmit the 9th bit,
 * write UARTx_C3[T8] to the desired value, then write the UARTx_D register with
 * the remaining data.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_T8 field. */
#define UART_RD_C3_T8(base)  ((UART_C3_REG(base) & UART_C3_T8_MASK) >> UART_C3_T8_SHIFT)
#define UART_BRD_C3_T8(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_T8_SHIFT))

/*! @brief Set the T8 field to a new value. */
#define UART_WR_C3_T8(base, value) (UART_RMW_C3(base, UART_C3_T8_MASK, UART_C3_T8(value)))
#define UART_BWR_C3_T8(base, value) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_T8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C3, field R8[7] (RO)
 *
 * R8 is the ninth data bit received when the UART is configured for 9-bit data
 * format, that is, if C1[M] = 1 or C4[M10] = 1. The R8 value corresponds to the
 * current data value in the UARTx_D register. To read the 9th bit, read the
 * value of UARTx_C3[R8], then read the UARTx_D register.
 */
/*@{*/
/*! @brief Read current value of the UART_C3_R8 field. */
#define UART_RD_C3_R8(base)  ((UART_C3_REG(base) & UART_C3_R8_MASK) >> UART_C3_R8_SHIFT)
#define UART_BRD_C3_R8(base) (BITBAND_ACCESS8(&UART_C3_REG(base), UART_C3_R8_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_D - UART Data Register
 ******************************************************************************/

/*!
 * @brief UART_D - UART Data Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register is actually two separate registers. Reads return the contents
 * of the read-only receive data register and writes go to the write-only transmit
 * data register. In 8-bit or 9-bit data format, only UART data register (D)
 * needs to be accessed to clear the S1[RDRF] bit (assuming receiver buffer level is
 * less than RWFIFO[RXWATER]). The C3 register needs to be read, prior to the D
 * register, only if the ninth bit of data needs to be captured. Similarly, the
 * ED register needs to be read, prior to the D register, only if the additional
 * flag data for the dataword needs to be captured. In the normal 8-bit mode (M
 * bit cleared) if the parity is enabled, you get seven data bits and one parity
 * bit. That one parity bit is loaded into the D register. So, for the data bits,
 * mask off the parity bit from the value you read out of this register. When
 * transmitting in 9-bit data format and using 8-bit write instructions, write first
 * to transmit bit 8 in UART control register 3 (C3[T8]), then D. A write to
 * C3[T8] stores the data in a temporary register. If D register is written first,
 * and then the new data on data bus is stored in D, the temporary value written by
 * the last write to C3[T8] gets stored in the C3[T8] register.
 */
/*!
 * @name Constants and macros for entire UART_D register
 */
/*@{*/
#define UART_RD_D(base)          (UART_D_REG(base))
#define UART_WR_D(base, value)   (UART_D_REG(base) = (value))
#define UART_RMW_D(base, mask, value) (UART_WR_D(base, (UART_RD_D(base) & ~(mask)) | (value)))
#define UART_SET_D(base, value)  (UART_WR_D(base, UART_RD_D(base) |  (value)))
#define UART_CLR_D(base, value)  (UART_WR_D(base, UART_RD_D(base) & ~(value)))
#define UART_TOG_D(base, value)  (UART_WR_D(base, UART_RD_D(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_MA1 - UART Match Address Registers 1
 ******************************************************************************/

/*!
 * @brief UART_MA1 - UART Match Address Registers 1 (RW)
 *
 * Reset value: 0x00U
 *
 * The MA1 and MA2 registers are compared to input data addresses when the most
 * significant bit is set and the associated C4[MAEN] field is set. If a match
 * occurs, the following data is transferred to the data register. If a match
 * fails, the following data is discarded. These registers can be read and written at
 * anytime.
 */
/*!
 * @name Constants and macros for entire UART_MA1 register
 */
/*@{*/
#define UART_RD_MA1(base)        (UART_MA1_REG(base))
#define UART_WR_MA1(base, value) (UART_MA1_REG(base) = (value))
#define UART_RMW_MA1(base, mask, value) (UART_WR_MA1(base, (UART_RD_MA1(base) & ~(mask)) | (value)))
#define UART_SET_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) |  (value)))
#define UART_CLR_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) & ~(value)))
#define UART_TOG_MA1(base, value) (UART_WR_MA1(base, UART_RD_MA1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_MA2 - UART Match Address Registers 2
 ******************************************************************************/

/*!
 * @brief UART_MA2 - UART Match Address Registers 2 (RW)
 *
 * Reset value: 0x00U
 *
 * These registers can be read and written at anytime. The MA1 and MA2 registers
 * are compared to input data addresses when the most significant bit is set and
 * the associated C4[MAEN] field is set. If a match occurs, the following data
 * is transferred to the data register. If a match fails, the following data is
 * discarded.
 */
/*!
 * @name Constants and macros for entire UART_MA2 register
 */
/*@{*/
#define UART_RD_MA2(base)        (UART_MA2_REG(base))
#define UART_WR_MA2(base, value) (UART_MA2_REG(base) = (value))
#define UART_RMW_MA2(base, mask, value) (UART_WR_MA2(base, (UART_RD_MA2(base) & ~(mask)) | (value)))
#define UART_SET_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) |  (value)))
#define UART_CLR_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) & ~(value)))
#define UART_TOG_MA2(base, value) (UART_WR_MA2(base, UART_RD_MA2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_C4 - UART Control Register 4
 ******************************************************************************/

/*!
 * @brief UART_C4 - UART Control Register 4 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C4 register
 */
/*@{*/
#define UART_RD_C4(base)         (UART_C4_REG(base))
#define UART_WR_C4(base, value)  (UART_C4_REG(base) = (value))
#define UART_RMW_C4(base, mask, value) (UART_WR_C4(base, (UART_RD_C4(base) & ~(mask)) | (value)))
#define UART_SET_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) |  (value)))
#define UART_CLR_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) & ~(value)))
#define UART_TOG_C4(base, value) (UART_WR_C4(base, UART_RD_C4(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C4 bitfields
 */

/*!
 * @name Register UART_C4, field BRFA[4:0] (RW)
 *
 * This bit field is used to add more timing resolution to the average baud
 * frequency, in increments of 1/32. See Baud rate generation for more information.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_BRFA field. */
#define UART_RD_C4_BRFA(base) ((UART_C4_REG(base) & UART_C4_BRFA_MASK) >> UART_C4_BRFA_SHIFT)
#define UART_BRD_C4_BRFA(base) (UART_RD_C4_BRFA(base))

/*! @brief Set the BRFA field to a new value. */
#define UART_WR_C4_BRFA(base, value) (UART_RMW_C4(base, UART_C4_BRFA_MASK, UART_C4_BRFA(value)))
#define UART_BWR_C4_BRFA(base, value) (UART_WR_C4_BRFA(base, value))
/*@}*/

/*!
 * @name Register UART_C4, field M10[5] (RW)
 *
 * Causes a tenth, non-memory mapped bit to be part of the serial transmission.
 * This tenth bit is generated and interpreted as a parity bit. The M10 field
 * does not affect the LIN send or detect break behavior. If M10 is set, then both
 * C1[M] and C1[PE] must also be set. This field must be cleared when
 * C7816[ISO7816E] is set/enabled. See Data format (non ISO-7816) for more information.
 *
 * Values:
 * - 0 - The parity bit is the ninth bit in the serial transmission.
 * - 1 - The parity bit is the tenth bit in the serial transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_M10 field. */
#define UART_RD_C4_M10(base) ((UART_C4_REG(base) & UART_C4_M10_MASK) >> UART_C4_M10_SHIFT)
#define UART_BRD_C4_M10(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_M10_SHIFT))

/*! @brief Set the M10 field to a new value. */
#define UART_WR_C4_M10(base, value) (UART_RMW_C4(base, UART_C4_M10_MASK, UART_C4_M10(value)))
#define UART_BWR_C4_M10(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_M10_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN2[6] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN1 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA2 register. If no match occurs, the data is discarded. If a
 *     match occurs, data is transferred to the data buffer. This field must be
 *     cleared when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN2 field. */
#define UART_RD_C4_MAEN2(base) ((UART_C4_REG(base) & UART_C4_MAEN2_MASK) >> UART_C4_MAEN2_SHIFT)
#define UART_BRD_C4_MAEN2(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT))

/*! @brief Set the MAEN2 field to a new value. */
#define UART_WR_C4_MAEN2(base, value) (UART_RMW_C4(base, UART_C4_MAEN2_MASK, UART_C4_MAEN2(value)))
#define UART_BWR_C4_MAEN2(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN2_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C4, field MAEN1[7] (RW)
 *
 * See Match address operation for more information.
 *
 * Values:
 * - 0 - All data received is transferred to the data buffer if MAEN2 is cleared.
 * - 1 - All data received with the most significant bit cleared, is discarded.
 *     All data received with the most significant bit set, is compared with
 *     contents of MA1 register. If no match occurs, the data is discarded. If match
 *     occurs, data is transferred to the data buffer. This field must be cleared
 *     when C7816[ISO7816E] is set/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C4_MAEN1 field. */
#define UART_RD_C4_MAEN1(base) ((UART_C4_REG(base) & UART_C4_MAEN1_MASK) >> UART_C4_MAEN1_SHIFT)
#define UART_BRD_C4_MAEN1(base) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT))

/*! @brief Set the MAEN1 field to a new value. */
#define UART_WR_C4_MAEN1(base, value) (UART_RMW_C4(base, UART_C4_MAEN1_MASK, UART_C4_MAEN1(value)))
#define UART_BWR_C4_MAEN1(base, value) (BITBAND_ACCESS8(&UART_C4_REG(base), UART_C4_MAEN1_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_C5 - UART Control Register 5
 ******************************************************************************/

/*!
 * @brief UART_C5 - UART Control Register 5 (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire UART_C5 register
 */
/*@{*/
#define UART_RD_C5(base)         (UART_C5_REG(base))
#define UART_WR_C5(base, value)  (UART_C5_REG(base) = (value))
#define UART_RMW_C5(base, mask, value) (UART_WR_C5(base, (UART_RD_C5(base) & ~(mask)) | (value)))
#define UART_SET_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) |  (value)))
#define UART_CLR_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) & ~(value)))
#define UART_TOG_C5(base, value) (UART_WR_C5(base, UART_RD_C5(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C5 bitfields
 */

/*!
 * @name Register UART_C5, field LBKDDMAS[3] (RW)
 *
 * Configures the LIN break detect flag, S2[LBKDIF], to generate interrupt or
 * DMA requests if BDH[LBKDIE] is set. If BDH[LBKDIE] is cleared, and S2[LBKDIF] is
 * set, the LBKDIF DMA and LBKDIF interrupt signals are not asserted, regardless
 * of the state of LBKDDMAS.
 *
 * Values:
 * - 0 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF interrupt signal is
 *     asserted to request an interrupt service.
 * - 1 - If BDH[LBKDIE] and S2[LBKDIF] are set, the LBKDIF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_LBKDDMAS field. */
#define UART_RD_C5_LBKDDMAS(base) ((UART_C5_REG(base) & UART_C5_LBKDDMAS_MASK) >> UART_C5_LBKDDMAS_SHIFT)
#define UART_BRD_C5_LBKDDMAS(base) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_LBKDDMAS_SHIFT))

/*! @brief Set the LBKDDMAS field to a new value. */
#define UART_WR_C5_LBKDDMAS(base, value) (UART_RMW_C5(base, UART_C5_LBKDDMAS_MASK, UART_C5_LBKDDMAS(value)))
#define UART_BWR_C5_LBKDDMAS(base, value) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_LBKDDMAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C5, field RDMAS[5] (RW)
 *
 * Configures the receiver data register full flag, S1[RDRF], to generate
 * interrupt or DMA requests if C2[RIE] is set. If C2[RIE] is cleared, and S1[RDRF] is
 * set, the RDRF DMA and RDFR interrupt request signals are not asserted,
 * regardless of the state of RDMAS.
 *
 * Values:
 * - 0 - If C2[RIE] and S1[RDRF] are set, the RDFR interrupt request signal is
 *     asserted to request an interrupt service.
 * - 1 - If C2[RIE] and S1[RDRF] are set, the RDRF DMA request signal is
 *     asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_RDMAS field. */
#define UART_RD_C5_RDMAS(base) ((UART_C5_REG(base) & UART_C5_RDMAS_MASK) >> UART_C5_RDMAS_SHIFT)
#define UART_BRD_C5_RDMAS(base) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT))

/*! @brief Set the RDMAS field to a new value. */
#define UART_WR_C5_RDMAS(base, value) (UART_RMW_C5(base, UART_C5_RDMAS_MASK, UART_C5_RDMAS(value)))
#define UART_BWR_C5_RDMAS(base, value) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_RDMAS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C5, field TDMAS[7] (RW)
 *
 * Configures the transmit data register empty flag, S1[TDRE], to generate
 * interrupt or DMA requests if C2[TIE] is set. If C2[TIE] is cleared, TDRE DMA and
 * TDRE interrupt request signals are not asserted when the TDRE flag is set,
 * regardless of the state of TDMAS. If C2[TIE] and TDMAS are both set, then C2[TCIE]
 * must be cleared, and D must not be written unless a DMA request is being
 * serviced.
 *
 * Values:
 * - 0 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE interrupt
 *     request signal is asserted to request interrupt service.
 * - 1 - If C2[TIE] is set and the S1[TDRE] flag is set, the TDRE DMA request
 *     signal is asserted to request a DMA transfer.
 */
/*@{*/
/*! @brief Read current value of the UART_C5_TDMAS field. */
#define UART_RD_C5_TDMAS(base) ((UART_C5_REG(base) & UART_C5_TDMAS_MASK) >> UART_C5_TDMAS_SHIFT)
#define UART_BRD_C5_TDMAS(base) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT))

/*! @brief Set the TDMAS field to a new value. */
#define UART_WR_C5_TDMAS(base, value) (UART_RMW_C5(base, UART_C5_TDMAS_MASK, UART_C5_TDMAS(value)))
#define UART_BWR_C5_TDMAS(base, value) (BITBAND_ACCESS8(&UART_C5_REG(base), UART_C5_TDMAS_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_ED - UART Extended Data Register
 ******************************************************************************/

/*!
 * @brief UART_ED - UART Extended Data Register (RO)
 *
 * Reset value: 0x00U
 *
 * This register contains additional information flags that are stored with a
 * received dataword. This register may be read at any time but contains valid data
 * only if there is a dataword in the receive FIFO. The data contained in this
 * register represents additional information regarding the conditions on which a
 * dataword was received. The importance of this data varies with the
 * application, and in some cases maybe completely optional. These fields automatically
 * update to reflect the conditions of the next dataword whenever D is read. If
 * S1[NF] and S1[PF] have not been set since the last time the receive buffer was
 * empty, the NOISY and PARITYE fields will be zero.
 */
/*!
 * @name Constants and macros for entire UART_ED register
 */
/*@{*/
#define UART_RD_ED(base)         (UART_ED_REG(base))
/*@}*/

/*
 * Constants & macros for individual UART_ED bitfields
 */

/*!
 * @name Register UART_ED, field PARITYE[6] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with a
 * parity error.
 *
 * Values:
 * - 0 - The dataword was received without a parity error.
 * - 1 - The dataword was received with a parity error.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_PARITYE field. */
#define UART_RD_ED_PARITYE(base) ((UART_ED_REG(base) & UART_ED_PARITYE_MASK) >> UART_ED_PARITYE_SHIFT)
#define UART_BRD_ED_PARITYE(base) (BITBAND_ACCESS8(&UART_ED_REG(base), UART_ED_PARITYE_SHIFT))
/*@}*/

/*!
 * @name Register UART_ED, field NOISY[7] (RO)
 *
 * The current received dataword contained in D and C3[R8] was received with
 * noise.
 *
 * Values:
 * - 0 - The dataword was received without noise.
 * - 1 - The data was received with noise.
 */
/*@{*/
/*! @brief Read current value of the UART_ED_NOISY field. */
#define UART_RD_ED_NOISY(base) ((UART_ED_REG(base) & UART_ED_NOISY_MASK) >> UART_ED_NOISY_SHIFT)
#define UART_BRD_ED_NOISY(base) (BITBAND_ACCESS8(&UART_ED_REG(base), UART_ED_NOISY_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_MODEM - UART Modem Register
 ******************************************************************************/

/*!
 * @brief UART_MODEM - UART Modem Register (RW)
 *
 * Reset value: 0x00U
 *
 * The MODEM register controls options for setting the modem configuration.
 * RXRTSE, TXRTSPOL, TXRTSE, and TXCTSE must all be cleared when C7816[ISO7816EN] is
 * enabled. This will cause the RTS to deassert during ISO-7816 wait times. The
 * ISO-7816 protocol does not use the RTS and CTS signals.
 */
/*!
 * @name Constants and macros for entire UART_MODEM register
 */
/*@{*/
#define UART_RD_MODEM(base)      (UART_MODEM_REG(base))
#define UART_WR_MODEM(base, value) (UART_MODEM_REG(base) = (value))
#define UART_RMW_MODEM(base, mask, value) (UART_WR_MODEM(base, (UART_RD_MODEM(base) & ~(mask)) | (value)))
#define UART_SET_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) |  (value)))
#define UART_CLR_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) & ~(value)))
#define UART_TOG_MODEM(base, value) (UART_WR_MODEM(base, UART_RD_MODEM(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_MODEM bitfields
 */

/*!
 * @name Register UART_MODEM, field TXCTSE[0] (RW)
 *
 * TXCTSE controls the operation of the transmitter. TXCTSE can be set
 * independently from the state of TXRTSE and RXRTSE.
 *
 * Values:
 * - 0 - CTS has no effect on the transmitter.
 * - 1 - Enables clear-to-send operation. The transmitter checks the state of
 *     CTS each time it is ready to send a character. If CTS is asserted, the
 *     character is sent. If CTS is deasserted, the signal TXD remains in the mark
 *     state and transmission is delayed until CTS is asserted. Changes in CTS as a
 *     character is being sent do not affect its transmission.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXCTSE field. */
#define UART_RD_MODEM_TXCTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXCTSE_MASK) >> UART_MODEM_TXCTSE_SHIFT)
#define UART_BRD_MODEM_TXCTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT))

/*! @brief Set the TXCTSE field to a new value. */
#define UART_WR_MODEM_TXCTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXCTSE_MASK, UART_MODEM_TXCTSE(value)))
#define UART_BWR_MODEM_TXCTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXCTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSE[1] (RW)
 *
 * Controls RTS before and after a transmission.
 *
 * Values:
 * - 0 - The transmitter has no effect on RTS.
 * - 1 - When a character is placed into an empty transmitter data buffer , RTS
 *     asserts one bit time before the start bit is transmitted. RTS deasserts
 *     one bit time after all characters in the transmitter data buffer and shift
 *     register are completely sent, including the last stop bit. (FIFO) Ensure
 *     that C2[TE] is asserted before assertion of this bit.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSE field. */
#define UART_RD_MODEM_TXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSE_MASK) >> UART_MODEM_TXRTSE_SHIFT)
#define UART_BRD_MODEM_TXRTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT))

/*! @brief Set the TXRTSE field to a new value. */
#define UART_WR_MODEM_TXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSE_MASK, UART_MODEM_TXRTSE(value)))
#define UART_BWR_MODEM_TXRTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field TXRTSPOL[2] (RW)
 *
 * Controls the polarity of the transmitter RTS. TXRTSPOL does not affect the
 * polarity of the receiver RTS. RTS will remain negated in the active low state
 * unless TXRTSE is set.
 *
 * Values:
 * - 0 - Transmitter RTS is active low.
 * - 1 - Transmitter RTS is active high.
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_TXRTSPOL field. */
#define UART_RD_MODEM_TXRTSPOL(base) ((UART_MODEM_REG(base) & UART_MODEM_TXRTSPOL_MASK) >> UART_MODEM_TXRTSPOL_SHIFT)
#define UART_BRD_MODEM_TXRTSPOL(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT))

/*! @brief Set the TXRTSPOL field to a new value. */
#define UART_WR_MODEM_TXRTSPOL(base, value) (UART_RMW_MODEM(base, UART_MODEM_TXRTSPOL_MASK, UART_MODEM_TXRTSPOL(value)))
#define UART_BWR_MODEM_TXRTSPOL(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_TXRTSPOL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_MODEM, field RXRTSE[3] (RW)
 *
 * Allows the RTS output to control the CTS input of the transmitting device to
 * prevent receiver overrun. Do not set both RXRTSE and TXRTSE.
 *
 * Values:
 * - 0 - The receiver has no effect on RTS.
 * - 1 - RTS is deasserted if the number of characters in the receiver data
 *     register (FIFO) is equal to or greater than RWFIFO[RXWATER]. RTS is asserted
 *     when the number of characters in the receiver data register (FIFO) is less
 *     than RWFIFO[RXWATER]. See Hardware flow control
 */
/*@{*/
/*! @brief Read current value of the UART_MODEM_RXRTSE field. */
#define UART_RD_MODEM_RXRTSE(base) ((UART_MODEM_REG(base) & UART_MODEM_RXRTSE_MASK) >> UART_MODEM_RXRTSE_SHIFT)
#define UART_BRD_MODEM_RXRTSE(base) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT))

/*! @brief Set the RXRTSE field to a new value. */
#define UART_WR_MODEM_RXRTSE(base, value) (UART_RMW_MODEM(base, UART_MODEM_RXRTSE_MASK, UART_MODEM_RXRTSE(value)))
#define UART_BWR_MODEM_RXRTSE(base, value) (BITBAND_ACCESS8(&UART_MODEM_REG(base), UART_MODEM_RXRTSE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IR - UART Infrared Register
 ******************************************************************************/

/*!
 * @brief UART_IR - UART Infrared Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IR register controls options for setting the infrared configuration.
 */
/*!
 * @name Constants and macros for entire UART_IR register
 */
/*@{*/
#define UART_RD_IR(base)         (UART_IR_REG(base))
#define UART_WR_IR(base, value)  (UART_IR_REG(base) = (value))
#define UART_RMW_IR(base, mask, value) (UART_WR_IR(base, (UART_RD_IR(base) & ~(mask)) | (value)))
#define UART_SET_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) |  (value)))
#define UART_CLR_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) & ~(value)))
#define UART_TOG_IR(base, value) (UART_WR_IR(base, UART_RD_IR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IR bitfields
 */

/*!
 * @name Register UART_IR, field TNP[1:0] (RW)
 *
 * Enables whether the UART transmits a 1/16, 3/16, 1/32, or 1/4 narrow pulse.
 *
 * Values:
 * - 00 - 3/16.
 * - 01 - 1/16.
 * - 10 - 1/32.
 * - 11 - 1/4.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_TNP field. */
#define UART_RD_IR_TNP(base) ((UART_IR_REG(base) & UART_IR_TNP_MASK) >> UART_IR_TNP_SHIFT)
#define UART_BRD_IR_TNP(base) (UART_RD_IR_TNP(base))

/*! @brief Set the TNP field to a new value. */
#define UART_WR_IR_TNP(base, value) (UART_RMW_IR(base, UART_IR_TNP_MASK, UART_IR_TNP(value)))
#define UART_BWR_IR_TNP(base, value) (UART_WR_IR_TNP(base, value))
/*@}*/

/*!
 * @name Register UART_IR, field IREN[2] (RW)
 *
 * Enables/disables the infrared modulation/demodulation.
 *
 * Values:
 * - 0 - IR disabled.
 * - 1 - IR enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_IR_IREN field. */
#define UART_RD_IR_IREN(base) ((UART_IR_REG(base) & UART_IR_IREN_MASK) >> UART_IR_IREN_SHIFT)
#define UART_BRD_IR_IREN(base) (BITBAND_ACCESS8(&UART_IR_REG(base), UART_IR_IREN_SHIFT))

/*! @brief Set the IREN field to a new value. */
#define UART_WR_IR_IREN(base, value) (UART_RMW_IR(base, UART_IR_IREN_MASK, UART_IR_IREN(value)))
#define UART_BWR_IR_IREN(base, value) (BITBAND_ACCESS8(&UART_IR_REG(base), UART_IR_IREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_PFIFO - UART FIFO Parameters
 ******************************************************************************/

/*!
 * @brief UART_PFIFO - UART FIFO Parameters (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability for the programmer to turn on and off FIFO
 * functionality. It also provides the size of the FIFO that has been
 * implemented. This register may be read at any time. This register must be written only
 * when C2[RE] and C2[TE] are cleared/not set and when the data buffer/FIFO is
 * empty.
 */
/*!
 * @name Constants and macros for entire UART_PFIFO register
 */
/*@{*/
#define UART_RD_PFIFO(base)      (UART_PFIFO_REG(base))
#define UART_WR_PFIFO(base, value) (UART_PFIFO_REG(base) = (value))
#define UART_RMW_PFIFO(base, mask, value) (UART_WR_PFIFO(base, (UART_RD_PFIFO(base) & ~(mask)) | (value)))
#define UART_SET_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) |  (value)))
#define UART_CLR_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) & ~(value)))
#define UART_TOG_PFIFO(base, value) (UART_WR_PFIFO(base, UART_RD_PFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_PFIFO bitfields
 */

/*!
 * @name Register UART_PFIFO, field RXFIFOSIZE[2:0] (RO)
 *
 * The maximum number of receive datawords that can be stored in the receive
 * buffer before an overrun occurs. This field is read only.
 *
 * Values:
 * - 000 - Receive FIFO/Buffer depth = 1 dataword.
 * - 001 - Receive FIFO/Buffer depth = 4 datawords.
 * - 010 - Receive FIFO/Buffer depth = 8 datawords.
 * - 011 - Receive FIFO/Buffer depth = 16 datawords.
 * - 100 - Receive FIFO/Buffer depth = 32 datawords.
 * - 101 - Receive FIFO/Buffer depth = 64 datawords.
 * - 110 - Receive FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFIFOSIZE field. */
#define UART_RD_PFIFO_RXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFIFOSIZE_MASK) >> UART_PFIFO_RXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_RXFIFOSIZE(base) (UART_RD_PFIFO_RXFIFOSIZE(base))
/*@}*/

/*!
 * @name Register UART_PFIFO, field RXFE[3] (RW)
 *
 * When this field is set, the built in FIFO structure for the receive buffer is
 * enabled. The size of the FIFO structure is indicated by the RXFIFOSIZE field.
 * If this field is not set, the receive buffer operates as a FIFO of depth one
 * dataword regardless of the value in RXFIFOSIZE. Both C2[TE] and C2[RE] must be
 * cleared prior to changing this field. Additionally, TXFLUSH and RXFLUSH
 * commands must be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Receive FIFO is not enabled. Buffer is depth 1. (Legacy support)
 * - 1 - Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_RXFE field. */
#define UART_RD_PFIFO_RXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_RXFE_MASK) >> UART_PFIFO_RXFE_SHIFT)
#define UART_BRD_PFIFO_RXFE(base) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT))

/*! @brief Set the RXFE field to a new value. */
#define UART_WR_PFIFO_RXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_RXFE_MASK, UART_PFIFO_RXFE(value)))
#define UART_BWR_PFIFO_RXFE(base, value) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_RXFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFIFOSIZE[6:4] (RO)
 *
 * The maximum number of transmit datawords that can be stored in the transmit
 * buffer. This field is read only.
 *
 * Values:
 * - 000 - Transmit FIFO/Buffer depth = 1 dataword.
 * - 001 - Transmit FIFO/Buffer depth = 4 datawords.
 * - 010 - Transmit FIFO/Buffer depth = 8 datawords.
 * - 011 - Transmit FIFO/Buffer depth = 16 datawords.
 * - 100 - Transmit FIFO/Buffer depth = 32 datawords.
 * - 101 - Transmit FIFO/Buffer depth = 64 datawords.
 * - 110 - Transmit FIFO/Buffer depth = 128 datawords.
 * - 111 - Reserved.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFIFOSIZE field. */
#define UART_RD_PFIFO_TXFIFOSIZE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFIFOSIZE_MASK) >> UART_PFIFO_TXFIFOSIZE_SHIFT)
#define UART_BRD_PFIFO_TXFIFOSIZE(base) (UART_RD_PFIFO_TXFIFOSIZE(base))
/*@}*/

/*!
 * @name Register UART_PFIFO, field TXFE[7] (RW)
 *
 * When this field is set, the built in FIFO structure for the transmit buffer
 * is enabled. The size of the FIFO structure is indicated by TXFIFOSIZE. If this
 * field is not set, the transmit buffer operates as a FIFO of depth one dataword
 * regardless of the value in TXFIFOSIZE. Both C2[TE] and C2[RE] must be cleared
 * prior to changing this field. Additionally, TXFLUSH and RXFLUSH commands must
 * be issued immediately after changing this field.
 *
 * Values:
 * - 0 - Transmit FIFO is not enabled. Buffer is depth 1. (Legacy support).
 * - 1 - Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.
 */
/*@{*/
/*! @brief Read current value of the UART_PFIFO_TXFE field. */
#define UART_RD_PFIFO_TXFE(base) ((UART_PFIFO_REG(base) & UART_PFIFO_TXFE_MASK) >> UART_PFIFO_TXFE_SHIFT)
#define UART_BRD_PFIFO_TXFE(base) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT))

/*! @brief Set the TXFE field to a new value. */
#define UART_WR_PFIFO_TXFE(base, value) (UART_RMW_PFIFO(base, UART_PFIFO_TXFE_MASK, UART_PFIFO_TXFE(value)))
#define UART_BWR_PFIFO_TXFE(base, value) (BITBAND_ACCESS8(&UART_PFIFO_REG(base), UART_PFIFO_TXFE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_CFIFO - UART FIFO Control Register
 ******************************************************************************/

/*!
 * @brief UART_CFIFO - UART FIFO Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to program various control fields for FIFO
 * operation. This register may be read or written at any time. Note that
 * writing to TXFLUSH and RXFLUSH may result in data loss and requires careful action
 * to prevent unintended/unpredictable behavior. Therefore, it is recommended that
 * TE and RE be cleared prior to flushing the corresponding FIFO.
 */
/*!
 * @name Constants and macros for entire UART_CFIFO register
 */
/*@{*/
#define UART_RD_CFIFO(base)      (UART_CFIFO_REG(base))
#define UART_WR_CFIFO(base, value) (UART_CFIFO_REG(base) = (value))
#define UART_RMW_CFIFO(base, mask, value) (UART_WR_CFIFO(base, (UART_RD_CFIFO(base) & ~(mask)) | (value)))
#define UART_SET_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) |  (value)))
#define UART_CLR_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) & ~(value)))
#define UART_TOG_CFIFO(base, value) (UART_WR_CFIFO(base, UART_RD_CFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_CFIFO bitfields
 */

/*!
 * @name Register UART_CFIFO, field RXUFE[0] (RW)
 *
 * When this field is set, the RXUF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXUF flag does not generate an interrupt to the host.
 * - 1 - RXUF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXUFE field. */
#define UART_RD_CFIFO_RXUFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXUFE_MASK) >> UART_CFIFO_RXUFE_SHIFT)
#define UART_BRD_CFIFO_RXUFE(base) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT))

/*! @brief Set the RXUFE field to a new value. */
#define UART_WR_CFIFO_RXUFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXUFE_MASK, UART_CFIFO_RXUFE(value)))
#define UART_BWR_CFIFO_RXUFE(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXUFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXOFE[1] (RW)
 *
 * When this field is set, the TXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - TXOF flag does not generate an interrupt to the host.
 * - 1 - TXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_TXOFE field. */
#define UART_RD_CFIFO_TXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_TXOFE_MASK) >> UART_CFIFO_TXOFE_SHIFT)
#define UART_BRD_CFIFO_TXOFE(base) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT))

/*! @brief Set the TXOFE field to a new value. */
#define UART_WR_CFIFO_TXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXOFE_MASK, UART_CFIFO_TXOFE(value)))
#define UART_BWR_CFIFO_TXOFE(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXOFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXOFE[2] (RW)
 *
 * When this field is set, the RXOF flag generates an interrupt to the host.
 *
 * Values:
 * - 0 - RXOF flag does not generate an interrupt to the host.
 * - 1 - RXOF flag generates an interrupt to the host.
 */
/*@{*/
/*! @brief Read current value of the UART_CFIFO_RXOFE field. */
#define UART_RD_CFIFO_RXOFE(base) ((UART_CFIFO_REG(base) & UART_CFIFO_RXOFE_MASK) >> UART_CFIFO_RXOFE_SHIFT)
#define UART_BRD_CFIFO_RXOFE(base) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXOFE_SHIFT))

/*! @brief Set the RXOFE field to a new value. */
#define UART_WR_CFIFO_RXOFE(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXOFE_MASK, UART_CFIFO_RXOFE(value)))
#define UART_BWR_CFIFO_RXOFE(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXOFE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field RXFLUSH[6] (WORZ)
 *
 * Writing to this field causes all data that is stored in the receive
 * FIFO/buffer to be flushed. This does not affect data that is in the receive shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the receive FIFO/buffer is cleared out.
 */
/*@{*/
/*! @brief Set the RXFLUSH field to a new value. */
#define UART_WR_CFIFO_RXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_RXFLUSH_MASK, UART_CFIFO_RXFLUSH(value)))
#define UART_BWR_CFIFO_RXFLUSH(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_RXFLUSH_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_CFIFO, field TXFLUSH[7] (WORZ)
 *
 * Writing to this field causes all data that is stored in the transmit
 * FIFO/buffer to be flushed. This does not affect data that is in the transmit shift
 * register.
 *
 * Values:
 * - 0 - No flush operation occurs.
 * - 1 - All data in the transmit FIFO/Buffer is cleared out.
 */
/*@{*/
/*! @brief Set the TXFLUSH field to a new value. */
#define UART_WR_CFIFO_TXFLUSH(base, value) (UART_RMW_CFIFO(base, UART_CFIFO_TXFLUSH_MASK, UART_CFIFO_TXFLUSH(value)))
#define UART_BWR_CFIFO_TXFLUSH(base, value) (BITBAND_ACCESS8(&UART_CFIFO_REG(base), UART_CFIFO_TXFLUSH_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_SFIFO - UART FIFO Status Register
 ******************************************************************************/

/*!
 * @brief UART_SFIFO - UART FIFO Status Register (RW)
 *
 * Reset value: 0xC0U
 *
 * This register provides status information regarding the transmit and receiver
 * buffers/FIFOs, including interrupt information. This register may be written
 * to or read at any time.
 */
/*!
 * @name Constants and macros for entire UART_SFIFO register
 */
/*@{*/
#define UART_RD_SFIFO(base)      (UART_SFIFO_REG(base))
#define UART_WR_SFIFO(base, value) (UART_SFIFO_REG(base) = (value))
#define UART_RMW_SFIFO(base, mask, value) (UART_WR_SFIFO(base, (UART_RD_SFIFO(base) & ~(mask)) | (value)))
#define UART_SET_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) |  (value)))
#define UART_CLR_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) & ~(value)))
#define UART_TOG_SFIFO(base, value) (UART_WR_SFIFO(base, UART_RD_SFIFO(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_SFIFO bitfields
 */

/*!
 * @name Register UART_SFIFO, field RXUF[0] (W1C)
 *
 * Indicates that more data has been read from the receive buffer than was
 * present. This field will assert regardless of the value of CFIFO[RXUFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXUFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer underflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer underflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXUF field. */
#define UART_RD_SFIFO_RXUF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXUF_MASK) >> UART_SFIFO_RXUF_SHIFT)
#define UART_BRD_SFIFO_RXUF(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT))

/*! @brief Set the RXUF field to a new value. */
#define UART_WR_SFIFO_RXUF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_RXUF(value)))
#define UART_BWR_SFIFO_RXUF(base, value) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXUF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXOF[1] (W1C)
 *
 * Indicates that more data has been written to the transmit buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[TXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[TXOFE] is set. This
 * flag is cleared by writing a 1.
 *
 * Values:
 * - 0 - No transmit buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one transmit buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXOF field. */
#define UART_RD_SFIFO_TXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXOF_MASK) >> UART_SFIFO_TXOF_SHIFT)
#define UART_BRD_SFIFO_TXOF(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT))

/*! @brief Set the TXOF field to a new value. */
#define UART_WR_SFIFO_TXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_TXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_RXOF_MASK), UART_SFIFO_TXOF(value)))
#define UART_BWR_SFIFO_TXOF(base, value) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXOF[2] (W1C)
 *
 * Indicates that more data has been written to the receive buffer than it can
 * hold. This field will assert regardless of the value of CFIFO[RXOFE]. However,
 * an interrupt will be issued to the host only if CFIFO[RXOFE] is set. This flag
 * is cleared by writing a 1.
 *
 * Values:
 * - 0 - No receive buffer overflow has occurred since the last time the flag
 *     was cleared.
 * - 1 - At least one receive buffer overflow has occurred since the last time
 *     the flag was cleared.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXOF field. */
#define UART_RD_SFIFO_RXOF(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXOF_MASK) >> UART_SFIFO_RXOF_SHIFT)
#define UART_BRD_SFIFO_RXOF(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXOF_SHIFT))

/*! @brief Set the RXOF field to a new value. */
#define UART_WR_SFIFO_RXOF(base, value) (UART_RMW_SFIFO(base, (UART_SFIFO_RXOF_MASK | UART_SFIFO_RXUF_MASK | UART_SFIFO_TXOF_MASK), UART_SFIFO_RXOF(value)))
#define UART_BWR_SFIFO_RXOF(base, value) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_SFIFO, field RXEMPT[6] (RO)
 *
 * Asserts when there is no data in the receive FIFO/Buffer. This field does not
 * take into account data that is in the receive shift register.
 *
 * Values:
 * - 0 - Receive buffer is not empty.
 * - 1 - Receive buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_RXEMPT field. */
#define UART_RD_SFIFO_RXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_RXEMPT_MASK) >> UART_SFIFO_RXEMPT_SHIFT)
#define UART_BRD_SFIFO_RXEMPT(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_RXEMPT_SHIFT))
/*@}*/

/*!
 * @name Register UART_SFIFO, field TXEMPT[7] (RO)
 *
 * Asserts when there is no data in the Transmit FIFO/buffer. This field does
 * not take into account data that is in the transmit shift register.
 *
 * Values:
 * - 0 - Transmit buffer is not empty.
 * - 1 - Transmit buffer is empty.
 */
/*@{*/
/*! @brief Read current value of the UART_SFIFO_TXEMPT field. */
#define UART_RD_SFIFO_TXEMPT(base) ((UART_SFIFO_REG(base) & UART_SFIFO_TXEMPT_MASK) >> UART_SFIFO_TXEMPT_SHIFT)
#define UART_BRD_SFIFO_TXEMPT(base) (BITBAND_ACCESS8(&UART_SFIFO_REG(base), UART_SFIFO_TXEMPT_SHIFT))
/*@}*/

/*******************************************************************************
 * UART_TWFIFO - UART FIFO Transmit Watermark
 ******************************************************************************/

/*!
 * @brief UART_TWFIFO - UART FIFO Transmit Watermark (RW)
 *
 * Reset value: 0x00U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of needing additional transmit data. This register may be read at any
 * time but must be written only when C2[TE] is not set. Changing the value of the
 * watermark will not clear the S1[TDRE] flag.
 */
/*!
 * @name Constants and macros for entire UART_TWFIFO register
 */
/*@{*/
#define UART_RD_TWFIFO(base)     (UART_TWFIFO_REG(base))
#define UART_WR_TWFIFO(base, value) (UART_TWFIFO_REG(base) = (value))
#define UART_RMW_TWFIFO(base, mask, value) (UART_WR_TWFIFO(base, (UART_RD_TWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) |  (value)))
#define UART_CLR_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) & ~(value)))
#define UART_TOG_TWFIFO(base, value) (UART_WR_TWFIFO(base, UART_RD_TWFIFO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_TCFIFO - UART FIFO Transmit Count
 ******************************************************************************/

/*!
 * @brief UART_TCFIFO - UART FIFO Transmit Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the transmit buffer/FIFO. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_TCFIFO register
 */
/*@{*/
#define UART_RD_TCFIFO(base)     (UART_TCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_RWFIFO - UART FIFO Receive Watermark
 ******************************************************************************/

/*!
 * @brief UART_RWFIFO - UART FIFO Receive Watermark (RW)
 *
 * Reset value: 0x01U
 *
 * This register provides the ability to set a programmable threshold for
 * notification of the need to remove data from the receiver FIFO/buffer. This register
 * may be read at any time but must be written only when C2[RE] is not asserted.
 * Changing the value in this register will not clear S1[RDRF].
 */
/*!
 * @name Constants and macros for entire UART_RWFIFO register
 */
/*@{*/
#define UART_RD_RWFIFO(base)     (UART_RWFIFO_REG(base))
#define UART_WR_RWFIFO(base, value) (UART_RWFIFO_REG(base) = (value))
#define UART_RMW_RWFIFO(base, mask, value) (UART_WR_RWFIFO(base, (UART_RD_RWFIFO(base) & ~(mask)) | (value)))
#define UART_SET_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) |  (value)))
#define UART_CLR_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) & ~(value)))
#define UART_TOG_RWFIFO(base, value) (UART_WR_RWFIFO(base, UART_RD_RWFIFO(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_RCFIFO - UART FIFO Receive Count
 ******************************************************************************/

/*!
 * @brief UART_RCFIFO - UART FIFO Receive Count (RO)
 *
 * Reset value: 0x00U
 *
 * This is a read only register that indicates how many datawords are currently
 * in the receive FIFO/buffer. It may be read at any time.
 */
/*!
 * @name Constants and macros for entire UART_RCFIFO register
 */
/*@{*/
#define UART_RD_RCFIFO(base)     (UART_RCFIFO_REG(base))
/*@}*/

/*******************************************************************************
 * UART_C7816 - UART 7816 Control Register
 ******************************************************************************/

/*!
 * @brief UART_C7816 - UART 7816 Control Register (RW)
 *
 * Reset value: 0x00U
 *
 * The C7816 register is the primary control register for ISO-7816 specific
 * functionality. This register is specific to 7816 functionality and the values in
 * this register have no effect on UART operation and should be ignored if
 * ISO_7816E is not set/enabled. This register may be read at any time but values must
 * be changed only when ISO_7816E is not set.
 */
/*!
 * @name Constants and macros for entire UART_C7816 register
 */
/*@{*/
#define UART_RD_C7816(base)      (UART_C7816_REG(base))
#define UART_WR_C7816(base, value) (UART_C7816_REG(base) = (value))
#define UART_RMW_C7816(base, mask, value) (UART_WR_C7816(base, (UART_RD_C7816(base) & ~(mask)) | (value)))
#define UART_SET_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) |  (value)))
#define UART_CLR_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) & ~(value)))
#define UART_TOG_C7816(base, value) (UART_WR_C7816(base, UART_RD_C7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_C7816 bitfields
 */

/*!
 * @name Register UART_C7816, field ISO_7816E[0] (RW)
 *
 * Indicates that the UART is operating according to the ISO-7816 protocol. This
 * field must be modified only when no transmit or receive is occurring. If this
 * field is changed during a data transfer, the data being transmitted or
 * received may be transferred incorrectly.
 *
 * Values:
 * - 0 - ISO-7816 functionality is turned off/not enabled.
 * - 1 - ISO-7816 functionality is turned on/enabled.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ISO_7816E field. */
#define UART_RD_C7816_ISO_7816E(base) ((UART_C7816_REG(base) & UART_C7816_ISO_7816E_MASK) >> UART_C7816_ISO_7816E_SHIFT)
#define UART_BRD_C7816_ISO_7816E(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT))

/*! @brief Set the ISO_7816E field to a new value. */
#define UART_WR_C7816_ISO_7816E(base, value) (UART_RMW_C7816(base, UART_C7816_ISO_7816E_MASK, UART_C7816_ISO_7816E(value)))
#define UART_BWR_C7816_ISO_7816E(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ISO_7816E_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field TTYPE[1] (RW)
 *
 * Indicates the transfer protocol being used. See ISO-7816 / smartcard support
 * for more details.
 *
 * Values:
 * - 0 - T = 0 per the ISO-7816 specification.
 * - 1 - T = 1 per the ISO-7816 specification.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_TTYPE field. */
#define UART_RD_C7816_TTYPE(base) ((UART_C7816_REG(base) & UART_C7816_TTYPE_MASK) >> UART_C7816_TTYPE_SHIFT)
#define UART_BRD_C7816_TTYPE(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT))

/*! @brief Set the TTYPE field to a new value. */
#define UART_WR_C7816_TTYPE(base, value) (UART_RMW_C7816(base, UART_C7816_TTYPE_MASK, UART_C7816_TTYPE(value)))
#define UART_BWR_C7816_TTYPE(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_TTYPE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field INIT[2] (RW)
 *
 * When this field is set, all received characters are searched for a valid
 * initial character. If an invalid initial character is identified, and ANACK is
 * set, a NACK is sent. All received data is discarded and error flags blocked
 * (S1[NF], S1[OR], S1[FE], S1[PF], IS7816[WT], IS7816[CWT], IS7816[BWT], IS7816[ADT],
 * IS7816[GTV]) until a valid initial character is detected. Upon detecting a
 * valid initial character, the configuration values S2[MSBF], C3[TXINV], and
 * S2[RXINV] are automatically updated to reflect the initial character that was
 * received. The actual INIT data value is not stored in the receive buffer.
 * Additionally, upon detection of a valid initial character, IS7816[INITD] is set and an
 * interrupt issued as programmed by IE7816[INITDE]. When a valid initial
 * character is detected, INIT is automatically cleared. This Initial Character Detect
 * feature is supported only in T = 0 protocol mode.
 *
 * Values:
 * - 0 - Normal operating mode. Receiver does not seek to identify initial
 *     character.
 * - 1 - Receiver searches for initial character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_INIT field. */
#define UART_RD_C7816_INIT(base) ((UART_C7816_REG(base) & UART_C7816_INIT_MASK) >> UART_C7816_INIT_SHIFT)
#define UART_BRD_C7816_INIT(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT))

/*! @brief Set the INIT field to a new value. */
#define UART_WR_C7816_INIT(base, value) (UART_RMW_C7816(base, UART_C7816_INIT_MASK, UART_C7816_INIT(value)))
#define UART_BWR_C7816_INIT(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_INIT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field ANACK[3] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a parity error occurs or if INIT is set and an invalid initial character is
 * detected. A NACK is generated only if TTYPE = 0. If ANACK is set, the UART
 * attempts to retransmit the data indefinitely. To stop retransmission attempts,
 * clear C2[TE] or ISO_7816E and do not set until S1[TC] sets C2[TE] again.
 *
 * Values:
 * - 0 - No NACK is automatically generated.
 * - 1 - A NACK is automatically generated if a parity error is detected or if
 *     an invalid initial character is detected.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ANACK field. */
#define UART_RD_C7816_ANACK(base) ((UART_C7816_REG(base) & UART_C7816_ANACK_MASK) >> UART_C7816_ANACK_SHIFT)
#define UART_BRD_C7816_ANACK(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT))

/*! @brief Set the ANACK field to a new value. */
#define UART_WR_C7816_ANACK(base, value) (UART_RMW_C7816(base, UART_C7816_ANACK_MASK, UART_C7816_ANACK(value)))
#define UART_BWR_C7816_ANACK(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ANACK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_C7816, field ONACK[4] (RW)
 *
 * When this field is set, the receiver automatically generates a NACK response
 * if a receive buffer overrun occurs, as indicated by S1[OR]. In many systems,
 * this results in the transmitter resending the packet that overflowed until the
 * retransmit threshold for that transmitter is reached. A NACK is generated only
 * if TTYPE=0. This field operates independently of ANACK. See . Overrun NACK
 * considerations
 *
 * Values:
 * - 0 - The received data does not generate a NACK when the receipt of the data
 *     results in an overflow event.
 * - 1 - If the receiver buffer overflows, a NACK is automatically sent on a
 *     received character.
 */
/*@{*/
/*! @brief Read current value of the UART_C7816_ONACK field. */
#define UART_RD_C7816_ONACK(base) ((UART_C7816_REG(base) & UART_C7816_ONACK_MASK) >> UART_C7816_ONACK_SHIFT)
#define UART_BRD_C7816_ONACK(base) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT))

/*! @brief Set the ONACK field to a new value. */
#define UART_WR_C7816_ONACK(base, value) (UART_RMW_C7816(base, UART_C7816_ONACK_MASK, UART_C7816_ONACK(value)))
#define UART_BWR_C7816_ONACK(base, value) (BITBAND_ACCESS8(&UART_C7816_REG(base), UART_C7816_ONACK_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IE7816 - UART 7816 Interrupt Enable Register
 ******************************************************************************/

/*!
 * @brief UART_IE7816 - UART 7816 Interrupt Enable Register (RW)
 *
 * Reset value: 0x00U
 *
 * The IE7816 register controls which flags result in an interrupt being issued.
 * This register is specific to 7816 functionality, the corresponding flags that
 * drive the interrupts are not asserted when 7816E is not set/enabled. However,
 * these flags may remain set if they are asserted while 7816E was set and not
 * subsequently cleared. This register may be read or written to at any time.
 */
/*!
 * @name Constants and macros for entire UART_IE7816 register
 */
/*@{*/
#define UART_RD_IE7816(base)     (UART_IE7816_REG(base))
#define UART_WR_IE7816(base, value) (UART_IE7816_REG(base) = (value))
#define UART_RMW_IE7816(base, mask, value) (UART_WR_IE7816(base, (UART_RD_IE7816(base) & ~(mask)) | (value)))
#define UART_SET_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) |  (value)))
#define UART_CLR_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) & ~(value)))
#define UART_TOG_IE7816(base, value) (UART_WR_IE7816(base, UART_RD_IE7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IE7816 bitfields
 */

/*!
 * @name Register UART_IE7816, field RXTE[0] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[RXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[RXT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_RXTE field. */
#define UART_RD_IE7816_RXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_RXTE_MASK) >> UART_IE7816_RXTE_SHIFT)
#define UART_BRD_IE7816_RXTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT))

/*! @brief Set the RXTE field to a new value. */
#define UART_WR_IE7816_RXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_RXTE_MASK, UART_IE7816_RXTE(value)))
#define UART_BWR_IE7816_RXTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_RXTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field TXTE[1] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[TXT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[TXT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_TXTE field. */
#define UART_RD_IE7816_TXTE(base) ((UART_IE7816_REG(base) & UART_IE7816_TXTE_MASK) >> UART_IE7816_TXTE_SHIFT)
#define UART_BRD_IE7816_TXTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT))

/*! @brief Set the TXTE field to a new value. */
#define UART_WR_IE7816_TXTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_TXTE_MASK, UART_IE7816_TXTE(value)))
#define UART_BWR_IE7816_TXTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_TXTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field GTVE[2] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[GTV] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[GTV] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_GTVE field. */
#define UART_RD_IE7816_GTVE(base) ((UART_IE7816_REG(base) & UART_IE7816_GTVE_MASK) >> UART_IE7816_GTVE_SHIFT)
#define UART_BRD_IE7816_GTVE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT))

/*! @brief Set the GTVE field to a new value. */
#define UART_WR_IE7816_GTVE(base, value) (UART_RMW_IE7816(base, UART_IE7816_GTVE_MASK, UART_IE7816_GTVE(value)))
#define UART_BWR_IE7816_GTVE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_GTVE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field ADTE[3] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[ADT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[ADT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_ADTE field. */
#define UART_RD_IE7816_ADTE(base) ((UART_IE7816_REG(base) & UART_IE7816_ADTE_MASK) >> UART_IE7816_ADTE_SHIFT)
#define UART_BRD_IE7816_ADTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_ADTE_SHIFT))

/*! @brief Set the ADTE field to a new value. */
#define UART_WR_IE7816_ADTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_ADTE_MASK, UART_IE7816_ADTE(value)))
#define UART_BWR_IE7816_ADTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_ADTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field INITDE[4] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[INITD] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[INITD] results in the generation of an
 *     interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_INITDE field. */
#define UART_RD_IE7816_INITDE(base) ((UART_IE7816_REG(base) & UART_IE7816_INITDE_MASK) >> UART_IE7816_INITDE_SHIFT)
#define UART_BRD_IE7816_INITDE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT))

/*! @brief Set the INITDE field to a new value. */
#define UART_WR_IE7816_INITDE(base, value) (UART_RMW_IE7816(base, UART_IE7816_INITDE_MASK, UART_IE7816_INITDE(value)))
#define UART_BWR_IE7816_INITDE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_INITDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field BWTE[5] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[BWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[BWT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_BWTE field. */
#define UART_RD_IE7816_BWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_BWTE_MASK) >> UART_IE7816_BWTE_SHIFT)
#define UART_BRD_IE7816_BWTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT))

/*! @brief Set the BWTE field to a new value. */
#define UART_WR_IE7816_BWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_BWTE_MASK, UART_IE7816_BWTE(value)))
#define UART_BWR_IE7816_BWTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_BWTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field CWTE[6] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[CWT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[CWT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_CWTE field. */
#define UART_RD_IE7816_CWTE(base) ((UART_IE7816_REG(base) & UART_IE7816_CWTE_MASK) >> UART_IE7816_CWTE_SHIFT)
#define UART_BRD_IE7816_CWTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT))

/*! @brief Set the CWTE field to a new value. */
#define UART_WR_IE7816_CWTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_CWTE_MASK, UART_IE7816_CWTE(value)))
#define UART_BWR_IE7816_CWTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_CWTE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IE7816, field WTE[7] (RW)
 *
 * Values:
 * - 0 - The assertion of IS7816[WT] does not result in the generation of an
 *     interrupt.
 * - 1 - The assertion of IS7816[WT] results in the generation of an interrupt.
 */
/*@{*/
/*! @brief Read current value of the UART_IE7816_WTE field. */
#define UART_RD_IE7816_WTE(base) ((UART_IE7816_REG(base) & UART_IE7816_WTE_MASK) >> UART_IE7816_WTE_SHIFT)
#define UART_BRD_IE7816_WTE(base) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT))

/*! @brief Set the WTE field to a new value. */
#define UART_WR_IE7816_WTE(base, value) (UART_RMW_IE7816(base, UART_IE7816_WTE_MASK, UART_IE7816_WTE(value)))
#define UART_BWR_IE7816_WTE(base, value) (BITBAND_ACCESS8(&UART_IE7816_REG(base), UART_IE7816_WTE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_IS7816 - UART 7816 Interrupt Status Register
 ******************************************************************************/

/*!
 * @brief UART_IS7816 - UART 7816 Interrupt Status Register (W1C)
 *
 * Reset value: 0x00U
 *
 * The IS7816 register provides a mechanism to read and clear the interrupt
 * flags. All flags/interrupts are cleared by writing a 1 to the field location.
 * Writing a 0 has no effect. All bits are "sticky", meaning they indicate that only
 * the flag condition that occurred since the last time the bit was cleared, not
 * that the condition currently exists. The status flags are set regardless of
 * whether the corresponding field in the IE7816 is set or cleared. The IE7816
 * controls only if an interrupt is issued to the host processor. This register is
 * specific to 7816 functionality and the values in this register have no affect on
 * UART operation and should be ignored if 7816E is not set/enabled. This
 * register may be read or written at anytime.
 */
/*!
 * @name Constants and macros for entire UART_IS7816 register
 */
/*@{*/
#define UART_RD_IS7816(base)     (UART_IS7816_REG(base))
#define UART_WR_IS7816(base, value) (UART_IS7816_REG(base) = (value))
#define UART_RMW_IS7816(base, mask, value) (UART_WR_IS7816(base, (UART_RD_IS7816(base) & ~(mask)) | (value)))
#define UART_SET_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) |  (value)))
#define UART_CLR_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) & ~(value)))
#define UART_TOG_IS7816(base, value) (UART_WR_IS7816(base, UART_RD_IS7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_IS7816 bitfields
 */

/*!
 * @name Register UART_IS7816, field RXT[0] (W1C)
 *
 * Indicates that there are more than ET7816[RXTHRESHOLD] consecutive NACKS
 * generated in response to parity errors on received data. This flag requires ANACK
 * to be set. Additionally, this flag asserts only when C7816[TTYPE] = 0.
 * Clearing this field also resets the counter keeping track of consecutive NACKS. The
 * UART will continue to attempt to receive data regardless of whether this flag
 * is set. If 7816E is cleared/disabled, RE is cleared/disabled, C7816[TTYPE] = 1,
 * or packet is received without needing to issue a NACK, the internal NACK
 * detection counter is cleared and the count restarts from zero on the next
 * transmitted NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is less than or equal to the value in
 *     ET7816[RXTHRESHOLD].
 * - 1 - The number of consecutive NACKS generated as a result of parity errors
 *     and buffer overruns is greater than the value in ET7816[RXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_RXT field. */
#define UART_RD_IS7816_RXT(base) ((UART_IS7816_REG(base) & UART_IS7816_RXT_MASK) >> UART_IS7816_RXT_SHIFT)
#define UART_BRD_IS7816_RXT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT))

/*! @brief Set the RXT field to a new value. */
#define UART_WR_IS7816_RXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_RXT(value)))
#define UART_BWR_IS7816_RXT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_RXT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field TXT[1] (W1C)
 *
 * Indicates that the transmit NACK threshold has been exceeded as indicated by
 * ET7816[TXTHRESHOLD]. Regardless of whether this flag is set, the UART
 * continues to retransmit indefinitely. This flag asserts only when C7816[TTYPE] = 0. If
 * 7816E is cleared/disabled, ANACK is cleared/disabled, C2[TE] is
 * cleared/disabled, C7816[TTYPE] = 1, or packet is transferred without receiving a NACK, the
 * internal NACK detection counter is cleared and the count restarts from zero on
 * the next received NACK. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - The number of retries and corresponding NACKS does not exceed the value
 *     in ET7816[TXTHRESHOLD].
 * - 1 - The number of retries and corresponding NACKS exceeds the value in
 *     ET7816[TXTHRESHOLD].
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_TXT field. */
#define UART_RD_IS7816_TXT(base) ((UART_IS7816_REG(base) & UART_IS7816_TXT_MASK) >> UART_IS7816_TXT_SHIFT)
#define UART_BRD_IS7816_TXT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT))

/*! @brief Set the TXT field to a new value. */
#define UART_WR_IS7816_TXT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_TXT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_TXT(value)))
#define UART_BWR_IS7816_TXT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_TXT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field GTV[2] (W1C)
 *
 * Indicates that one or more of the character guard time, block guard time, or
 * guard time are violated. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - A guard time (GT, CGT, or BGT) has not been violated.
 * - 1 - A guard time (GT, CGT, or BGT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_GTV field. */
#define UART_RD_IS7816_GTV(base) ((UART_IS7816_REG(base) & UART_IS7816_GTV_MASK) >> UART_IS7816_GTV_SHIFT)
#define UART_BRD_IS7816_GTV(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT))

/*! @brief Set the GTV field to a new value. */
#define UART_WR_IS7816_GTV(base, value) (UART_RMW_IS7816(base, (UART_IS7816_GTV_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_GTV(value)))
#define UART_BWR_IS7816_GTV(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_GTV_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field ADT[3] (W1C)
 *
 * Indicates that the ATR duration time, the time between the leading edge of
 * the TS character being received and the leading edge of the next response
 * character, has exceeded the programmed value. This flag asserts only when
 * C7816[TTYPE] = 0. This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - ATR Duration time (ADT) has not been violated.
 * - 1 - ATR Duration time (ADT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_ADT field. */
#define UART_RD_IS7816_ADT(base) ((UART_IS7816_REG(base) & UART_IS7816_ADT_MASK) >> UART_IS7816_ADT_SHIFT)
#define UART_BRD_IS7816_ADT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_ADT_SHIFT))

/*! @brief Set the ADT field to a new value. */
#define UART_WR_IS7816_ADT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_ADT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_ADT(value)))
#define UART_BWR_IS7816_ADT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_ADT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field INITD[4] (W1C)
 *
 * Indicates that a valid initial character is received. This interrupt is
 * cleared by writing 1.
 *
 * Values:
 * - 0 - A valid initial character has not been received.
 * - 1 - A valid initial character has been received.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_INITD field. */
#define UART_RD_IS7816_INITD(base) ((UART_IS7816_REG(base) & UART_IS7816_INITD_MASK) >> UART_IS7816_INITD_SHIFT)
#define UART_BRD_IS7816_INITD(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT))

/*! @brief Set the INITD field to a new value. */
#define UART_WR_IS7816_INITD(base, value) (UART_RMW_IS7816(base, (UART_IS7816_INITD_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_INITD(value)))
#define UART_BWR_IS7816_INITD(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_INITD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field BWT[5] (W1C)
 *
 * Indicates that the block wait time, the time between the leading edge of
 * first received character of a block and the leading edge of the last character the
 * previously transmitted block, has exceeded the programmed value. This flag
 * asserts only when C7816[TTYPE] = 1.This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Block wait time (BWT) has not been violated.
 * - 1 - Block wait time (BWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_BWT field. */
#define UART_RD_IS7816_BWT(base) ((UART_IS7816_REG(base) & UART_IS7816_BWT_MASK) >> UART_IS7816_BWT_SHIFT)
#define UART_BRD_IS7816_BWT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT))

/*! @brief Set the BWT field to a new value. */
#define UART_WR_IS7816_BWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_BWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_CWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_BWT(value)))
#define UART_BWR_IS7816_BWT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_BWT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field CWT[6] (W1C)
 *
 * Indicates that the character wait time, the time between the leading edges of
 * two consecutive characters in a block, has exceeded the programmed value.
 * This flag asserts only when C7816[TTYPE] = 1. This interrupt is cleared by
 * writing 1.
 *
 * Values:
 * - 0 - Character wait time (CWT) has not been violated.
 * - 1 - Character wait time (CWT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_CWT field. */
#define UART_RD_IS7816_CWT(base) ((UART_IS7816_REG(base) & UART_IS7816_CWT_MASK) >> UART_IS7816_CWT_SHIFT)
#define UART_BRD_IS7816_CWT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT))

/*! @brief Set the CWT field to a new value. */
#define UART_WR_IS7816_CWT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_CWT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_WT_MASK), UART_IS7816_CWT(value)))
#define UART_BWR_IS7816_CWT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_CWT_SHIFT) = (value))
/*@}*/

/*!
 * @name Register UART_IS7816, field WT[7] (W1C)
 *
 * Indicates that the wait time, the time between the leading edge of a
 * character being transmitted and the leading edge of the next response character, has
 * exceeded the programmed value. This flag asserts only when C7816[TTYPE] = 0.
 * This interrupt is cleared by writing 1.
 *
 * Values:
 * - 0 - Wait time (WT) has not been violated.
 * - 1 - Wait time (WT) has been violated.
 */
/*@{*/
/*! @brief Read current value of the UART_IS7816_WT field. */
#define UART_RD_IS7816_WT(base) ((UART_IS7816_REG(base) & UART_IS7816_WT_MASK) >> UART_IS7816_WT_SHIFT)
#define UART_BRD_IS7816_WT(base) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT))

/*! @brief Set the WT field to a new value. */
#define UART_WR_IS7816_WT(base, value) (UART_RMW_IS7816(base, (UART_IS7816_WT_MASK | UART_IS7816_RXT_MASK | UART_IS7816_TXT_MASK | UART_IS7816_GTV_MASK | UART_IS7816_ADT_MASK | UART_IS7816_INITD_MASK | UART_IS7816_BWT_MASK | UART_IS7816_CWT_MASK), UART_IS7816_WT(value)))
#define UART_BWR_IS7816_WT(base, value) (BITBAND_ACCESS8(&UART_IS7816_REG(base), UART_IS7816_WT_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * UART_WP7816 - UART 7816 Wait Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WP7816 - UART 7816 Wait Parameter Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816 register contains the WTX variable used in the generation of the
 * block wait timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816 register
 */
/*@{*/
#define UART_RD_WP7816(base)     (UART_WP7816_REG(base))
#define UART_WR_WP7816(base, value) (UART_WP7816_REG(base) = (value))
#define UART_RMW_WP7816(base, mask, value) (UART_WR_WP7816(base, (UART_RD_WP7816(base) & ~(mask)) | (value)))
#define UART_SET_WP7816(base, value) (UART_WR_WP7816(base, UART_RD_WP7816(base) |  (value)))
#define UART_CLR_WP7816(base, value) (UART_WR_WP7816(base, UART_RD_WP7816(base) & ~(value)))
#define UART_TOG_WP7816(base, value) (UART_WR_WP7816(base, UART_RD_WP7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WN7816 - UART 7816 Wait N Register
 ******************************************************************************/

/*!
 * @brief UART_WN7816 - UART 7816 Wait N Register (RW)
 *
 * Reset value: 0x00U
 *
 * The WN7816 register contains a parameter that is used in the calculation of
 * the guard time counter. This register may be read at any time. This register
 * must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WN7816 register
 */
/*@{*/
#define UART_RD_WN7816(base)     (UART_WN7816_REG(base))
#define UART_WR_WN7816(base, value) (UART_WN7816_REG(base) = (value))
#define UART_RMW_WN7816(base, mask, value) (UART_WR_WN7816(base, (UART_RD_WN7816(base) & ~(mask)) | (value)))
#define UART_SET_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) |  (value)))
#define UART_CLR_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) & ~(value)))
#define UART_TOG_WN7816(base, value) (UART_WR_WN7816(base, UART_RD_WN7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WF7816 - UART 7816 Wait FD Register
 ******************************************************************************/

/*!
 * @brief UART_WF7816 - UART 7816 Wait FD Register (RW)
 *
 * Reset value: 0x01U
 *
 * The WF7816 contains parameters that are used in the generation of various
 * counters including GT, CGT, BGT, WT, and BWT. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WF7816 register
 */
/*@{*/
#define UART_RD_WF7816(base)     (UART_WF7816_REG(base))
#define UART_WR_WF7816(base, value) (UART_WF7816_REG(base) = (value))
#define UART_RMW_WF7816(base, mask, value) (UART_WR_WF7816(base, (UART_RD_WF7816(base) & ~(mask)) | (value)))
#define UART_SET_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) |  (value)))
#define UART_CLR_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) & ~(value)))
#define UART_TOG_WF7816(base, value) (UART_WR_WF7816(base, UART_RD_WF7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_ET7816 - UART 7816 Error Threshold Register
 ******************************************************************************/

/*!
 * @brief UART_ET7816 - UART 7816 Error Threshold Register (RW)
 *
 * Reset value: 0x00U
 *
 * The ET7816 register contains fields that determine the number of NACKs that
 * must be received or transmitted before the host processor is notified. This
 * register may be read at anytime. This register must be written to only when
 * C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_ET7816 register
 */
/*@{*/
#define UART_RD_ET7816(base)     (UART_ET7816_REG(base))
#define UART_WR_ET7816(base, value) (UART_ET7816_REG(base) = (value))
#define UART_RMW_ET7816(base, mask, value) (UART_WR_ET7816(base, (UART_RD_ET7816(base) & ~(mask)) | (value)))
#define UART_SET_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) |  (value)))
#define UART_CLR_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) & ~(value)))
#define UART_TOG_ET7816(base, value) (UART_WR_ET7816(base, UART_RD_ET7816(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_ET7816 bitfields
 */

/*!
 * @name Register UART_ET7816, field RXTHRESHOLD[3:0] (RW)
 *
 * The value written to this field indicates the maximum number of consecutive
 * NACKs generated as a result of a parity error or receiver buffer overruns
 * before the host processor is notified. After the counter exceeds that value in the
 * field, the IS7816[RXT] is asserted. This field is meaningful only when
 * C7816[TTYPE] = 0. The value read from this field represents the number of consecutive
 * NACKs that have been transmitted since the last successful reception. This
 * counter saturates at 4'hF and does not wrap around. Regardless of the number of
 * NACKs sent, the UART continues to receive valid packets indefinitely. For
 * additional information, see IS7816[RXT] field description.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_RXTHRESHOLD field. */
#define UART_RD_ET7816_RXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_RXTHRESHOLD_MASK) >> UART_ET7816_RXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_RXTHRESHOLD(base) (UART_RD_ET7816_RXTHRESHOLD(base))

/*! @brief Set the RXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_RXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_RXTHRESHOLD_MASK, UART_ET7816_RXTHRESHOLD(value)))
#define UART_BWR_ET7816_RXTHRESHOLD(base, value) (UART_WR_ET7816_RXTHRESHOLD(base, value))
/*@}*/

/*!
 * @name Register UART_ET7816, field TXTHRESHOLD[7:4] (RW)
 *
 * The value written to this field indicates the maximum number of failed
 * attempts (NACKs) a transmitted character can have before the host processor is
 * notified. This field is meaningful only when C7816[TTYPE] = 0 and C7816[ANACK] = 1.
 * The value read from this field represents the number of consecutive NACKs
 * that have been received since the last successful transmission. This counter
 * saturates at 4'hF and does not wrap around. Regardless of how many NACKs that are
 * received, the UART continues to retransmit indefinitely. This flag only
 * asserts when C7816[TTYPE] = 0. For additional information see the IS7816[TXT] field
 * description.
 *
 * Values:
 * - 0 - TXT asserts on the first NACK that is received.
 * - 1 - TXT asserts on the second NACK that is received.
 */
/*@{*/
/*! @brief Read current value of the UART_ET7816_TXTHRESHOLD field. */
#define UART_RD_ET7816_TXTHRESHOLD(base) ((UART_ET7816_REG(base) & UART_ET7816_TXTHRESHOLD_MASK) >> UART_ET7816_TXTHRESHOLD_SHIFT)
#define UART_BRD_ET7816_TXTHRESHOLD(base) (UART_RD_ET7816_TXTHRESHOLD(base))

/*! @brief Set the TXTHRESHOLD field to a new value. */
#define UART_WR_ET7816_TXTHRESHOLD(base, value) (UART_RMW_ET7816(base, UART_ET7816_TXTHRESHOLD_MASK, UART_ET7816_TXTHRESHOLD(value)))
#define UART_BWR_ET7816_TXTHRESHOLD(base, value) (UART_WR_ET7816_TXTHRESHOLD(base, value))
/*@}*/

/*******************************************************************************
 * UART_TL7816 - UART 7816 Transmit Length Register
 ******************************************************************************/

/*!
 * @brief UART_TL7816 - UART 7816 Transmit Length Register (RW)
 *
 * Reset value: 0x00U
 *
 * The TL7816 register is used to indicate the number of characters contained in
 * the block being transmitted. This register is used only when C7816[TTYPE] =
 * 1. This register may be read at anytime. This register must be written only
 * when C2[TE] is not enabled.
 */
/*!
 * @name Constants and macros for entire UART_TL7816 register
 */
/*@{*/
#define UART_RD_TL7816(base)     (UART_TL7816_REG(base))
#define UART_WR_TL7816(base, value) (UART_TL7816_REG(base) = (value))
#define UART_RMW_TL7816(base, mask, value) (UART_WR_TL7816(base, (UART_RD_TL7816(base) & ~(mask)) | (value)))
#define UART_SET_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) |  (value)))
#define UART_CLR_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) & ~(value)))
#define UART_TOG_TL7816(base, value) (UART_WR_TL7816(base, UART_RD_TL7816(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A
 ******************************************************************************/

/*!
 * @brief UART_AP7816A_T0 - UART 7816 ATR Duration Timer Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816A_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816A_T0 register
 */
/*@{*/
#define UART_RD_AP7816A_T0(base) (UART_AP7816A_T0_REG(base))
#define UART_WR_AP7816A_T0(base, value) (UART_AP7816A_T0_REG(base) = (value))
#define UART_RMW_AP7816A_T0(base, mask, value) (UART_WR_AP7816A_T0(base, (UART_RD_AP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816A_T0(base, value) (UART_WR_AP7816A_T0(base, UART_RD_AP7816A_T0(base) |  (value)))
#define UART_CLR_AP7816A_T0(base, value) (UART_WR_AP7816A_T0(base, UART_RD_AP7816A_T0(base) & ~(value)))
#define UART_TOG_AP7816A_T0(base, value) (UART_WR_AP7816A_T0(base, UART_RD_AP7816A_T0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B
 ******************************************************************************/

/*!
 * @brief UART_AP7816B_T0 - UART 7816 ATR Duration Timer Register B (RW)
 *
 * Reset value: 0x00U
 *
 * The AP7816B_T0 register contains variables used in the generation of the ATR
 * Duration Timer. This register may be read at any time. This register must be
 * written to only when C7816[ISO_7816E] is not set, except when writing 0 to
 * clear the ADT Counter. The ADT Counter starts counting on detection of the
 * complete TS Character. It must be noted that by this time, exactly 10 ETUs have
 * elapsed since the start bit of the TS character. The user must take this into
 * account while programming this register.
 */
/*!
 * @name Constants and macros for entire UART_AP7816B_T0 register
 */
/*@{*/
#define UART_RD_AP7816B_T0(base) (UART_AP7816B_T0_REG(base))
#define UART_WR_AP7816B_T0(base, value) (UART_AP7816B_T0_REG(base) = (value))
#define UART_RMW_AP7816B_T0(base, mask, value) (UART_WR_AP7816B_T0(base, (UART_RD_AP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_AP7816B_T0(base, value) (UART_WR_AP7816B_T0(base, UART_RD_AP7816B_T0(base) |  (value)))
#define UART_CLR_AP7816B_T0(base, value) (UART_WR_AP7816B_T0(base, UART_RD_AP7816B_T0(base) & ~(value)))
#define UART_TOG_AP7816B_T0(base, value) (UART_WR_AP7816B_T0(base, UART_RD_AP7816B_T0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T0 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T0 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T0 register
 */
/*@{*/
#define UART_RD_WP7816A_T0(base) (UART_WP7816A_T0_REG(base))
#define UART_WR_WP7816A_T0(base, value) (UART_WP7816A_T0_REG(base) = (value))
#define UART_RMW_WP7816A_T0(base, mask, value) (UART_WR_WP7816A_T0(base, (UART_RD_WP7816A_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T0(base, value) (UART_WR_WP7816A_T0(base, UART_RD_WP7816A_T0(base) |  (value)))
#define UART_CLR_WP7816A_T0(base, value) (UART_WR_WP7816A_T0(base, UART_RD_WP7816A_T0(base) & ~(value)))
#define UART_TOG_WP7816A_T0(base, value) (UART_WR_WP7816A_T0(base, UART_RD_WP7816A_T0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816A_T1 - UART 7816 Wait Parameter Register A
 ******************************************************************************/

/*!
 * @brief UART_WP7816A_T1 - UART 7816 Wait Parameter Register A (RW)
 *
 * Reset value: 0x00U
 *
 * The WP7816A_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816A_T1 register
 */
/*@{*/
#define UART_RD_WP7816A_T1(base) (UART_WP7816A_T1_REG(base))
#define UART_WR_WP7816A_T1(base, value) (UART_WP7816A_T1_REG(base) = (value))
#define UART_RMW_WP7816A_T1(base, mask, value) (UART_WR_WP7816A_T1(base, (UART_RD_WP7816A_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816A_T1(base, value) (UART_WR_WP7816A_T1(base, UART_RD_WP7816A_T1(base) |  (value)))
#define UART_CLR_WP7816A_T1(base, value) (UART_WR_WP7816A_T1(base, UART_RD_WP7816A_T1(base) & ~(value)))
#define UART_TOG_WP7816A_T1(base, value) (UART_WR_WP7816A_T1(base, UART_RD_WP7816A_T1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T0 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T0 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T0 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T0 register
 */
/*@{*/
#define UART_RD_WP7816B_T0(base) (UART_WP7816B_T0_REG(base))
#define UART_WR_WP7816B_T0(base, value) (UART_WP7816B_T0_REG(base) = (value))
#define UART_RMW_WP7816B_T0(base, mask, value) (UART_WR_WP7816B_T0(base, (UART_RD_WP7816B_T0(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T0(base, value) (UART_WR_WP7816B_T0(base, UART_RD_WP7816B_T0(base) |  (value)))
#define UART_CLR_WP7816B_T0(base, value) (UART_WR_WP7816B_T0(base, UART_RD_WP7816B_T0(base) & ~(value)))
#define UART_TOG_WP7816B_T0(base, value) (UART_WR_WP7816B_T0(base, UART_RD_WP7816B_T0(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WP7816B_T1 - UART 7816 Wait Parameter Register B
 ******************************************************************************/

/*!
 * @brief UART_WP7816B_T1 - UART 7816 Wait Parameter Register B (RW)
 *
 * Reset value: 0x14U
 *
 * The WP7816B_T1 register contains constants used in the generation of various
 * wait time counters. To save register space, this register is used differently
 * when C7816[TTYPE] = 0 and C7816[TTYPE] = 1. This register may be read at any
 * time. This register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816B_T1 register
 */
/*@{*/
#define UART_RD_WP7816B_T1(base) (UART_WP7816B_T1_REG(base))
#define UART_WR_WP7816B_T1(base, value) (UART_WP7816B_T1_REG(base) = (value))
#define UART_RMW_WP7816B_T1(base, mask, value) (UART_WR_WP7816B_T1(base, (UART_RD_WP7816B_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816B_T1(base, value) (UART_WR_WP7816B_T1(base, UART_RD_WP7816B_T1(base) |  (value)))
#define UART_CLR_WP7816B_T1(base, value) (UART_WR_WP7816B_T1(base, UART_RD_WP7816B_T1(base) & ~(value)))
#define UART_TOG_WP7816B_T1(base, value) (UART_WR_WP7816B_T1(base, UART_RD_WP7816B_T1(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register
 ******************************************************************************/

/*!
 * @brief UART_WGP7816_T1 - UART 7816 Wait and Guard Parameter Register (RW)
 *
 * Reset value: 0x06U
 *
 * The WGP7816_T1 register contains constants used in the generation of various
 * wait and guard timer counters. This register may be read at any time. This
 * register must be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WGP7816_T1 register
 */
/*@{*/
#define UART_RD_WGP7816_T1(base) (UART_WGP7816_T1_REG(base))
#define UART_WR_WGP7816_T1(base, value) (UART_WGP7816_T1_REG(base) = (value))
#define UART_RMW_WGP7816_T1(base, mask, value) (UART_WR_WGP7816_T1(base, (UART_RD_WGP7816_T1(base) & ~(mask)) | (value)))
#define UART_SET_WGP7816_T1(base, value) (UART_WR_WGP7816_T1(base, UART_RD_WGP7816_T1(base) |  (value)))
#define UART_CLR_WGP7816_T1(base, value) (UART_WR_WGP7816_T1(base, UART_RD_WGP7816_T1(base) & ~(value)))
#define UART_TOG_WGP7816_T1(base, value) (UART_WR_WGP7816_T1(base, UART_RD_WGP7816_T1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_WGP7816_T1 bitfields
 */

/*!
 * @name Register UART_WGP7816_T1, field BGI[3:0] (RW)
 *
 * Used to calculate the value used for the BGT counter. It represent a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_BGI field. */
#define UART_RD_WGP7816_T1_BGI(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_BGI_MASK) >> UART_WGP7816_T1_BGI_SHIFT)
#define UART_BRD_WGP7816_T1_BGI(base) (UART_RD_WGP7816_T1_BGI(base))

/*! @brief Set the BGI field to a new value. */
#define UART_WR_WGP7816_T1_BGI(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_BGI_MASK, UART_WGP7816_T1_BGI(value)))
#define UART_BWR_WGP7816_T1_BGI(base, value) (UART_WR_WGP7816_T1_BGI(base, value))
/*@}*/

/*!
 * @name Register UART_WGP7816_T1, field CWI1[7:4] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 15. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WGP7816_T1_CWI1 field. */
#define UART_RD_WGP7816_T1_CWI1(base) ((UART_WGP7816_T1_REG(base) & UART_WGP7816_T1_CWI1_MASK) >> UART_WGP7816_T1_CWI1_SHIFT)
#define UART_BRD_WGP7816_T1_CWI1(base) (UART_RD_WGP7816_T1_CWI1(base))

/*! @brief Set the CWI1 field to a new value. */
#define UART_WR_WGP7816_T1_CWI1(base, value) (UART_RMW_WGP7816_T1(base, UART_WGP7816_T1_CWI1_MASK, UART_WGP7816_T1_CWI1(value)))
#define UART_BWR_WGP7816_T1_CWI1(base, value) (UART_WR_WGP7816_T1_CWI1(base, value))
/*@}*/

/*******************************************************************************
 * UART_WP7816C_T1 - UART 7816 Wait Parameter Register C
 ******************************************************************************/

/*!
 * @brief UART_WP7816C_T1 - UART 7816 Wait Parameter Register C (RW)
 *
 * Reset value: 0x0BU
 *
 * The WP7816C_T1 register contains constants used in the generation of various
 * wait timer counters. This register may be read at any time. This register must
 * be written to only when C7816[ISO_7816E] is not set.
 */
/*!
 * @name Constants and macros for entire UART_WP7816C_T1 register
 */
/*@{*/
#define UART_RD_WP7816C_T1(base) (UART_WP7816C_T1_REG(base))
#define UART_WR_WP7816C_T1(base, value) (UART_WP7816C_T1_REG(base) = (value))
#define UART_RMW_WP7816C_T1(base, mask, value) (UART_WR_WP7816C_T1(base, (UART_RD_WP7816C_T1(base) & ~(mask)) | (value)))
#define UART_SET_WP7816C_T1(base, value) (UART_WR_WP7816C_T1(base, UART_RD_WP7816C_T1(base) |  (value)))
#define UART_CLR_WP7816C_T1(base, value) (UART_WR_WP7816C_T1(base, UART_RD_WP7816C_T1(base) & ~(value)))
#define UART_TOG_WP7816C_T1(base, value) (UART_WR_WP7816C_T1(base, UART_RD_WP7816C_T1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual UART_WP7816C_T1 bitfields
 */

/*!
 * @name Register UART_WP7816C_T1, field CWI2[4:0] (RW)
 *
 * Used to calculate the value used for the CWT counter. It represents a value
 * between 0 and 31. This value is used only when C7816[TTYPE] = 1. See Wait time
 * and guard time parameters .
 */
/*@{*/
/*! @brief Read current value of the UART_WP7816C_T1_CWI2 field. */
#define UART_RD_WP7816C_T1_CWI2(base) ((UART_WP7816C_T1_REG(base) & UART_WP7816C_T1_CWI2_MASK) >> UART_WP7816C_T1_CWI2_SHIFT)
#define UART_BRD_WP7816C_T1_CWI2(base) (UART_RD_WP7816C_T1_CWI2(base))

/*! @brief Set the CWI2 field to a new value. */
#define UART_WR_WP7816C_T1_CWI2(base, value) (UART_RMW_WP7816C_T1(base, UART_WP7816C_T1_CWI2_MASK, UART_WP7816C_T1_CWI2(value)))
#define UART_BWR_WP7816C_T1_CWI2(base, value) (UART_WR_WP7816C_T1_CWI2(base, value))
/*@}*/

/*
 * MKS22F25612 USB
 *
 * Universal Serial Bus, OTG Capable Controller
 *
 * Registers defined in this header file:
 * - USB_PERID - Peripheral ID register
 * - USB_IDCOMP - Peripheral ID Complement register
 * - USB_REV - Peripheral Revision register
 * - USB_ADDINFO - Peripheral Additional Info register
 * - USB_OTGISTAT - OTG Interrupt Status register
 * - USB_OTGICR - OTG Interrupt Control register
 * - USB_OTGSTAT - OTG Status register
 * - USB_OTGCTL - OTG Control register
 * - USB_ISTAT - Interrupt Status register
 * - USB_INTEN - Interrupt Enable register
 * - USB_ERRSTAT - Error Interrupt Status register
 * - USB_ERREN - Error Interrupt Enable register
 * - USB_STAT - Status register
 * - USB_CTL - Control register
 * - USB_ADDR - Address register
 * - USB_BDTPAGE1 - BDT Page register 1
 * - USB_FRMNUML - Frame Number register Low
 * - USB_FRMNUMH - Frame Number register High
 * - USB_TOKEN - Token register
 * - USB_SOFTHLD - SOF Threshold register
 * - USB_BDTPAGE2 - BDT Page Register 2
 * - USB_BDTPAGE3 - BDT Page Register 3
 * - USB_ENDPT - Endpoint Control register
 * - USB_USBCTRL - USB Control register
 * - USB_OBSERVE - USB OTG Observe register
 * - USB_CONTROL - USB OTG Control register
 * - USB_USBTRC0 - USB Transceiver Control register 0
 * - USB_USBFRMADJUST - Frame Adjust Register
 * - USB_MISCCTRL - Miscellaneous Control register
 * - USB_CLK_RECOVER_CTRL - USB Clock recovery control
 * - USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 * - USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 * - USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 */

#define USB_INSTANCE_COUNT (1U) /*!< Number of instances of the USB module. */
#define USB0_IDX (0U) /*!< Instance number for USB0. */

/*******************************************************************************
 * USB_PERID - Peripheral ID register
 ******************************************************************************/

/*!
 * @brief USB_PERID - Peripheral ID register (RO)
 *
 * Reset value: 0x04U
 *
 * Reads back the value of 0x04. This value is defined for the USB peripheral.
 */
/*!
 * @name Constants and macros for entire USB_PERID register
 */
/*@{*/
#define USB_RD_PERID(base)       (USB_PERID_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_PERID bitfields
 */

/*!
 * @name Register USB_PERID, field ID[5:0] (RO)
 *
 * This field always reads 0x4h.
 */
/*@{*/
/*! @brief Read current value of the USB_PERID_ID field. */
#define USB_RD_PERID_ID(base) ((USB_PERID_REG(base) & USB_PERID_ID_MASK) >> USB_PERID_ID_SHIFT)
#define USB_BRD_PERID_ID(base) (USB_RD_PERID_ID(base))
/*@}*/

/*******************************************************************************
 * USB_IDCOMP - Peripheral ID Complement register
 ******************************************************************************/

/*!
 * @brief USB_IDCOMP - Peripheral ID Complement register (RO)
 *
 * Reset value: 0xFBU
 *
 * Reads back the complement of the Peripheral ID register. For the USB
 * peripheral, the value is 0xFB.
 */
/*!
 * @name Constants and macros for entire USB_IDCOMP register
 */
/*@{*/
#define USB_RD_IDCOMP(base)      (USB_IDCOMP_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_IDCOMP bitfields
 */

/*!
 * @name Register USB_IDCOMP, field NID[5:0] (RO)
 *
 * Ones' complement of PERID[ID] bits.
 */
/*@{*/
/*! @brief Read current value of the USB_IDCOMP_NID field. */
#define USB_RD_IDCOMP_NID(base) ((USB_IDCOMP_REG(base) & USB_IDCOMP_NID_MASK) >> USB_IDCOMP_NID_SHIFT)
#define USB_BRD_IDCOMP_NID(base) (USB_RD_IDCOMP_NID(base))
/*@}*/

/*******************************************************************************
 * USB_REV - Peripheral Revision register
 ******************************************************************************/

/*!
 * @brief USB_REV - Peripheral Revision register (RO)
 *
 * Reset value: 0x33U
 *
 * Contains the revision number of the USB module.
 */
/*!
 * @name Constants and macros for entire USB_REV register
 */
/*@{*/
#define USB_RD_REV(base)         (USB_REV_REG(base))
/*@}*/

/*******************************************************************************
 * USB_ADDINFO - Peripheral Additional Info register
 ******************************************************************************/

/*!
 * @brief USB_ADDINFO - Peripheral Additional Info register (RO)
 *
 * Reset value: 0x01U
 *
 * Reads back the value of the Host Enable bit.
 */
/*!
 * @name Constants and macros for entire USB_ADDINFO register
 */
/*@{*/
#define USB_RD_ADDINFO(base)     (USB_ADDINFO_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_ADDINFO bitfields
 */

/*!
 * @name Register USB_ADDINFO, field IEHOST[0] (RO)
 *
 * This bit is set if host mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDINFO_IEHOST field. */
#define USB_RD_ADDINFO_IEHOST(base) ((USB_ADDINFO_REG(base) & USB_ADDINFO_IEHOST_MASK) >> USB_ADDINFO_IEHOST_SHIFT)
#define USB_BRD_ADDINFO_IEHOST(base) (BITBAND_ACCESS8(&USB_ADDINFO_REG(base), USB_ADDINFO_IEHOST_SHIFT))
/*@}*/

/*******************************************************************************
 * USB_OTGISTAT - OTG Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_OTGISTAT - OTG Interrupt Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Records changes of the ID sense and VBUS signals. Software can read this
 * register to determine the event that triggers an interrupt. Only bits that have
 * changed since the last software read are set. Writing a one to a bit clears the
 * associated interrupt.
 */
/*!
 * @name Constants and macros for entire USB_OTGISTAT register
 */
/*@{*/
#define USB_RD_OTGISTAT(base)    (USB_OTGISTAT_REG(base))
#define USB_WR_OTGISTAT(base, value) (USB_OTGISTAT_REG(base) = (value))
#define USB_RMW_OTGISTAT(base, mask, value) (USB_WR_OTGISTAT(base, (USB_RD_OTGISTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) |  (value)))
#define USB_CLR_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) & ~(value)))
#define USB_TOG_OTGISTAT(base, value) (USB_WR_OTGISTAT(base, USB_RD_OTGISTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGISTAT bitfields
 */

/*!
 * @name Register USB_OTGISTAT, field AVBUSCHG[0] (RW)
 *
 * This bit is set when a change in VBUS is detected on an A device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_AVBUSCHG field. */
#define USB_RD_OTGISTAT_AVBUSCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_AVBUSCHG_MASK) >> USB_OTGISTAT_AVBUSCHG_SHIFT)
#define USB_BRD_OTGISTAT_AVBUSCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_AVBUSCHG_SHIFT))

/*! @brief Set the AVBUSCHG field to a new value. */
#define USB_WR_OTGISTAT_AVBUSCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_AVBUSCHG_MASK, USB_OTGISTAT_AVBUSCHG(value)))
#define USB_BWR_OTGISTAT_AVBUSCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_AVBUSCHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field B_SESS_CHG[2] (RW)
 *
 * This bit is set when a change in VBUS is detected on a B device.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_B_SESS_CHG field. */
#define USB_RD_OTGISTAT_B_SESS_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_B_SESS_CHG_MASK) >> USB_OTGISTAT_B_SESS_CHG_SHIFT)
#define USB_BRD_OTGISTAT_B_SESS_CHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_B_SESS_CHG_SHIFT))

/*! @brief Set the B_SESS_CHG field to a new value. */
#define USB_WR_OTGISTAT_B_SESS_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_B_SESS_CHG_MASK, USB_OTGISTAT_B_SESS_CHG(value)))
#define USB_BWR_OTGISTAT_B_SESS_CHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_B_SESS_CHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field SESSVLDCHG[3] (RW)
 *
 * This bit is set when a change in VBUS is detected indicating a session valid
 * or a session no longer valid.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_SESSVLDCHG field. */
#define USB_RD_OTGISTAT_SESSVLDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_SESSVLDCHG_MASK) >> USB_OTGISTAT_SESSVLDCHG_SHIFT)
#define USB_BRD_OTGISTAT_SESSVLDCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_SESSVLDCHG_SHIFT))

/*! @brief Set the SESSVLDCHG field to a new value. */
#define USB_WR_OTGISTAT_SESSVLDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_SESSVLDCHG_MASK, USB_OTGISTAT_SESSVLDCHG(value)))
#define USB_BWR_OTGISTAT_SESSVLDCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_SESSVLDCHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field LINE_STATE_CHG[5] (RW)
 *
 * This interrupt is set when the USB line state (CTL[SE0] and CTL[JSTATE] bits)
 * are stable without change for 1 millisecond, and the value of the line state
 * is different from the last time when the line state was stable. It is set on
 * transitions between SE0 and J-state, SE0 and K-state, and J-state and K-state.
 * Changes in J-state while SE0 is true do not cause an interrupt. This interrupt
 * can be used in detecting Reset, Resume, Connect, and Data Line Pulse
 * signaling.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_LINE_STATE_CHG field. */
#define USB_RD_OTGISTAT_LINE_STATE_CHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_LINE_STATE_CHG_MASK) >> USB_OTGISTAT_LINE_STATE_CHG_SHIFT)
#define USB_BRD_OTGISTAT_LINE_STATE_CHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_LINE_STATE_CHG_SHIFT))

/*! @brief Set the LINE_STATE_CHG field to a new value. */
#define USB_WR_OTGISTAT_LINE_STATE_CHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_LINE_STATE_CHG_MASK, USB_OTGISTAT_LINE_STATE_CHG(value)))
#define USB_BWR_OTGISTAT_LINE_STATE_CHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_LINE_STATE_CHG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field ONEMSEC[6] (RW)
 *
 * This bit is set when the 1 millisecond timer expires. This bit stays asserted
 * until cleared by software. The interrupt must be serviced every millisecond
 * to avoid losing 1msec counts.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_ONEMSEC field. */
#define USB_RD_OTGISTAT_ONEMSEC(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_ONEMSEC_MASK) >> USB_OTGISTAT_ONEMSEC_SHIFT)
#define USB_BRD_OTGISTAT_ONEMSEC(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_ONEMSEC_SHIFT))

/*! @brief Set the ONEMSEC field to a new value. */
#define USB_WR_OTGISTAT_ONEMSEC(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_ONEMSEC_MASK, USB_OTGISTAT_ONEMSEC(value)))
#define USB_BWR_OTGISTAT_ONEMSEC(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_ONEMSEC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGISTAT, field IDCHG[7] (RW)
 *
 * This bit is set when a change in the ID Signal from the USB connector is
 * sensed.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGISTAT_IDCHG field. */
#define USB_RD_OTGISTAT_IDCHG(base) ((USB_OTGISTAT_REG(base) & USB_OTGISTAT_IDCHG_MASK) >> USB_OTGISTAT_IDCHG_SHIFT)
#define USB_BRD_OTGISTAT_IDCHG(base) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_IDCHG_SHIFT))

/*! @brief Set the IDCHG field to a new value. */
#define USB_WR_OTGISTAT_IDCHG(base, value) (USB_RMW_OTGISTAT(base, USB_OTGISTAT_IDCHG_MASK, USB_OTGISTAT_IDCHG(value)))
#define USB_BWR_OTGISTAT_IDCHG(base, value) (BITBAND_ACCESS8(&USB_OTGISTAT_REG(base), USB_OTGISTAT_IDCHG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGICR - OTG Interrupt Control register
 ******************************************************************************/

/*!
 * @brief USB_OTGICR - OTG Interrupt Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Enables the corresponding interrupt status bits defined in the OTG Interrupt
 * Status Register.
 */
/*!
 * @name Constants and macros for entire USB_OTGICR register
 */
/*@{*/
#define USB_RD_OTGICR(base)      (USB_OTGICR_REG(base))
#define USB_WR_OTGICR(base, value) (USB_OTGICR_REG(base) = (value))
#define USB_RMW_OTGICR(base, mask, value) (USB_WR_OTGICR(base, (USB_RD_OTGICR(base) & ~(mask)) | (value)))
#define USB_SET_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) |  (value)))
#define USB_CLR_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) & ~(value)))
#define USB_TOG_OTGICR(base, value) (USB_WR_OTGICR(base, USB_RD_OTGICR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGICR bitfields
 */

/*!
 * @name Register USB_OTGICR, field AVBUSEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the AVBUSCHG interrupt.
 * - 1 - Enables the AVBUSCHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_AVBUSEN field. */
#define USB_RD_OTGICR_AVBUSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_AVBUSEN_MASK) >> USB_OTGICR_AVBUSEN_SHIFT)
#define USB_BRD_OTGICR_AVBUSEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_AVBUSEN_SHIFT))

/*! @brief Set the AVBUSEN field to a new value. */
#define USB_WR_OTGICR_AVBUSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_AVBUSEN_MASK, USB_OTGICR_AVBUSEN(value)))
#define USB_BWR_OTGICR_AVBUSEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_AVBUSEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field BSESSEN[2] (RW)
 *
 * Values:
 * - 0 - Disables the B_SESS_CHG interrupt.
 * - 1 - Enables the B_SESS_CHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_BSESSEN field. */
#define USB_RD_OTGICR_BSESSEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_BSESSEN_MASK) >> USB_OTGICR_BSESSEN_SHIFT)
#define USB_BRD_OTGICR_BSESSEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_BSESSEN_SHIFT))

/*! @brief Set the BSESSEN field to a new value. */
#define USB_WR_OTGICR_BSESSEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_BSESSEN_MASK, USB_OTGICR_BSESSEN(value)))
#define USB_BWR_OTGICR_BSESSEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_BSESSEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field SESSVLDEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the SESSVLDCHG interrupt.
 * - 1 - Enables the SESSVLDCHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_SESSVLDEN field. */
#define USB_RD_OTGICR_SESSVLDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_SESSVLDEN_MASK) >> USB_OTGICR_SESSVLDEN_SHIFT)
#define USB_BRD_OTGICR_SESSVLDEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_SESSVLDEN_SHIFT))

/*! @brief Set the SESSVLDEN field to a new value. */
#define USB_WR_OTGICR_SESSVLDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_SESSVLDEN_MASK, USB_OTGICR_SESSVLDEN(value)))
#define USB_BWR_OTGICR_SESSVLDEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_SESSVLDEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field LINESTATEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the LINE_STAT_CHG interrupt.
 * - 1 - Enables the LINE_STAT_CHG interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_LINESTATEEN field. */
#define USB_RD_OTGICR_LINESTATEEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_LINESTATEEN_MASK) >> USB_OTGICR_LINESTATEEN_SHIFT)
#define USB_BRD_OTGICR_LINESTATEEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_LINESTATEEN_SHIFT))

/*! @brief Set the LINESTATEEN field to a new value. */
#define USB_WR_OTGICR_LINESTATEEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_LINESTATEEN_MASK, USB_OTGICR_LINESTATEEN(value)))
#define USB_BWR_OTGICR_LINESTATEEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_LINESTATEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field ONEMSECEN[6] (RW)
 *
 * Values:
 * - 0 - Diables the 1ms timer interrupt.
 * - 1 - Enables the 1ms timer interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_ONEMSECEN field. */
#define USB_RD_OTGICR_ONEMSECEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_ONEMSECEN_MASK) >> USB_OTGICR_ONEMSECEN_SHIFT)
#define USB_BRD_OTGICR_ONEMSECEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_ONEMSECEN_SHIFT))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGICR_ONEMSECEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_ONEMSECEN_MASK, USB_OTGICR_ONEMSECEN(value)))
#define USB_BWR_OTGICR_ONEMSECEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_ONEMSECEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGICR, field IDEN[7] (RW)
 *
 * Values:
 * - 0 - The ID interrupt is disabled
 * - 1 - The ID interrupt is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGICR_IDEN field. */
#define USB_RD_OTGICR_IDEN(base) ((USB_OTGICR_REG(base) & USB_OTGICR_IDEN_MASK) >> USB_OTGICR_IDEN_SHIFT)
#define USB_BRD_OTGICR_IDEN(base) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_IDEN_SHIFT))

/*! @brief Set the IDEN field to a new value. */
#define USB_WR_OTGICR_IDEN(base, value) (USB_RMW_OTGICR(base, USB_OTGICR_IDEN_MASK, USB_OTGICR_IDEN(value)))
#define USB_BWR_OTGICR_IDEN(base, value) (BITBAND_ACCESS8(&USB_OTGICR_REG(base), USB_OTGICR_IDEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGSTAT - OTG Status register
 ******************************************************************************/

/*!
 * @brief USB_OTGSTAT - OTG Status register (RW)
 *
 * Reset value: 0x00U
 *
 * Displays the actual value from the external comparator outputs of the ID pin
 * and VBUS.
 */
/*!
 * @name Constants and macros for entire USB_OTGSTAT register
 */
/*@{*/
#define USB_RD_OTGSTAT(base)     (USB_OTGSTAT_REG(base))
#define USB_WR_OTGSTAT(base, value) (USB_OTGSTAT_REG(base) = (value))
#define USB_RMW_OTGSTAT(base, mask, value) (USB_WR_OTGSTAT(base, (USB_RD_OTGSTAT(base) & ~(mask)) | (value)))
#define USB_SET_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) |  (value)))
#define USB_CLR_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) & ~(value)))
#define USB_TOG_OTGSTAT(base, value) (USB_WR_OTGSTAT(base, USB_RD_OTGSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGSTAT bitfields
 */

/*!
 * @name Register USB_OTGSTAT, field AVBUSVLD[0] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the A VBUS Valid threshold.
 * - 1 - The VBUS voltage is above the A VBUS Valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_AVBUSVLD field. */
#define USB_RD_OTGSTAT_AVBUSVLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_AVBUSVLD_MASK) >> USB_OTGSTAT_AVBUSVLD_SHIFT)
#define USB_BRD_OTGSTAT_AVBUSVLD(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_AVBUSVLD_SHIFT))

/*! @brief Set the AVBUSVLD field to a new value. */
#define USB_WR_OTGSTAT_AVBUSVLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_AVBUSVLD_MASK, USB_OTGSTAT_AVBUSVLD(value)))
#define USB_BWR_OTGSTAT_AVBUSVLD(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_AVBUSVLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field BSESSEND[2] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is above the B session end threshold.
 * - 1 - The VBUS voltage is below the B session end threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_BSESSEND field. */
#define USB_RD_OTGSTAT_BSESSEND(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_BSESSEND_MASK) >> USB_OTGSTAT_BSESSEND_SHIFT)
#define USB_BRD_OTGSTAT_BSESSEND(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_BSESSEND_SHIFT))

/*! @brief Set the BSESSEND field to a new value. */
#define USB_WR_OTGSTAT_BSESSEND(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_BSESSEND_MASK, USB_OTGSTAT_BSESSEND(value)))
#define USB_BWR_OTGSTAT_BSESSEND(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_BSESSEND_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field SESS_VLD[3] (RW)
 *
 * Values:
 * - 0 - The VBUS voltage is below the B session valid threshold
 * - 1 - The VBUS voltage is above the B session valid threshold.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_SESS_VLD field. */
#define USB_RD_OTGSTAT_SESS_VLD(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_SESS_VLD_MASK) >> USB_OTGSTAT_SESS_VLD_SHIFT)
#define USB_BRD_OTGSTAT_SESS_VLD(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_SESS_VLD_SHIFT))

/*! @brief Set the SESS_VLD field to a new value. */
#define USB_WR_OTGSTAT_SESS_VLD(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_SESS_VLD_MASK, USB_OTGSTAT_SESS_VLD(value)))
#define USB_BWR_OTGSTAT_SESS_VLD(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_SESS_VLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field LINESTATESTABLE[5] (RW)
 *
 * Indicates that the internal signals that control the LINE_STATE_CHG field of
 * OTGISTAT are stable for at least 1 ms. This bit is used to provide a hardware
 * debounce of the linestate in detection of Connect, Disconnect and Resume
 * signaling. First read LINE_STATE_CHG field and then read this field. If this field
 * reads as 1, then the value of LINE_STATE_CHG can be considered stable.
 *
 * Values:
 * - 0 - The LINE_STAT_CHG bit is not yet stable.
 * - 1 - The LINE_STAT_CHG bit has been debounced and is stable.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_LINESTATESTABLE field. */
#define USB_RD_OTGSTAT_LINESTATESTABLE(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_LINESTATESTABLE_MASK) >> USB_OTGSTAT_LINESTATESTABLE_SHIFT)
#define USB_BRD_OTGSTAT_LINESTATESTABLE(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_LINESTATESTABLE_SHIFT))

/*! @brief Set the LINESTATESTABLE field to a new value. */
#define USB_WR_OTGSTAT_LINESTATESTABLE(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_LINESTATESTABLE_MASK, USB_OTGSTAT_LINESTATESTABLE(value)))
#define USB_BWR_OTGSTAT_LINESTATESTABLE(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_LINESTATESTABLE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ONEMSECEN[6] (RW)
 *
 * This bit is reserved for the 1ms count, but it is not useful to software.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ONEMSECEN field. */
#define USB_RD_OTGSTAT_ONEMSECEN(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ONEMSECEN_MASK) >> USB_OTGSTAT_ONEMSECEN_SHIFT)
#define USB_BRD_OTGSTAT_ONEMSECEN(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ONEMSECEN_SHIFT))

/*! @brief Set the ONEMSECEN field to a new value. */
#define USB_WR_OTGSTAT_ONEMSECEN(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ONEMSECEN_MASK, USB_OTGSTAT_ONEMSECEN(value)))
#define USB_BWR_OTGSTAT_ONEMSECEN(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ONEMSECEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGSTAT, field ID[7] (RW)
 *
 * Indicates the current state of the ID pin on the USB connector
 *
 * Values:
 * - 0 - Indicates a Type A cable is plugged into the USB connector.
 * - 1 - Indicates no cable is attached or a Type B cable is plugged into the
 *     USB connector.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGSTAT_ID field. */
#define USB_RD_OTGSTAT_ID(base) ((USB_OTGSTAT_REG(base) & USB_OTGSTAT_ID_MASK) >> USB_OTGSTAT_ID_SHIFT)
#define USB_BRD_OTGSTAT_ID(base) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ID_SHIFT))

/*! @brief Set the ID field to a new value. */
#define USB_WR_OTGSTAT_ID(base, value) (USB_RMW_OTGSTAT(base, USB_OTGSTAT_ID_MASK, USB_OTGSTAT_ID(value)))
#define USB_BWR_OTGSTAT_ID(base, value) (BITBAND_ACCESS8(&USB_OTGSTAT_REG(base), USB_OTGSTAT_ID_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OTGCTL - OTG Control register
 ******************************************************************************/

/*!
 * @brief USB_OTGCTL - OTG Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Controls the operation of VBUS and Data Line termination resistors.
 */
/*!
 * @name Constants and macros for entire USB_OTGCTL register
 */
/*@{*/
#define USB_RD_OTGCTL(base)      (USB_OTGCTL_REG(base))
#define USB_WR_OTGCTL(base, value) (USB_OTGCTL_REG(base) = (value))
#define USB_RMW_OTGCTL(base, mask, value) (USB_WR_OTGCTL(base, (USB_RD_OTGCTL(base) & ~(mask)) | (value)))
#define USB_SET_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) |  (value)))
#define USB_CLR_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) & ~(value)))
#define USB_TOG_OTGCTL(base, value) (USB_WR_OTGCTL(base, USB_RD_OTGCTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_OTGCTL bitfields
 */

/*!
 * @name Register USB_OTGCTL, field OTGEN[2] (RW)
 *
 * Values:
 * - 0 - If USB_EN is 1 and HOST_MODE is 0 in the Control Register (CTL), then
 *     the D+ Data Line pull-up resistors are enabled. If HOST_MODE is 1 the D+
 *     and D- Data Line pull-down resistors are engaged.
 * - 1 - The pull-up and pull-down controls in this register are used.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_OTGEN field. */
#define USB_RD_OTGCTL_OTGEN(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_OTGEN_MASK) >> USB_OTGCTL_OTGEN_SHIFT)
#define USB_BRD_OTGCTL_OTGEN(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_OTGEN_SHIFT))

/*! @brief Set the OTGEN field to a new value. */
#define USB_WR_OTGCTL_OTGEN(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_OTGEN_MASK, USB_OTGCTL_OTGEN(value)))
#define USB_BWR_OTGCTL_OTGEN(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_OTGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DMLOW[4] (RW)
 *
 * Values:
 * - 0 - D- pulldown resistor is not enabled.
 * - 1 - D- pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DMLOW field. */
#define USB_RD_OTGCTL_DMLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DMLOW_MASK) >> USB_OTGCTL_DMLOW_SHIFT)
#define USB_BRD_OTGCTL_DMLOW(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DMLOW_SHIFT))

/*! @brief Set the DMLOW field to a new value. */
#define USB_WR_OTGCTL_DMLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DMLOW_MASK, USB_OTGCTL_DMLOW(value)))
#define USB_BWR_OTGCTL_DMLOW(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DMLOW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPLOW[5] (RW)
 *
 * This bit should always be enabled together with bit 4 (DMLOW)
 *
 * Values:
 * - 0 - D+ pulldown resistor is not enabled.
 * - 1 - D+ pulldown resistor is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPLOW field. */
#define USB_RD_OTGCTL_DPLOW(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPLOW_MASK) >> USB_OTGCTL_DPLOW_SHIFT)
#define USB_BRD_OTGCTL_DPLOW(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPLOW_SHIFT))

/*! @brief Set the DPLOW field to a new value. */
#define USB_WR_OTGCTL_DPLOW(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPLOW_MASK, USB_OTGCTL_DPLOW(value)))
#define USB_BWR_OTGCTL_DPLOW(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPLOW_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_OTGCTL, field DPHIGH[7] (RW)
 *
 * Values:
 * - 0 - D+ pullup resistor is not enabled
 * - 1 - D+ pullup resistor is enabled
 */
/*@{*/
/*! @brief Read current value of the USB_OTGCTL_DPHIGH field. */
#define USB_RD_OTGCTL_DPHIGH(base) ((USB_OTGCTL_REG(base) & USB_OTGCTL_DPHIGH_MASK) >> USB_OTGCTL_DPHIGH_SHIFT)
#define USB_BRD_OTGCTL_DPHIGH(base) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPHIGH_SHIFT))

/*! @brief Set the DPHIGH field to a new value. */
#define USB_WR_OTGCTL_DPHIGH(base, value) (USB_RMW_OTGCTL(base, USB_OTGCTL_DPHIGH_MASK, USB_OTGCTL_DPHIGH(value)))
#define USB_BWR_OTGCTL_DPHIGH(base, value) (BITBAND_ACCESS8(&USB_OTGCTL_REG(base), USB_OTGCTL_DPHIGH_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ISTAT - Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_ISTAT - Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains fields for each of the interrupt sources within the USB Module. Each
 * of these fields are qualified with their respective interrupt enable bits.
 * All fields of this register are logically OR'd together along with the OTG
 * Interrupt Status Register (OTGSTAT) to form a single interrupt source for the
 * processor's interrupt controller. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. This register
 * contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ISTAT register
 */
/*@{*/
#define USB_RD_ISTAT(base)       (USB_ISTAT_REG(base))
#define USB_WR_ISTAT(base, value) (USB_ISTAT_REG(base) = (value))
#define USB_RMW_ISTAT(base, mask, value) (USB_WR_ISTAT(base, (USB_RD_ISTAT(base) & ~(mask)) | (value)))
#define USB_SET_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) |  (value)))
#define USB_CLR_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) & ~(value)))
#define USB_TOG_ISTAT(base, value) (USB_WR_ISTAT(base, USB_RD_ISTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ISTAT bitfields
 */

/*!
 * @name Register USB_ISTAT, field USBRST[0] (W1C)
 *
 * This bit is set when the USB Module has decoded a valid USB reset. This
 * informs the processor that it should write 0x00 into the address register and
 * enable endpoint 0. USBRST is set after a USB reset has been detected for 2.5
 * microseconds. It is not asserted again until the USB reset condition has been
 * removed and then reasserted.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_USBRST field. */
#define USB_RD_ISTAT_USBRST(base) ((USB_ISTAT_REG(base) & USB_ISTAT_USBRST_MASK) >> USB_ISTAT_USBRST_SHIFT)
#define USB_BRD_ISTAT_USBRST(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_USBRST_SHIFT))

/*! @brief Set the USBRST field to a new value. */
#define USB_WR_ISTAT_USBRST(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_USBRST(value)))
#define USB_BWR_ISTAT_USBRST(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_USBRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ERROR[1] (W1C)
 *
 * This bit is set when any of the error conditions within Error Interrupt
 * Status (ERRSTAT) register occur. The processor must then read the ERRSTAT register
 * to determine the source of the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ERROR field. */
#define USB_RD_ISTAT_ERROR(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ERROR_MASK) >> USB_ISTAT_ERROR_SHIFT)
#define USB_BRD_ISTAT_ERROR(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ERROR_SHIFT))

/*! @brief Set the ERROR field to a new value. */
#define USB_WR_ISTAT_ERROR(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ERROR_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ERROR(value)))
#define USB_BWR_ISTAT_ERROR(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ERROR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SOFTOK[2] (W1C)
 *
 * This bit is set when the USB Module receives a Start Of Frame (SOF) token. In
 * Host mode this field is set when the SOF threshold is reached
 * (MISCCTRL[SOFBUSSET]=0), or when the SOF counter reaches 0 (MISCCTRL[SOFBUSSET]=1), so that
 * software can prepare for the next SOF.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SOFTOK field. */
#define USB_RD_ISTAT_SOFTOK(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SOFTOK_MASK) >> USB_ISTAT_SOFTOK_SHIFT)
#define USB_BRD_ISTAT_SOFTOK(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SOFTOK_SHIFT))

/*! @brief Set the SOFTOK field to a new value. */
#define USB_WR_ISTAT_SOFTOK(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SOFTOK_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SOFTOK(value)))
#define USB_BWR_ISTAT_SOFTOK(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SOFTOK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field TOKDNE[3] (W1C)
 *
 * This bit is set when the current token being processed has completed. The
 * processor must immediately read the STATUS (STAT) register to determine the
 * EndPoint and BD used for this token. Clearing this bit (by writing a one) causes
 * STAT to be cleared or the STAT holding register to be loaded into the STAT
 * register.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_TOKDNE field. */
#define USB_RD_ISTAT_TOKDNE(base) ((USB_ISTAT_REG(base) & USB_ISTAT_TOKDNE_MASK) >> USB_ISTAT_TOKDNE_SHIFT)
#define USB_BRD_ISTAT_TOKDNE(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_TOKDNE_SHIFT))

/*! @brief Set the TOKDNE field to a new value. */
#define USB_WR_ISTAT_TOKDNE(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_TOKDNE_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_TOKDNE(value)))
#define USB_BWR_ISTAT_TOKDNE(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_TOKDNE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field SLEEP[4] (W1C)
 *
 * This bit is set when the USB Module detects a constant idle on the USB bus
 * for 3 ms. The sleep timer is reset by activity on the USB bus.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_SLEEP field. */
#define USB_RD_ISTAT_SLEEP(base) ((USB_ISTAT_REG(base) & USB_ISTAT_SLEEP_MASK) >> USB_ISTAT_SLEEP_SHIFT)
#define USB_BRD_ISTAT_SLEEP(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SLEEP_SHIFT))

/*! @brief Set the SLEEP field to a new value. */
#define USB_WR_ISTAT_SLEEP(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_SLEEP_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_SLEEP(value)))
#define USB_BWR_ISTAT_SLEEP(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_SLEEP_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field RESUME[5] (W1C)
 *
 * This bit is set when a K-state is observed on the DP/DM signals for 2.5 us.
 * When not in suspend mode this interrupt must be disabled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_RESUME field. */
#define USB_RD_ISTAT_RESUME(base) ((USB_ISTAT_REG(base) & USB_ISTAT_RESUME_MASK) >> USB_ISTAT_RESUME_SHIFT)
#define USB_BRD_ISTAT_RESUME(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_RESUME_SHIFT))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_ISTAT_RESUME(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_RESUME_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_ATTACH_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_RESUME(value)))
#define USB_BWR_ISTAT_RESUME(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_RESUME_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field ATTACH[6] (W1C)
 *
 * This field is set when the USB Module detects an attach of a USB device. This
 * field is only valid if CTL[HOSTMODEEN]=1. This interrupt signifies that a
 * peripheral is now present and must be configured; it is asserted if there have
 * been no transitions on the USB for 2.5 us and the current bus state is not SE0."
 *
 * Values:
 * - 0 - No Attach is detected since the last time the ATTACH bit was cleared.
 * - 1 - A peripheral is now present and must be configured (a stable non-SE0
 *     state is detected for more than 2.5 us).
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_ATTACH field. */
#define USB_RD_ISTAT_ATTACH(base) ((USB_ISTAT_REG(base) & USB_ISTAT_ATTACH_MASK) >> USB_ISTAT_ATTACH_SHIFT)
#define USB_BRD_ISTAT_ATTACH(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ATTACH_SHIFT))

/*! @brief Set the ATTACH field to a new value. */
#define USB_WR_ISTAT_ATTACH(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_ATTACH_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_STALL_MASK), USB_ISTAT_ATTACH(value)))
#define USB_BWR_ISTAT_ATTACH(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_ATTACH_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ISTAT, field STALL[7] (W1C)
 *
 * In Target mode this bit is asserted when a STALL handshake is sent by the
 * SIE. In Host mode this bit is set when the USB Module detects a STALL acknowledge
 * during the handshake phase of a USB transaction.This interrupt can be used to
 * determine whether the last USB transaction was completed successfully or
 * stalled.
 */
/*@{*/
/*! @brief Read current value of the USB_ISTAT_STALL field. */
#define USB_RD_ISTAT_STALL(base) ((USB_ISTAT_REG(base) & USB_ISTAT_STALL_MASK) >> USB_ISTAT_STALL_SHIFT)
#define USB_BRD_ISTAT_STALL(base) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_STALL_SHIFT))

/*! @brief Set the STALL field to a new value. */
#define USB_WR_ISTAT_STALL(base, value) (USB_RMW_ISTAT(base, (USB_ISTAT_STALL_MASK | USB_ISTAT_USBRST_MASK | USB_ISTAT_ERROR_MASK | USB_ISTAT_SOFTOK_MASK | USB_ISTAT_TOKDNE_MASK | USB_ISTAT_SLEEP_MASK | USB_ISTAT_RESUME_MASK | USB_ISTAT_ATTACH_MASK), USB_ISTAT_STALL(value)))
#define USB_BWR_ISTAT_STALL(base, value) (BITBAND_ACCESS8(&USB_ISTAT_REG(base), USB_ISTAT_STALL_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_INTEN - Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief USB_INTEN - Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable fields for each of the interrupt sources within the USB
 * Module. Setting any of these bits enables the respective interrupt source in the
 * ISTAT register. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_INTEN register
 */
/*@{*/
#define USB_RD_INTEN(base)       (USB_INTEN_REG(base))
#define USB_WR_INTEN(base, value) (USB_INTEN_REG(base) = (value))
#define USB_RMW_INTEN(base, mask, value) (USB_WR_INTEN(base, (USB_RD_INTEN(base) & ~(mask)) | (value)))
#define USB_SET_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) |  (value)))
#define USB_CLR_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) & ~(value)))
#define USB_TOG_INTEN(base, value) (USB_WR_INTEN(base, USB_RD_INTEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_INTEN bitfields
 */

/*!
 * @name Register USB_INTEN, field USBRSTEN[0] (RW)
 *
 * Values:
 * - 0 - Disables the USBRST interrupt.
 * - 1 - Enables the USBRST interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_USBRSTEN field. */
#define USB_RD_INTEN_USBRSTEN(base) ((USB_INTEN_REG(base) & USB_INTEN_USBRSTEN_MASK) >> USB_INTEN_USBRSTEN_SHIFT)
#define USB_BRD_INTEN_USBRSTEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_USBRSTEN_SHIFT))

/*! @brief Set the USBRSTEN field to a new value. */
#define USB_WR_INTEN_USBRSTEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_USBRSTEN_MASK, USB_INTEN_USBRSTEN(value)))
#define USB_BWR_INTEN_USBRSTEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_USBRSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field ERROREN[1] (RW)
 *
 * Values:
 * - 0 - Disables the ERROR interrupt.
 * - 1 - Enables the ERROR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ERROREN field. */
#define USB_RD_INTEN_ERROREN(base) ((USB_INTEN_REG(base) & USB_INTEN_ERROREN_MASK) >> USB_INTEN_ERROREN_SHIFT)
#define USB_BRD_INTEN_ERROREN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ERROREN_SHIFT))

/*! @brief Set the ERROREN field to a new value. */
#define USB_WR_INTEN_ERROREN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ERROREN_MASK, USB_INTEN_ERROREN(value)))
#define USB_BWR_INTEN_ERROREN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ERROREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field SOFTOKEN[2] (RW)
 *
 * Values:
 * - 0 - Disbles the SOFTOK interrupt.
 * - 1 - Enables the SOFTOK interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SOFTOKEN field. */
#define USB_RD_INTEN_SOFTOKEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SOFTOKEN_MASK) >> USB_INTEN_SOFTOKEN_SHIFT)
#define USB_BRD_INTEN_SOFTOKEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SOFTOKEN_SHIFT))

/*! @brief Set the SOFTOKEN field to a new value. */
#define USB_WR_INTEN_SOFTOKEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SOFTOKEN_MASK, USB_INTEN_SOFTOKEN(value)))
#define USB_BWR_INTEN_SOFTOKEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SOFTOKEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field TOKDNEEN[3] (RW)
 *
 * Values:
 * - 0 - Disables the TOKDNE interrupt.
 * - 1 - Enables the TOKDNE interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_TOKDNEEN field. */
#define USB_RD_INTEN_TOKDNEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_TOKDNEEN_MASK) >> USB_INTEN_TOKDNEEN_SHIFT)
#define USB_BRD_INTEN_TOKDNEEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_TOKDNEEN_SHIFT))

/*! @brief Set the TOKDNEEN field to a new value. */
#define USB_WR_INTEN_TOKDNEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_TOKDNEEN_MASK, USB_INTEN_TOKDNEEN(value)))
#define USB_BWR_INTEN_TOKDNEEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_TOKDNEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field SLEEPEN[4] (RW)
 *
 * Values:
 * - 0 - Disables the SLEEP interrupt.
 * - 1 - Enables the SLEEP interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_SLEEPEN field. */
#define USB_RD_INTEN_SLEEPEN(base) ((USB_INTEN_REG(base) & USB_INTEN_SLEEPEN_MASK) >> USB_INTEN_SLEEPEN_SHIFT)
#define USB_BRD_INTEN_SLEEPEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SLEEPEN_SHIFT))

/*! @brief Set the SLEEPEN field to a new value. */
#define USB_WR_INTEN_SLEEPEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_SLEEPEN_MASK, USB_INTEN_SLEEPEN(value)))
#define USB_BWR_INTEN_SLEEPEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_SLEEPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field RESUMEEN[5] (RW)
 *
 * Values:
 * - 0 - Disables the RESUME interrupt.
 * - 1 - Enables the RESUME interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_RESUMEEN field. */
#define USB_RD_INTEN_RESUMEEN(base) ((USB_INTEN_REG(base) & USB_INTEN_RESUMEEN_MASK) >> USB_INTEN_RESUMEEN_SHIFT)
#define USB_BRD_INTEN_RESUMEEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_RESUMEEN_SHIFT))

/*! @brief Set the RESUMEEN field to a new value. */
#define USB_WR_INTEN_RESUMEEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_RESUMEEN_MASK, USB_INTEN_RESUMEEN(value)))
#define USB_BWR_INTEN_RESUMEEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_RESUMEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field ATTACHEN[6] (RW)
 *
 * Values:
 * - 0 - Disables the ATTACH interrupt.
 * - 1 - Enables the ATTACH interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_ATTACHEN field. */
#define USB_RD_INTEN_ATTACHEN(base) ((USB_INTEN_REG(base) & USB_INTEN_ATTACHEN_MASK) >> USB_INTEN_ATTACHEN_SHIFT)
#define USB_BRD_INTEN_ATTACHEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ATTACHEN_SHIFT))

/*! @brief Set the ATTACHEN field to a new value. */
#define USB_WR_INTEN_ATTACHEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_ATTACHEN_MASK, USB_INTEN_ATTACHEN(value)))
#define USB_BWR_INTEN_ATTACHEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_ATTACHEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_INTEN, field STALLEN[7] (RW)
 *
 * Values:
 * - 0 - Diasbles the STALL interrupt.
 * - 1 - Enables the STALL interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_INTEN_STALLEN field. */
#define USB_RD_INTEN_STALLEN(base) ((USB_INTEN_REG(base) & USB_INTEN_STALLEN_MASK) >> USB_INTEN_STALLEN_SHIFT)
#define USB_BRD_INTEN_STALLEN(base) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_STALLEN_SHIFT))

/*! @brief Set the STALLEN field to a new value. */
#define USB_WR_INTEN_STALLEN(base, value) (USB_RMW_INTEN(base, USB_INTEN_STALLEN_MASK, USB_INTEN_STALLEN(value)))
#define USB_BWR_INTEN_STALLEN(base, value) (BITBAND_ACCESS8(&USB_INTEN_REG(base), USB_INTEN_STALLEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ERRSTAT - Error Interrupt Status register
 ******************************************************************************/

/*!
 * @brief USB_ERRSTAT - Error Interrupt Status register (W1C)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error sources within the USB Module.
 * Each of these bits are qualified with their respective error enable bits. All
 * bits of this register are logically OR'd together and the result placed in the
 * ERROR bit of the ISTAT register. After an interrupt bit has been set it may only
 * be cleared by writing a one to the respective interrupt bit. Each bit is set
 * as soon as the error condition is detected. Therefore, the interrupt does not
 * typically correspond with the end of a token being processed. This register
 * contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERRSTAT register
 */
/*@{*/
#define USB_RD_ERRSTAT(base)     (USB_ERRSTAT_REG(base))
#define USB_WR_ERRSTAT(base, value) (USB_ERRSTAT_REG(base) = (value))
#define USB_RMW_ERRSTAT(base, mask, value) (USB_WR_ERRSTAT(base, (USB_RD_ERRSTAT(base) & ~(mask)) | (value)))
#define USB_SET_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) |  (value)))
#define USB_CLR_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) & ~(value)))
#define USB_TOG_ERRSTAT(base, value) (USB_WR_ERRSTAT(base, USB_RD_ERRSTAT(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERRSTAT bitfields
 */

/*!
 * @name Register USB_ERRSTAT, field PIDERR[0] (W1C)
 *
 * This bit is set when the PID check field fails.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_PIDERR field. */
#define USB_RD_ERRSTAT_PIDERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_PIDERR_MASK) >> USB_ERRSTAT_PIDERR_SHIFT)
#define USB_BRD_ERRSTAT_PIDERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_PIDERR_SHIFT))

/*! @brief Set the PIDERR field to a new value. */
#define USB_WR_ERRSTAT_PIDERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_PIDERR(value)))
#define USB_BWR_ERRSTAT_PIDERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_PIDERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC5EOF[1] (W1C)
 *
 * This error interrupt has two functions. When the USB Module is operating in
 * peripheral mode (CTL[HOSTMODEEN]=0), this interrupt detects CRC5 errors in the
 * token packets generated by the host. If set the token packet was rejected due
 * to a CRC5 error. When the USB Module is operating in host mode
 * (CTL[HOSTMODEEN]=1), this interrupt detects End Of Frame (EOF) error conditions. This occurs
 * when the USB Module is transmitting or receiving data and the SOF counter
 * reaches zero. This interrupt is useful when developing USB packet scheduling
 * software to ensure that no USB transactions cross the start of the next frame.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC5EOF field. */
#define USB_RD_ERRSTAT_CRC5EOF(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC5EOF_MASK) >> USB_ERRSTAT_CRC5EOF_SHIFT)
#define USB_BRD_ERRSTAT_CRC5EOF(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC5EOF_SHIFT))

/*! @brief Set the CRC5EOF field to a new value. */
#define USB_WR_ERRSTAT_CRC5EOF(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC5EOF(value)))
#define USB_BWR_ERRSTAT_CRC5EOF(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC5EOF_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field CRC16[2] (W1C)
 *
 * This bit is set when a data packet is rejected due to a CRC16 error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_CRC16 field. */
#define USB_RD_ERRSTAT_CRC16(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_CRC16_MASK) >> USB_ERRSTAT_CRC16_SHIFT)
#define USB_BRD_ERRSTAT_CRC16(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC16_SHIFT))

/*! @brief Set the CRC16 field to a new value. */
#define USB_WR_ERRSTAT_CRC16(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_CRC16(value)))
#define USB_BWR_ERRSTAT_CRC16(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_CRC16_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DFN8[3] (W1C)
 *
 * This bit is set if the data field received was not 8 bits in length. USB
 * Specification 1.0 requires that data fields be an integral number of bytes. If the
 * data field was not an integral number of bytes, this bit is set.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DFN8 field. */
#define USB_RD_ERRSTAT_DFN8(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DFN8_MASK) >> USB_ERRSTAT_DFN8_SHIFT)
#define USB_BRD_ERRSTAT_DFN8(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DFN8_SHIFT))

/*! @brief Set the DFN8 field to a new value. */
#define USB_WR_ERRSTAT_DFN8(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DFN8(value)))
#define USB_BWR_ERRSTAT_DFN8(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DFN8_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTOERR[4] (W1C)
 *
 * This bit is set when a bus turnaround timeout error occurs. The USB module
 * contains a bus turnaround timer that keeps track of the amount of time elapsed
 * between the token and data phases of a SETUP or OUT TOKEN or the data and
 * handshake phases of a IN TOKEN. If more than 16 bit times are counted from the
 * previous EOP before a transition from IDLE, a bus turnaround timeout error occurs.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTOERR field. */
#define USB_RD_ERRSTAT_BTOERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTOERR_MASK) >> USB_ERRSTAT_BTOERR_SHIFT)
#define USB_BRD_ERRSTAT_BTOERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTOERR_SHIFT))

/*! @brief Set the BTOERR field to a new value. */
#define USB_WR_ERRSTAT_BTOERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_BTOERR(value)))
#define USB_BWR_ERRSTAT_BTOERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTOERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field DMAERR[5] (W1C)
 *
 * This bit is set if the USB Module has requested a DMA access to read a new
 * BDT but has not been given the bus before it needs to receive or transmit data.
 * If processing a TX transfer this would cause a transmit data underflow
 * condition. If processing a RX transfer this would cause a receive data overflow
 * condition. This interrupt is useful when developing device arbitration hardware for
 * the microprocessor and the USB module to minimize bus request and bus grant
 * latency. This bit is also set if a data packet to or from the host is larger
 * than the buffer size allocated in the BDT. In this case the data packet is
 * truncated as it is put in buffer memory.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_DMAERR field. */
#define USB_RD_ERRSTAT_DMAERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_DMAERR_MASK) >> USB_ERRSTAT_DMAERR_SHIFT)
#define USB_BRD_ERRSTAT_DMAERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DMAERR_SHIFT))

/*! @brief Set the DMAERR field to a new value. */
#define USB_WR_ERRSTAT_DMAERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_DMAERR(value)))
#define USB_BWR_ERRSTAT_DMAERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_DMAERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field OWNERR[6] (W1C)
 *
 * This field is valid when the USB Module is operating in peripheral mode
 * (CTL[HOSTMODEEN]=0). It is set if the USB Module requires a new BD for SETUP, ISO
 * IN, or ISO OUT transfer while a new BD is not available.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_OWNERR field. */
#define USB_RD_ERRSTAT_OWNERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_OWNERR_MASK) >> USB_ERRSTAT_OWNERR_SHIFT)
#define USB_BRD_ERRSTAT_OWNERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_OWNERR_SHIFT))

/*! @brief Set the OWNERR field to a new value. */
#define USB_WR_ERRSTAT_OWNERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_OWNERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_BTSERR_MASK), USB_ERRSTAT_OWNERR(value)))
#define USB_BWR_ERRSTAT_OWNERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_OWNERR_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERRSTAT, field BTSERR[7] (W1C)
 *
 * This bit is set when a bit stuff error is detected. If set, the corresponding
 * packet is rejected due to the error.
 */
/*@{*/
/*! @brief Read current value of the USB_ERRSTAT_BTSERR field. */
#define USB_RD_ERRSTAT_BTSERR(base) ((USB_ERRSTAT_REG(base) & USB_ERRSTAT_BTSERR_MASK) >> USB_ERRSTAT_BTSERR_SHIFT)
#define USB_BRD_ERRSTAT_BTSERR(base) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTSERR_SHIFT))

/*! @brief Set the BTSERR field to a new value. */
#define USB_WR_ERRSTAT_BTSERR(base, value) (USB_RMW_ERRSTAT(base, (USB_ERRSTAT_BTSERR_MASK | USB_ERRSTAT_PIDERR_MASK | USB_ERRSTAT_CRC5EOF_MASK | USB_ERRSTAT_CRC16_MASK | USB_ERRSTAT_DFN8_MASK | USB_ERRSTAT_BTOERR_MASK | USB_ERRSTAT_DMAERR_MASK | USB_ERRSTAT_OWNERR_MASK), USB_ERRSTAT_BTSERR(value)))
#define USB_BWR_ERRSTAT_BTSERR(base, value) (BITBAND_ACCESS8(&USB_ERRSTAT_REG(base), USB_ERRSTAT_BTSERR_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ERREN - Error Interrupt Enable register
 ******************************************************************************/

/*!
 * @brief USB_ERREN - Error Interrupt Enable register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains enable bits for each of the error interrupt sources within the USB
 * module. Setting any of these bits enables the respective interrupt source in
 * ERRSTAT. Each bit is set as soon as the error condition is detected. Therefore,
 * the interrupt does not typically correspond with the end of a token being
 * processed. This register contains the value of 0x00 after a reset.
 */
/*!
 * @name Constants and macros for entire USB_ERREN register
 */
/*@{*/
#define USB_RD_ERREN(base)       (USB_ERREN_REG(base))
#define USB_WR_ERREN(base, value) (USB_ERREN_REG(base) = (value))
#define USB_RMW_ERREN(base, mask, value) (USB_WR_ERREN(base, (USB_RD_ERREN(base) & ~(mask)) | (value)))
#define USB_SET_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) |  (value)))
#define USB_CLR_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) & ~(value)))
#define USB_TOG_ERREN(base, value) (USB_WR_ERREN(base, USB_RD_ERREN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ERREN bitfields
 */

/*!
 * @name Register USB_ERREN, field PIDERREN[0] (RW)
 *
 * Values:
 * - 0 - Disables the PIDERR interrupt.
 * - 1 - Enters the PIDERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_PIDERREN field. */
#define USB_RD_ERREN_PIDERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_PIDERREN_MASK) >> USB_ERREN_PIDERREN_SHIFT)
#define USB_BRD_ERREN_PIDERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_PIDERREN_SHIFT))

/*! @brief Set the PIDERREN field to a new value. */
#define USB_WR_ERREN_PIDERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_PIDERREN_MASK, USB_ERREN_PIDERREN(value)))
#define USB_BWR_ERREN_PIDERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_PIDERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC5EOFEN[1] (RW)
 *
 * Values:
 * - 0 - Disables the CRC5/EOF interrupt.
 * - 1 - Enables the CRC5/EOF interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC5EOFEN field. */
#define USB_RD_ERREN_CRC5EOFEN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC5EOFEN_MASK) >> USB_ERREN_CRC5EOFEN_SHIFT)
#define USB_BRD_ERREN_CRC5EOFEN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC5EOFEN_SHIFT))

/*! @brief Set the CRC5EOFEN field to a new value. */
#define USB_WR_ERREN_CRC5EOFEN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC5EOFEN_MASK, USB_ERREN_CRC5EOFEN(value)))
#define USB_BWR_ERREN_CRC5EOFEN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC5EOFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field CRC16EN[2] (RW)
 *
 * Values:
 * - 0 - Disables the CRC16 interrupt.
 * - 1 - Enables the CRC16 interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_CRC16EN field. */
#define USB_RD_ERREN_CRC16EN(base) ((USB_ERREN_REG(base) & USB_ERREN_CRC16EN_MASK) >> USB_ERREN_CRC16EN_SHIFT)
#define USB_BRD_ERREN_CRC16EN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC16EN_SHIFT))

/*! @brief Set the CRC16EN field to a new value. */
#define USB_WR_ERREN_CRC16EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_CRC16EN_MASK, USB_ERREN_CRC16EN(value)))
#define USB_BWR_ERREN_CRC16EN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_CRC16EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field DFN8EN[3] (RW)
 *
 * Values:
 * - 0 - Disables the DFN8 interrupt.
 * - 1 - Enables the DFN8 interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DFN8EN field. */
#define USB_RD_ERREN_DFN8EN(base) ((USB_ERREN_REG(base) & USB_ERREN_DFN8EN_MASK) >> USB_ERREN_DFN8EN_SHIFT)
#define USB_BRD_ERREN_DFN8EN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DFN8EN_SHIFT))

/*! @brief Set the DFN8EN field to a new value. */
#define USB_WR_ERREN_DFN8EN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DFN8EN_MASK, USB_ERREN_DFN8EN(value)))
#define USB_BWR_ERREN_DFN8EN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DFN8EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTOERREN[4] (RW)
 *
 * Values:
 * - 0 - Disables the BTOERR interrupt.
 * - 1 - Enables the BTOERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTOERREN field. */
#define USB_RD_ERREN_BTOERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTOERREN_MASK) >> USB_ERREN_BTOERREN_SHIFT)
#define USB_BRD_ERREN_BTOERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTOERREN_SHIFT))

/*! @brief Set the BTOERREN field to a new value. */
#define USB_WR_ERREN_BTOERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTOERREN_MASK, USB_ERREN_BTOERREN(value)))
#define USB_BWR_ERREN_BTOERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTOERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field DMAERREN[5] (RW)
 *
 * Values:
 * - 0 - Disables the DMAERR interrupt.
 * - 1 - Enables the DMAERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_DMAERREN field. */
#define USB_RD_ERREN_DMAERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_DMAERREN_MASK) >> USB_ERREN_DMAERREN_SHIFT)
#define USB_BRD_ERREN_DMAERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DMAERREN_SHIFT))

/*! @brief Set the DMAERREN field to a new value. */
#define USB_WR_ERREN_DMAERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_DMAERREN_MASK, USB_ERREN_DMAERREN(value)))
#define USB_BWR_ERREN_DMAERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_DMAERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field OWNERREN[6] (RW)
 *
 * This field is valid when the USB module is operating in peripheral mode
 * (CTL[HOSTMODEEN]=0).
 *
 * Values:
 * - 0 - Disables the OWNERR interrupt.
 * - 1 - Enables the OWNERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_OWNERREN field. */
#define USB_RD_ERREN_OWNERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_OWNERREN_MASK) >> USB_ERREN_OWNERREN_SHIFT)
#define USB_BRD_ERREN_OWNERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_OWNERREN_SHIFT))

/*! @brief Set the OWNERREN field to a new value. */
#define USB_WR_ERREN_OWNERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_OWNERREN_MASK, USB_ERREN_OWNERREN(value)))
#define USB_BWR_ERREN_OWNERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_OWNERREN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ERREN, field BTSERREN[7] (RW)
 *
 * Values:
 * - 0 - Disables the BTSERR interrupt.
 * - 1 - Enables the BTSERR interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_ERREN_BTSERREN field. */
#define USB_RD_ERREN_BTSERREN(base) ((USB_ERREN_REG(base) & USB_ERREN_BTSERREN_MASK) >> USB_ERREN_BTSERREN_SHIFT)
#define USB_BRD_ERREN_BTSERREN(base) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTSERREN_SHIFT))

/*! @brief Set the BTSERREN field to a new value. */
#define USB_WR_ERREN_BTSERREN(base, value) (USB_RMW_ERREN(base, USB_ERREN_BTSERREN_MASK, USB_ERREN_BTSERREN(value)))
#define USB_BWR_ERREN_BTSERREN(base, value) (BITBAND_ACCESS8(&USB_ERREN_REG(base), USB_ERREN_BTSERREN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_STAT - Status register
 ******************************************************************************/

/*!
 * @brief USB_STAT - Status register (RO)
 *
 * Reset value: 0x00U
 *
 * Reports the transaction status within the USB module. When the processor's
 * interrupt controller has received a TOKDNE, interrupt the Status Register must
 * be read to determine the status of the previous endpoint communication. The
 * data in the status register is valid when TOKDNE interrupt is asserted. The
 * Status register is actually a read window into a status FIFO maintained by the USB
 * module. When the USB module uses a BD, it updates the Status register. If
 * another USB transaction is performed before the TOKDNE interrupt is serviced, the
 * USB module stores the status of the next transaction in the STAT FIFO. Thus
 * STAT is actually a four byte FIFO that allows the processor core to process one
 * transaction while the SIE is processing the next transaction. Clearing the
 * TOKDNE bit in the ISTAT register causes the SIE to update STAT with the contents
 * of the next STAT value. If the data in the STAT holding register is valid, the
 * SIE immediately reasserts to TOKDNE interrupt.
 */
/*!
 * @name Constants and macros for entire USB_STAT register
 */
/*@{*/
#define USB_RD_STAT(base)        (USB_STAT_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_STAT bitfields
 */

/*!
 * @name Register USB_STAT, field ODD[2] (RO)
 *
 * This bit is set if the last buffer descriptor updated was in the odd bank of
 * the BDT.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ODD field. */
#define USB_RD_STAT_ODD(base) ((USB_STAT_REG(base) & USB_STAT_ODD_MASK) >> USB_STAT_ODD_SHIFT)
#define USB_BRD_STAT_ODD(base) (BITBAND_ACCESS8(&USB_STAT_REG(base), USB_STAT_ODD_SHIFT))
/*@}*/

/*!
 * @name Register USB_STAT, field TX[3] (RO)
 *
 * Values:
 * - 0 - The most recent transaction was a receive operation.
 * - 1 - The most recent transaction was a transmit operation.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_TX field. */
#define USB_RD_STAT_TX(base) ((USB_STAT_REG(base) & USB_STAT_TX_MASK) >> USB_STAT_TX_SHIFT)
#define USB_BRD_STAT_TX(base) (BITBAND_ACCESS8(&USB_STAT_REG(base), USB_STAT_TX_SHIFT))
/*@}*/

/*!
 * @name Register USB_STAT, field ENDP[7:4] (RO)
 *
 * This four-bit field encodes the endpoint address that received or transmitted
 * the previous token. This allows the processor core to determine the BDT entry
 * that was updated by the last USB transaction.
 */
/*@{*/
/*! @brief Read current value of the USB_STAT_ENDP field. */
#define USB_RD_STAT_ENDP(base) ((USB_STAT_REG(base) & USB_STAT_ENDP_MASK) >> USB_STAT_ENDP_SHIFT)
#define USB_BRD_STAT_ENDP(base) (USB_RD_STAT_ENDP(base))
/*@}*/

/*******************************************************************************
 * USB_CTL - Control register
 ******************************************************************************/

/*!
 * @brief USB_CTL - Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Provides various control and configuration information for the USB module.
 */
/*!
 * @name Constants and macros for entire USB_CTL register
 */
/*@{*/
#define USB_RD_CTL(base)         (USB_CTL_REG(base))
#define USB_WR_CTL(base, value)  (USB_CTL_REG(base) = (value))
#define USB_RMW_CTL(base, mask, value) (USB_WR_CTL(base, (USB_RD_CTL(base) & ~(mask)) | (value)))
#define USB_SET_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) |  (value)))
#define USB_CLR_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) & ~(value)))
#define USB_TOG_CTL(base, value) (USB_WR_CTL(base, USB_RD_CTL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CTL bitfields
 */

/*!
 * @name Register USB_CTL, field USBENSOFEN[0] (RW)
 *
 * Setting this bit enables the USB-FS to operate; clearing it disables the
 * USB-FS. Setting the bit causes the SIE to reset all of its ODD bits to the BDTs.
 * Therefore, setting this bit resets much of the logic in the SIE. When host mode
 * is enabled, clearing this bit causes the SIE to stop sending SOF tokens.
 *
 * Values:
 * - 0 - Disables the USB Module.
 * - 1 - Enables the USB Module.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_USBENSOFEN field. */
#define USB_RD_CTL_USBENSOFEN(base) ((USB_CTL_REG(base) & USB_CTL_USBENSOFEN_MASK) >> USB_CTL_USBENSOFEN_SHIFT)
#define USB_BRD_CTL_USBENSOFEN(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_USBENSOFEN_SHIFT))

/*! @brief Set the USBENSOFEN field to a new value. */
#define USB_WR_CTL_USBENSOFEN(base, value) (USB_RMW_CTL(base, USB_CTL_USBENSOFEN_MASK, USB_CTL_USBENSOFEN(value)))
#define USB_BWR_CTL_USBENSOFEN(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_USBENSOFEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field ODDRST[1] (RW)
 *
 * Setting this bit to 1 resets all the BDT ODD ping/pong fields to 0, which
 * then specifies the EVEN BDT bank.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_ODDRST field. */
#define USB_RD_CTL_ODDRST(base) ((USB_CTL_REG(base) & USB_CTL_ODDRST_MASK) >> USB_CTL_ODDRST_SHIFT)
#define USB_BRD_CTL_ODDRST(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_ODDRST_SHIFT))

/*! @brief Set the ODDRST field to a new value. */
#define USB_WR_CTL_ODDRST(base, value) (USB_RMW_CTL(base, USB_CTL_ODDRST_MASK, USB_CTL_ODDRST(value)))
#define USB_BWR_CTL_ODDRST(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_ODDRST_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field RESUME[2] (RW)
 *
 * When set to 1 this bit enables the USB Module to execute resume signaling.
 * This allows the USB Module to perform remote wake-up. Software must set RESUME
 * to 1 for the required amount of time and then clear it to 0. If HOSTMODEENis
 * set, the USB module appends a Low Speed End of Packet to the Resume signaling
 * when the RESUME bit is cleared. For more information on RESUME signaling see
 * Section 7.1.4.5 of the USB specification version 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESUME field. */
#define USB_RD_CTL_RESUME(base) ((USB_CTL_REG(base) & USB_CTL_RESUME_MASK) >> USB_CTL_RESUME_SHIFT)
#define USB_BRD_CTL_RESUME(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESUME_SHIFT))

/*! @brief Set the RESUME field to a new value. */
#define USB_WR_CTL_RESUME(base, value) (USB_RMW_CTL(base, USB_CTL_RESUME_MASK, USB_CTL_RESUME(value)))
#define USB_BWR_CTL_RESUME(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESUME_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field HOSTMODEEN[3] (RW)
 *
 * When set to 1, this bit enables the USB Module to operate in Host mode. In
 * host mode, the USB module performs USB transactions under the programmed control
 * of the host processor.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_HOSTMODEEN field. */
#define USB_RD_CTL_HOSTMODEEN(base) ((USB_CTL_REG(base) & USB_CTL_HOSTMODEEN_MASK) >> USB_CTL_HOSTMODEEN_SHIFT)
#define USB_BRD_CTL_HOSTMODEEN(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_HOSTMODEEN_SHIFT))

/*! @brief Set the HOSTMODEEN field to a new value. */
#define USB_WR_CTL_HOSTMODEEN(base, value) (USB_RMW_CTL(base, USB_CTL_HOSTMODEEN_MASK, USB_CTL_HOSTMODEEN(value)))
#define USB_BWR_CTL_HOSTMODEEN(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_HOSTMODEEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field RESET[4] (RW)
 *
 * Setting this bit enables the USB Module to generate USB reset signaling. This
 * allows the USB Module to reset USB peripherals. This control signal is only
 * valid in Host mode (CTL[HOSTMODEEN]=1). Software must set RESET to 1 for the
 * required amount of time and then clear it to 0 to end reset signaling. For more
 * information on reset signaling see Section 7.1.4.3 of the USB specification
 * version 1.0.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_RESET field. */
#define USB_RD_CTL_RESET(base) ((USB_CTL_REG(base) & USB_CTL_RESET_MASK) >> USB_CTL_RESET_SHIFT)
#define USB_BRD_CTL_RESET(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESET_SHIFT))

/*! @brief Set the RESET field to a new value. */
#define USB_WR_CTL_RESET(base, value) (USB_RMW_CTL(base, USB_CTL_RESET_MASK, USB_CTL_RESET(value)))
#define USB_BWR_CTL_RESET(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_RESET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field TXSUSPENDTOKENBUSY[5] (RW)
 *
 * In Host mode, TOKEN_BUSY is set when the USB module is busy executing a USB
 * token. Software must not write more token commands to the Token Register when
 * TOKEN_BUSY is set. Software should check this field before writing any tokens
 * to the Token Register to ensure that token commands are not lost. In Target
 * mode, TXD_SUSPEND is set when the SIE has disabled packet transmission and
 * reception. Clearing this bit allows the SIE to continue token processing. This bit
 * is set by the SIE when a SETUP Token is received allowing software to dequeue
 * any pending packet transactions in the BDT before resuming token processing.
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_TXSUSPENDTOKENBUSY field. */
#define USB_RD_CTL_TXSUSPENDTOKENBUSY(base) ((USB_CTL_REG(base) & USB_CTL_TXSUSPENDTOKENBUSY_MASK) >> USB_CTL_TXSUSPENDTOKENBUSY_SHIFT)
#define USB_BRD_CTL_TXSUSPENDTOKENBUSY(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT))

/*! @brief Set the TXSUSPENDTOKENBUSY field to a new value. */
#define USB_WR_CTL_TXSUSPENDTOKENBUSY(base, value) (USB_RMW_CTL(base, USB_CTL_TXSUSPENDTOKENBUSY_MASK, USB_CTL_TXSUSPENDTOKENBUSY(value)))
#define USB_BWR_CTL_TXSUSPENDTOKENBUSY(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_TXSUSPENDTOKENBUSY_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field SE0[6] (RW)
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_SE0 field. */
#define USB_RD_CTL_SE0(base) ((USB_CTL_REG(base) & USB_CTL_SE0_MASK) >> USB_CTL_SE0_SHIFT)
#define USB_BRD_CTL_SE0(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_SE0_SHIFT))

/*! @brief Set the SE0 field to a new value. */
#define USB_WR_CTL_SE0(base, value) (USB_RMW_CTL(base, USB_CTL_SE0_MASK, USB_CTL_SE0(value)))
#define USB_BWR_CTL_SE0(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_SE0_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CTL, field JSTATE[7] (RW)
 *
 * The polarity of this signal is affected by the current state of LSEN .
 */
/*@{*/
/*! @brief Read current value of the USB_CTL_JSTATE field. */
#define USB_RD_CTL_JSTATE(base) ((USB_CTL_REG(base) & USB_CTL_JSTATE_MASK) >> USB_CTL_JSTATE_SHIFT)
#define USB_BRD_CTL_JSTATE(base) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_JSTATE_SHIFT))

/*! @brief Set the JSTATE field to a new value. */
#define USB_WR_CTL_JSTATE(base, value) (USB_RMW_CTL(base, USB_CTL_JSTATE_MASK, USB_CTL_JSTATE(value)))
#define USB_BWR_CTL_JSTATE(base, value) (BITBAND_ACCESS8(&USB_CTL_REG(base), USB_CTL_JSTATE_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_ADDR - Address register
 ******************************************************************************/

/*!
 * @brief USB_ADDR - Address register (RW)
 *
 * Reset value: 0x00U
 *
 * Holds the unique USB address that the USB module decodes when in Peripheral
 * mode (CTL[HOSTMODEEN]=0). When operating in Host mode (CTL[HOSTMODEEN]=1) the
 * USB module transmits this address with a TOKEN packet. This enables the USB
 * module to uniquely address any USB peripheral. In either mode, CTL[USBENSOFEN]
 * must be 1. The Address register is reset to 0x00 after the reset input becomes
 * active or the USB module decodes a USB reset signal. This action initializes
 * the Address register to decode address 0x00 as required by the USB specification.
 */
/*!
 * @name Constants and macros for entire USB_ADDR register
 */
/*@{*/
#define USB_RD_ADDR(base)        (USB_ADDR_REG(base))
#define USB_WR_ADDR(base, value) (USB_ADDR_REG(base) = (value))
#define USB_RMW_ADDR(base, mask, value) (USB_WR_ADDR(base, (USB_RD_ADDR(base) & ~(mask)) | (value)))
#define USB_SET_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) |  (value)))
#define USB_CLR_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) & ~(value)))
#define USB_TOG_ADDR(base, value) (USB_WR_ADDR(base, USB_RD_ADDR(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ADDR bitfields
 */

/*!
 * @name Register USB_ADDR, field ADDR[6:0] (RW)
 *
 * Defines the USB address that the USB module decodes in peripheral mode, or
 * transmits when in host mode.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_ADDR field. */
#define USB_RD_ADDR_ADDR(base) ((USB_ADDR_REG(base) & USB_ADDR_ADDR_MASK) >> USB_ADDR_ADDR_SHIFT)
#define USB_BRD_ADDR_ADDR(base) (USB_RD_ADDR_ADDR(base))

/*! @brief Set the ADDR field to a new value. */
#define USB_WR_ADDR_ADDR(base, value) (USB_RMW_ADDR(base, USB_ADDR_ADDR_MASK, USB_ADDR_ADDR(value)))
#define USB_BWR_ADDR_ADDR(base, value) (USB_WR_ADDR_ADDR(base, value))
/*@}*/

/*!
 * @name Register USB_ADDR, field LSEN[7] (RW)
 *
 * Informs the USB module that the next token command written to the token
 * register must be performed at low speed. This enables the USB module to perform the
 * necessary preamble required for low-speed data transmissions.
 */
/*@{*/
/*! @brief Read current value of the USB_ADDR_LSEN field. */
#define USB_RD_ADDR_LSEN(base) ((USB_ADDR_REG(base) & USB_ADDR_LSEN_MASK) >> USB_ADDR_LSEN_SHIFT)
#define USB_BRD_ADDR_LSEN(base) (BITBAND_ACCESS8(&USB_ADDR_REG(base), USB_ADDR_LSEN_SHIFT))

/*! @brief Set the LSEN field to a new value. */
#define USB_WR_ADDR_LSEN(base, value) (USB_RMW_ADDR(base, USB_ADDR_LSEN_MASK, USB_ADDR_LSEN(value)))
#define USB_BWR_ADDR_LSEN(base, value) (BITBAND_ACCESS8(&USB_ADDR_REG(base), USB_ADDR_LSEN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE1 - BDT Page register 1
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE1 - BDT Page register 1 (RW)
 *
 * Reset value: 0x00U
 *
 * Provides address bits 15 through 9 of the base address where the current
 * Buffer Descriptor Table (BDT) resides in system memory. See Buffer Descriptor
 * Table. The 32-bit BDT Base Address is always aligned on 512-byte boundaries, so
 * bits 8 through 0 of the base address are always zero.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE1 register
 */
/*@{*/
#define USB_RD_BDTPAGE1(base)    (USB_BDTPAGE1_REG(base))
#define USB_WR_BDTPAGE1(base, value) (USB_BDTPAGE1_REG(base) = (value))
#define USB_RMW_BDTPAGE1(base, mask, value) (USB_WR_BDTPAGE1(base, (USB_RD_BDTPAGE1(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) |  (value)))
#define USB_CLR_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) & ~(value)))
#define USB_TOG_BDTPAGE1(base, value) (USB_WR_BDTPAGE1(base, USB_RD_BDTPAGE1(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_BDTPAGE1 bitfields
 */

/*!
 * @name Register USB_BDTPAGE1, field BDTBA[7:1] (RW)
 *
 * Provides address bits 15 through 9 of the BDT base address.
 */
/*@{*/
/*! @brief Read current value of the USB_BDTPAGE1_BDTBA field. */
#define USB_RD_BDTPAGE1_BDTBA(base) ((USB_BDTPAGE1_REG(base) & USB_BDTPAGE1_BDTBA_MASK) >> USB_BDTPAGE1_BDTBA_SHIFT)
#define USB_BRD_BDTPAGE1_BDTBA(base) (USB_RD_BDTPAGE1_BDTBA(base))

/*! @brief Set the BDTBA field to a new value. */
#define USB_WR_BDTPAGE1_BDTBA(base, value) (USB_RMW_BDTPAGE1(base, USB_BDTPAGE1_BDTBA_MASK, USB_BDTPAGE1_BDTBA(value)))
#define USB_BWR_BDTPAGE1_BDTBA(base, value) (USB_WR_BDTPAGE1_BDTBA(base, value))
/*@}*/

/*******************************************************************************
 * USB_FRMNUML - Frame Number register Low
 ******************************************************************************/

/*!
 * @brief USB_FRMNUML - Frame Number register Low (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUML register
 */
/*@{*/
#define USB_RD_FRMNUML(base)     (USB_FRMNUML_REG(base))
#define USB_WR_FRMNUML(base, value) (USB_FRMNUML_REG(base) = (value))
#define USB_RMW_FRMNUML(base, mask, value) (USB_WR_FRMNUML(base, (USB_RD_FRMNUML(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) |  (value)))
#define USB_CLR_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) & ~(value)))
#define USB_TOG_FRMNUML(base, value) (USB_WR_FRMNUML(base, USB_RD_FRMNUML(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_FRMNUMH - Frame Number register High
 ******************************************************************************/

/*!
 * @brief USB_FRMNUMH - Frame Number register High (RW)
 *
 * Reset value: 0x00U
 *
 * The Frame Number registers (low and high) contain the 11-bit frame number.
 * These registers are updated with the current frame number whenever a SOF TOKEN
 * is received.
 */
/*!
 * @name Constants and macros for entire USB_FRMNUMH register
 */
/*@{*/
#define USB_RD_FRMNUMH(base)     (USB_FRMNUMH_REG(base))
#define USB_WR_FRMNUMH(base, value) (USB_FRMNUMH_REG(base) = (value))
#define USB_RMW_FRMNUMH(base, mask, value) (USB_WR_FRMNUMH(base, (USB_RD_FRMNUMH(base) & ~(mask)) | (value)))
#define USB_SET_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) |  (value)))
#define USB_CLR_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) & ~(value)))
#define USB_TOG_FRMNUMH(base, value) (USB_WR_FRMNUMH(base, USB_RD_FRMNUMH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_FRMNUMH bitfields
 */

/*!
 * @name Register USB_FRMNUMH, field FRM[2:0] (RW)
 *
 * This 3-bit field and the 8-bit field in the Frame Number Register Low are
 * used to compute the address where the current Buffer Descriptor Table (BDT)
 * resides in system memory.
 */
/*@{*/
/*! @brief Read current value of the USB_FRMNUMH_FRM field. */
#define USB_RD_FRMNUMH_FRM(base) ((USB_FRMNUMH_REG(base) & USB_FRMNUMH_FRM_MASK) >> USB_FRMNUMH_FRM_SHIFT)
#define USB_BRD_FRMNUMH_FRM(base) (USB_RD_FRMNUMH_FRM(base))

/*! @brief Set the FRM field to a new value. */
#define USB_WR_FRMNUMH_FRM(base, value) (USB_RMW_FRMNUMH(base, USB_FRMNUMH_FRM_MASK, USB_FRMNUMH_FRM(value)))
#define USB_BWR_FRMNUMH_FRM(base, value) (USB_WR_FRMNUMH_FRM(base, value))
/*@}*/

/*******************************************************************************
 * USB_TOKEN - Token register
 ******************************************************************************/

/*!
 * @brief USB_TOKEN - Token register (RW)
 *
 * Reset value: 0x00U
 *
 * Used to initiate USB transactions when in host mode (CTL[HOSTMODEEN]=1). When
 * the software needs to execute a USB transaction to a peripheral, it writes
 * the TOKEN type and endpoint to this register. After this register has been
 * written, the USB module begins the specified USB transaction to the address
 * contained in the address register. The processor core must always check that the
 * TOKEN_BUSY bit in the control register is not 1 before writing to the Token
 * Register. This ensures that the token commands are not overwritten before they can
 * be executed. The address register and endpoint control register 0 are also used
 * when performing a token command and therefore must also be written before the
 * Token Register. The address register is used to select the USB peripheral
 * address transmitted by the token command. The endpoint control register
 * determines the handshake and retry policies used during the transfer.
 */
/*!
 * @name Constants and macros for entire USB_TOKEN register
 */
/*@{*/
#define USB_RD_TOKEN(base)       (USB_TOKEN_REG(base))
#define USB_WR_TOKEN(base, value) (USB_TOKEN_REG(base) = (value))
#define USB_RMW_TOKEN(base, mask, value) (USB_WR_TOKEN(base, (USB_RD_TOKEN(base) & ~(mask)) | (value)))
#define USB_SET_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) |  (value)))
#define USB_CLR_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) & ~(value)))
#define USB_TOG_TOKEN(base, value) (USB_WR_TOKEN(base, USB_RD_TOKEN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_TOKEN bitfields
 */

/*!
 * @name Register USB_TOKEN, field TOKENENDPT[3:0] (RW)
 *
 * Holds the Endpoint address for the token command. The four bit value written
 * must be a valid endpoint.
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENENDPT field. */
#define USB_RD_TOKEN_TOKENENDPT(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENENDPT_MASK) >> USB_TOKEN_TOKENENDPT_SHIFT)
#define USB_BRD_TOKEN_TOKENENDPT(base) (USB_RD_TOKEN_TOKENENDPT(base))

/*! @brief Set the TOKENENDPT field to a new value. */
#define USB_WR_TOKEN_TOKENENDPT(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENENDPT_MASK, USB_TOKEN_TOKENENDPT(value)))
#define USB_BWR_TOKEN_TOKENENDPT(base, value) (USB_WR_TOKEN_TOKENENDPT(base, value))
/*@}*/

/*!
 * @name Register USB_TOKEN, field TOKENPID[7:4] (RW)
 *
 * Contains the token type executed by the USB module.
 *
 * Values:
 * - 0001 - OUT Token. USB Module performs an OUT (TX) transaction.
 * - 1001 - IN Token. USB Module performs an In (RX) transaction.
 * - 1101 - SETUP Token. USB Module performs a SETUP (TX) transaction
 */
/*@{*/
/*! @brief Read current value of the USB_TOKEN_TOKENPID field. */
#define USB_RD_TOKEN_TOKENPID(base) ((USB_TOKEN_REG(base) & USB_TOKEN_TOKENPID_MASK) >> USB_TOKEN_TOKENPID_SHIFT)
#define USB_BRD_TOKEN_TOKENPID(base) (USB_RD_TOKEN_TOKENPID(base))

/*! @brief Set the TOKENPID field to a new value. */
#define USB_WR_TOKEN_TOKENPID(base, value) (USB_RMW_TOKEN(base, USB_TOKEN_TOKENPID_MASK, USB_TOKEN_TOKENPID(value)))
#define USB_BWR_TOKEN_TOKENPID(base, value) (USB_WR_TOKEN_TOKENPID(base, value))
/*@}*/

/*******************************************************************************
 * USB_SOFTHLD - SOF Threshold register
 ******************************************************************************/

/*!
 * @brief USB_SOFTHLD - SOF Threshold register (RW)
 *
 * Reset value: 0x00U
 *
 * The SOF Threshold Register is used only in Host mode (CTL[HOSTMODEEN]=1).
 * When in Host mode, the 14-bit SOF counter counts the interval between SOF frames.
 * The SOF must be transmitted every 1ms so therefore the SOF counter is loaded
 * with a value of 12000. When the SOF counter reaches zero, a Start Of Frame
 * (SOF) token is transmitted. The SOF threshold register is used to program the
 * number of USB byte times when SOFDYNTHLD=0, or 8 byte times when SOFDYNTHLD=1,
 * before the SOF stops initiating token packet transactions. This register must be
 * set to a value that ensures that other packets are not actively being
 * transmitted when the SOF time counts to zero. When the SOF counter reaches the
 * threshold value, no more tokens are transmitted until after the SOF has been
 * transmitted. The value programmed into the threshold register must reserve enough
 * time to ensure the worst case transaction completes. In general the worst case
 * transaction is an IN token followed by a data packet from the target followed by
 * the response from the host. The actual time required is a function of the
 * maximum packet size on the bus. Typical values for the SOF threshold are: 64-byte
 * packets=74; 32-byte packets=42; 16-byte packets=26; 8-byte packets=18.
 */
/*!
 * @name Constants and macros for entire USB_SOFTHLD register
 */
/*@{*/
#define USB_RD_SOFTHLD(base)     (USB_SOFTHLD_REG(base))
#define USB_WR_SOFTHLD(base, value) (USB_SOFTHLD_REG(base) = (value))
#define USB_RMW_SOFTHLD(base, mask, value) (USB_WR_SOFTHLD(base, (USB_RD_SOFTHLD(base) & ~(mask)) | (value)))
#define USB_SET_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) |  (value)))
#define USB_CLR_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) & ~(value)))
#define USB_TOG_SOFTHLD(base, value) (USB_WR_SOFTHLD(base, USB_RD_SOFTHLD(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE2 - BDT Page Register 2
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE2 - BDT Page Register 2 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE2 register
 */
/*@{*/
#define USB_RD_BDTPAGE2(base)    (USB_BDTPAGE2_REG(base))
#define USB_WR_BDTPAGE2(base, value) (USB_BDTPAGE2_REG(base) = (value))
#define USB_RMW_BDTPAGE2(base, mask, value) (USB_WR_BDTPAGE2(base, (USB_RD_BDTPAGE2(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) |  (value)))
#define USB_CLR_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) & ~(value)))
#define USB_TOG_BDTPAGE2(base, value) (USB_WR_BDTPAGE2(base, USB_RD_BDTPAGE2(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_BDTPAGE3 - BDT Page Register 3
 ******************************************************************************/

/*!
 * @brief USB_BDTPAGE3 - BDT Page Register 3 (RW)
 *
 * Reset value: 0x00U
 *
 * Contains an 8-bit value used to compute the address where the current Buffer
 * Descriptor Table (BDT) resides in system memory. See Buffer Descriptor Table.
 */
/*!
 * @name Constants and macros for entire USB_BDTPAGE3 register
 */
/*@{*/
#define USB_RD_BDTPAGE3(base)    (USB_BDTPAGE3_REG(base))
#define USB_WR_BDTPAGE3(base, value) (USB_BDTPAGE3_REG(base) = (value))
#define USB_RMW_BDTPAGE3(base, mask, value) (USB_WR_BDTPAGE3(base, (USB_RD_BDTPAGE3(base) & ~(mask)) | (value)))
#define USB_SET_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) |  (value)))
#define USB_CLR_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) & ~(value)))
#define USB_TOG_BDTPAGE3(base, value) (USB_WR_BDTPAGE3(base, USB_RD_BDTPAGE3(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_ENDPT - Endpoint Control register
 ******************************************************************************/

/*!
 * @brief USB_ENDPT - Endpoint Control register (RW)
 *
 * Reset value: 0x00U
 *
 * Contains the endpoint control bits for each of the 16 endpoints available
 * within the USB module for a decoded address. The format for these registers is
 * shown in the following figure. Endpoint 0 (ENDPT0) is associated with control
 * pipe 0, which is required for all USB functions. Therefore, after a USBRST
 * interrupt occurs the processor core should set ENDPT0 to contain 0x0D. In Host mode
 * ENDPT0 is used to determine the handshake, retry and low speed
 * characteristics of the host transfer. For Control, Bulk and Interrupt transfers, the EPHSHK
 * bit should be 1. For Isochronous transfers it should be 0. Common values to
 * use for ENDPT0 in host mode are 0x4D for Control, Bulk, and Interrupt transfers,
 * and 0x4C for Isochronous transfers. The three bits EPCTLDIS, EPRXEN, and
 * EPTXEN define if an endpoint is enabled and define the direction of the endpoint.
 * The endpoint enable/direction control is defined in the following table.
 * Endpoint enable and direction control EPCTLDIS EPRXEN EPTXEN Endpoint
 * enable/direction control X 0 0 Disable endpoint X 0 1 Enable endpoint for Tx transfers only
 * X 1 0 Enable endpoint for Rx transfers only 1 1 1 Enable endpoint for Rx and
 * Tx transfers 0 1 1 Enable Endpoint for RX and TX as well as control (SETUP)
 * transfers.
 */
/*!
 * @name Constants and macros for entire USB_ENDPT register
 */
/*@{*/
#define USB_RD_ENDPT(base, index) (USB_ENDPT_REG(base, index))
#define USB_WR_ENDPT(base, index, value) (USB_ENDPT_REG(base, index) = (value))
#define USB_RMW_ENDPT(base, index, mask, value) (USB_WR_ENDPT(base, index, (USB_RD_ENDPT(base, index) & ~(mask)) | (value)))
#define USB_SET_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) |  (value)))
#define USB_CLR_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) & ~(value)))
#define USB_TOG_ENDPT(base, index, value) (USB_WR_ENDPT(base, index, USB_RD_ENDPT(base, index) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_ENDPT bitfields
 */

/*!
 * @name Register USB_ENDPT, field EPHSHK[0] (RW)
 *
 * When set this bit enables an endpoint to perform handshaking during a
 * transaction to this endpoint. This bit is generally 1 unless the endpoint is
 * Isochronous.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPHSHK field. */
#define USB_RD_ENDPT_EPHSHK(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPHSHK_MASK) >> USB_ENDPT_EPHSHK_SHIFT)
#define USB_BRD_ENDPT_EPHSHK(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPHSHK_SHIFT))

/*! @brief Set the EPHSHK field to a new value. */
#define USB_WR_ENDPT_EPHSHK(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPHSHK_MASK, USB_ENDPT_EPHSHK(value)))
#define USB_BWR_ENDPT_EPHSHK(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPHSHK_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPSTALL[1] (RW)
 *
 * When set this bit indicates that the endpoint is called. This bit has
 * priority over all other control bits in the EndPoint Enable Register, but it is only
 * valid if EPTXEN=1 or EPRXEN=1. Any access to this endpoint causes the USB
 * Module to return a STALL handshake. After an endpoint is stalled it requires
 * intervention from the Host Controller.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPSTALL field. */
#define USB_RD_ENDPT_EPSTALL(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPSTALL_MASK) >> USB_ENDPT_EPSTALL_SHIFT)
#define USB_BRD_ENDPT_EPSTALL(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPSTALL_SHIFT))

/*! @brief Set the EPSTALL field to a new value. */
#define USB_WR_ENDPT_EPSTALL(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPSTALL_MASK, USB_ENDPT_EPSTALL(value)))
#define USB_BWR_ENDPT_EPSTALL(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPSTALL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPTXEN[2] (RW)
 *
 * This bit, when set, enables the endpoint for TX transfers. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPTXEN field. */
#define USB_RD_ENDPT_EPTXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPTXEN_MASK) >> USB_ENDPT_EPTXEN_SHIFT)
#define USB_BRD_ENDPT_EPTXEN(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPTXEN_SHIFT))

/*! @brief Set the EPTXEN field to a new value. */
#define USB_WR_ENDPT_EPTXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPTXEN_MASK, USB_ENDPT_EPTXEN(value)))
#define USB_BWR_ENDPT_EPTXEN(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPTXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPRXEN[3] (RW)
 *
 * This bit, when set, enables the endpoint for RX transfers. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPRXEN field. */
#define USB_RD_ENDPT_EPRXEN(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPRXEN_MASK) >> USB_ENDPT_EPRXEN_SHIFT)
#define USB_BRD_ENDPT_EPRXEN(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPRXEN_SHIFT))

/*! @brief Set the EPRXEN field to a new value. */
#define USB_WR_ENDPT_EPRXEN(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPRXEN_MASK, USB_ENDPT_EPRXEN(value)))
#define USB_BWR_ENDPT_EPRXEN(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPRXEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field EPCTLDIS[4] (RW)
 *
 * This bit, when set, disables control (SETUP) transfers. When cleared, control
 * transfers are enabled. This applies if and only if the EPRXEN and EPTXEN bits
 * are also set. See
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_EPCTLDIS field. */
#define USB_RD_ENDPT_EPCTLDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_EPCTLDIS_MASK) >> USB_ENDPT_EPCTLDIS_SHIFT)
#define USB_BRD_ENDPT_EPCTLDIS(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPCTLDIS_SHIFT))

/*! @brief Set the EPCTLDIS field to a new value. */
#define USB_WR_ENDPT_EPCTLDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_EPCTLDIS_MASK, USB_ENDPT_EPCTLDIS(value)))
#define USB_BWR_ENDPT_EPCTLDIS(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_EPCTLDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field RETRYDIS[6] (RW)
 *
 * This is a Host mode only bit and is present in the control register for
 * endpoint 0 (ENDPT0) only. When set this bit causes the host to not retry NAK'ed
 * (Negative Acknowledgement) transactions. When a transaction is NAKed, the BDT PID
 * field is updated with the NAK PID, and the TOKEN_DNE interrupt is set. When
 * this bit is cleared, NAKed transactions are retried in hardware. This bit must
 * be set when the host is attempting to poll an interrupt endpoint.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_RETRYDIS field. */
#define USB_RD_ENDPT_RETRYDIS(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_RETRYDIS_MASK) >> USB_ENDPT_RETRYDIS_SHIFT)
#define USB_BRD_ENDPT_RETRYDIS(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_RETRYDIS_SHIFT))

/*! @brief Set the RETRYDIS field to a new value. */
#define USB_WR_ENDPT_RETRYDIS(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_RETRYDIS_MASK, USB_ENDPT_RETRYDIS(value)))
#define USB_BWR_ENDPT_RETRYDIS(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_RETRYDIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_ENDPT, field HOSTWOHUB[7] (RW)
 *
 * Host without a hub This is a Host mode only field and is present in the
 * control register for endpoint 0 (ENDPT0) only.
 *
 * Values:
 * - 0 - Low-speed device connected to Host through a hub. PRE_PID will be
 *     generated as required.
 * - 1 - Low-speed device directly connected. No hub, or no low-speed device
 *     attached.
 */
/*@{*/
/*! @brief Read current value of the USB_ENDPT_HOSTWOHUB field. */
#define USB_RD_ENDPT_HOSTWOHUB(base, index) ((USB_ENDPT_REG(base, index) & USB_ENDPT_HOSTWOHUB_MASK) >> USB_ENDPT_HOSTWOHUB_SHIFT)
#define USB_BRD_ENDPT_HOSTWOHUB(base, index) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_HOSTWOHUB_SHIFT))

/*! @brief Set the HOSTWOHUB field to a new value. */
#define USB_WR_ENDPT_HOSTWOHUB(base, index, value) (USB_RMW_ENDPT(base, index, USB_ENDPT_HOSTWOHUB_MASK, USB_ENDPT_HOSTWOHUB(value)))
#define USB_BWR_ENDPT_HOSTWOHUB(base, index, value) (BITBAND_ACCESS8(&USB_ENDPT_REG(base, index), USB_ENDPT_HOSTWOHUB_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_USBCTRL - USB Control register
 ******************************************************************************/

/*!
 * @brief USB_USBCTRL - USB Control register (RW)
 *
 * Reset value: 0xC0U
 */
/*!
 * @name Constants and macros for entire USB_USBCTRL register
 */
/*@{*/
#define USB_RD_USBCTRL(base)     (USB_USBCTRL_REG(base))
#define USB_WR_USBCTRL(base, value) (USB_USBCTRL_REG(base) = (value))
#define USB_RMW_USBCTRL(base, mask, value) (USB_WR_USBCTRL(base, (USB_RD_USBCTRL(base) & ~(mask)) | (value)))
#define USB_SET_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) |  (value)))
#define USB_CLR_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) & ~(value)))
#define USB_TOG_USBCTRL(base, value) (USB_WR_USBCTRL(base, USB_RD_USBCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBCTRL bitfields
 */

/*!
 * @name Register USB_USBCTRL, field UARTSEL[4] (RW)
 *
 * Selects USB signals to be used as UART signals.
 *
 * Values:
 * - 0 - USB signals not used as UART signals.
 * - 1 - USB signals used as UART signals.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_UARTSEL field. */
#define USB_RD_USBCTRL_UARTSEL(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_UARTSEL_MASK) >> USB_USBCTRL_UARTSEL_SHIFT)
#define USB_BRD_USBCTRL_UARTSEL(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTSEL_SHIFT))

/*! @brief Set the UARTSEL field to a new value. */
#define USB_WR_USBCTRL_UARTSEL(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_UARTSEL_MASK, USB_USBCTRL_UARTSEL(value)))
#define USB_BWR_USBCTRL_UARTSEL(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field UARTCHLS[5] (RW)
 *
 * This field is valid only when USB signals are selected to be used as UART
 * signals.
 *
 * Values:
 * - 0 - USB DP/DM signals used as UART TX/RX.
 * - 1 - USB DP/DM signals used as UART RX/TX.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_UARTCHLS field. */
#define USB_RD_USBCTRL_UARTCHLS(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_UARTCHLS_MASK) >> USB_USBCTRL_UARTCHLS_SHIFT)
#define USB_BRD_USBCTRL_UARTCHLS(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTCHLS_SHIFT))

/*! @brief Set the UARTCHLS field to a new value. */
#define USB_WR_USBCTRL_UARTCHLS(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_UARTCHLS_MASK, USB_USBCTRL_UARTCHLS(value)))
#define USB_BWR_USBCTRL_UARTCHLS(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_UARTCHLS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field PDE[6] (RW)
 *
 * Enables the weak pulldowns on the USB transceiver.
 *
 * Values:
 * - 0 - Weak pulldowns are disabled on D+ and D-.
 * - 1 - Weak pulldowns are enabled on D+ and D-.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_PDE field. */
#define USB_RD_USBCTRL_PDE(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_PDE_MASK) >> USB_USBCTRL_PDE_SHIFT)
#define USB_BRD_USBCTRL_PDE(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_PDE_SHIFT))

/*! @brief Set the PDE field to a new value. */
#define USB_WR_USBCTRL_PDE(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_PDE_MASK, USB_USBCTRL_PDE(value)))
#define USB_BWR_USBCTRL_PDE(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_PDE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBCTRL, field SUSP[7] (RW)
 *
 * Places the USB transceiver into the suspend state.
 *
 * Values:
 * - 0 - USB transceiver is not in suspend state.
 * - 1 - USB transceiver is in suspend state.
 */
/*@{*/
/*! @brief Read current value of the USB_USBCTRL_SUSP field. */
#define USB_RD_USBCTRL_SUSP(base) ((USB_USBCTRL_REG(base) & USB_USBCTRL_SUSP_MASK) >> USB_USBCTRL_SUSP_SHIFT)
#define USB_BRD_USBCTRL_SUSP(base) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_SUSP_SHIFT))

/*! @brief Set the SUSP field to a new value. */
#define USB_WR_USBCTRL_SUSP(base, value) (USB_RMW_USBCTRL(base, USB_USBCTRL_SUSP_MASK, USB_USBCTRL_SUSP(value)))
#define USB_BWR_USBCTRL_SUSP(base, value) (BITBAND_ACCESS8(&USB_USBCTRL_REG(base), USB_USBCTRL_SUSP_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_OBSERVE - USB OTG Observe register
 ******************************************************************************/

/*!
 * @brief USB_OBSERVE - USB OTG Observe register (RO)
 *
 * Reset value: 0x50U
 *
 * Provides visibility on the state of the pull-ups and pull-downs at the
 * transceiver. Useful when interfacing to an external OTG control module via a serial
 * interface.
 */
/*!
 * @name Constants and macros for entire USB_OBSERVE register
 */
/*@{*/
#define USB_RD_OBSERVE(base)     (USB_OBSERVE_REG(base))
/*@}*/

/*
 * Constants & macros for individual USB_OBSERVE bitfields
 */

/*!
 * @name Register USB_OBSERVE, field DMPD[4] (RO)
 *
 * Provides observability of the D- Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D- pulldown disabled.
 * - 1 - D- pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DMPD field. */
#define USB_RD_OBSERVE_DMPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DMPD_MASK) >> USB_OBSERVE_DMPD_SHIFT)
#define USB_BRD_OBSERVE_DMPD(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DMPD_SHIFT))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPD[6] (RO)
 *
 * Provides observability of the D+ Pulldown enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pulldown disabled.
 * - 1 - D+ pulldown enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPD field. */
#define USB_RD_OBSERVE_DPPD(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPD_MASK) >> USB_OBSERVE_DPPD_SHIFT)
#define USB_BRD_OBSERVE_DPPD(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPD_SHIFT))
/*@}*/

/*!
 * @name Register USB_OBSERVE, field DPPU[7] (RO)
 *
 * Provides observability of the D+ Pullup enable at the USB transceiver.
 *
 * Values:
 * - 0 - D+ pullup disabled.
 * - 1 - D+ pullup enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_OBSERVE_DPPU field. */
#define USB_RD_OBSERVE_DPPU(base) ((USB_OBSERVE_REG(base) & USB_OBSERVE_DPPU_MASK) >> USB_OBSERVE_DPPU_SHIFT)
#define USB_BRD_OBSERVE_DPPU(base) (BITBAND_ACCESS8(&USB_OBSERVE_REG(base), USB_OBSERVE_DPPU_SHIFT))
/*@}*/

/*******************************************************************************
 * USB_CONTROL - USB OTG Control register
 ******************************************************************************/

/*!
 * @brief USB_CONTROL - USB OTG Control register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_CONTROL register
 */
/*@{*/
#define USB_RD_CONTROL(base)     (USB_CONTROL_REG(base))
#define USB_WR_CONTROL(base, value) (USB_CONTROL_REG(base) = (value))
#define USB_RMW_CONTROL(base, mask, value) (USB_WR_CONTROL(base, (USB_RD_CONTROL(base) & ~(mask)) | (value)))
#define USB_SET_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) |  (value)))
#define USB_CLR_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) & ~(value)))
#define USB_TOG_CONTROL(base, value) (USB_WR_CONTROL(base, USB_RD_CONTROL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CONTROL bitfields
 */

/*!
 * @name Register USB_CONTROL, field DPPULLUPNONOTG[4] (RW)
 *
 * Provides control of the DP Pullup in USBOTG, if USB is configured in non-OTG
 * device mode.
 *
 * Values:
 * - 0 - DP Pullup in non-OTG device mode is not enabled.
 * - 1 - DP Pullup in non-OTG device mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_CONTROL_DPPULLUPNONOTG field. */
#define USB_RD_CONTROL_DPPULLUPNONOTG(base) ((USB_CONTROL_REG(base) & USB_CONTROL_DPPULLUPNONOTG_MASK) >> USB_CONTROL_DPPULLUPNONOTG_SHIFT)
#define USB_BRD_CONTROL_DPPULLUPNONOTG(base) (BITBAND_ACCESS8(&USB_CONTROL_REG(base), USB_CONTROL_DPPULLUPNONOTG_SHIFT))

/*! @brief Set the DPPULLUPNONOTG field to a new value. */
#define USB_WR_CONTROL_DPPULLUPNONOTG(base, value) (USB_RMW_CONTROL(base, USB_CONTROL_DPPULLUPNONOTG_MASK, USB_CONTROL_DPPULLUPNONOTG(value)))
#define USB_BWR_CONTROL_DPPULLUPNONOTG(base, value) (BITBAND_ACCESS8(&USB_CONTROL_REG(base), USB_CONTROL_DPPULLUPNONOTG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_USBTRC0 - USB Transceiver Control register 0
 ******************************************************************************/

/*!
 * @brief USB_USBTRC0 - USB Transceiver Control register 0 (RW)
 *
 * Reset value: 0x00U
 *
 * Includes signals for basic operation of the on-chip USB Full Speed
 * transceiver and configuration of the USB data connection that are not otherwise included
 * in the USB Full Speed controller registers.
 */
/*!
 * @name Constants and macros for entire USB_USBTRC0 register
 */
/*@{*/
#define USB_RD_USBTRC0(base)     (USB_USBTRC0_REG(base))
#define USB_WR_USBTRC0(base, value) (USB_USBTRC0_REG(base) = (value))
#define USB_RMW_USBTRC0(base, mask, value) (USB_WR_USBTRC0(base, (USB_RD_USBTRC0(base) & ~(mask)) | (value)))
#define USB_SET_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) |  (value)))
#define USB_CLR_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) & ~(value)))
#define USB_TOG_USBTRC0(base, value) (USB_WR_USBTRC0(base, USB_RD_USBTRC0(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_USBTRC0 bitfields
 */

/*!
 * @name Register USB_USBTRC0, field USB_RESUME_INT[0] (RO)
 *
 * Values:
 * - 0 - No interrupt was generated.
 * - 1 - Interrupt was generated because of the USB asynchronous interrupt.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USB_RESUME_INT field. */
#define USB_RD_USBTRC0_USB_RESUME_INT(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USB_RESUME_INT_MASK) >> USB_USBTRC0_USB_RESUME_INT_SHIFT)
#define USB_BRD_USBTRC0_USB_RESUME_INT(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USB_RESUME_INT_SHIFT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field SYNC_DET[1] (RO)
 *
 * Values:
 * - 0 - Synchronous interrupt has not been detected.
 * - 1 - Synchronous interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_SYNC_DET field. */
#define USB_RD_USBTRC0_SYNC_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_SYNC_DET_MASK) >> USB_USBTRC0_SYNC_DET_SHIFT)
#define USB_BRD_USBTRC0_SYNC_DET(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_SYNC_DET_SHIFT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USB_CLK_RECOVERY_INT[2] (RO)
 *
 * This read-only field will be set to value high at 1'b1 when any of USB clock
 * recovery interrupt conditions are detected and those interrupts are unmasked.
 * For customer use the only unmasked USB clock recovery interrupt condition
 * results from an overflow of the frequency trim setting values indicating that the
 * frequency trim calculated is out of the adjustment range of the IRC48M output
 * clock. To clear this bit after it has been set, Write 0xFF to register
 * USB_CLK_RECOVER_INT_STATUS.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USB_CLK_RECOVERY_INT field. */
#define USB_RD_USBTRC0_USB_CLK_RECOVERY_INT(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USB_CLK_RECOVERY_INT_MASK) >> USB_USBTRC0_USB_CLK_RECOVERY_INT_SHIFT)
#define USB_BRD_USBTRC0_USB_CLK_RECOVERY_INT(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USB_CLK_RECOVERY_INT_SHIFT))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field VREDG_DET[3] (RW)
 *
 * Values:
 * - 0 - VBUS rising edge interrupt has not been detected.
 * - 1 - VBUS rising edge interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_VREDG_DET field. */
#define USB_RD_USBTRC0_VREDG_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_VREDG_DET_MASK) >> USB_USBTRC0_VREDG_DET_SHIFT)
#define USB_BRD_USBTRC0_VREDG_DET(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_VREDG_DET_SHIFT))

/*! @brief Set the VREDG_DET field to a new value. */
#define USB_WR_USBTRC0_VREDG_DET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_VREDG_DET_MASK, USB_USBTRC0_VREDG_DET(value)))
#define USB_BWR_USBTRC0_VREDG_DET(base, value) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_VREDG_DET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field VFEDG_DET[4] (RW)
 *
 * Values:
 * - 0 - VBUS falling edge interrupt has not been detected.
 * - 1 - VBUS falling edge interrupt has been detected.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_VFEDG_DET field. */
#define USB_RD_USBTRC0_VFEDG_DET(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_VFEDG_DET_MASK) >> USB_USBTRC0_VFEDG_DET_SHIFT)
#define USB_BRD_USBTRC0_VFEDG_DET(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_VFEDG_DET_SHIFT))

/*! @brief Set the VFEDG_DET field to a new value. */
#define USB_WR_USBTRC0_VFEDG_DET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_VFEDG_DET_MASK, USB_USBTRC0_VFEDG_DET(value)))
#define USB_BWR_USBTRC0_VFEDG_DET(base, value) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_VFEDG_DET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESMEN[5] (RW)
 *
 * This bit, when set, allows the USB module to send an asynchronous wakeup
 * event to the MCU upon detection of resume signaling on the USB bus. The MCU then
 * re-enables clocks to the USB module. It is used for low-power suspend mode when
 * USB module clocks are stopped or the USB transceiver is in Suspend mode.
 * Async wakeup only works in device mode.
 *
 * Values:
 * - 0 - USB asynchronous wakeup from suspend mode disabled.
 * - 1 - USB asynchronous wakeup from suspend mode enabled. The asynchronous
 *     resume interrupt differs from the synchronous resume interrupt in that it
 *     asynchronously detects K-state using the unfiltered state of the D+ and D-
 *     pins. This interrupt should only be enabled when the Transceiver is
 *     suspended.
 */
/*@{*/
/*! @brief Read current value of the USB_USBTRC0_USBRESMEN field. */
#define USB_RD_USBTRC0_USBRESMEN(base) ((USB_USBTRC0_REG(base) & USB_USBTRC0_USBRESMEN_MASK) >> USB_USBTRC0_USBRESMEN_SHIFT)
#define USB_BRD_USBTRC0_USBRESMEN(base) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USBRESMEN_SHIFT))

/*! @brief Set the USBRESMEN field to a new value. */
#define USB_WR_USBTRC0_USBRESMEN(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESMEN_MASK, USB_USBTRC0_USBRESMEN(value)))
#define USB_BWR_USBTRC0_USBRESMEN(base, value) (BITBAND_ACCESS8(&USB_USBTRC0_REG(base), USB_USBTRC0_USBRESMEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_USBTRC0, field USBRESET[7] (WO)
 *
 * Generates a hard reset to USBOTG. After this bit is set and the reset occurs,
 * this bit is automatically cleared. This bit is always read as zero. Wait two
 * USB clock cycles after setting this bit.
 *
 * Values:
 * - 0 - Normal USB module operation.
 * - 1 - Returns the USB module to its reset state.
 */
/*@{*/
/*! @brief Set the USBRESET field to a new value. */
#define USB_WR_USBTRC0_USBRESET(base, value) (USB_RMW_USBTRC0(base, USB_USBTRC0_USBRESET_MASK, USB_USBTRC0_USBRESET(value)))
#define USB_BWR_USBTRC0_USBRESET(base, value) (USB_WR_USBTRC0_USBRESET(base, value))
/*@}*/

/*******************************************************************************
 * USB_USBFRMADJUST - Frame Adjust Register
 ******************************************************************************/

/*!
 * @brief USB_USBFRMADJUST - Frame Adjust Register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_USBFRMADJUST register
 */
/*@{*/
#define USB_RD_USBFRMADJUST(base) (USB_USBFRMADJUST_REG(base))
#define USB_WR_USBFRMADJUST(base, value) (USB_USBFRMADJUST_REG(base) = (value))
#define USB_RMW_USBFRMADJUST(base, mask, value) (USB_WR_USBFRMADJUST(base, (USB_RD_USBFRMADJUST(base) & ~(mask)) | (value)))
#define USB_SET_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) |  (value)))
#define USB_CLR_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) & ~(value)))
#define USB_TOG_USBFRMADJUST(base, value) (USB_WR_USBFRMADJUST(base, USB_RD_USBFRMADJUST(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * USB_MISCCTRL - Miscellaneous Control register
 ******************************************************************************/

/*!
 * @brief USB_MISCCTRL - Miscellaneous Control register (RW)
 *
 * Reset value: 0x00U
 */
/*!
 * @name Constants and macros for entire USB_MISCCTRL register
 */
/*@{*/
#define USB_RD_MISCCTRL(base)    (USB_MISCCTRL_REG(base))
#define USB_WR_MISCCTRL(base, value) (USB_MISCCTRL_REG(base) = (value))
#define USB_RMW_MISCCTRL(base, mask, value) (USB_WR_MISCCTRL(base, (USB_RD_MISCCTRL(base) & ~(mask)) | (value)))
#define USB_SET_MISCCTRL(base, value) (USB_WR_MISCCTRL(base, USB_RD_MISCCTRL(base) |  (value)))
#define USB_CLR_MISCCTRL(base, value) (USB_WR_MISCCTRL(base, USB_RD_MISCCTRL(base) & ~(value)))
#define USB_TOG_MISCCTRL(base, value) (USB_WR_MISCCTRL(base, USB_RD_MISCCTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_MISCCTRL bitfields
 */

/*!
 * @name Register USB_MISCCTRL, field SOFDYNTHLD[0] (RW)
 *
 * This field is only valid for Host mode, that is, CTL[HOSTMODEEN]=1.
 *
 * Values:
 * - 0 - SOF_TOK interrupt is set when byte times SOF threshold is reached.
 * - 1 - SOF_TOK interrupt is set when 8 byte times SOF threshold is reached or
 *     overstepped.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_SOFDYNTHLD field. */
#define USB_RD_MISCCTRL_SOFDYNTHLD(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_SOFDYNTHLD_MASK) >> USB_MISCCTRL_SOFDYNTHLD_SHIFT)
#define USB_BRD_MISCCTRL_SOFDYNTHLD(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFDYNTHLD_SHIFT))

/*! @brief Set the SOFDYNTHLD field to a new value. */
#define USB_WR_MISCCTRL_SOFDYNTHLD(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_SOFDYNTHLD_MASK, USB_MISCCTRL_SOFDYNTHLD(value)))
#define USB_BWR_MISCCTRL_SOFDYNTHLD(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFDYNTHLD_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field SOFBUSSET[1] (RW)
 *
 * This field is only valid for Host mode, that is, CTL[HOSTMODEEN]=1.
 *
 * Values:
 * - 0 - SOF_TOK interrupt is set according to SOF threshold value.
 * - 1 - SOF_TOK interrupt is set when SOF counter reaches 0.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_SOFBUSSET field. */
#define USB_RD_MISCCTRL_SOFBUSSET(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_SOFBUSSET_MASK) >> USB_MISCCTRL_SOFBUSSET_SHIFT)
#define USB_BRD_MISCCTRL_SOFBUSSET(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFBUSSET_SHIFT))

/*! @brief Set the SOFBUSSET field to a new value. */
#define USB_WR_MISCCTRL_SOFBUSSET(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_SOFBUSSET_MASK, USB_MISCCTRL_SOFBUSSET(value)))
#define USB_BWR_MISCCTRL_SOFBUSSET(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_SOFBUSSET_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field OWNERRISODIS[2] (RW)
 *
 * This field is only valid for Peripheral mode, that is, CTL[HOSTMODEEN]=0.
 *
 * Values:
 * - 0 - OWN error detect for ISO IN / ISO OUT is not disabled.
 * - 1 - OWN error detect for ISO IN / ISO OUT is disabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_OWNERRISODIS field. */
#define USB_RD_MISCCTRL_OWNERRISODIS(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_OWNERRISODIS_MASK) >> USB_MISCCTRL_OWNERRISODIS_SHIFT)
#define USB_BRD_MISCCTRL_OWNERRISODIS(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_OWNERRISODIS_SHIFT))

/*! @brief Set the OWNERRISODIS field to a new value. */
#define USB_WR_MISCCTRL_OWNERRISODIS(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_OWNERRISODIS_MASK, USB_MISCCTRL_OWNERRISODIS(value)))
#define USB_BWR_MISCCTRL_OWNERRISODIS(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_OWNERRISODIS_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field VREDG_EN[3] (RW)
 *
 * Values:
 * - 0 - VBUS rising edge interrupt disabled.
 * - 1 - VBUS rising edge interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_VREDG_EN field. */
#define USB_RD_MISCCTRL_VREDG_EN(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_VREDG_EN_MASK) >> USB_MISCCTRL_VREDG_EN_SHIFT)
#define USB_BRD_MISCCTRL_VREDG_EN(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VREDG_EN_SHIFT))

/*! @brief Set the VREDG_EN field to a new value. */
#define USB_WR_MISCCTRL_VREDG_EN(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_VREDG_EN_MASK, USB_MISCCTRL_VREDG_EN(value)))
#define USB_BWR_MISCCTRL_VREDG_EN(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VREDG_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field VFEDG_EN[4] (RW)
 *
 * Values:
 * - 0 - VBUS falling edge interrupt disabled.
 * - 1 - VBUS falling edge interrupt enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_VFEDG_EN field. */
#define USB_RD_MISCCTRL_VFEDG_EN(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_VFEDG_EN_MASK) >> USB_MISCCTRL_VFEDG_EN_SHIFT)
#define USB_BRD_MISCCTRL_VFEDG_EN(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VFEDG_EN_SHIFT))

/*! @brief Set the VFEDG_EN field to a new value. */
#define USB_WR_MISCCTRL_VFEDG_EN(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_VFEDG_EN_MASK, USB_MISCCTRL_VFEDG_EN(value)))
#define USB_BWR_MISCCTRL_VFEDG_EN(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_VFEDG_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_MISCCTRL, field STL_ADJ_EN[7] (RW)
 *
 * This field is valid only in peripheral mode (CTL[HOSTMODEEN]=0). When an
 * endpoint is stalled (ENDPTn[END_STALL]=1), writing a 0 to this bit would stall
 * both IN and OUT directions . By writing a 1 to this bit, we can adjust default
 * stall function and enable stall for just IN or OUT direction.
 *
 * Values:
 * - 0 - USB device mode stall adjust disabled.
 * - 1 - USB device mode stall adjust enabled.
 */
/*@{*/
/*! @brief Read current value of the USB_MISCCTRL_STL_ADJ_EN field. */
#define USB_RD_MISCCTRL_STL_ADJ_EN(base) ((USB_MISCCTRL_REG(base) & USB_MISCCTRL_STL_ADJ_EN_MASK) >> USB_MISCCTRL_STL_ADJ_EN_SHIFT)
#define USB_BRD_MISCCTRL_STL_ADJ_EN(base) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_STL_ADJ_EN_SHIFT))

/*! @brief Set the STL_ADJ_EN field to a new value. */
#define USB_WR_MISCCTRL_STL_ADJ_EN(base, value) (USB_RMW_MISCCTRL(base, USB_MISCCTRL_STL_ADJ_EN_MASK, USB_MISCCTRL_STL_ADJ_EN(value)))
#define USB_BWR_MISCCTRL_STL_ADJ_EN(base, value) (BITBAND_ACCESS8(&USB_MISCCTRL_REG(base), USB_MISCCTRL_STL_ADJ_EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_CTRL - USB Clock recovery control
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_CTRL - USB Clock recovery control (RW)
 *
 * Reset value: 0x00U
 *
 * Signals in this register control the crystal-less USB clock mode in which the
 * internal IRC48M oscillator is tuned to match the clock extracted from the
 * incoming USB data stream. The IRC48M internal oscillator module must be enabled
 * in register USB_CLK_RECOVER_IRC_EN for this mode.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_CTRL register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_CTRL(base) (USB_CLK_RECOVER_CTRL_REG(base))
#define USB_WR_CLK_RECOVER_CTRL(base, value) (USB_CLK_RECOVER_CTRL_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_CTRL(base, mask, value) (USB_WR_CLK_RECOVER_CTRL(base, (USB_RD_CLK_RECOVER_CTRL(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_CTRL(base, value) (USB_WR_CLK_RECOVER_CTRL(base, USB_RD_CLK_RECOVER_CTRL(base) |  (value)))
#define USB_CLR_CLK_RECOVER_CTRL(base, value) (USB_WR_CLK_RECOVER_CTRL(base, USB_RD_CLK_RECOVER_CTRL(base) & ~(value)))
#define USB_TOG_CLK_RECOVER_CTRL(base, value) (USB_WR_CLK_RECOVER_CTRL(base, USB_RD_CLK_RECOVER_CTRL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_CTRL bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESTART_IFRTRIM_EN[5] (RW)
 *
 * IRC48 has a default trim fine value whose default value is factory trimmed
 * (the IFR trim value). Clock recover block tracks the accuracy of the clock 48Mhz
 * and keeps updating the trim fine value accordingly
 *
 * Values:
 * - 0 - Trim fine adjustment always works based on the previous updated trim
 *     fine value (default)
 * - 1 - Trim fine restarts from the IFR trim value whenever
 *     bus_reset/bus_resume is detected or module enable is desasserted
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_MASK) >> USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT))

/*! @brief Set the RESTART_IFRTRIM_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_MASK, USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESTART_IFRTRIM_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field RESET_RESUME_ROUGH_EN[6] (RW)
 *
 * The clock recovery block tracks the IRC48Mhz to get an accurate 48Mhz clock.
 * It has two phases after user enables clock_recover_en bit, rough phase and
 * tracking phase. The step to fine tune the IRC 48Mhz by adjusting the trim fine
 * value is different during these two phases. The step in rough phase is larger
 * than that in tracking phase. Switch back to rough stage whenever USB bus reset
 * or bus resume occurs.
 *
 * Values:
 * - 0 - Always works in tracking phase after the 1st time rough to track
 *     transition (default)
 * - 1 - Go back to rough stage whenever bus reset or bus resume occurs
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_MASK) >> USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT))

/*! @brief Set the RESET_RESUME_ROUGH_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_MASK, USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_RESET_RESUME_ROUGH_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_CTRL, field CLOCK_RECOVER_EN[7] (RW)
 *
 * This bit must be enabled if user wants to use the crystal-less USB mode for
 * the Full Speed USB controller and transceiver. This bit should not be set for
 * USB host mode or OTG.
 *
 * Values:
 * - 0 - Disable clock recovery block (default)
 * - 1 - Enable clock recovery block
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN field. */
#define USB_RD_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base) ((USB_CLK_RECOVER_CTRL_REG(base) & USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK) >> USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT))

/*! @brief Set the CLOCK_RECOVER_EN field to a new value. */
#define USB_WR_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base, value) (USB_RMW_CLK_RECOVER_CTRL(base, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_MASK, USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(value)))
#define USB_BWR_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_CTRL_REG(base), USB_CLK_RECOVER_CTRL_CLOCK_RECOVER_EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_IRC_EN - IRC48M oscillator enable register (RW)
 *
 * Reset value: 0x01U
 *
 * Controls basic operation of the on-chip IRC48M module used to produce nominal
 * 48MHz clocks for USB crystal-less operation and other functions. See
 * additional information about the IRC48M operation in the Clock Distribution chapter.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_IRC_EN register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_IRC_EN(base) (USB_CLK_RECOVER_IRC_EN_REG(base))
#define USB_WR_CLK_RECOVER_IRC_EN(base, value) (USB_CLK_RECOVER_IRC_EN_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_IRC_EN(base, mask, value) (USB_WR_CLK_RECOVER_IRC_EN(base, (USB_RD_CLK_RECOVER_IRC_EN(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_IRC_EN(base, value) (USB_WR_CLK_RECOVER_IRC_EN(base, USB_RD_CLK_RECOVER_IRC_EN(base) |  (value)))
#define USB_CLR_CLK_RECOVER_IRC_EN(base, value) (USB_WR_CLK_RECOVER_IRC_EN(base, USB_RD_CLK_RECOVER_IRC_EN(base) & ~(value)))
#define USB_TOG_CLK_RECOVER_IRC_EN(base, value) (USB_WR_CLK_RECOVER_IRC_EN(base, USB_RD_CLK_RECOVER_IRC_EN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_IRC_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field REG_EN[0] (RW)
 *
 * This bit is used to enable the local analog regulator for IRC48Mhz module.
 * This bit must be set if user wants to use the crystal-less USB clock
 * configuration.
 *
 * Values:
 * - 0 - IRC48M local regulator is disabled
 * - 1 - IRC48M local regulator is enabled (default)
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_REG_EN field. */
#define USB_RD_CLK_RECOVER_IRC_EN_REG_EN(base) ((USB_CLK_RECOVER_IRC_EN_REG(base) & USB_CLK_RECOVER_IRC_EN_REG_EN_MASK) >> USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_IRC_EN_REG_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT))

/*! @brief Set the REG_EN field to a new value. */
#define USB_WR_CLK_RECOVER_IRC_EN_REG_EN(base, value) (USB_RMW_CLK_RECOVER_IRC_EN(base, USB_CLK_RECOVER_IRC_EN_REG_EN_MASK, USB_CLK_RECOVER_IRC_EN_REG_EN(value)))
#define USB_BWR_CLK_RECOVER_IRC_EN_REG_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_REG_EN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register USB_CLK_RECOVER_IRC_EN, field IRC_EN[1] (RW)
 *
 * This bit is used to enable the on-chip IRC48Mhz module to generate clocks for
 * crystal-less USB. It can be used for FS USB device mode operation. This bit
 * must be set before using the crystal-less USB clock configuration.
 *
 * Values:
 * - 0 - Disable the IRC48M module (default)
 * - 1 - Enable the IRC48M module
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_IRC_EN_IRC_EN field. */
#define USB_RD_CLK_RECOVER_IRC_EN_IRC_EN(base) ((USB_CLK_RECOVER_IRC_EN_REG(base) & USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK) >> USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_IRC_EN_IRC_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT))

/*! @brief Set the IRC_EN field to a new value. */
#define USB_WR_CLK_RECOVER_IRC_EN_IRC_EN(base, value) (USB_RMW_CLK_RECOVER_IRC_EN(base, USB_CLK_RECOVER_IRC_EN_IRC_EN_MASK, USB_CLK_RECOVER_IRC_EN_IRC_EN(value)))
#define USB_BWR_CLK_RECOVER_IRC_EN_IRC_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_IRC_EN_REG(base), USB_CLK_RECOVER_IRC_EN_IRC_EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_INT_EN - Clock recovery combined interrupt enable (RW)
 *
 * Reset value: 0x10U
 *
 * Enables or masks the individual interrupt flags which are logically OR'ed
 * together to produce the combined interrupt indication on the USB_CLK_RECOVERY_INT
 * bit in the USB_USBTRC0 register if the indicated conditions have been
 * detected in the USB clock recovery algorithm operation.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_EN register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_INT_EN(base) (USB_CLK_RECOVER_INT_EN_REG(base))
#define USB_WR_CLK_RECOVER_INT_EN(base, value) (USB_CLK_RECOVER_INT_EN_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_INT_EN(base, mask, value) (USB_WR_CLK_RECOVER_INT_EN(base, (USB_RD_CLK_RECOVER_INT_EN(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_INT_EN(base, value) (USB_WR_CLK_RECOVER_INT_EN(base, USB_RD_CLK_RECOVER_INT_EN(base) |  (value)))
#define USB_CLR_CLK_RECOVER_INT_EN(base, value) (USB_WR_CLK_RECOVER_INT_EN(base, USB_RD_CLK_RECOVER_INT_EN(base) & ~(value)))
#define USB_TOG_CLK_RECOVER_INT_EN(base, value) (USB_WR_CLK_RECOVER_INT_EN(base, USB_RD_CLK_RECOVER_INT_EN(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_EN bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_EN, field OVF_ERROR_EN[4] (RW)
 *
 * Determines whether OVF_ERROR condition signal is used in generation of
 * USB_CLK_RECOVERY_INT.
 *
 * Values:
 * - 0 - The interrupt will be masked
 * - 1 - The interrupt will be enabled (default)
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN field. */
#define USB_RD_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base) ((USB_CLK_RECOVER_INT_EN_REG(base) & USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_MASK) >> USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT)
#define USB_BRD_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_INT_EN_REG(base), USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT))

/*! @brief Set the OVF_ERROR_EN field to a new value. */
#define USB_WR_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base, value) (USB_RMW_CLK_RECOVER_INT_EN(base, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_MASK, USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN(value)))
#define USB_BWR_CLK_RECOVER_INT_EN_OVF_ERROR_EN(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_INT_EN_REG(base), USB_CLK_RECOVER_INT_EN_OVF_ERROR_EN_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status
 ******************************************************************************/

/*!
 * @brief USB_CLK_RECOVER_INT_STATUS - Clock recovery separated interrupt status (W1C)
 *
 * Reset value: 0x00U
 *
 * A Write operation with value high at 1'b1 on any combination of individual
 * bits will clear those bits.
 */
/*!
 * @name Constants and macros for entire USB_CLK_RECOVER_INT_STATUS register
 */
/*@{*/
#define USB_RD_CLK_RECOVER_INT_STATUS(base) (USB_CLK_RECOVER_INT_STATUS_REG(base))
#define USB_WR_CLK_RECOVER_INT_STATUS(base, value) (USB_CLK_RECOVER_INT_STATUS_REG(base) = (value))
#define USB_RMW_CLK_RECOVER_INT_STATUS(base, mask, value) (USB_WR_CLK_RECOVER_INT_STATUS(base, (USB_RD_CLK_RECOVER_INT_STATUS(base) & ~(mask)) | (value)))
#define USB_SET_CLK_RECOVER_INT_STATUS(base, value) (USB_WR_CLK_RECOVER_INT_STATUS(base, USB_RD_CLK_RECOVER_INT_STATUS(base) |  (value)))
#define USB_CLR_CLK_RECOVER_INT_STATUS(base, value) (USB_WR_CLK_RECOVER_INT_STATUS(base, USB_RD_CLK_RECOVER_INT_STATUS(base) & ~(value)))
#define USB_TOG_CLK_RECOVER_INT_STATUS(base, value) (USB_WR_CLK_RECOVER_INT_STATUS(base, USB_RD_CLK_RECOVER_INT_STATUS(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual USB_CLK_RECOVER_INT_STATUS bitfields
 */

/*!
 * @name Register USB_CLK_RECOVER_INT_STATUS, field OVF_ERROR[4] (W1C)
 *
 * Indicates that the USB clock recovery algorithm has detected that the
 * frequency trim adjustment needed for the IRC48M output clock is outside the available
 * TRIM_FINE adjustment range for the IRC48M module.
 *
 * Values:
 * - 0 - No interrupt is reported
 * - 1 - Unmasked interrupt has been generated
 */
/*@{*/
/*! @brief Read current value of the USB_CLK_RECOVER_INT_STATUS_OVF_ERROR field. */
#define USB_RD_CLK_RECOVER_INT_STATUS_OVF_ERROR(base) ((USB_CLK_RECOVER_INT_STATUS_REG(base) & USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_MASK) >> USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT)
#define USB_BRD_CLK_RECOVER_INT_STATUS_OVF_ERROR(base) (BITBAND_ACCESS8(&USB_CLK_RECOVER_INT_STATUS_REG(base), USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT))

/*! @brief Set the OVF_ERROR field to a new value. */
#define USB_WR_CLK_RECOVER_INT_STATUS_OVF_ERROR(base, value) (USB_RMW_CLK_RECOVER_INT_STATUS(base, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_MASK, USB_CLK_RECOVER_INT_STATUS_OVF_ERROR(value)))
#define USB_BWR_CLK_RECOVER_INT_STATUS_OVF_ERROR(base, value) (BITBAND_ACCESS8(&USB_CLK_RECOVER_INT_STATUS_REG(base), USB_CLK_RECOVER_INT_STATUS_OVF_ERROR_SHIFT) = (value))
/*@}*/

/*
 * MKS22F25612 WDOG
 *
 * Generation 2008 Watchdog Timer
 *
 * Registers defined in this header file:
 * - WDOG_STCTRLH - Watchdog Status and Control Register High
 * - WDOG_STCTRLL - Watchdog Status and Control Register Low
 * - WDOG_TOVALH - Watchdog Time-out Value Register High
 * - WDOG_TOVALL - Watchdog Time-out Value Register Low
 * - WDOG_WINH - Watchdog Window Register High
 * - WDOG_WINL - Watchdog Window Register Low
 * - WDOG_REFRESH - Watchdog Refresh register
 * - WDOG_UNLOCK - Watchdog Unlock register
 * - WDOG_TMROUTH - Watchdog Timer Output Register High
 * - WDOG_TMROUTL - Watchdog Timer Output Register Low
 * - WDOG_RSTCNT - Watchdog Reset Count register
 * - WDOG_PRESC - Watchdog Prescaler register
 */

#define WDOG_INSTANCE_COUNT (1U) /*!< Number of instances of the WDOG module. */
#define WDOG_IDX (0U) /*!< Instance number for WDOG. */

/*******************************************************************************
 * WDOG_STCTRLH - Watchdog Status and Control Register High
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLH - Watchdog Status and Control Register High (RW)
 *
 * Reset value: 0x01D3U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLH register
 */
/*@{*/
#define WDOG_RD_STCTRLH(base)    (WDOG_STCTRLH_REG(base))
#define WDOG_WR_STCTRLH(base, value) (WDOG_STCTRLH_REG(base) = (value))
#define WDOG_RMW_STCTRLH(base, mask, value) (WDOG_WR_STCTRLH(base, (WDOG_RD_STCTRLH(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) |  (value)))
#define WDOG_CLR_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) & ~(value)))
#define WDOG_TOG_STCTRLH(base, value) (WDOG_WR_STCTRLH(base, WDOG_RD_STCTRLH(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLH bitfields
 */

/*!
 * @name Register WDOG_STCTRLH, field WDOGEN[0] (RW)
 *
 * Enables or disables the WDOG's operation. In the disabled state, the watchdog
 * timer is kept in the reset state, but the other exception conditions can
 * still trigger a reset/interrupt. A change in the value of this bit must be held
 * for more than one WDOG_CLK cycle for the WDOG to be enabled or disabled.
 *
 * Values:
 * - 0 - WDOG is disabled.
 * - 1 - WDOG is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WDOGEN field. */
#define WDOG_RD_STCTRLH_WDOGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WDOGEN_MASK) >> WDOG_STCTRLH_WDOGEN_SHIFT)
#define WDOG_BRD_STCTRLH_WDOGEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT))

/*! @brief Set the WDOGEN field to a new value. */
#define WDOG_WR_STCTRLH_WDOGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WDOGEN_MASK, WDOG_STCTRLH_WDOGEN(value)))
#define WDOG_BWR_STCTRLH_WDOGEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WDOGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field CLKSRC[1] (RW)
 *
 * Selects clock source for the WDOG timer and other internal timing operations.
 *
 * Values:
 * - 0 - WDOG clock sourced from LPO .
 * - 1 - WDOG clock sourced from alternate clock source.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_CLKSRC field. */
#define WDOG_RD_STCTRLH_CLKSRC(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_CLKSRC_MASK) >> WDOG_STCTRLH_CLKSRC_SHIFT)
#define WDOG_BRD_STCTRLH_CLKSRC(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT))

/*! @brief Set the CLKSRC field to a new value. */
#define WDOG_WR_STCTRLH_CLKSRC(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_CLKSRC_MASK, WDOG_STCTRLH_CLKSRC(value)))
#define WDOG_BWR_STCTRLH_CLKSRC(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_CLKSRC_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field IRQRSTEN[2] (RW)
 *
 * Used to enable the debug breadcrumbs feature. A change in this bit is updated
 * immediately, as opposed to updating after WCT.
 *
 * Values:
 * - 0 - WDOG time-out generates reset only.
 * - 1 - WDOG time-out initially generates an interrupt. After WCT, it generates
 *     a reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_IRQRSTEN field. */
#define WDOG_RD_STCTRLH_IRQRSTEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_IRQRSTEN_MASK) >> WDOG_STCTRLH_IRQRSTEN_SHIFT)
#define WDOG_BRD_STCTRLH_IRQRSTEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT))

/*! @brief Set the IRQRSTEN field to a new value. */
#define WDOG_WR_STCTRLH_IRQRSTEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_IRQRSTEN_MASK, WDOG_STCTRLH_IRQRSTEN(value)))
#define WDOG_BWR_STCTRLH_IRQRSTEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_IRQRSTEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WINEN[3] (RW)
 *
 * Enables Windowing mode.
 *
 * Values:
 * - 0 - Windowing mode is disabled.
 * - 1 - Windowing mode is enabled.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WINEN field. */
#define WDOG_RD_STCTRLH_WINEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WINEN_MASK) >> WDOG_STCTRLH_WINEN_SHIFT)
#define WDOG_BRD_STCTRLH_WINEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT))

/*! @brief Set the WINEN field to a new value. */
#define WDOG_WR_STCTRLH_WINEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WINEN_MASK, WDOG_STCTRLH_WINEN(value)))
#define WDOG_BWR_STCTRLH_WINEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WINEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field ALLOWUPDATE[4] (RW)
 *
 * Enables updates to watchdog write-once registers, after the reset-triggered
 * initial configuration window (WCT) closes, through unlock sequence.
 *
 * Values:
 * - 0 - No further updates allowed to WDOG write-once registers.
 * - 1 - WDOG write-once registers can be unlocked for updating.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_ALLOWUPDATE field. */
#define WDOG_RD_STCTRLH_ALLOWUPDATE(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_ALLOWUPDATE_MASK) >> WDOG_STCTRLH_ALLOWUPDATE_SHIFT)
#define WDOG_BRD_STCTRLH_ALLOWUPDATE(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT))

/*! @brief Set the ALLOWUPDATE field to a new value. */
#define WDOG_WR_STCTRLH_ALLOWUPDATE(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_ALLOWUPDATE_MASK, WDOG_STCTRLH_ALLOWUPDATE(value)))
#define WDOG_BWR_STCTRLH_ALLOWUPDATE(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_ALLOWUPDATE_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DBGEN[5] (RW)
 *
 * Enables or disables WDOG in Debug mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Debug mode.
 * - 1 - WDOG is enabled in CPU Debug mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DBGEN field. */
#define WDOG_RD_STCTRLH_DBGEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DBGEN_MASK) >> WDOG_STCTRLH_DBGEN_SHIFT)
#define WDOG_BRD_STCTRLH_DBGEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT))

/*! @brief Set the DBGEN field to a new value. */
#define WDOG_WR_STCTRLH_DBGEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DBGEN_MASK, WDOG_STCTRLH_DBGEN(value)))
#define WDOG_BWR_STCTRLH_DBGEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DBGEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field STOPEN[6] (RW)
 *
 * Enables or disables WDOG in Stop mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Stop mode.
 * - 1 - WDOG is enabled in CPU Stop mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_STOPEN field. */
#define WDOG_RD_STCTRLH_STOPEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_STOPEN_MASK) >> WDOG_STCTRLH_STOPEN_SHIFT)
#define WDOG_BRD_STCTRLH_STOPEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT))

/*! @brief Set the STOPEN field to a new value. */
#define WDOG_WR_STCTRLH_STOPEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_STOPEN_MASK, WDOG_STCTRLH_STOPEN(value)))
#define WDOG_BWR_STCTRLH_STOPEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_STOPEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field WAITEN[7] (RW)
 *
 * Enables or disables WDOG in Wait mode.
 *
 * Values:
 * - 0 - WDOG is disabled in CPU Wait mode.
 * - 1 - WDOG is enabled in CPU Wait mode.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_WAITEN field. */
#define WDOG_RD_STCTRLH_WAITEN(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_WAITEN_MASK) >> WDOG_STCTRLH_WAITEN_SHIFT)
#define WDOG_BRD_STCTRLH_WAITEN(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT))

/*! @brief Set the WAITEN field to a new value. */
#define WDOG_WR_STCTRLH_WAITEN(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_WAITEN_MASK, WDOG_STCTRLH_WAITEN(value)))
#define WDOG_BWR_STCTRLH_WAITEN(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_WAITEN_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTWDOG[10] (RW)
 *
 * Puts the watchdog in the functional test mode. In this mode, the watchdog
 * timer and the associated compare and reset generation logic is tested for correct
 * operation. The clock for the timer is switched from the main watchdog clock
 * to the fast clock input for watchdog functional test. The TESTSEL bit selects
 * the test to be run.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTWDOG field. */
#define WDOG_RD_STCTRLH_TESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTWDOG_MASK) >> WDOG_STCTRLH_TESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_TESTWDOG(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT))

/*! @brief Set the TESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_TESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTWDOG_MASK, WDOG_STCTRLH_TESTWDOG(value)))
#define WDOG_BWR_STCTRLH_TESTWDOG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTWDOG_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field TESTSEL[11] (RW)
 *
 * Effective only if TESTWDOG is set. Selects the test to be run on the watchdog
 * timer.
 *
 * Values:
 * - 0 - Quick test. The timer runs in normal operation. You can load a small
 *     time-out value to do a quick test.
 * - 1 - Byte test. Puts the timer in the byte test mode where individual bytes
 *     of the timer are enabled for operation and are compared for time-out
 *     against the corresponding byte of the programmed time-out value. Select the
 *     byte through BYTESEL[1:0] for testing.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_TESTSEL field. */
#define WDOG_RD_STCTRLH_TESTSEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_TESTSEL_MASK) >> WDOG_STCTRLH_TESTSEL_SHIFT)
#define WDOG_BRD_STCTRLH_TESTSEL(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT))

/*! @brief Set the TESTSEL field to a new value. */
#define WDOG_WR_STCTRLH_TESTSEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_TESTSEL_MASK, WDOG_STCTRLH_TESTSEL(value)))
#define WDOG_BWR_STCTRLH_TESTSEL(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_TESTSEL_SHIFT) = (value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field BYTESEL[13:12] (RW)
 *
 * This 2-bit field selects the byte to be tested when the watchdog is in the
 * byte test mode.
 *
 * Values:
 * - 00 - Byte 0 selected
 * - 01 - Byte 1 selected
 * - 10 - Byte 2 selected
 * - 11 - Byte 3 selected
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_BYTESEL field. */
#define WDOG_RD_STCTRLH_BYTESEL(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_BYTESEL_MASK) >> WDOG_STCTRLH_BYTESEL_SHIFT)
#define WDOG_BRD_STCTRLH_BYTESEL(base) (WDOG_RD_STCTRLH_BYTESEL(base))

/*! @brief Set the BYTESEL field to a new value. */
#define WDOG_WR_STCTRLH_BYTESEL(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_BYTESEL_MASK, WDOG_STCTRLH_BYTESEL(value)))
#define WDOG_BWR_STCTRLH_BYTESEL(base, value) (WDOG_WR_STCTRLH_BYTESEL(base, value))
/*@}*/

/*!
 * @name Register WDOG_STCTRLH, field DISTESTWDOG[14] (RW)
 *
 * Allows the WDOG's functional test mode to be disabled permanently. After it
 * is set, it can only be cleared by a reset. It cannot be unlocked for editing
 * after it is set.
 *
 * Values:
 * - 0 - WDOG functional test mode is not disabled.
 * - 1 - WDOG functional test mode is disabled permanently until reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLH_DISTESTWDOG field. */
#define WDOG_RD_STCTRLH_DISTESTWDOG(base) ((WDOG_STCTRLH_REG(base) & WDOG_STCTRLH_DISTESTWDOG_MASK) >> WDOG_STCTRLH_DISTESTWDOG_SHIFT)
#define WDOG_BRD_STCTRLH_DISTESTWDOG(base) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT))

/*! @brief Set the DISTESTWDOG field to a new value. */
#define WDOG_WR_STCTRLH_DISTESTWDOG(base, value) (WDOG_RMW_STCTRLH(base, WDOG_STCTRLH_DISTESTWDOG_MASK, WDOG_STCTRLH_DISTESTWDOG(value)))
#define WDOG_BWR_STCTRLH_DISTESTWDOG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLH_REG(base), WDOG_STCTRLH_DISTESTWDOG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * WDOG_STCTRLL - Watchdog Status and Control Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_STCTRLL - Watchdog Status and Control Register Low (RW)
 *
 * Reset value: 0x0001U
 */
/*!
 * @name Constants and macros for entire WDOG_STCTRLL register
 */
/*@{*/
#define WDOG_RD_STCTRLL(base)    (WDOG_STCTRLL_REG(base))
#define WDOG_WR_STCTRLL(base, value) (WDOG_STCTRLL_REG(base) = (value))
#define WDOG_RMW_STCTRLL(base, mask, value) (WDOG_WR_STCTRLL(base, (WDOG_RD_STCTRLL(base) & ~(mask)) | (value)))
#define WDOG_SET_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) |  (value)))
#define WDOG_CLR_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) & ~(value)))
#define WDOG_TOG_STCTRLL(base, value) (WDOG_WR_STCTRLL(base, WDOG_RD_STCTRLL(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_STCTRLL bitfields
 */

/*!
 * @name Register WDOG_STCTRLL, field INTFLG[15] (RW)
 *
 * Interrupt flag. It is set when an exception occurs. IRQRSTEN = 1 is a
 * precondition to set this flag. INTFLG = 1 results in an interrupt being issued
 * followed by a reset, WCT later. The interrupt can be cleared by writing 1 to this
 * bit. It also gets cleared on a system reset.
 */
/*@{*/
/*! @brief Read current value of the WDOG_STCTRLL_INTFLG field. */
#define WDOG_RD_STCTRLL_INTFLG(base) ((WDOG_STCTRLL_REG(base) & WDOG_STCTRLL_INTFLG_MASK) >> WDOG_STCTRLL_INTFLG_SHIFT)
#define WDOG_BRD_STCTRLL_INTFLG(base) (BITBAND_ACCESS16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT))

/*! @brief Set the INTFLG field to a new value. */
#define WDOG_WR_STCTRLL_INTFLG(base, value) (WDOG_RMW_STCTRLL(base, WDOG_STCTRLL_INTFLG_MASK, WDOG_STCTRLL_INTFLG(value)))
#define WDOG_BWR_STCTRLL_INTFLG(base, value) (BITBAND_ACCESS16(&WDOG_STCTRLL_REG(base), WDOG_STCTRLL_INTFLG_SHIFT) = (value))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALH - Watchdog Time-out Value Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALH - Watchdog Time-out Value Register High (RW)
 *
 * Reset value: 0x004CU
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALH register
 */
/*@{*/
#define WDOG_RD_TOVALH(base)     (WDOG_TOVALH_REG(base))
#define WDOG_WR_TOVALH(base, value) (WDOG_TOVALH_REG(base) = (value))
#define WDOG_RMW_TOVALH(base, mask, value) (WDOG_WR_TOVALH(base, (WDOG_RD_TOVALH(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) |  (value)))
#define WDOG_CLR_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) & ~(value)))
#define WDOG_TOG_TOVALH(base, value) (WDOG_WR_TOVALH(base, WDOG_RD_TOVALH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TOVALL - Watchdog Time-out Value Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TOVALL - Watchdog Time-out Value Register Low (RW)
 *
 * Reset value: 0x4B4CU
 *
 * The time-out value of the watchdog must be set to a minimum of four watchdog
 * clock cycles. This is to take into account the delay in new settings taking
 * effect in the watchdog clock domain.
 */
/*!
 * @name Constants and macros for entire WDOG_TOVALL register
 */
/*@{*/
#define WDOG_RD_TOVALL(base)     (WDOG_TOVALL_REG(base))
#define WDOG_WR_TOVALL(base, value) (WDOG_TOVALL_REG(base) = (value))
#define WDOG_RMW_TOVALL(base, mask, value) (WDOG_WR_TOVALL(base, (WDOG_RD_TOVALL(base) & ~(mask)) | (value)))
#define WDOG_SET_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) |  (value)))
#define WDOG_CLR_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) & ~(value)))
#define WDOG_TOG_TOVALL(base, value) (WDOG_WR_TOVALL(base, WDOG_RD_TOVALL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINH - Watchdog Window Register High
 ******************************************************************************/

/*!
 * @brief WDOG_WINH - Watchdog Window Register High (RW)
 *
 * Reset value: 0x0000U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINH register
 */
/*@{*/
#define WDOG_RD_WINH(base)       (WDOG_WINH_REG(base))
#define WDOG_WR_WINH(base, value) (WDOG_WINH_REG(base) = (value))
#define WDOG_RMW_WINH(base, mask, value) (WDOG_WR_WINH(base, (WDOG_RD_WINH(base) & ~(mask)) | (value)))
#define WDOG_SET_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) |  (value)))
#define WDOG_CLR_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) & ~(value)))
#define WDOG_TOG_WINH(base, value) (WDOG_WR_WINH(base, WDOG_RD_WINH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_WINL - Watchdog Window Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_WINL - Watchdog Window Register Low (RW)
 *
 * Reset value: 0x0010U
 *
 * You must set the Window Register value lower than the Time-out Value Register.
 */
/*!
 * @name Constants and macros for entire WDOG_WINL register
 */
/*@{*/
#define WDOG_RD_WINL(base)       (WDOG_WINL_REG(base))
#define WDOG_WR_WINL(base, value) (WDOG_WINL_REG(base) = (value))
#define WDOG_RMW_WINL(base, mask, value) (WDOG_WR_WINL(base, (WDOG_RD_WINL(base) & ~(mask)) | (value)))
#define WDOG_SET_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) |  (value)))
#define WDOG_CLR_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) & ~(value)))
#define WDOG_TOG_WINL(base, value) (WDOG_WR_WINL(base, WDOG_RD_WINL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_REFRESH - Watchdog Refresh register
 ******************************************************************************/

/*!
 * @brief WDOG_REFRESH - Watchdog Refresh register (RW)
 *
 * Reset value: 0xB480U
 */
/*!
 * @name Constants and macros for entire WDOG_REFRESH register
 */
/*@{*/
#define WDOG_RD_REFRESH(base)    (WDOG_REFRESH_REG(base))
#define WDOG_WR_REFRESH(base, value) (WDOG_REFRESH_REG(base) = (value))
#define WDOG_RMW_REFRESH(base, mask, value) (WDOG_WR_REFRESH(base, (WDOG_RD_REFRESH(base) & ~(mask)) | (value)))
#define WDOG_SET_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) |  (value)))
#define WDOG_CLR_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) & ~(value)))
#define WDOG_TOG_REFRESH(base, value) (WDOG_WR_REFRESH(base, WDOG_RD_REFRESH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_UNLOCK - Watchdog Unlock register
 ******************************************************************************/

/*!
 * @brief WDOG_UNLOCK - Watchdog Unlock register (RW)
 *
 * Reset value: 0xD928U
 */
/*!
 * @name Constants and macros for entire WDOG_UNLOCK register
 */
/*@{*/
#define WDOG_RD_UNLOCK(base)     (WDOG_UNLOCK_REG(base))
#define WDOG_WR_UNLOCK(base, value) (WDOG_UNLOCK_REG(base) = (value))
#define WDOG_RMW_UNLOCK(base, mask, value) (WDOG_WR_UNLOCK(base, (WDOG_RD_UNLOCK(base) & ~(mask)) | (value)))
#define WDOG_SET_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) |  (value)))
#define WDOG_CLR_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) & ~(value)))
#define WDOG_TOG_UNLOCK(base, value) (WDOG_WR_UNLOCK(base, WDOG_RD_UNLOCK(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTH - Watchdog Timer Output Register High
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTH - Watchdog Timer Output Register High (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTH register
 */
/*@{*/
#define WDOG_RD_TMROUTH(base)    (WDOG_TMROUTH_REG(base))
#define WDOG_WR_TMROUTH(base, value) (WDOG_TMROUTH_REG(base) = (value))
#define WDOG_RMW_TMROUTH(base, mask, value) (WDOG_WR_TMROUTH(base, (WDOG_RD_TMROUTH(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) |  (value)))
#define WDOG_CLR_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) & ~(value)))
#define WDOG_TOG_TMROUTH(base, value) (WDOG_WR_TMROUTH(base, WDOG_RD_TMROUTH(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_TMROUTL - Watchdog Timer Output Register Low
 ******************************************************************************/

/*!
 * @brief WDOG_TMROUTL - Watchdog Timer Output Register Low (RW)
 *
 * Reset value: 0x0000U
 *
 * During Stop mode, the WDOG_TIMER_OUT will be caught at the pre-stop value of
 * the watchdog timer. After exiting Stop mode, a maximum delay of 1 WDOG_CLK
 * cycle + 3 bus clock cycles will occur before the WDOG_TIMER_OUT starts following
 * the watchdog timer.
 */
/*!
 * @name Constants and macros for entire WDOG_TMROUTL register
 */
/*@{*/
#define WDOG_RD_TMROUTL(base)    (WDOG_TMROUTL_REG(base))
#define WDOG_WR_TMROUTL(base, value) (WDOG_TMROUTL_REG(base) = (value))
#define WDOG_RMW_TMROUTL(base, mask, value) (WDOG_WR_TMROUTL(base, (WDOG_RD_TMROUTL(base) & ~(mask)) | (value)))
#define WDOG_SET_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) |  (value)))
#define WDOG_CLR_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) & ~(value)))
#define WDOG_TOG_TMROUTL(base, value) (WDOG_WR_TMROUTL(base, WDOG_RD_TMROUTL(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_RSTCNT - Watchdog Reset Count register
 ******************************************************************************/

/*!
 * @brief WDOG_RSTCNT - Watchdog Reset Count register (RW)
 *
 * Reset value: 0x0000U
 */
/*!
 * @name Constants and macros for entire WDOG_RSTCNT register
 */
/*@{*/
#define WDOG_RD_RSTCNT(base)     (WDOG_RSTCNT_REG(base))
#define WDOG_WR_RSTCNT(base, value) (WDOG_RSTCNT_REG(base) = (value))
#define WDOG_RMW_RSTCNT(base, mask, value) (WDOG_WR_RSTCNT(base, (WDOG_RD_RSTCNT(base) & ~(mask)) | (value)))
#define WDOG_SET_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) |  (value)))
#define WDOG_CLR_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) & ~(value)))
#define WDOG_TOG_RSTCNT(base, value) (WDOG_WR_RSTCNT(base, WDOG_RD_RSTCNT(base) ^  (value)))
/*@}*/

/*******************************************************************************
 * WDOG_PRESC - Watchdog Prescaler register
 ******************************************************************************/

/*!
 * @brief WDOG_PRESC - Watchdog Prescaler register (RW)
 *
 * Reset value: 0x0400U
 */
/*!
 * @name Constants and macros for entire WDOG_PRESC register
 */
/*@{*/
#define WDOG_RD_PRESC(base)      (WDOG_PRESC_REG(base))
#define WDOG_WR_PRESC(base, value) (WDOG_PRESC_REG(base) = (value))
#define WDOG_RMW_PRESC(base, mask, value) (WDOG_WR_PRESC(base, (WDOG_RD_PRESC(base) & ~(mask)) | (value)))
#define WDOG_SET_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) |  (value)))
#define WDOG_CLR_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) & ~(value)))
#define WDOG_TOG_PRESC(base, value) (WDOG_WR_PRESC(base, WDOG_RD_PRESC(base) ^  (value)))
/*@}*/

/*
 * Constants & macros for individual WDOG_PRESC bitfields
 */

/*!
 * @name Register WDOG_PRESC, field PRESCVAL[10:8] (RW)
 *
 * 3-bit prescaler for the watchdog clock source. A value of zero indicates no
 * division of the input WDOG clock. The watchdog clock is divided by (PRESCVAL +
 * 1) to provide the prescaled WDOG_CLK.
 */
/*@{*/
/*! @brief Read current value of the WDOG_PRESC_PRESCVAL field. */
#define WDOG_RD_PRESC_PRESCVAL(base) ((WDOG_PRESC_REG(base) & WDOG_PRESC_PRESCVAL_MASK) >> WDOG_PRESC_PRESCVAL_SHIFT)
#define WDOG_BRD_PRESC_PRESCVAL(base) (WDOG_RD_PRESC_PRESCVAL(base))

/*! @brief Set the PRESCVAL field to a new value. */
#define WDOG_WR_PRESC_PRESCVAL(base, value) (WDOG_RMW_PRESC(base, WDOG_PRESC_PRESCVAL_MASK, WDOG_PRESC_PRESCVAL(value)))
#define WDOG_BWR_PRESC_PRESCVAL(base, value) (WDOG_WR_PRESC_PRESCVAL(base, value))
/*@}*/

/* Instance numbers for core modules */
#define JTAG_IDX (0) /*!< Instance number for JTAG. */
#define TPIU_IDX (0) /*!< Instance number for TPIU. */
#define SCB_IDX (0) /*!< Instance number for SCB. */
#define CoreDebug_IDX (0) /*!< Instance number for CoreDebug. */

#endif /* __MKS22F25612_EXTENSION_H__ */
/* EOF */
